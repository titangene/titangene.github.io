<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Titangene Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://titangene.github.io/"/>
  <updated>2020-06-14T15:56:29.097Z</updated>
  <id>https://titangene.github.io/</id>
  
  <author>
    <name>Titangene</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jest：Describe &amp; Test case</title>
    <link href="https://titangene.github.io/article/jest-describe-test-case.html"/>
    <id>https://titangene.github.io/article/jest-describe-test-case.html</id>
    <published>2020-06-14T15:57:34.000Z</published>
    <updated>2020-06-14T15:56:29.097Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>上次介紹了 <a href="https://titangene.github.io/article/jest-matcher-assertion.html">Jest 提供的 matcher</a>，可讓你驗證程式碼是否符合預期，而這次來說明如何透過 <code>describe</code> 和 <code>test</code> 區塊來組織測試案例。當需求變多時，可針對需求來分類測試案例，將相關的測試放在同一個群組區塊內，此時就會用到 Jest 提供的 <code>describe</code> 和 <code>test</code> 區塊。</p><a id="more"></a><ul><li><code>test</code> 區塊：即測試案例 (test case)，使用 matcher 驗證程式執行結果是否符合預期</li><li><code>describe</code> 區塊：將多個相關的 <code>test</code> 區塊放在一起，便於組織測試案例</li></ul><div class="info"><h1 id="系列文章"><a class="header-anchor" href="#系列文章"></a>系列文章</h1><p>環境建制：</p><ul><li><a href="https://titangene.github.io/article/jest-build-test-env.html">Jest：建置測試環境 (包含 Babel)</a></li><li><a href="https://titangene.github.io/article/jest-typescript.html">Jest + TypeScript：建置測試環境</a></li></ul><p>使用：</p><ul><li><a href="https://titangene.github.io/article/jest-matcher-assertion.html">Jest：Matcher &amp; Assertion</a></li><li><a href="https://titangene.github.io/article/jest-describe-test-case.html">Jest：Describe &amp; Test case</a> (本文)</li></ul></div><p>下面範例都會用數學運算的範例來說明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> addition = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(x) === <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-keyword">typeof</span>(y) === <span class="hljs-string">'number'</span>)<br>   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomError(<span class="hljs-string">'請輸入數字'</span>);<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br><span class="hljs-keyword">const</span> subtraction = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(x) === <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-keyword">typeof</span>(y) === <span class="hljs-string">'number'</span>)<br>   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomError(<span class="hljs-string">'請輸入數字'</span>);<br>  <span class="hljs-keyword">return</span> x - y;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="describe-區塊"><a class="header-anchor" href="#describe-區塊"></a><code>describe</code> 區塊</h1><h2 id="describe-name-fn"><a class="header-anchor" href="#describe-name-fn"></a><code>describe(name, fn)</code></h2><p>argument：</p><ul><li><code>name</code>：描素此 <code>describe</code> 區塊的敘述</li><li><code>fn</code>：包含 <code>test</code> 區塊的函數</li></ul><p>用來將多個相關的 <code>test</code> 區塊放在同一個 <code>describe</code> 區塊內，以便於將測試組織成群組。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe(<span class="hljs-string">'數學運算'</span>, () =&gt; &#123;<br>  test(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>    expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'減法運算'</span>, () =&gt; &#123;<br>    expect(subtraction(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)).toBe(<span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>但寫測試不一定要用 <code>describe</code> 區塊，也可以不用將 <code>test</code> 區塊包在 <code>describe</code> 區塊內，而是直接寫在測試檔上，但建議你使用 <code>describe</code> 區塊。</p><p>也可以巢狀使用 <code>describe</code> 區塊：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe(<span class="hljs-string">'數學運算'</span>, () =&gt; &#123;<br>  describe(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>    describe(<span class="hljs-string">'傳入非數字值'</span>, () =&gt; &#123;<br>      test(<span class="hljs-string">'傳入布林值應拋出 CustomError'</span>, () =&gt; &#123;<br>        expect(addition(<span class="hljs-literal">true</span>, <span class="hljs-number">2</span>)).toThrow(CustomError);<br>      &#125;);<br><br>      test(<span class="hljs-string">'傳入字串值應拋出 CustomError'</span>, () =&gt; &#123;<br>        expect(addition(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>)).toThrow(CustomError);<br>      &#125;);<br>    &#125;);<br>    <br>    describe(<span class="hljs-string">'傳入數字值'</span>, () =&gt; &#123;<br>      test(<span class="hljs-string">'應回傳正確的運算結果'</span>, () =&gt; &#123;<br>        expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br><br>  describe(<span class="hljs-string">'減法運算'</span>, () =&gt; &#123;<br>    describe(<span class="hljs-string">'傳入非數字值'</span>, () =&gt; &#123;<br>      test(<span class="hljs-string">'傳入布林值應拋出 CustomError'</span>, () =&gt; &#123;<br>        expect(subtraction(<span class="hljs-literal">true</span>, <span class="hljs-number">2</span>)).toThrow(CustomError);<br>      &#125;);<br><br>      test(<span class="hljs-string">'傳入字串值應拋出 CustomError'</span>, () =&gt; &#123;<br>        expect(subtraction(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>)).toThrow(CustomError);<br>      &#125;);<br>    &#125;);<br>    <br>    describe(<span class="hljs-string">'傳入數字值'</span>, () =&gt; &#123;<br>      test(<span class="hljs-string">'應回傳正確的運算結果'</span>, () =&gt; &#123;<br>        expect(subtraction(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)).toBe(<span class="hljs-number">2</span>);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="describe-only-name-fn"><a class="header-anchor" href="#describe-only-name-fn"></a><code>describe.only(name, fn)</code></h2><p>alias：<code>fdescribe(name, fn)</code></p><p>讓測試只跑使用 <code>describe.only()</code> 的 <code>describe</code> 區塊。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe.only(<span class="hljs-string">'數學運算'</span>, () =&gt; &#123;<br>  test(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>    expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'減法運算'</span>, () =&gt; &#123;<br>    expect(subtraction(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)).toBe(<span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;);<br><br>describe(<span class="hljs-string">'其他'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 此區塊的測試會被略過</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="describe-skip-name-fn"><a class="header-anchor" href="#describe-skip-name-fn"></a><code>describe.skip(name, fn)</code></h2><p>alias：<code>xdescribe(name, fn)</code></p><p>不想執行指定的 <code>describe</code> 區塊可用 <code>describe.skip()</code>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe(<span class="hljs-string">'數學運算'</span>, () =&gt; &#123;<br>  test(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>    expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'減法運算'</span>, () =&gt; &#123;<br>    expect(subtraction(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)).toBe(<span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;);<br><br>describe.skip(<span class="hljs-string">'其他'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 略過此區塊的測試</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="test-區塊"><a class="header-anchor" href="#test-區塊"></a><code>test</code> 區塊</h1><h2 id="test-name-fn-timeout"><a class="header-anchor" href="#test-name-fn-timeout"></a><code>test(name, fn, timeout)</code></h2><p>alias：<code>it(name, fn, timeout)</code></p><p>argument：</p><ul><li><code>name</code>：測試名稱</li><li><code>fn</code>：包含要測試的期望函數</li><li><code>timeout</code> (可選)：測試終止之前要等待的時間 (單位毫秒)，預設為 5 秒</li></ul><p>測試檔案內一定要有 <code>test</code> 區塊才能測試程式。</p><p>剛剛有提到，不一定要 <code>describe</code> 區塊，可直接在測試檔內放 <code>test</code> 區塊即可。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>  expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="test-only-name-fn-timeout"><a class="header-anchor" href="#test-only-name-fn-timeout"></a><code>test.only(name, fn, timeout)</code></h2><p>alias：<code>it.only(name, fn, timeout)</code> 和 <code>fit(name, fn, timeout)</code></p><p>在 debug 測試檔內的測試時，通常只需要執行一部分的測試，此時就可以將那些 <code>test</code> 區塊加上 <code>.only</code> 來指定要執行哪些測試，其餘的測試都會被略過。</p><blockquote><p>註：<code>timeout</code> argument 跟 <code>test()</code> 一樣，所以不再次重複說明。</p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test.only(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>  expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>&#125;);<br><br>test(<span class="hljs-string">'其他運算'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 略過此區塊的測試</span><br>&#125;);<br></code></pre></td></tr></table></figure><div class="info"><p><code>test.only</code> 只會在 debug 階段使用，不建議 commit 至 Git 版本控制中，記得要在 debug 後刪掉 <code>.only</code>。</p></div><h2 id="test-skip-name-fn"><a class="header-anchor" href="#test-skip-name-fn"></a><code>test.skip(name, fn)</code></h2><p>alias：<code>it.skip(name, fn)</code> 或 <code>xit(name, fn)</code> 或 <code>xtest(name, fn)</code></p><p>若要跳過一些 <code>test</code> 區塊的測試，可用 <code>test.skip()</code>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>  expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>&#125;);<br><br>test.skip(<span class="hljs-string">'其他運算'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 略過此區塊的測試</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>若不想執行某 <code>test</code> 區塊的測試，雖然可將該測試註解掉，但建議用 <code>test.skip</code>，因為只少會保留原本的縮排和顯示程式碼 highlight。</p><h2 id="test-todo-name"><a class="header-anchor" href="#test-todo-name"></a><code>test.todo(name)</code></h2><p>alias：<code>it.todo(name)</code></p><p>規劃要寫的測試 (寫在 <code>name</code> argument 上) 可用 <code>test.todo()</code>，這些測試會在摘要輸出中 highlight 顯示，以便提醒你還有多少測試還沒寫。</p><p>若提供 test callback 函數，<code>test.todo()</code> 會拋出錯誤。若你已實作了該測試，且該測試已出錯，而你不想執行此測試，請改用 <code>test.skip()</code>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br><br>test.todo(<span class="hljs-string">'add should be associative'</span>);<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/api" target="_blank" rel="noopener">Globals · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;上次介紹了 &lt;a href=&quot;https://titangene.github.io/article/jest-matcher-assertion.html&quot;&gt;Jest 提供的 matcher&lt;/a&gt;，可讓你驗證程式碼是否符合預期，而這次來說明如何透過 &lt;code&gt;describe&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; 區塊來組織測試案例。當需求變多時，可針對需求來分類測試案例，將相關的測試放在同一個群組區塊內，此時就會用到 Jest 提供的 &lt;code&gt;describe&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; 區塊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="Node.js" scheme="https://titangene.github.io/tags/node-js/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Matcher &amp; Assertion</title>
    <link href="https://titangene.github.io/article/jest-matcher-assertion.html"/>
    <id>https://titangene.github.io/article/jest-matcher-assertion.html</id>
    <published>2020-06-07T03:56:22.000Z</published>
    <updated>2020-06-07T17:54:55.537Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>Assertion (斷言) 就要測試程式碼的執行結果是否符合預期，如果結果一致，代表測試通過，否則 assertion 就會拋出錯誤，代表測試失敗。而 Jest 提供多種 matcher，能讓你 assert 程式碼執行結果的正確性。</p><a id="more"></a><blockquote><p>之前介紹了如何建制 Jest 測試環境，還沒安裝環境的可參閱：</p><ul><li><a href="https://titangene.github.io/article/jest-build-test-env.html">Jest：建置測試環境 (包含 Babel) | Titangene Blog</a></li><li><a href="https://titangene.github.io/article/jest-typescript.html">Jest + TypeScript：建置測試環境 | Titangene Blog</a></li></ul></blockquote><p>下面介紹 Jest 提供的各種 matcher：</p><h1 id="通用-Matchers"><a class="header-anchor" href="#通用-Matchers"></a>通用 Matchers</h1><p><code>expect()</code> 回傳一個 “期望 (expectation)” 的物件</p><p>當 Jest 執行時，它會追蹤所有失敗的 matcher，以便列印錯誤訊息：</p><ul><li><code>.toBe()</code> 是 matcher，使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noopener"><code>Object.is()</code></a> 來測試 exact equality (精確相等)</li><li><code>.toEqual()</code>：檢查物件的值，遞迴的檢查物件或陣列的每個 field</li><li><code>.not</code>：matcher 的相反</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'two plus two is four'</span>, () =&gt; &#123;<br>  expect(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>).toBe(<span class="hljs-number">4</span>);<br>&#125;);<br><br>test(<span class="hljs-string">'object assignment'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">one</span>: <span class="hljs-number">1</span>&#125;;<br>  data[<span class="hljs-string">'two'</span>] = <span class="hljs-number">2</span>;<br>  expect(data).toEqual(&#123;<span class="hljs-attr">one</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">two</span>: <span class="hljs-number">2</span>&#125;);<br>&#125;);<br><br>test(<span class="hljs-string">'adding positive numbers is not zero'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>; a &lt; <span class="hljs-number">10</span>; a++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>; b &lt; <span class="hljs-number">10</span>; b++) &#123;<br>      expect(a + b).not.toBe(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Truthiness-真實性"><a class="header-anchor" href="#Truthiness-真實性"></a>Truthiness (真實性)</h1><p>在測試中，有時需要區分 <code>undefined</code>、<code>null</code> 和 <code>false</code>，但有時你又不需要區分。Jest 包含一些 helper，便於確認想要的內容：</p><ul><li><code>toBeNull</code> 只 match <code>null</code></li><li><code>toBeUndefined</code> 只 match <code>undefined</code></li><li><code>toBeDefined</code> 與 <code>toBeUndefined</code> 相反</li><li><code>toBeTruthy</code> match 任何 <code>if</code> 陳述句為 true</li><li><code>toBeFalsy</code> match 任何 <code>if</code> 陳述句為 false</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'null'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> n = <span class="hljs-literal">null</span>;<br>  expect(n).toBeNull();<br>  expect(n).not.toBeUndefined();<br>  expect(n).toBeDefined();<br>  expect(n).not.toBeTruthy();<br>  expect(n).toBeFalsy();<br>&#125;);<br><br>test(<span class="hljs-string">'zero'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> z = <span class="hljs-number">0</span>;<br>  expect(z).not.toBeNull();<br>  expect(z).toBeDefined();<br>  expect(z).not.toBeUndefined();<br>  expect(z).not.toBeTruthy();<br>  expect(z).toBeFalsy();<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Numbers"><a class="header-anchor" href="#Numbers"></a>Numbers</h1><p>大多數的比較數字都有 matcher equivalents (等價物)：</p><ul><li><code>toBeGreaterThan()</code>：比較 <code>received &gt; expected</code></li><li><code>toBeGreaterThanOrEqual()</code>：比較 <code>received &gt;= expected</code></li><li><code>toBeLessThan()</code>：比較 <code>received &lt; expected</code></li><li><code>toBeLessThanOrEqual()</code>：比較 <code>received &lt;= expected</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'two plus two'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> value = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>  expect(value).toBeGreaterThan(<span class="hljs-number">3</span>);<br>  expect(value).toBeGreaterThanOrEqual(<span class="hljs-number">3.5</span>);<br>  expect(value).toBeLessThan(<span class="hljs-number">5</span>);<br>  expect(value).toBeLessThanOrEqual(<span class="hljs-number">4.5</span>);<br><br>  <span class="hljs-comment">// toBe 和 toEqual 等價於數字</span><br>  expect(value).toBe(<span class="hljs-number">4</span>);<br>  expect(value).toEqual(<span class="hljs-number">4</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>對於浮點數相等，請使用 <code>toBeCloseTo()</code> 而不是 <code>toEqual()</code>，因為你不希望測試依賴於微小的捨入誤差 (rounding error)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'adding floating point numbers'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> value = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;<br>  <span class="hljs-comment">// expect(value).toBe(0.3);        由於舍入錯誤無法運作</span><br>  expect(value).toBeCloseTo(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// 可運作</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Strings"><a class="header-anchor" href="#Strings"></a>Strings</h1><p>可用 <code>toMatch()</code> 根據 regex 檢查字串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'there is no I in team'</span>, () =&gt; &#123;<br>  expect(<span class="hljs-string">'team'</span>).not.toMatch(<span class="hljs-regexp">/I/</span>);<br>&#125;);<br><br>test(<span class="hljs-string">'but there is a "stop" in Christoph'</span>, () =&gt; &#123;<br>  expect(<span class="hljs-string">'Christoph'</span>).toMatch(<span class="hljs-regexp">/stop/</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Arrays-和-iterables"><a class="header-anchor" href="#Arrays-和-iterables"></a>Arrays 和 iterables</h1><p>可用 <code>toContain()</code> 來檢查陣列或可迭代物件是否包含特定項目：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> shoppingList = [<br>  <span class="hljs-string">'diapers'</span>,<br>  <span class="hljs-string">'kleenex'</span>,<br>  <span class="hljs-string">'trash bags'</span>,<br>  <span class="hljs-string">'paper towels'</span>,<br>  <span class="hljs-string">'beer'</span>,<br>];<br><br>test(<span class="hljs-string">'the shopping list has beer on it'</span>, () =&gt; &#123;<br>  expect(shoppingList).toContain(<span class="hljs-string">'beer'</span>);<br>  expect(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(shoppingList)).toContain(<span class="hljs-string">'beer'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Exceptions"><a class="header-anchor" href="#Exceptions"></a>Exceptions</h1><p>若要測試特定函數在呼叫時是否拋出錯誤，請使用 <code>toThrow()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileAndroidCode</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'you are using the wrong JDK'</span>);<br>&#125;<br><br>test(<span class="hljs-string">'compiling android goes as expected'</span>, () =&gt; &#123;<br>  expect(compileAndroidCode).toThrow();<br>  expect(compileAndroidCode).toThrow(<span class="hljs-built_in">Error</span>);<br><br>  <span class="hljs-comment">// 還可以使用確切的錯誤訊息或 regexp</span><br>  expect(compileAndroidCode).toThrow(<span class="hljs-string">'you are using the wrong JDK'</span>);<br>  expect(compileAndroidCode).toThrow(<span class="hljs-regexp">/JDK/</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>更多 matcher 可參閱 Jest 社群維護的 <a href="https://github.com/jest-community/jest-extended" target="_blank" rel="noopener">jest-community/jest-extended</a>。</p></blockquote><p>資料來源：<a href="https://jestjs.io/docs/en/using-matchers" target="_blank" rel="noopener">Using Matchers · Jest</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;Assertion (斷言) 就要測試程式碼的執行結果是否符合預期，如果結果一致，代表測試通過，否則 assertion 就會拋出錯誤，代表測試失敗。而 Jest 提供多種 matcher，能讓你 assert 程式碼執行結果的正確性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="Node.js" scheme="https://titangene.github.io/tags/node-js/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
  </entry>
  
  <entry>
    <title>Jest + TypeScript：建置測試環境</title>
    <link href="https://titangene.github.io/article/jest-typescript.html"/>
    <id>https://titangene.github.io/article/jest-typescript.html</id>
    <published>2020-05-31T15:59:10.000Z</published>
    <updated>2020-05-31T16:17:18.711Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest-typescript.jpg" alt=""></p><p>TypeScript 是 JavaScript 的 typed superset，提供強大的型別檢查系統，讓你在編譯時期就能即時發現錯誤，而不是到了 runtime 才發生未知的 bug。上次介紹了 <a href="https://titangene.github.io/article/jest-build-test-env.html">Jest + Babel 的測試環境建置</a>，這次來介紹 Jest + TypeScript 的測試環境建置過程。</p><a id="more"></a><p>下面來介紹如何建置 Jest + TypeScript 的測試開發環境。</p><h1 id="建立開發環境"><a class="header-anchor" href="#建立開發環境"></a>建立開發環境</h1><h2 id="建立-npm-專案"><a class="header-anchor" href="#建立-npm-專案"></a>建立 npm 專案</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm init -y</span><br></code></pre></td></tr></table></figure><h2 id="安裝-TypeScript"><a class="header-anchor" href="#安裝-TypeScript"></a>安裝 TypeScript</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add -D typescript</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -D typescript</span><br></code></pre></td></tr></table></figure><h2 id="安裝與-Node-js-和-TypeScript-相關的環境"><a class="header-anchor" href="#安裝與-Node-js-和-TypeScript-相關的環境"></a>安裝與 Node.js 和 TypeScript 相關的環境</h2><ul><li><a href="https://github.com/TypeStrong/ts-node" target="_blank" rel="noopener"><code>ts-node</code></a>：Node.js 的 TypeScript 執行環境和 REPL，且支援 source map<ul><li>不用手動執行 <code>tsc</code> 編譯 TypeScript 檔案，就能直接像是使用 <code>node</code> 指令那樣，直接透過 <code>ts-node</code> 指令來編譯並執行 TypeScript 檔案</li></ul></li><li><a href="https://github.com/remy/nodemon" target="_blank" rel="noopener"><code>nodemon</code></a>：提供 watch 模式的 <code>node</code><ul><li>當 <code>nodemon</code> 檢測到指定目錄中的檔案有變更時，就會重新啟動 Node 應用程式</li></ul></li><li><a href="https://www.npmjs.com/package/@types/node" target="_blank" rel="noopener"><code>@types/node</code></a>：Node.js 的型別定義檔</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add -D ts-node nodemon @types/node</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -D ts-node nodemon @types/node</span><br></code></pre></td></tr></table></figure><h2 id="安裝與-Jest-和-TS-相關的環境"><a class="header-anchor" href="#安裝與-Jest-和-TS-相關的環境"></a>安裝與 Jest 和 TS 相關的環境</h2><ul><li><a href="https://github.com/facebook/jest" target="_blank" rel="noopener"><code>jest</code></a>：JavaScript 測試框架</li><li><a href="https://github.com/kulshekhar/ts-jest" target="_blank" rel="noopener"><code>ts-jest</code></a>：用於 Jest preprocessor 的 TypeScript preprocessor<ul><li>支援 Jest 的 source map</li><li>可讓你使用 Jest 來測試用 TypeScript 寫的專案</li><li>支援 TS 的所有功能，包括型別檢查</li></ul></li><li><a href="https://www.npmjs.com/package/@types/jest" target="_blank" rel="noopener"><code>@types/jest</code></a>：Jest 的型別定義檔</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add -D jest ts-jest @types/jest</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -D jest ts-jest @types/jest</span><br></code></pre></td></tr></table></figure><h2 id="設定-package-json"><a class="header-anchor" href="#設定-package-json"></a>設定 <code>package.json</code></h2><p>在 <code>package.json</code> 加上下面內容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"scripts"</span>: &#123;<br>    <span class="hljs-attr">"start"</span>: <span class="hljs-string">"ts-node src/main.ts"</span>,<br>    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"nodemon --watch 'src/**/*.ts' --exec ts-node src/main.ts"</span>,<br>    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"tsc"</span>,<br>    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"jest --coverage"</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="設定-jest-config-js"><a class="header-anchor" href="#設定-jest-config-js"></a>設定 <code>jest.config.js</code></h2><p>Jest 的預設是可以不用配置任何檔案就能執行測試，但 Jest 的預設是使用 Babel 來處理 <code>.ts</code> (和 <code>.tsx</code> ) 檔案 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，而 Babel 不會對 <code>.ts</code> 檔案進行編譯處理，所以就不會進行型別檢查。而 <code>ts-jest</code> 就能幫你處理 TS 該做的這些事。</p><blockquote><p>在 <a href="https://kulshekhar.github.io/ts-jest/user/babel7-or-ts" target="_blank" rel="noopener">Babel7 or TypeScript | ts-jest</a> 這篇文章內有提到為何不要用 <code>@babel/preset-typescript</code>，而要用 <code>ts-jest</code> 的原因。</p><p>所以若要開發 TypeScript，不建議使用 Babel，建議用 <code>tsc</code> 來編譯 TypeScript。</p></blockquote><p>為了要使用 <code>ts-jest</code> 來 transpile TypeScript，請執行以下指令來建立 Jest 的配置檔案 <code>jest.config.js</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx ts-jest config:init</span><br></code></pre></td></tr></table></figure><p>此指令建立的 <code>jest.config.js</code> 檔案內容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  preset: <span class="hljs-string">'ts-jest'</span>,<br>  testEnvironment: <span class="hljs-string">'node'</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>但我自己自訂了一些配置：</p><ul><li><code>coverageDirectory</code>：Jest 輸出的 coverage 檔案要放在哪個目錄<ul><li>預設：<code>undefined</code></li></ul></li><li><code>preset</code>：設定 preset<ul><li>預設：<code>undefined</code></li><li>preset 應指向 root 目錄上具有 <code>jest-preset.json</code> 或 <code>jest-preset.js</code> 檔案的 npm 模組</li></ul></li><li><code>testEnvironment</code>：用於測試的測試環境<ul><li>預設：<code>&quot;jsdom&quot;</code> (類似瀏覽器的環境)</li><li>若要建置 node service，可用 <code>&quot;node&quot;</code> 來使用類似 node 的環境</li></ul></li><li><code>testRegex</code>：Jest 只執行 match 此 pattern 的測試檔案<ul><li>預設：<code>(/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$</code><ul><li>即在 <code>__tests__</code> 目錄內的 <code>.js</code>、<code>.jsx</code>、<code>.ts</code> 和 <code>.tsx</code> 檔，以及帶有 <code>.test</code> 或 <code>.spec</code> 後綴的任何檔案，例如：<code>sum.test.ts</code> 或 <code>sum.spec.ts</code></li></ul></li><li>Jest 會用 <code>testRegex</code> 配置的 pattern 來嘗試 match 測試檔案的絕對路徑</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  coverageDirectory: <span class="hljs-string">"coverage"</span>,<br>  preset: <span class="hljs-string">'ts-jest'</span>,<br>  testEnvironment: <span class="hljs-string">"node"</span>,<br>  testRegex: <span class="hljs-string">"(/__tests__/.*|(\\.|/)(test|spec))\\.tsx?$"</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>更多 Jest 配置詳情可參閱 <a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">Configuring Jest · Jest</a>。</p></blockquote><h1 id="設定-tsconfig-json"><a class="header-anchor" href="#設定-tsconfig-json"></a>設定 <code>tsconfig.json</code></h1><p>自己手動建立 <code>tsconfig.json</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"compilerOptions"</span>: &#123;<br>    <span class="hljs-attr">"target"</span>: <span class="hljs-string">"es6"</span>,<br>    <span class="hljs-attr">"module"</span>: <span class="hljs-string">"commonjs"</span>,<br>    <span class="hljs-attr">"outDir"</span>: <span class="hljs-string">"dist"</span>,<br>    <span class="hljs-attr">"strict"</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">"sourceMap"</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">"esModuleInterop"</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>當然你也可以用 <code>tsc --init</code> 指令來建立 <code>tsconfig.json</code>。</p><blockquote><p>更多 <code>tsconfig.json</code> 配置詳情可參閱 <a href="https://www.typescriptlang.org/tsconfig" target="_blank" rel="noopener">TypeScript: TSConfig Reference - Docs on every TSConfig option</a>。</p></blockquote><h1 id="寫範例程式碼"><a class="header-anchor" href="#寫範例程式碼"></a>寫範例程式碼</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/sum.ts</span><br><span class="hljs-keyword">type</span> sumType = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">const</span> sum: sumType = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> sum;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/main.ts</span><br><span class="hljs-keyword">import</span> sum <span class="hljs-keyword">from</span> <span class="hljs-string">'./sum'</span>;<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>執行 <code>main.js</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn start</span><br>yarn run v1.21.1<br><span class="hljs-meta">$</span><span class="bash"> ts-node src/main.ts</span><br>3<br>Done in 4.71s.<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm run start</span><br><br><span class="hljs-meta">&gt;</span><span class="bash"> jest-typescript-101@1.0.0 start /home/titan/project/jest/jest-typescript-101</span><br><span class="hljs-meta">&gt;</span><span class="bash"> ts-node src/main.ts</span><br><br>3<br></code></pre></td></tr></table></figure><h1 id="建立測試"><a class="header-anchor" href="#建立測試"></a>建立測試</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/__tests__/sum.test.ts</span><br><span class="hljs-keyword">import</span> sum <span class="hljs-keyword">from</span> <span class="hljs-string">'../sum'</span>;<br><br>test(<span class="hljs-string">'adds 1 + 2 to equal 3'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// Arrange</span><br>  <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>, y: <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> expected: <span class="hljs-built_in">number</span> = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-comment">// Act</span><br>  <span class="hljs-keyword">let</span> actual: <span class="hljs-built_in">number</span> = sum(x, y);<br><br>  <span class="hljs-comment">// Assert</span><br>  expect(actual).toBe(expected);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="執行測試"><a class="header-anchor" href="#執行測試"></a>執行測試</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm run <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>測試通過：</p><p><img src="../images/jest-typescript/2020-05-31-23-23-21.png" alt=""></p><p>資料來源：</p><ul><li><a href="https://kulshekhar.github.io/ts-jest/" target="_blank" rel="noopener">ts-jest</a></li><li><a href="https://github.com/TypeStrong/ts-node" target="_blank" rel="noopener">ts-node</a></li><li><a href="https://github.com/remy/nodemon" target="_blank" rel="noopener">nodemon</a></li><li><a href="https://jestjs.io/docs/en/getting-started" target="_blank" rel="noopener">Getting Started · Jest</a></li><li><a href="https://jestjs.io/docs/en/cli" target="_blank" rel="noopener">Jest CLI Options · Jest</a></li><li><a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">Configuring Jest · Jest</a></li><li><a href="https://www.typescriptlang.org/tsconfig" target="_blank" rel="noopener">TypeScript: TSConfig Reference - Docs on every TSConfig option</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://jestjs.io/blog/2019/01/25/jest-24-refreshing-polished-typescript-friendly#typescript-support" target="_blank" rel="noopener">Jest 24: 💅 Refreshing, Polished, TypeScript-friendly · Jest</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest-typescript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;TypeScript 是 JavaScript 的 typed superset，提供強大的型別檢查系統，讓你在編譯時期就能即時發現錯誤，而不是到了 runtime 才發生未知的 bug。上次介紹了 &lt;a href=&quot;https://titangene.github.io/article/jest-build-test-env.html&quot;&gt;Jest + Babel 的測試環境建置&lt;/a&gt;，這次來介紹 Jest + TypeScript 的測試環境建置過程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="Node.js" scheme="https://titangene.github.io/tags/node-js/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="TypeScript" scheme="https://titangene.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Jest：建置測試環境 (包含 Babel)</title>
    <link href="https://titangene.github.io/article/jest-build-test-env.html"/>
    <id>https://titangene.github.io/article/jest-build-test-env.html</id>
    <published>2020-05-24T15:50:20.000Z</published>
    <updated>2020-05-31T14:26:12.479Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>最近在學習單元測試，而 Jest 是在前端蠻常見的測試框架，可透過建立測試來確保自己寫的程式碼是否符合需求，而且當改動程式碼時，才能確保是否因不小心而產生的 bug，測試能讓我更有信心的去重構程式碼。</p><a id="more"></a><p>那 Jest 可以用在哪些專案？你可為下面這些專案建立測試：</p><ul><li><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a></li><li><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node</a></li><li><a href="https://angular.io/" target="_blank" rel="noopener">Angular</a>、<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>、<a href="https://reactjs.org/" target="_blank" rel="noopener">React</a></li><li>…等</li></ul><p>下面來介紹如何建置 Jest 的測試開發環境。</p><h1 id="建立開發環境"><a class="header-anchor" href="#建立開發環境"></a>建立開發環境</h1><h2 id="建立-npm-專案"><a class="header-anchor" href="#建立-npm-專案"></a>建立 npm 專案</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm init -y</span><br></code></pre></td></tr></table></figure><h2 id="安裝-Jest"><a class="header-anchor" href="#安裝-Jest"></a>安裝 Jest</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add -D jest</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -D jest</span><br></code></pre></td></tr></table></figure><h2 id="設定-package-json"><a class="header-anchor" href="#設定-package-json"></a>設定 <code>package.json</code></h2><p>在 <code>package.json</code> 加上下面內容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"scripts"</span>: &#123;<br>    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"jest"</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="寫範例程式碼"><a class="header-anchor" href="#寫範例程式碼"></a>寫範例程式碼</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// sum.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = sum;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./sum'</span>);<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>執行 <code>main.js</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node main.js</span><br>3<br></code></pre></td></tr></table></figure><h1 id="建立測試"><a class="header-anchor" href="#建立測試"></a>建立測試</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// sum.test.js</span><br><span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./sum'</span>);<br><br>test(<span class="hljs-string">'adds 1 + 2 to equal 3'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// Arrange</span><br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> expected = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-comment">// Act</span><br>  <span class="hljs-keyword">let</span> actual = sum(x, y);<br><br>  <span class="hljs-comment">// Assert</span><br>  expect(actual).toBe(expected);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="執行測試"><a class="header-anchor" href="#執行測試"></a>執行測試</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm run <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>測試通過：</p><p><img src="../images/jest-build-test-env/2020-05-24-22-26-37.png" alt=""></p><h1 id="從指令列執行測試"><a class="header-anchor" href="#從指令列執行測試"></a>從指令列執行測試</h1><p>例如：Jest 只執行 match <code>my-test</code> 的測試檔案，以及使用 <code>config.json</code> 作為配置檔案，並且在執行後顯示 native 的 OS 通知：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> jest my-test --notify --config=config.json</span><br></code></pre></td></tr></table></figure><p>Jest CLI option 說明：</p><ul><li><code>jest &lt;regexForTestFiles&gt;</code>：match 到名為 <code>&lt;regexForTestFiles&gt;</code> (像此範例的 <code>my-test</code> ) 的檔案執行 Jest<ul><li>若在執行 <code>jest</code> 時使用了 <code>&lt;regexForTestFiles&gt;</code> argument，該 argument 會被視為 regex pattern，Jest 只會執行與 pattern match 的測試檔案</li><li>有些 terminal 可能需要用引號把 argument 包起來，例如：<code>jest &quot;my.*(complex)?pattern&quot;</code></li><li>Windows 需使用 <code>/</code> 作為路徑分隔字元 (separator) 或將 <code>\</code> 轉義 (escape) 成 <code>\\</code></li></ul></li><li><code>--config=&lt;path&gt;</code>，<code>-c=&lt;path&gt;</code>：使用 <code>&lt;path&gt;</code> (像此範例的 <code>config.json</code> ) 作為配置檔案<ul><li>Jest 配置檔案的路徑來指定如何查找和執行測試</li><li>如果在配置中未設定 <code>rootDir</code>，則假定包含配置檔案的目錄為專案的 <code>rootDir</code></li><li>也可以是 JSON-encoded value 作為 Jest 的配置</li></ul></li><li><code>--notify</code>：執行完成後顯示原生的 OS 通知<ul><li>激活 (activates) 測試結果通知</li><li>當你不希望自己的意識能夠專注於 JavaScript 測試以外的任何事物時，可用此 option</li><li>Beware：Jest 使用 <a href="https://github.com/mikaelbr/node-notifier" target="_blank" rel="noopener">node-notifier</a> 來顯示桌面通知<ul><li>在 Windows 上，它在第一次使用時會建立一個新的 start menu entry，並且不會顯示通知。通知將在後續執行中正確顯示</li></ul></li></ul></li></ul><h1 id="Jest-Config"><a class="header-anchor" href="#Jest-Config"></a>Jest Config</h1><p>使用下面指令生成 Jest 的基礎配置檔案 <code>jest.config.js</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> jest --init</span><br></code></pre></td></tr></table></figure><p>因為我沒有在 global 安裝 <code>jest</code>，所以需要透過 <code>yarn</code> 來執行 Jest CLI (或是可透過 <code>npx</code> 來執行)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn <span class="hljs-built_in">test</span> --init</span><br>yarn run v1.21.1<br><span class="hljs-meta">$</span><span class="bash"> jest --init</span><br><br>The following questions will help Jest to create a suitable configuration for your project<br><br>✔ Choose the test environment that will be used for testing › node<br>✔ Do you want Jest to add coverage reports? … yes<br>✔ Automatically clear mock calls and instances between every test? … no<br><br>📝  Configuration file created at /home/titan/.local/share/Trash/files/jest.config.js<br>Done in 7.41s.<br></code></pre></td></tr></table></figure><p>第一個問題我選擇 <code>node</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">? Choose the test environment that will be used for testing › - Use arrow-keys. Return to submit.<br>❯   node<br>    jsdom (browser-like)<br></code></pre></td></tr></table></figure><p>第二個問題：是否要測試涵蓋報告 (coverage reports)？我選擇 <code>yes</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">? Do you want Jest to add coverage reports? › (y/N)<br></code></pre></td></tr></table></figure><p>第三個問題：是否要在每個測試之間自動清除 mock calls 和 instance？我選擇 <code>No</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">? Automatically clear mock calls and instances between every test? › (y/N)<br></code></pre></td></tr></table></figure><p>下面是剛剛執行 <code>jest init</code> 時，所生成的 <code>jest.config.js</code> 設定：</p><ul><li><code>coverageDirectory</code>：Jest 輸出的 coverage 檔案要放在哪個目錄<ul><li>預設：<code>undefined</code></li></ul></li><li><code>testEnvironment</code>：用於測試的測試環境<ul><li>預設：<code>&quot;jsdom&quot;</code> (類似瀏覽器的環境)</li><li>若要建置 node service，可用 <code>&quot;node&quot;</code> 來使用類似 node 的環境</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  coverageDirectory: <span class="hljs-string">"coverage"</span>,<br>  testEnvironment: <span class="hljs-string">"node"</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>更多 Jest 配置設定，詳情可參閱 <a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">Configuring Jest · Jest</a>。</p></blockquote><h1 id="使用-Babel"><a class="header-anchor" href="#使用-Babel"></a>使用 Babel</h1><p>在安裝 Babel 前，將程式碼改成 ES6 語法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// sum.js</span><br><span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> sum;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> sum <span class="hljs-keyword">from</span> <span class="hljs-string">'./sum'</span>;<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// sum.test.js</span><br><span class="hljs-keyword">import</span> sum <span class="hljs-keyword">from</span> <span class="hljs-string">'./sum'</span>;<br><br>test(<span class="hljs-string">'adds 1 + 2 to equal 3'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// Arrange</span><br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> expected = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-comment">// Act</span><br>  <span class="hljs-keyword">let</span> actual = sum(x, y);<br><br>  <span class="hljs-comment">// Assert</span><br>  expect(actual).toBe(expected);<br>&#125;);<br></code></pre></td></tr></table></figure><p>跑測試會出錯，因為 Jest 需要透過 Babel 才能執行 ES6 的語法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-build-test-env/2020-05-24-23-17-50.png" alt=""></p><p>所以來安裝 <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add -D babel-jest @babel/core @babel/preset-env</span><br></code></pre></td></tr></table></figure><p>在專案根目錄建立 <code>babel.config.js</code>，此檔案用於配置與你當前 Node 版本相容的 Babel：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// babel.config.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  presets: [<br>    [<br>      <span class="hljs-string">'@babel/preset-env'</span>,<br>      &#123;<br>        targets: &#123;<br>          node: <span class="hljs-string">'current'</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>再跑測試就會通過：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-build-test-env/2020-05-24-23-24-29.png" alt=""></p><blockquote><p>詳情可參閱 <a href="https://babeljs.io/docs/en/" target="_blank" rel="noopener">Babel 官方文件</a>。</p></blockquote><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/getting-started" target="_blank" rel="noopener">Getting Started · Jest</a></li><li><a href="https://jestjs.io/docs/en/cli" target="_blank" rel="noopener">Jest CLI Options · Jest</a></li><li><a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">Configuring Jest · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;最近在學習單元測試，而 Jest 是在前端蠻常見的測試框架，可透過建立測試來確保自己寫的程式碼是否符合需求，而且當改動程式碼時，才能確保是否因不小心而產生的 bug，測試能讓我更有信心的去重構程式碼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Babel" scheme="https://titangene.github.io/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>Sass：@import rule</title>
    <link href="https://titangene.github.io/article/sass-import-rule.html"/>
    <id>https://titangene.github.io/article/sass-import-rule.html</id>
    <published>2020-05-17T15:54:46.000Z</published>
    <updated>2020-05-17T15:53:41.487Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/sass.jpg" alt=""></p><p>Sass 的 <code>@import</code> rule 可以引入 Sass 和 CSS stylesheet、提供對 mixin、function 和變數的存取，並且還能將多個 stylesheet 的 CSS 組合在一起。例如：<code>main.scss</code> 內使用 <code>@import</code> 引入 Sass 和 CSS 檔，在編譯 Sass 後，就只會產生一個 <code>main.css</code> 檔。</p><a id="more"></a><p>而 CSS 本身提供的 <code>@import</code> rule 會讓瀏覽器在呈現頁面時，有幾個 CSS 檔案是透過 <code>@import</code> 引入的，就要發出幾個 HTTP request，這與 Sass <code>@import</code> rule 的行為不同。</p><h2 id="同時引入多個檔案"><a class="header-anchor" href="#同時引入多個檔案"></a>同時引入多個檔案</h2><p>雖然 Sass 和 CSS 的引入語法相同，但 Sass 可以用逗號分隔，一次引入多個檔案，不需要每個檔案都各別用一行 <code>@import</code> 引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; _button.scss<br>.button &#123; color: #aaa; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; _nav.scss<br>.nav &#123; color: #bbb; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; main.scss<br>@import &#39;button&#39;, &#39;nav&#39;;<br><br>main &#123; color: #000; &#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>; &#125;<br><span class="hljs-selector-class">.nav</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#bbb</span>; &#125;<br><span class="hljs-selector-tag">main</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>; &#125;<br></code></pre></td></tr></table></figure><p>當 Sass 引入檔案時，會對該檔案進行估算，很像是將內容直接抄在你使用 <code>@import</code> 的位置上。</p><p>在 <code>@import</code> 之前定義的任何 mixin、function 或變數 (甚至來自其他 <code>@import</code> 的) 都可以在你引入的 stylesheet 中使用他們。</p><h2 id="不要重複引入"><a class="header-anchor" href="#不要重複引入"></a>不要重複引入</h2><p>所以若對同一個檔案引入多次，就會造成編譯出來的 CSS 檔案內，會有重複的 stylesheet。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; main.scss<br>@import &#39;button&#39;;<br>@import &#39;button&#39;;<br><br>main &#123; color: #000; &#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>; &#125;<br><span class="hljs-selector-class">.button</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>; &#125;<br><span class="hljs-selector-tag">main</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>; &#125;<br></code></pre></td></tr></table></figure><p>除非你重複引入的檔案內，只有像是 mixin、function 或變數等不會產生樣式規則的東西，就不會產生重複的內容。</p><h2 id="引入不用寫副檔名"><a class="header-anchor" href="#引入不用寫副檔名"></a>引入不用寫副檔名</h2><p>另外，使用 Sass 的 <code>@import</code> rule 時，不用寫檔案的副檔名，因為 Sass 會自動幫你引入。</p><p>例如：當你引入 <code>@import &quot;a&quot;</code> 時，Sass 會自動引入 <code>a.scss</code>、<code>a.sass</code> 或 <code>a.css</code>。但 CSS 本身提供的 <code>@import</code> rule 記得要寫檔案的副檔名才能正確的引入。</p><h2 id="引入路徑"><a class="header-anchor" href="#引入路徑"></a>引入路徑</h2><ul><li>在引入 partials (以 <code>_</code> 為開頭的檔案) 時，不用寫 <code>_</code> 就能引入，且該檔案不會被編譯</li><li>引入檔案時可省略 <code>./</code> 相對引入</li><li>在使用 Sass CLI 時，若有提供 <code>--load-path</code> 或 <code>-I</code> option，就可以簡化引入的路徑<ul><li>詳情可參閱我之前寫的 <a href="https://titangene.github.io/article/dart-sass.html#load-path%EF%BC%8C-I">Dart Sass 介紹 (使用與安裝)</a></li><li>但引入時，Sass 會先解析相對於當前檔案的路徑，若沒有找到時，才會引入相對於 <code>--load-path</code> 提供的路徑內的檔案</li></ul></li></ul><p>例如：在 <code>node_modules/bootstrap/scss</code> 目錄內正好有名為 <code>_button.scss</code> 的檔案，而我引入了 <code>@import 'buttons'</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; src&#x2F;_buttons.scss<br>.button &#123; color: blue; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; src&#x2F;main.scss<br>@import &#39;buttons&#39;;<br><br>main &#123; color: #000; &#125;<br></code></pre></td></tr></table></figure><p>編譯 Sass (注意，我使用了 <code>--load-path</code> option，指定了 Bootstrap 內的路徑)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --load-path=node_modules/bootstrap/scss src/main.scss</span><br></code></pre></td></tr></table></figure><p>但輸出的結果表名，我引入的 <code>@import 'buttons'</code> 指的是 <code>src/_buttons.scss</code> 這個檔案，而不是 <code>node_modules/bootstrap/scss</code> 目錄內的 <code>_button.scss</code> 這個檔案：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123; <span class="hljs-attribute">color</span>: blue; &#125;<br><span class="hljs-selector-tag">main</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>; &#125;<br></code></pre></td></tr></table></figure><p>因為在 <code>src</code> 目錄內，<code>_buttons.scss</code> 相對於 <code>main.scss</code>，所以不會引用到 Bootstrap 內的檔案。</p><h2 id="index-檔案"><a class="header-anchor" href="#index-檔案"></a>index 檔案</h2><p>若在資料夾 (例如：<code>base</code> 資料夾) 內建立 <code>_index.scss</code> 或 <code>_index.sass</code> 檔案，而 index 檔案內引入了該資料夾內的其他檔案 (例如：<code>_code.scss</code> 和 <code>_list.scss</code> ) 時，則可直接透過 <code>@import</code> 該資料夾來引入那些檔案。</p><p>目錄結構：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree</span><br>.<br>├── base<br>│   ├── _code.scss<br>│   ├── _index.scss<br>│   └── _list.scss<br>└── main.scss<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; base&#x2F;_code.scss<br>code &#123; padding: 4px; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; base&#x2F;_list.scss<br>ul &#123; padding: 0; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; base&#x2F;_index.scss<br>@import &#39;code&#39;, &#39;list&#39;;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; main.scss<br>@import &#39;base&#39;;<br><br>main &#123; color: #000; &#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">code</span> &#123; <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>; &#125;<br><span class="hljs-selector-tag">ul</span> &#123; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>; &#125;<br><span class="hljs-selector-tag">main</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>; &#125;<br></code></pre></td></tr></table></figure><h2 id="巢狀引入"><a class="header-anchor" href="#巢狀引入"></a>巢狀引入</h2><p>也可以巢狀引入，但要注意的是在巢狀引入 (nested import) 中定義的 mixin、function 或變數都還是全域定義的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; _button.scss<br>.button &#123; color: #aaa; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; main.scss<br>main &#123;<br>  @import &#39;a&#39;;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span> <span class="hljs-selector-class">.button</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>; &#125;<br></code></pre></td></tr></table></figure><p>若是巢狀引入的檔案內有使用 parent selectors (也就是 <code>&amp;</code> )，則會引用 stylesheet 巢狀在其中的選擇器 (估算的方式類似 mixin)，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; _theme.scss<br>ul li &#123;<br>  padding-left: 16px;<br><br>  [dir&#x3D;rtl] &amp; &#123;<br>    padding-left: 0;<br>    padding-right: 16px;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; style.scss<br>.theme-sample &#123;<br>  @import &#39;theme&#39;;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.theme-sample</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">16px</span>;<br>&#125;<br><span class="hljs-selector-attr">[dir=rtl]</span> <span class="hljs-selector-class">.theme-sample</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">16px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引入-CSS"><a class="header-anchor" href="#引入-CSS"></a>引入 CSS</h2><p>Sass 的 <code>@import</code> rule 除了可以引入 <code>.scss</code> 和 <code>.sass</code> 檔，也可以引入 <code>.css</code> 檔。</p><p>但要記得在引入 <code>.css</code> 檔時，不可以像 <code>@import 'file.css';</code> 這樣明確的寫你引入了 <code>.css</code> 檔，而是要忽略副檔名。因為當你明確的寫 <code>.css</code> 副檔名時，代表你想用 <a href="https://sass-lang.com/documentation/at-rules/import#plain-css-imports" target="_blank" rel="noopener">CSS 原本的 <code>@import</code> rule</a>。</p><p>以下這些引入方式都是 CSS 原本的 <code>@import</code> rule：</p><ul><li>以 <code>.css</code> 為結尾的 URL</li><li>以 <code>http://</code> 或 <code>https://</code> 為開頭的 URL</li><li>用 <code>url()</code> 來引入 URL</li><li>具有 media query 的引入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">@import &quot;theme.css&quot;;<br>@import &quot;http:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;Droid+Sans&quot;;<br>@import url(theme);<br>@import &quot;landscape&quot; screen and (orientation: landscape);<br></code></pre></td></tr></table></figure><h2 id="Interpolation"><a class="header-anchor" href="#Interpolation"></a>Interpolation</h2><p>雖然 Sass imports 不能使用 <a href="https://sass-lang.com/documentation/interpolation" target="_blank" rel="noopener">interpolation</a>，但 CSS 原本的 <code>@import</code> 是可以的。這樣就可以動態生成引入的 URL，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sass">@mixin google-font($family) &#123;<br>  @import url(&quot;http:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;#&#123;$family&#125;&quot;);<br>&#125;<br><br>@include google-font(&quot;Droid Sans&quot;);<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">"http://fonts.googleapis.com/css?family=Droid Sans"</span>);<br></code></pre></td></tr></table></figure><p>資料來源：<a href="https://sass-lang.com/documentation/at-rules/import" target="_blank" rel="noopener">Sass: @import</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/sass.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;Sass 的 &lt;code&gt;@import&lt;/code&gt; rule 可以引入 Sass 和 CSS stylesheet、提供對 mixin、function 和變數的存取，並且還能將多個 stylesheet 的 CSS 組合在一起。例如：&lt;code&gt;main.scss&lt;/code&gt; 內使用 &lt;code&gt;@import&lt;/code&gt; 引入 Sass 和 CSS 檔，在編譯 Sass 後，就只會產生一個 &lt;code&gt;main.css&lt;/code&gt; 檔。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web Dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Sass" scheme="https://titangene.github.io/tags/sass/"/>
    
      <category term="CSS" scheme="https://titangene.github.io/tags/css/"/>
    
      <category term="Dart Sass" scheme="https://titangene.github.io/tags/dart-sass/"/>
    
  </entry>
  
  <entry>
    <title>Sass：@use rule</title>
    <link href="https://titangene.github.io/article/sass-use-rule.html"/>
    <id>https://titangene.github.io/article/sass-use-rule.html</id>
    <published>2020-05-10T15:54:48.000Z</published>
    <updated>2020-05-10T23:03:19.504Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/sass.jpg" alt=""></p><p>若要模組化 Sass，最常用的就是 <code>@import</code> 規則。但在 <a href="https://titangene.github.io/article/dart-sass.html">Dart Sass</a> 推出了一個新功能：模組系統，可用 <code>@use</code> 規則，並透過 namespace 來引入其他 stylesheet 中的成員。</p><a id="more"></a><h1 id="Overview"><a class="header-anchor" href="#Overview"></a>Overview</h1><ul><li>載入其他 Sass stylesheet 中的 mixin、函數和變數，並將多個 stylesheet 中的 CSS 組合在一起</li><li>不管用 <code>@use</code> 載入幾次的任何樣式，都只會在編譯的 CSS 輸出中出現一次</li><li><code>@use</code> 必須放在所有規則之前 (除了 <code>@forward</code> 和變數宣告之外)</li><li>便於了解成員是從哪些檔案載入的</li><li>不用像使用 <code>@import</code> 時那樣，需把命名寫清楚，因為可透過 <code>@use</code> 提供的 namespace 來避免命名衝突</li></ul><div class="info"><p>只要使用 <code>@use</code> 引入的檔案，stylesheet 就會被全部引入，不管有無另外使用。</p></div><h1 id="語法"><a class="header-anchor" href="#語法"></a>語法</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span>;<br><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> as &lt;namespace&gt;;<br><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> as *;<br><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> with (<br>  &lt;variable&gt;: &lt;value&gt;,<br>  &lt;variable&gt;: &lt;value&gt;<br>);<br></code></pre></td></tr></table></figure><h1 id="載入成員"><a class="header-anchor" href="#載入成員"></a>載入成員</h1><ul><li>用 <code>@use</code> 載入的 stylesheet 稱為「modules (模組)」。</li><li>使用 <code>@use</code> 時，可透過 namespace 來存取另一個模組中的變數、函數和 mixin：<ul><li>變數：<code>&lt;namespace&gt;.&lt;variable&gt;</code></li><li>函數：<code>&lt;namespace&gt;.&lt;function&gt;()</code></li><li>mixin：<code>@include &lt;namespace&gt;.&lt;mixin&gt;()</code></li></ul></li><li>預設的 <code>&lt;namespace&gt;</code> 就是模組 URL 的檔名 (不包含 <code>_</code> 底線前綴和副檔名)</li><li>用 <code>@use</code> 載入的成員有存取範圍，只有載入它們的 stylesheet 才能存取<ul><li>若其他 stylesheet 想存取這些成員，就必須自己寫 <code>@use</code> 載入</li></ul></li></ul><p>例如：用 <code>@use</code> 引入的 <code>styles/base/_color.scss</code> 檔案會像下面這樣，而此模組的 namespace 就是 <code>color</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/base/_color.scss</span><br><span class="hljs-variable">$blue</span>: <span class="hljs-number">#2979ff</span>;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/_tool.scss</span><br><span class="hljs-keyword">@mixin</span> rounded &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>&#125;<br><br><span class="hljs-keyword">@function</span> px2em(<span class="hljs-variable">$pixel</span>, <span class="hljs-variable">$font-size-base</span>: <span class="hljs-number">16px</span>) &#123;<br>  <span class="hljs-keyword">@return</span> (<span class="hljs-variable">$pixel</span> / <span class="hljs-variable">$font-size-base</span>) * <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/main.scss</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"base/color"</span>;<br><span class="hljs-keyword">@use</span> <span class="hljs-string">"tool"</span>;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: color.<span class="hljs-variable">$blue</span>;<br>  <span class="hljs-attribute">font-size</span>: tool.px2em(<span class="hljs-number">32px</span>);<br>  <span class="hljs-keyword">@include</span> tool.rounded;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#2979ff</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="設定-namespace"><a class="header-anchor" href="#設定-namespace"></a>設定 namespace</h1><p>語法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> as &lt;namespace&gt;;<br><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> as *;<br></code></pre></td></tr></table></figure><p>自訂 namespace (很像設定 alias) 的情境：</p><ul><li>載入相同檔名的多個模組 (例如：第三方 library 和我的檔名相同)</li><li>讓模組的名稱變短</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// src/_mycolor.scss</span><br><span class="hljs-variable">$blue</span>: <span class="hljs-number">#2979ff</span>;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// src/main.scss</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"src/mycolor"</span> as color;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">color</span>: color.<span class="hljs-variable">$blue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#2979ff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可用 <code>*</code> 來載入沒有 namespace 的模組，但建議使用在自己寫的 stylesheet 或 <a href="https://sass-lang.com/documentation/modules" target="_blank" rel="noopener">Sass 提供的內建模組</a>，以避免引入名稱衝突的成員：</p><p>例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">'sass:math'</span> as *;<br><br><span class="hljs-variable">$half</span>: percentage(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>);<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$half</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="私有成員"><a class="header-anchor" href="#私有成員"></a>私有成員</h1><p>若你不想讓你定義的所有成員都可在 stylesheet 之外使用，就可在成員名稱的前面加上 <code>-</code> 或 <code>_</code>，來讓它們變成私有成員。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/_corner.scss</span><br>$_radius: <span class="hljs-number">3px</span>;<br><br><span class="hljs-keyword">@mixin</span> rounded &#123;<br>  <span class="hljs-attribute">border-radius</span>: $_radius;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/main.scss</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"corner"</span>;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: corner.rounded;<br>  <span class="hljs-attribute">padding</span>: corner.$_radius;  <span class="hljs-comment">// Error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>編譯會報錯：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx sass styles:dict/styles</span><br>Error: Private members can't be accessed from outside their modules.<br>  ╷<br>5 │   padding: corner.$_radius;<br>  │            ^^^^^^^^^^^^^^^<br>  ╵<br>  src/scss/main.scss 5:12  root stylesheet<br></code></pre></td></tr></table></figure><h1 id="配置模組"><a class="header-anchor" href="#配置模組"></a>配置模組</h1><p>stylesheet 可用 <a href="https://sass-lang.com/documentation/variables#default-values" target="_blank" rel="noopener"><code>!default</code> flag</a> 來定義變數，會被新的值給覆蓋。</p><p>若要載入帶有配置的模組，可用以下語法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> with (<br>  &lt;variable&gt;: &lt;value&gt;,<br>  &lt;variable&gt;: &lt;value&gt;<br>);<br></code></pre></td></tr></table></figure><p>配置的值會覆蓋變數的預設值。</p><p>例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/base/_color.scss</span><br><span class="hljs-variable">$blue</span>: <span class="hljs-number">#2979ff</span> !default;<br><span class="hljs-variable">$red</span>: <span class="hljs-number">#f44336</span> !default;<br><br><span class="hljs-variable">$primary</span>: <span class="hljs-variable">$blue</span>;<br><span class="hljs-variable">$secondary</span>: <span class="hljs-variable">$red</span>;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/main.scss</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"base/color"</span> with (<br>  <span class="hljs-variable">$blue</span>: <span class="hljs-number">#00f</span>,<br>  <span class="hljs-variable">$red</span>: <span class="hljs-number">#f00</span><br>);<br><br><span class="hljs-selector-class">.button-primary</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: color.<span class="hljs-variable">$primary</span>;<br>&#125;<br><br><span class="hljs-selector-class">.button-secondary</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: color.<span class="hljs-variable">$secondary</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button-primary</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00f</span>;<br>&#125;<br><br><span class="hljs-selector-class">.button-secondary</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f00</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://sass-lang.com/documentation/at-rules/use#configuring-modules" target="_blank" rel="noopener">Sass: @use</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/sass.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;若要模組化 Sass，最常用的就是 &lt;code&gt;@import&lt;/code&gt; 規則。但在 &lt;a href=&quot;https://titangene.github.io/article/dart-sass.html&quot;&gt;Dart Sass&lt;/a&gt; 推出了一個新功能：模組系統，可用 &lt;code&gt;@use&lt;/code&gt; 規則，並透過 namespace 來引入其他 stylesheet 中的成員。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web Dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Sass" scheme="https://titangene.github.io/tags/sass/"/>
    
      <category term="CSS" scheme="https://titangene.github.io/tags/css/"/>
    
      <category term="Dart Sass" scheme="https://titangene.github.io/tags/dart-sass/"/>
    
  </entry>
  
  <entry>
    <title>Dart Sass 介紹 (使用與安裝)</title>
    <link href="https://titangene.github.io/article/dart-sass.html"/>
    <id>https://titangene.github.io/article/dart-sass.html</id>
    <published>2020-05-03T15:54:55.000Z</published>
    <updated>2020-05-10T23:03:26.624Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/sass.jpg" alt=""></p><p><a href="https://github.com/sass/dart-sass" target="_blank" rel="noopener">Dart Sass</a> 是 Sass 的主要實作，過去常見的是 Ruby Sass，而現今 <a href="https://sass-lang.com/ruby-sass" target="_blank" rel="noopener">Sass 官方推薦大家改用 Dart Sass</a>，尤其是用 JavaScript 或 Node.js 開發的相關專案。</p><a id="more"></a><p>Dart Sass 是 Sass 的 Dart 實作，效能比 Ruby Sass 還要快，且易於安裝，還可編譯成純 JavaScript，讓我們可以輕鬆的整合至現有的 Web 開發工作流程中。</p><h1 id="安裝"><a class="header-anchor" href="#安裝"></a>安裝</h1><p>有多種安裝和執行 Dart Sass 的方法：</p><h2 id="Standalone"><a class="header-anchor" href="#Standalone"></a>Standalone</h2><p>從 <a href="https://github.com/sass/dart-sass/releases/" target="_blank" rel="noopener">GitHub Release 頁面</a>下載適用於你 OS 的 standalone Dart Sass archive，其中包含 Dart VM 和 executable 的 snapshot。</p><p>使用方法很簡單，下載後並解壓縮，將解壓縮後的目錄新增至 <code>PATH</code> (<a href="https://katiek2.github.io/path-doc/" target="_blank" rel="noopener">這篇</a> 提供各 OS 如何設定 <code>PATH</code> 的步驟)，接著重新啟動 terminal，然後就能執行 <code>sass</code> executable 開始使用！</p><h2 id="npm"><a class="header-anchor" href="#npm"></a>npm</h2><p>可透過 npm 安裝 <a href="https://www.npmjs.com/package/sass" target="_blank" rel="noopener">Dart Sass</a>，該套件是已編譯為 JavaScript，且沒有任何 native code 或外部依賴。提供 command-line <code>sass</code> executable 和 Node.js API。</p><p>全域安裝：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -g sass</span><br></code></pre></td></tr></table></figure><p>local 安裝：新增至專案</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm init -y</span><br><span class="hljs-meta">$</span><span class="bash"> npm install --save-dev sass</span><br></code></pre></td></tr></table></figure><div class="info"><p>其餘的安裝方式可參考 <a href="https://github.com/sass/dart-sass#using-dart-sass" target="_blank" rel="noopener">Dart Sass GitHub Repo 的 README 說明</a>。</p></div><h1 id="為何用-Dart？"><a class="header-anchor" href="#為何用-Dart？"></a>為何用 Dart？</h1><p>在 <a href="https://github.com/sass/dart-sass#why-dart" target="_blank" rel="noopener">Dart Sass GitHub Repo</a> 的 README 有提到為何 Dart Sass 會取代 Ruby Sass，有以下幾個優點：</p><ul><li>效能快：比 Ruby 塊，且與 C++ 差不多</li><li>免安裝：<ul><li>Dart VM 沒有外部依賴，可將應用程式編譯成獨立的 snapshot 檔案，因此可將 Dart Sass 只需發佈三個檔案 (VM、snapshot 和 wrapper script)</li><li>可編譯成 JavaScript，所以可透過 npm 發佈</li></ul></li><li>容易寫：<ul><li>Dart 是比 C++ 更高級的語言，不需要太多的記憶體管理和建制系統的麻煩</li><li>Dart 是靜態型別 (statically typed)，與 Ruby 相比 可更容易的進行大型重構</li></ul></li><li>對貢獻者更友好：<ul><li>Dart 比 Ruby 更容易學習</li></ul></li></ul><h1 id="Command-Line"><a class="header-anchor" href="#Command-Line"></a>Command Line</h1><p>Dart Sass executable 有兩種使用模式：</p><ul><li>One-to-One Mode (一對一模式)</li><li>Many-to-many Mode (多對多模式)</li></ul><h2 id="One-to-One-Mode"><a class="header-anchor" href="#One-to-One-Mode"></a>One-to-One Mode</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass &lt;input.scss&gt; [output.css]</span><br></code></pre></td></tr></table></figure><ul><li>一個輸入檔 ( <code>input.scss</code> ) 編譯成一個輸出檔 ( <code>output.scss</code> )</li><li>若為提供輸出路徑，會將已編譯的 CSS 列印至 terminal 上</li><li>若輸入檔的副檔名是：<ul><li><code>.scss</code>：解析成 <a href="https://sass-lang.com/documentation/syntax#scss" target="_blank" rel="noopener">SCSS</a></li><li><code>.sass</code>：解析成 <a href="https://sass-lang.com/documentation/syntax#the-indented-syntax" target="_blank" rel="noopener">縮排語法 (indented syntax)</a></li><li><code>.css</code>：解析成 <a href="https://sass-lang.com/documentation/at-rules/import#importing-css" target="_blank" rel="noopener">純 CSS</a></li><li>若都不是以上三種，或來至標準輸入，預設會解析成 SCSS<ul><li>也可用 <code>--indented</code> flag 來控制輸出格式</li></ul></li></ul></li></ul><h2 id="Many-to-many-Mode"><a class="header-anchor" href="#Many-to-many-Mode"></a>Many-to-many Mode</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass [&lt;input.css&gt;:&lt;output.css&gt;] [&lt;input/&gt;:&lt;output/&gt;]...</span><br></code></pre></td></tr></table></figure><ul><li>一個或多個輸入檔編譯成一個或多個輸出檔</li><li>輸入和輸出用 <code>:</code> 字元來隔開</li><li>可將目錄中的所有 Sass 檔編譯為另一個目錄中具有相同名稱的 CSS 檔</li></ul><p>例如：</p><p>將 <code>style.scss</code> 編譯成 <code>style.css</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass style.scss:style.css</span><br></code></pre></td></tr></table></figure><p>將 <code>light.scss</code> 和 <code>dark.scss</code> 編譯成 <code>light.css</code> 和 <code>dark.css</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass light.scss:light.css dark.scss:dark.css</span><br></code></pre></td></tr></table></figure><p>將 <code>src/scss/</code> 目錄內的所有 Sass 檔編譯至 <code>public/css/</code> 目錄中，且會編譯成 CSS 檔：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass src/scss:public/css</span><br></code></pre></td></tr></table></figure><div class="info"><p>編譯整個目錄時，如果只想編譯出一個 CSS 檔案 (例如：<code>main.css</code> )，就要將主要檔案之外的其他檔案的名稱，改為以 <code>_</code> 為開頭的 (例如：<code>_color.scss</code>，這種檔案被稱為 <a href="https://sass-lang.com/documentation/at-rules/import#partials" target="_blank" rel="noopener">partial 檔案</a>)。</p></div><h2 id="CLI-option"><a class="header-anchor" href="#CLI-option"></a>CLI option</h2><h3 id="indented"><a class="header-anchor" href="#indented"></a><code>--indented</code></h3><p>指定輸入檔要解析成縮排語法 (indented syntax)</p><h3 id="load-path，-I"><a class="header-anchor" href="#load-path，-I"></a><code>--load-path</code>，<code>-I</code></h3><ul><li>新增額外的載入路徑來查找 stylesheet</li><li>此 option 可使用多次，代表提供多個載入路徑</li><li>最先載入的會優先於較晚載入的路徑</li></ul><p>例如：如果沒有使用 <code>--load-path</code> option，要 import Bootstrap 就必須使用很長的路徑：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">"../node_modules/bootstrap/scss/functions"</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">"../node_modules/bootstrap/scss/variables"</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">"../node_modules/bootstrap/scss/mixins"</span>;<br></code></pre></td></tr></table></figure><p>若使用 <code>--load-path</code> option，就能簡短 import Bootstrap 的路徑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --load-path=node_modules src/main.scss dist/main.css</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">"bootstrap/scss/functions"</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">"bootstrap/scss/variables"</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">"bootstrap/scss/mixins"</span>;<br></code></pre></td></tr></table></figure><h3 id="style，-s"><a class="header-anchor" href="#style，-s"></a><code>--style</code>，<code>-s</code></h3><p>指定 CSS 的輸出樣式。</p><p>Dart Sass 支援兩種輸出樣式：</p><ul><li><code>expanded</code>：預設，將每個選擇器和宣告寫在自己的那行上</li><li><code>compressed</code>：刪除盡可能多的多餘字元，並將整個 stylesheet 寫成一行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --style=expanded style.scss</span><br>h1 &#123;<br>  font-size: 40px;<br>&#125;<br><br><span class="hljs-meta">$</span><span class="bash"> sass --style=compressed style.scss</span><br>h1&#123;font-size:40px&#125;<br></code></pre></td></tr></table></figure><h3 id="error-css"><a class="header-anchor" href="#error-css"></a><code>--error-css</code></h3><ul><li>當編譯期間發生錯誤時，會告訴 Sass 是否 emit CSS 檔案</li><li>該 CSS 檔會在註解和 <code>body::before</code> 的 <code>content</code> property 中描述錯誤<ul><li>可在瀏覽器中察看錯誤訊息，而不會切回 terminal 察看</li></ul></li><li>預設若要編譯至少一個檔案 (不是標準輸出)，就會啟用 error CSS<ul><li>可在編譯成標準輸出時加上 <code>--error-css</code> 來啟用 error CSS</li><li>也可以加上 <code>--no-error-css</code> 來禁用 error CSS</li></ul></li><li>禁用 error CSS 後，<code>--update</code> flag 和 <code>--watch</code> flag 會在發生錯誤時刪除 CSS 檔案</li></ul><p>例如：以下 Sass 檔的內容是錯誤的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// main.scss</span><br><span class="hljs-variable">$width</span>: <span class="hljs-number">15px</span> + <span class="hljs-number">2em</span>;<br></code></pre></td></tr></table></figure><p>編譯此 Sass 檔會出現以下錯誤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --error-css main.scss main.css</span><br>Error: Incompatible units em and px.<br>  ╷<br>1 │ $width: 15px + 2em;<br>  │         ^^^^^^^^^^<br>  ╵<br>  test.scss 1:9  root stylesheet<br></code></pre></td></tr></table></figure><p>而輸出的 <code>main.css</code> 檔的內容如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* Error: Incompatible units em and px.</span><br><span class="hljs-comment"> *   ,</span><br><span class="hljs-comment"> * 1 | $width: 15px + 2em;</span><br><span class="hljs-comment"> *   |         ^^^^^^^^^^</span><br><span class="hljs-comment"> *   '</span><br><span class="hljs-comment"> *   test.scss 1:9  root stylesheet */</span><br><br><span class="hljs-selector-tag">body</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"Source Code Pro"</span>, <span class="hljs-string">"SF Mono"</span>, Monaco, Inconsolata, <span class="hljs-string">"Fira Mono"</span>,<br>      <span class="hljs-string">"Droid Sans Mono"</span>, monospace, monospace;<br>  <span class="hljs-attribute">white-space</span>: pre;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">1em</span>;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">"Error: Incompatible units em and px.\a   \2577 \a 1 \2502  $width: 15px + 2em;\a   \2502          ^^^^^^^^^^\a   \2575 \a   test.scss 1:9  root stylesheet"</span>;         <br>&#125;<br></code></pre></td></tr></table></figure><p>若用瀏覽器察看使用此 <code>main.css</code> 檔的頁面會像下圖這樣：</p><p><img src="../images/dart-sass/error-css.png" alt=""></p><h3 id="update"><a class="header-anchor" href="#update"></a><code>--update</code></h3><ul><li>當 stylesheets 的依賴更新時，Sass 就只會編譯 stylesheets</li><li>更新 stylesheets 時，會列印狀態訊息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --update themes:public/css</span><br>Compiled themes/light.scss to public/css/light.css.<br></code></pre></td></tr></table></figure><h3 id="watch"><a class="header-anchor" href="#watch"></a><code>--watch</code></h3><p>類似 <code>--update</code>，但是在完成第一次編譯後，Sass 保持 open 狀態，並在 stylesheets 或其依賴發生更改時繼續編譯 stylesheets。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --watch themes:public/css</span><br>Compiled themes/light.scss to public/css/light.css.<br><br><span class="hljs-meta">#</span><span class="bash"> Then when you edit themes/dark.scss...</span><br>Compiled themes/dark.scss to public/css/dark.css.<br></code></pre></td></tr></table></figure><h2 id="常用的-option"><a class="header-anchor" href="#常用的-option"></a>常用的 option</h2><p>開發用：</p><ul><li><code>--watch</code>：watch 模式</li><li><code>-I node_modules</code>：新增額外載入的 <code>node_modules</code> 目錄</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --watch -I node_modules src/scss:dict/styles</span><br></code></pre></td></tr></table></figure><p>部署用 (build)：</p><ul><li><code>-s compressed</code>：CSS Minifier</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass -s compressed src/scss:dict/styles</span><br></code></pre></td></tr></table></figure><div class="info"><p>更多 CLI option 可參閱 <a href="https://sass-lang.com/documentation/cli/dart-sass" target="_blank" rel="noopener">Sass 文件</a>。</p></div><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://github.com/sass/dart-sass#using-dart-sass" target="_blank" rel="noopener">sass/dart-sass: The reference implementation of Sass, written in Dart.</a></li><li><a href="https://sass-lang.com/ruby-sass" target="_blank" rel="noopener">Sass: Ruby Sass</a></li><li><a href="https://www.npmjs.com/package/sass" target="_blank" rel="noopener">sass - npm</a></li><li><a href="https://sass-lang.com/install" target="_blank" rel="noopener">Sass: Install Sass</a></li><li><a href="https://www.dart-china.org/t/topic/146" target="_blank" rel="noopener">CSS 預處理器 Sass 的預設實作將遷移到 Dart Sass - 分享 - Dart 中文社區</a></li><li><a href="https://sass-lang.com/documentation/cli/dart-sass" target="_blank" rel="noopener">Sass: Dart Sass Command-Line Interface</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/sass.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/sass/dart-sass&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dart Sass&lt;/a&gt; 是 Sass 的主要實作，過去常見的是 Ruby Sass，而現今 &lt;a href=&quot;https://sass-lang.com/ruby-sass&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sass 官方推薦大家改用 Dart Sass&lt;/a&gt;，尤其是用 JavaScript 或 Node.js 開發的相關專案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web Dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="Dart" scheme="https://titangene.github.io/tags/dart/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="CLI" scheme="https://titangene.github.io/tags/cli/"/>
    
      <category term="Sass" scheme="https://titangene.github.io/tags/sass/"/>
    
      <category term="CSS" scheme="https://titangene.github.io/tags/css/"/>
    
      <category term="Dart Sass" scheme="https://titangene.github.io/tags/dart-sass/"/>
    
  </entry>
  
  <entry>
    <title>npm / Yarn 套件管理器指令比對 cheatsheet</title>
    <link href="https://titangene.github.io/article/npm-and-yarn-cheatsheet.html"/>
    <id>https://titangene.github.io/article/npm-and-yarn-cheatsheet.html</id>
    <published>2020-04-26T11:36:11.000Z</published>
    <updated>2020-05-03T14:05:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/npm_yarn.jpg" alt=""></p><p>npm 或 Yarn 都是最常見的 Node.js 套件管理器。本篇紀錄兩個 CLI 對應的指令。</p><a id="more"></a><h2 id="建立新專案"><a class="header-anchor" href="#建立新專案"></a>建立新專案</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm init</span><br><span class="hljs-meta">$</span><span class="bash"> npm init -y</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn init</span><br><span class="hljs-meta">$</span><span class="bash"> yarn init -y</span><br></code></pre></td></tr></table></figure><h2 id="安裝專案-package-json-中的所有相依套件"><a class="header-anchor" href="#安裝專案-package-json-中的所有相依套件"></a>安裝專案 <code>package.json</code> 中的所有相依套件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn</span><br><span class="hljs-meta">$</span><span class="bash"> yarn install</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install</span><br><span class="hljs-meta">$</span><span class="bash"> npm i</span><br></code></pre></td></tr></table></figure><h2 id="安裝相依套件"><a class="header-anchor" href="#安裝相依套件"></a>安裝相依套件</h2><p>安裝相依套件，並將套件新增至不同類型的 <code>dependencies</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm i &lt;package&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt;@&lt;version&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt;@&lt;tag&gt;</span><br></code></pre></td></tr></table></figure><p>安裝套件並將此套件儲存至 <code>package.json</code> 中的 <code>dependencies</code> (目前 npm 的預設參數，不需加 <code>-S</code> 就有此功能，舊版 npm 需要加此 option 才會將安裝的套件存至 <code>package.json</code> )：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; --save</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; -S</span><br></code></pre></td></tr></table></figure><h3 id="新增至不同類型的-dependencies"><a class="header-anchor" href="#新增至不同類型的-dependencies"></a>新增至不同類型的 dependencies</h3><p>安裝相依套件，並將套件新增至不同類型的 <code>devDependencies</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; --save-dev</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; -D</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; --dev</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; -D</span><br></code></pre></td></tr></table></figure><p>安裝相依套件，並將套件新增至不同類型的 <code>optionalDependencies</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; --save-optional</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; -O</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; --optional</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; -O</span><br></code></pre></td></tr></table></figure><p>安裝相依套件，並將套件新增至不同類型的 <code>bundleDependencies</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; --save-bundle</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; -B</span><br></code></pre></td></tr></table></figure><p>安裝相依套件，並將套件新增至不同類型的 <code>peerDependencies</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; --peer</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; -P</span><br></code></pre></td></tr></table></figure><blockquote><p>不同類型的 dependencies 可參閱 <a href="https://classic.yarnpkg.com/zh-Hant/docs/dependency-types/" target="_blank" rel="noopener">Yarn 官方文件中的「依賴關係的種類」</a> 這篇。</p></blockquote><h3 id="安裝指定版本"><a class="header-anchor" href="#安裝指定版本"></a>安裝指定版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; --save-exact</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; -E</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; --exact</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; -E</span><br></code></pre></td></tr></table></figure><h3 id="安裝次版號的最新版"><a class="header-anchor" href="#安裝次版號的最新版"></a>安裝次版號的最新版</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; --tilde</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; -T</span><br></code></pre></td></tr></table></figure><h3 id="在全域安裝套件"><a class="header-anchor" href="#在全域安裝套件"></a>在全域安裝套件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -g &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn global add &lt;package&gt;</span><br></code></pre></td></tr></table></figure><h2 id="升級相依套件"><a class="header-anchor" href="#升級相依套件"></a>升級相依套件</h2><p>升級目前專案的相依套件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm update</span><br><span class="hljs-meta">$</span><span class="bash"> npm update &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn upgrade</span><br><span class="hljs-meta">$</span><span class="bash"> yarn upgrade &lt;package&gt;</span><br></code></pre></td></tr></table></figure><p>全域的相依套件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm update -g</span><br><span class="hljs-meta">$</span><span class="bash"> npm update -g &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn global upgrade</span><br><span class="hljs-meta">$</span><span class="bash"> yarn global upgrade &lt;package&gt;</span><br></code></pre></td></tr></table></figure><h3 id="升級至最新版"><a class="header-anchor" href="#升級至最新版"></a>升級至最新版</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn upgrade &lt;package&gt; --latest</span><br></code></pre></td></tr></table></figure><h2 id="升級相依套件可選擇是否升級"><a class="header-anchor" href="#升級相依套件可選擇是否升級"></a>升級相依套件可選擇是否升級</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn upgrade-interactive &lt;package&gt;</span><br></code></pre></td></tr></table></figure><h2 id="刪除套件"><a class="header-anchor" href="#刪除套件"></a>刪除套件</h2><p>刪除目前專案的相依套件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm uninstall &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn remove &lt;package&gt;</span><br></code></pre></td></tr></table></figure><p>刪除全域的相依套件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm uninstall -g &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn global remove &lt;package&gt;</span><br></code></pre></td></tr></table></figure><h2 id="列出已安裝的套件"><a class="header-anchor" href="#列出已安裝的套件"></a>列出已安裝的套件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm ls</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn list</span><br></code></pre></td></tr></table></figure><p>資料來源</p><ul><li><a href="https://classic.yarnpkg.com/zh-Hant/docs/migrating-from-npm" target="_blank" rel="noopener">migrating from npm | Yarn</a></li><li><a href="https://classic.yarnpkg.com/zh-Hant/docs/cli/add" target="_blank" rel="noopener">yarn add | Yarn</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/npm_yarn.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;npm 或 Yarn 都是最常見的 Node.js 套件管理器。本篇紀錄兩個 CLI 對應的指令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web Dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Node.js" scheme="https://titangene.github.io/tags/node-js/"/>
    
      <category term="version manager" scheme="https://titangene.github.io/tags/version-manager/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="CLI" scheme="https://titangene.github.io/tags/cli/"/>
    
      <category term="npm" scheme="https://titangene.github.io/tags/npm/"/>
    
      <category term="Yarn" scheme="https://titangene.github.io/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>nvm：安裝、切換不同 Node.js 版本的管理器</title>
    <link href="https://titangene.github.io/article/nvm.html"/>
    <id>https://titangene.github.io/article/nvm.html</id>
    <published>2020-04-19T15:56:52.000Z</published>
    <updated>2020-05-03T14:05:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/node.jpg" alt=""></p><p>nvm 是 Node.js 的版本管理器 (version manager)，可在同一台主機上安裝多個版本的 Node.js 環境，因為不同專案可能會使用不同的 Node.js 版本，那就需要透過一個版本管理器來切換不同的 Node.js 版本。</p><a id="more"></a><h2 id="安裝-NVM"><a class="header-anchor" href="#安裝-NVM"></a>安裝 NVM</h2><p>可用 <code>cURL</code> 或 <code>wget</code> 指令使用安裝腳本安裝或更新 nvm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br></code></pre></td></tr></table></figure><p>此安裝腳本會將 nvm repo clone 到 <code>~/.nvm</code>，並且將 source line 新增至你的 profile 設定 ( <code>~/.bash_profile</code>、<code>~/.zshrc</code>、<code>~/.profile</code> 或 <code>~/.bashrc</code> )：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NVM_DIR=<span class="hljs-string">"<span class="hljs-variable">$HOME</span>/.nvm"</span><br>[ -s <span class="hljs-string">"<span class="hljs-variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="hljs-string">"<span class="hljs-variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="hljs-comment"># This loads nvm</span><br>[ -s <span class="hljs-string">"<span class="hljs-variable">$NVM_DIR</span>/bash_completion"</span> ] &amp;&amp; \. <span class="hljs-string">"<span class="hljs-variable">$NVM_DIR</span>/bash_completion"</span>  <span class="hljs-comment"># This loads nvm bash_completion</span><br></code></pre></td></tr></table></figure><p>如果在 Linux 執行安裝腳本後，執行下面指令會顯示以下訊息或沒有任何訊息時，建議重開一個新的終端機 (terminal) 再重新執行一次 <code>nvm</code> 指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">command</span> -v nvm</span><br>nvm: command not found<br></code></pre></td></tr></table></figure><p>如果還是無法使用 nvm，可執行下面指令立即應用 ZSH 的設定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">source</span> .zshrc</span><br></code></pre></td></tr></table></figure><div class="warning"><p>注意：</p><ul><li>使用 <code>nvm</code> 時，不需要 <code>sudo</code> 即可使用 <code>npm -g</code> 全域安裝模組，所以與其執行 <code>sudo npm i -g</code>，不如執行 <code>npm i -g</code></li><li>若你有 <code>~/.npmrc</code>，請確保裡面不包含任何 <code>prefix</code> 的設定 (因為與 <code>nvm</code> 不相容)</li><li>你可以 (但不應該) 保留以前在 “系統” 安裝的 Node.js，但 <code>nvm</code> 只對你的使用者帳戶 (用於安裝 <code>nvm</code> 的使用者帳戶) 可用。可能會導致版本不 match，因為其他使用者會使用 <code>/usr/local/lib/node_modules/*</code>，而使用者帳戶會使用 <code>~/.nvm/versions/node/vX.X.X/lib/node_modules/*</code></li></ul></div><h2 id="version：確認-NVM-是否安裝成功"><a class="header-anchor" href="#version：確認-NVM-是否安裝成功"></a><code>--version</code>：確認 NVM 是否安裝成功</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm --version</span><br>0.34.0<br></code></pre></td></tr></table></figure><h2 id="install：利用-NVM-安裝-Node-js"><a class="header-anchor" href="#install：利用-NVM-安裝-Node-js"></a><code>install</code>：利用 NVM 安裝 Node.js</h2><p>安裝 NVM 後，其實還沒安裝 Node 環境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node  </span><br>zsh: command not found: node<br></code></pre></td></tr></table></figure><p>如果執行下面指令，會提醒你需要執行 <code>install</code> 指令才能安裝 Node.js：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm use node</span><br>N/A: version "node -&gt; N/A" is not yet installed.<br><br>You need to run "nvm install node" to install it before using it.<br></code></pre></td></tr></table></figure><p>安裝最新版的 Node.js：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm install node</span><br>Downloading and installing node v12.8.1...<br>Downloading https://nodejs.org/dist/v12.8.1/node-v12.8.1-linux-x64.tar.xz...<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">################################################################################################### 100.0%</span></span><br>Computing checksum with sha256sum<br>Checksums matched!<br>Now using node v12.8.1 (npm v6.10.2)<br>Creating default alias: default -&gt; node (-&gt; v12.8.1)<br></code></pre></td></tr></table></figure><p>如果要指定安裝版本，可以直接指定版本號：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm install 8.9.1</span><br></code></pre></td></tr></table></figure><p>安裝的第一個版本的 Node.js 會成員 nvm 的預設版本，新的 shell 就會以預設版本的 Node.js 來使用 (例如：<code>nvm alias default</code>)。</p><p>查看目前安裝 Node.js 的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node -v</span><br>v12.8.1<br></code></pre></td></tr></table></figure><h2 id="ls-remote：察看可用的安裝版本"><a class="header-anchor" href="#ls-remote：察看可用的安裝版本"></a><code>ls-remote</code>：察看可用的安裝版本</h2><p>可以看目前有哪些可用版本可安裝，在版本號前面的 <code>-&gt;</code> 箭頭符號代表目前 nvm 正在使用的 Node.js 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm ls-remote</span><br>...<br>       v10.16.1   (LTS: Dubnium)<br>       v10.16.2   (LTS: Dubnium)<br>       v10.16.3   (Latest LTS: Dubnium)<br>...<br>        v12.7.0<br>        v12.8.0<br><span class="hljs-meta">-&gt;</span><span class="bash">      v12.8.1</span><br></code></pre></td></tr></table></figure><p>不過剛剛的 <code>ls-remote</code> 指令會把所有可用的版本都列出來，但通常會選擇安裝 LTS (Long-term support，長期支援) 版，所以只要加上 <code>-lts</code> 參數就可以指列出可用的 LTS 版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm ls-remote --lts</span><br>...<br>       v10.16.1   (LTS: Dubnium)<br>       v10.16.2   (LTS: Dubnium)<br>       v10.16.3   (Latest LTS: Dubnium)<br></code></pre></td></tr></table></figure><p>如果版本號的文字有特殊顏色 (不是白色字)，則代表該版本的 Node.js 有透過 nvm 安裝過，例如：我的電腦就安裝了 <code>v10.16.3</code> 和 <code>v12.8.1</code>：</p><p><img src="../images/nvm/nvm-ls-remote.png" alt=""></p><h2 id="ls：查看目前安裝了哪些版本"><a class="header-anchor" href="#ls：查看目前安裝了哪些版本"></a><code>ls</code>：查看目前安裝了哪些版本</h2><p><code>ls</code> 指令可以查看目前安裝了哪些版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm ls</span><br>       v10.16.3<br><span class="hljs-meta">-&gt;</span><span class="bash">      v12.8.1</span><br>default -&gt; node (-&gt; v12.8.1)<br>node -&gt; stable (-&gt; v12.8.1) (default)<br>stable -&gt; 12.8 (-&gt; v12.8.1) (default)<br>iojs -&gt; N/A (default)<br>unstable -&gt; N/A (default)<br>lts/* -&gt; lts/dubnium (-&gt; N/A)<br>lts/argon -&gt; v4.9.1 (-&gt; N/A)<br>lts/boron -&gt; v6.17.1 (-&gt; N/A)<br>lts/carbon -&gt; v8.16.1 (-&gt; N/A)<br>lts/dubnium -&gt; v10.16.3<br></code></pre></td></tr></table></figure><h2 id="use：切換-Node-js-版本"><a class="header-anchor" href="#use：切換-Node-js-版本"></a><code>use</code>：切換 Node.js 版本</h2><p>如果要使用 nvm 切換正在使用的 Node.js 版本，可用 <code>use</code> 指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm use v10.6.3</span><br>Now using node v10.16.3 (npm v6.9.0)<br></code></pre></td></tr></table></figure><p>如果切換的目標版本還沒安裝，nvm 會提醒你要安裝：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm use lts/carbon </span><br>N/A: version "lts/carbon -&gt; N/A" is not yet installed.<br><br>You need to run "nvm install lts/carbon" to install it before using it.<br></code></pre></td></tr></table></figure><p>透過 nvm 安裝 Node.js 時，nvm 會將不同的 Node.js 版本儲存在 <code>~/.nvm/versions/node/vX.X.X</code>，然後再修改 <code>$PATH</code>，將指定版本的 Node.js 路徑加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm current</span><br>v10.16.3<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span>             </span><br>/home/titan/.nvm/versions/node/v10.16.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br><br><span class="hljs-meta">$</span><span class="bash"> use v12.13.1</span><br><span class="hljs-meta">$</span><span class="bash"> nvm current</span><br>v12.13.1<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span>             </span><br>/home/titan/.nvm/versions/node/v12.13.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br></code></pre></td></tr></table></figure><p>在 nvm 的各個 Node.js 版本安裝的全域套件都會在各自版本的目錄內安裝，所以在切換至新安裝的 Node.js 版本後需要重新安裝，也因為如此，不同版本間的套件就不會有衝突問題。</p><h2 id="current：察看目前使用版本"><a class="header-anchor" href="#current：察看目前使用版本"></a><code>current</code>：察看目前使用版本</h2><p>如果忘記自己切換到哪個版本，可以用 <code>current</code> 指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm current</span><br>v10.6.3<br></code></pre></td></tr></table></figure><h2 id="run：直接執行-Node-js"><a class="header-anchor" href="#run：直接執行-Node-js"></a><code>run</code>：直接執行 Node.js</h2><p>如果要直接執行 Node.js，可以使用下面指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm run node</span><br>Running node v12.8.1 (npm v6.10.2)<br>Welcome to Node.js v12.8.1.<br>Type ".help" for more information.<br><span class="hljs-meta">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="exec：指定要執行的-Node-js-版本"><a class="header-anchor" href="#exec：指定要執行的-Node-js-版本"></a><code>exec</code>：指定要執行的 Node.js 版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm <span class="hljs-built_in">exec</span> 12.8.1 node</span><br>Running node v12.8.1 (npm v6.10.2)<br>Welcome to Node.js v12.8.1.<br>Type ".help" for more information.<br><span class="hljs-meta">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="which：察看-Node-js-的安裝路徑"><a class="header-anchor" href="#which：察看-Node-js-的安裝路徑"></a><code>which</code>：察看 Node.js 的安裝路徑</h2><p>執行下面指令可以查看特定版本的 Node.js 的安裝路徑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm <span class="hljs-built_in">which</span> 12.8.1</span><br>/home/titan/.nvm/versions/node/v12.8.1/bin/node<br></code></pre></td></tr></table></figure><h2 id="alias"><a class="header-anchor" href="#alias"></a>alias</h2><p>如下圖有些版本的文字是紅色或是顯示 <code>N/A</code>，就代表該版本未在電腦安裝：</p><p><img src="../images/nvm/nvm-ls.png" alt=""></p><p>預設 alias 可以取代版本號：</p><ul><li><code>node</code>：安裝最新版的 Node.js</li><li><code>iojs</code>：安裝最新版的 io.js</li><li><code>stable</code>：此 alias 已棄用，僅適用於 v0.12 以及更舊版，目前改為 <code>node</code> alias</li><li><code>unstable</code>：此 alias 為 v0.11，最後一個 “unstable” (不穩定) Node release，在 v1.0 之後的版本都是穩定版 (in SemVer, versions communicate breakage, not stability)</li></ul><p>可在下面這些指令使用以上預設別名：</p><ul><li><code>nvm install</code></li><li><code>nvm use</code></li><li><code>nvm run</code></li><li><code>nvm exec</code></li><li><code>nvm which</code></li><li>… 等</li></ul><h2 id="alias：察看別名、設定別名"><a class="header-anchor" href="#alias：察看別名、設定別名"></a><code>alias</code>：察看別名、設定別名</h2><h3 id="察看別名"><a class="header-anchor" href="#察看別名"></a>察看別名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm <span class="hljs-built_in">alias</span>                                                                    * ?</span><br>default -&gt; v10.16.3<br>node -&gt; stable (-&gt; v12.8.1) (default)<br>stable -&gt; 12.8 (-&gt; v12.8.1) (default)<br>iojs -&gt; N/A (default)<br>unstable -&gt; N/A (default)<br>lts/* -&gt; lts/erbium (-&gt; N/A)<br>lts/argon -&gt; v4.9.1 (-&gt; N/A)<br>lts/boron -&gt; v6.17.1 (-&gt; N/A)<br>lts/carbon -&gt; v8.16.2 (-&gt; N/A)<br>lts/dubnium -&gt; v10.17.0 (-&gt; N/A)<br>lts/erbium -&gt; v12.13.0 (-&gt; N/A)<br></code></pre></td></tr></table></figure><h3 id="設定別名"><a class="header-anchor" href="#設定別名"></a>設定別名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm <span class="hljs-built_in">alias</span> titan-test v10.15.3                                                  * ?</span><br>titan-test -&gt; v10.15.3<br></code></pre></td></tr></table></figure><p>接著用 <code>nvm alias</code> 指令就會看到剛剛新增的別名所對應的 Node.js 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm <span class="hljs-built_in">alias</span>                                                                    * ?</span><br>titan-test -&gt; v10.15.3<br>default -&gt; v10.16.3<br>node -&gt; stable (-&gt; v12.8.1) (default)<br>stable -&gt; 12.8 (-&gt; v12.8.1) (default)<br>iojs -&gt; N/A (default)<br>unstable -&gt; N/A (default)<br>lts/* -&gt; lts/erbium (-&gt; N/A)<br>lts/argon -&gt; v4.9.1 (-&gt; N/A)<br>lts/boron -&gt; v6.17.1 (-&gt; N/A)<br>lts/carbon -&gt; v8.16.2 (-&gt; N/A)<br>lts/dubnium -&gt; v10.17.0 (-&gt; N/A)<br>lts/erbium -&gt; v12.13.0 (-&gt; N/A)<br></code></pre></td></tr></table></figure><h2 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h2><ul><li><a href="https://github.com/nvm-sh/nvm#install--update-script" target="_blank" rel="noopener">nvm-sh/nvm: Node Version Manager</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/node.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;nvm 是 Node.js 的版本管理器 (version manager)，可在同一台主機上安裝多個版本的 Node.js 環境，因為不同專案可能會使用不同的 Node.js 版本，那就需要透過一個版本管理器來切換不同的 Node.js 版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web Dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Node.js" scheme="https://titangene.github.io/tags/node-js/"/>
    
      <category term="version manager" scheme="https://titangene.github.io/tags/version-manager/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="CLI" scheme="https://titangene.github.io/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>淺入 Git：detached HEAD</title>
    <link href="https://titangene.github.io/article/git-detached-head.html"/>
    <id>https://titangene.github.io/article/git-detached-head.html</id>
    <published>2020-04-12T15:54:32.000Z</published>
    <updated>2020-04-12T15:55:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>在 Git 的世界中，想回到過去，也許你會用 <code>git checkout</code> 跳至某個過去的 commit，但 Git 會提醒你正在「detached HEAD」狀態。那 detached <code>HEAD</code> 是什麼？它能做什麼？要怎麼離開 detached <code>HEAD</code> 狀態？</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>在之前的 <a href="https://titangene.github.io/article/git-head-ref.html">深入 Git：<code>HEAD</code> refs</a> 有談到 <code>HEAD</code> 通常會指向當前分支，而當前分支通常會指向該分支頂端的 commit (也就是該分支最新的 commit)。不過再某些情況下，會發生 <code>HEAD</code> 不是指向分支，而是指向某個 commit，而這個狀態的 <code>HEAD</code> 就被稱為「detached HEAD」。</p><p>下面會用以下 Git 歷史紀錄作為範例來說明 detached <code>HEAD</code>。本專案內有四個檔案，分別是 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code>，我為每個檔案分別建立了一個 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls</span><br>a  b  c  d<br><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --graph --decorate</span><br>* 71e5770 (HEAD -&gt; master, origin/master) feat: d<br>* c3a31ea feat: c<br>* b757c26 feat: b<br>* 3b7be17 feat: a<br></code></pre></td></tr></table></figure><h2 id="路人甲發生的情境"><a class="header-anchor" href="#路人甲發生的情境"></a>路人甲發生的情境</h2><p>下面是路人甲發生的情境，讓我們來看這個情境發生了什麼？</p><p>現在 <code>HEAD</code> 指向 <code>master</code> 分支，而 <code>master</code> 分支指向名為 <code>e2f2a4</code> 的 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --graph --decorate</span><br>* 71e5770 (HEAD -&gt; master, origin/master) feat: d<br>* c3a31ea feat: c<br>* b757c26 feat: b<br>* 3b7be17 feat: a<br><br><span class="hljs-meta">$</span><span class="bash"> cat .git/HEAD</span><br>ref: refs/heads/master<br><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/heads/master</span><br>71e57702f208a7c463a2b5cd069ea47cdbed9eba<br></code></pre></td></tr></table></figure><p>路人甲可能想回到過去的 commit，於是使用了 <code>git checkout &lt;commit&gt;</code> 跳至指定的 commit，假設要 checkout 至名為 <code>b757c26</code> 的 commit 就會看到以下訊息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout b757c26</span><br>Note: checking out 'b757c26'.<br><br>You are in 'detached HEAD' state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make in this<br>state without impacting any branches by performing another checkout.<br><br>If you want to create a new branch to retain commits you create, you may<br>do so (now or later) by using -b with the checkout command again. Example:<br><br>  git checkout -b &lt;new-branch-name&gt;<br><br>HEAD is now at b757c26 feat: b<br></code></pre></td></tr></table></figure><div class="warning"><p>假設路人甲很少注意看 Git 提供的訊息，所以忽略了「detached HEAD」的提醒訊息。</p></div><p>路人甲只想確定自己是不是回到過去，於是執行 <code>git log</code> 來察看，的確看到 <code>HEAD</code> 指向 <code>b757c26</code> 這個 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --graph --decorate</span><br>* b757c26 (HEAD) feat: b<br>* 3b7be17 feat: a<br></code></pre></td></tr></table></figure><p>所以心滿意足的開始基於 <code>7e347a4</code> 這個 commit 開始建立兩個新的 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"test1"</span> &gt; test1</span><br><span class="hljs-meta">$</span><span class="bash"> git add test1</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">"feat: test1"</span></span><br>[detached HEAD 3936d06] feat: test1<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 test1<br><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"test2"</span> &gt; test2</span><br><span class="hljs-meta">$</span><span class="bash"> git add test2</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">"feat: test2"</span></span><br>[detached HEAD 845992a] feat: test2<br> 1 file changed, 1 insertion(+)<br> create mode 100644 test2<br></code></pre></td></tr></table></figure><p>所以現在 <code>git log</code> 變成這樣：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --graph --decorate</span><br>* 845992a (HEAD) feat: test2<br>* 9fd0924 feat: test1<br>* b757c26 feat: b<br>* 3b7be17 feat: a<br></code></pre></td></tr></table></figure><p>當路人甲建立完 commit 後，突然想回到之前的 <code>master</code> 分支，所以執行 <code>git checkout master</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br>Warning: you are leaving 2 commits behind, not connected to<br>any of your branches:<br><br>  845992a feat: test2<br>  9fd0924 feat: test1<br><br>If you want to keep them by creating a new branch, this may be a good time<br>to do so with:<br><br> git branch &lt;new-branch-name&gt; 845992a<br><br>Switched to branch 'master'<br>Your branch is up to date with 'origin/master'.<br></code></pre></td></tr></table></figure><p>回到 <code>master</code> 分支後，路人甲看 <code>git log</code> 變成下面這樣馬上傻眼，心想：「剛剛的那兩個 commit 呢？怎麼不見了！怎麼辦啊！還找的回來嗎？」：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --graph --decorate</span><br>* 71e5770 (HEAD -&gt; master, origin/master) feat: d<br>* c3a31ea feat: c<br>* b757c26 feat: b<br>* 3b7be17 feat: a<br></code></pre></td></tr></table></figure><p>好，看到這個故事，你應該會發現，其實 Git 一直不停的在輸出訊息提醒你：</p><ul><li>在 checkout 至某個 commit 時，會提醒你正在「detached HEAD」狀態</li><li>在「detached HEAD」狀態建立 commit 時，會像這樣提醒你：<code>[detached HEAD 845992a] feat: test2</code></li><li>在「detached HEAD」狀態建立 commit 後，checkout 回分支時，會像這樣提醒你：<code>Warning: you are leaving 2 commits behind</code></li></ul><p>所以看輸出訊息很重要！</p><div class="info"><p>我曾經就是那個不看輸出訊息的路人甲 XD</p></div><h2 id="此狀態有何用"><a class="header-anchor" href="#此狀態有何用"></a>此狀態有何用</h2><p>那「detached HEAD」狀態到底能做什麼？</p><p>如果在 detached <code>HEAD</code> 狀態時建立的 commit 是實驗性的，那的確可以直接 checkout 至任何分支，把那些 commit 都丟棄 (但 Git 不會馬上刪除，會自動等到 Git GC 來回收，所以還救的回來)，這代表你放棄了在 detached <code>HEAD</code> 狀態下所做的任何 commit，而且這些操作都不會影響任何分支。</p><p>那如果是像路人甲的情境那樣，你想保留那些 commit，那可以在該 commit 上建立 ref，讓該 ref 指向該 commit，ref 可以是分支或 tag。</p><p>建立 ref 有很多種方式，下面會介紹幾種處理的方式。</p><h2 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h2><ul><li><a href="https://git-scm.com/docs/git-checkout" target="_blank" rel="noopener">Git - git-checkout Documentation</a></li><li><a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches" target="_blank" rel="noopener">Git Branching - Remote Branches | Pro Git, 2/e</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;在 Git 的世界中，想回到過去，也許你會用 &lt;code&gt;git checkout&lt;/code&gt; 跳至某個過去的 commit，但 Git 會提醒你正在「detached HEAD」狀態。那 detached &lt;code&gt;HEAD&lt;/code&gt; 是什麼？它能做什麼？要怎麼離開 detached &lt;code&gt;HEAD&lt;/code&gt; 狀態？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>深入 Git：Git 物件儲存 - tag 物件</title>
    <link href="https://titangene.github.io/article/git-tag-object.html"/>
    <id>https://titangene.github.io/article/git-tag-object.html</id>
    <published>2020-04-05T15:40:46.000Z</published>
    <updated>2020-04-05T17:12:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>本篇將深入探討 Git tag 是什麼？如何建立 tag？Git 是如何儲存 tag？與 commit 和分支的差別在哪？</p><a id="more"></a><h1 id="Git-tag"><a class="header-anchor" href="#Git-tag"></a>Git tag</h1><p>Git tag 常用於標記某個版本號碼，例如：<code>v0.5</code>、<code>v1.0.1</code>、<code>9.1.0-rc.2</code>、<code>v2.6.0-beta.3</code>。</p><p>在 Git 中有兩種類型的 tag：lightweight tag (輕量標籤) 和 annotated tag (註解標籤)。</p><p>先介紹兩者的共通點：</p><ul><li>提供更 friendlier 的名稱的標記</li><li>都會指向某個 Git 物件 (通常為 commit 物件，但也可以是其他物件，也就是 tree 物件、blob 物件，甚至是其他 tag 物件)<ul><li>只是 lightweight tag 是直接指向某 Git 物件</li><li>而 annotated tag 則是透過 tag 物件，間接指向某 Git 物件</li></ul></li><li>不會改變 tag 所指向的物件 (除非用 <code>git tag -f</code> 替換現有 tag)</li></ul><p>接著會說明各自的特性、要如何建立 lightweight tag 和 annotated tag，以及在 Git 中是如何儲存這些 tag 的。</p><p>下面會用以下 Git 歷史紀錄的範例來說明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --decorate</span><br>32aa934 (HEAD -&gt; master) feat: c<br>9b6d639 feat: b<br>d835d6b feat: a<br></code></pre></td></tr></table></figure><h2 id="lightweight-tag-輕量標籤"><a class="header-anchor" href="#lightweight-tag-輕量標籤"></a>lightweight tag (輕量標籤)</h2><ul><li>很像不會移動的分支，tag 只會指向一個特定的 Git 物件</li><li>若只作為暫時的標籤，且不想保留額外資訊，可用 lightweight tag</li></ul><h3 id="建立-lightweight-tag"><a class="header-anchor" href="#建立-lightweight-tag"></a>建立 lightweight tag</h3><p>建立 lightweight tag 時，不要指定 <code>-a</code>、<code>-s</code> 或 <code>-m</code> option (建立 annotated tag 時才會用到，後面會說明)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag &lt;tagname&gt; [&lt;commit&gt; | &lt;object&gt;]</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag v1.0-lw</span><br></code></pre></td></tr></table></figure><p>也可以指定某個 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag v0.2-lw 9b6d639</span><br></code></pre></td></tr></table></figure><h3 id="察看-lightweight-tag"><a class="header-anchor" href="#察看-lightweight-tag"></a>察看 lightweight tag</h3><p>若要透過 <code>git show</code> 指令察看 lightweight tag，就不會看到該標籤的額外資訊，只會顯示標籤所在的 commit 資訊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git show v1.0-lw</span><br>commit 32aa934a24212ef22cc373e7838c30618952003d (HEAD -&gt; master, tag: v1.0-lw)<br>Author: titangene &lt;titangene.tw@gmail.com&gt;<br>Date:   Sun Apr 5 21:36:25 2020 +0800<br><br>    feat: c<br><br>diff --git a/c b/c<br>new file mode 100644<br>index 0000000..f2ad6c7<br>--- /dev/null<br>+++ b/c<br>@@ -0,0 +1 @@<br>+c<br></code></pre></td></tr></table></figure><h3 id="lightweight-tag-存在哪？"><a class="header-anchor" href="#lightweight-tag-存在哪？"></a>lightweight tag 存在哪？</h3><p>Git 將 lightweight tag 存在 <code>.git/refs/tag</code> 目錄內：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/refs/tags/</span><br>.git/refs/tags/<br>├── v0.2-lw<br>└── v1.0-lw<br><br>0 directories, 2 files<br></code></pre></td></tr></table></figure><p>tag ref 的內容就是該 tag 指向的 commit 物件 (也就是該 commit SHA-1 值)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/tags/v1.0-lw</span><br>32aa934a24212ef22cc373e7838c30618952003d<br></code></pre></td></tr></table></figure><p>使用 <code>git cat-file</code> 來確定此 SHA-1 值真的是 commit 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 32aa93</span><br>commit<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 32aa93</span><br>tree 04a59185a0c5f4047e4fd3fa87b0c84e671b00ee<br>parent 9b6d6398e5e020a76f9a0f8d620e676a1decc78a<br>author titangene &lt;titangene.tw@gmail.com&gt; 1586093785 +0800<br>committer titangene &lt;titangene.tw@gmail.com&gt; 1586093785 +0800<br><br>feat: c<br></code></pre></td></tr></table></figure><h3 id="使用底層指令建立-lightweight-tag"><a class="header-anchor" href="#使用底層指令建立-lightweight-tag"></a>使用底層指令建立 lightweight tag</h3><p>使用 <code>git update-ref</code> 底層指令建立 lightweight tag 的 ref：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git update-ref refs/tags/v0.1-lw d835d6bf85258f2fe93c582f60f3f148900e0d7f</span><br></code></pre></td></tr></table></figure><p>察看該 tag ref 的確是指向剛剛指定的 SHA-1 值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/tags/v0.1-lw </span><br>d835d6bf85258f2fe93c582f60f3f148900e0d7f<br></code></pre></td></tr></table></figure><h2 id="annotated-tag-註解標籤"><a class="header-anchor" href="#annotated-tag-註解標籤"></a>annotated tag (註解標籤)</h2><ul><li>會在 Git 的資料庫中儲存成完整的物件。它們將被計算校驗碼 (checksummed)</li><li>包含：<ul><li>建立標籤的人 (tagger) 的名字、電子郵件和建立日期</li><li>紀錄一個標籤訊息 (tagging message)</li><li>指標 (也就是 Git 物件)</li></ul></li><li>可以簽名 (signed) 及透過 GNU Privacy Guard (GPG) 驗證</li><li>若想紀錄與 tag 有關的資訊 (例如：建立 tag 的人、時間)，建議使用 annotated tag</li></ul><h3 id="建立-annotated-tag"><a class="header-anchor" href="#建立-annotated-tag"></a>建立 annotated tag</h3><p>建立 annotated tag 時，可同時指定以下 option：</p><ul><li><code>-a</code>，<code>--annotate</code>：製作一個 unsigned、annotated tag 物件 (未簽名且帶有註解的標籤物件)</li><li><code>-m &lt;msg&gt;</code>，<code>--message=&lt;msg&gt;</code>：<ul><li>指定標籤訊息，此訊息會和此標籤一起儲存</li><li>若你沒有為標籤指定訊息，Git 就會開啟編輯器讓你輸入 (很像 <code>git commit</code> 沒有加上 <code>-m</code> option 那樣)</li><li>若加上多組 <code>-m</code> option，會將這些值串聯成段落</li><li>如果使用 <code>-m</code> option 但沒有加上 <code>-a</code>、<code>-s</code> 或 <code>-u &lt;keyid&gt;</code>，則代表是 <code>-a</code> (也就是建立 annotated tag)</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a &lt;tagname&gt; -m &lt;msg&gt; [&lt;commit&gt; | &lt;object&gt;]</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a v1.0 -m <span class="hljs-string">"version 1.0"</span></span><br></code></pre></td></tr></table></figure><p>也可以指定某個 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a v0.1 -m <span class="hljs-string">"version 0.1"</span> d835d6b</span><br></code></pre></td></tr></table></figure><h3 id="察看-annotated-tag-資訊"><a class="header-anchor" href="#察看-annotated-tag-資訊"></a>察看 annotated tag 資訊</h3><p>使用 <code>git show</code> 指令可查看標籤資訊，以及此標籤所標記的 commit 資訊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git show v0.1</span><br>tag v0.1<br>Tagger: titangene &lt;titangene.tw@gmail.com&gt;<br>Date:   Sun Apr 5 21:39:01 2020 +0800<br><br>version 0.1<br><br>commit d835d6bf85258f2fe93c582f60f3f148900e0d7f (tag: v0.1)<br>Author: titangene &lt;titangene.tw@gmail.com&gt;<br>Date:   Sun Apr 5 21:36:18 2020 +0800<br><br>    feat: a<br><br>diff --git a/a b/a<br>new file mode 100644<br>index 0000000..7898192<br>--- /dev/null<br>+++ b/a<br>@@ -0,0 +1 @@<br>+a<br></code></pre></td></tr></table></figure><p>以上面標籤資訊為例，包含：</p><ul><li>標籤名稱：<code>v0.1</code></li><li>建立標籤的人 (tagger) 的名字、電子郵件：<code>Tagger: titangene &lt;titangene.tw@gmail.com&gt;</code></li><li>標籤建立日期：<code>Date: Sun Apr 5 21:39:01 2020 +0800</code></li><li>標籤訊息：<code>version 0.1</code></li><li>指標：在 <code>git show</code> 沒有提供，下面會提到</li></ul><h3 id="annotated-tag-存在哪？"><a class="header-anchor" href="#annotated-tag-存在哪？"></a>annotated tag 存在哪？</h3><p>Git 也將 annotated tag 存在 <code>.git/refs/tag</code> 目錄內：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/refs/tags/</span><br>.git/refs/tags/<br>├── v0.1<br>├── v0.1-lw<br>├── v0.2-lw<br>├── v1.0<br>└── v1.0-lw<br><br>0 directories, 5 files<br></code></pre></td></tr></table></figure><p>tag ref 的內容就是該 tag 指向的 commit 物件 (也就是該 commit SHA-1 值)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/tags/v0.1</span><br>530097c078c2fa4c16a532443170a40179599a69<br></code></pre></td></tr></table></figure><p>使用 <code>git cat-file</code> 來確定此 SHA-1 值時，會發現跟剛剛介紹的 lightweight tag 不一樣，lightweight tag 會直接指向 commit 物件，而 annotated tag 則是指向 tag 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 530097</span><br>tag<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 530097</span><br>object d835d6bf85258f2fe93c582f60f3f148900e0d7f<br>type commit<br>tag v0.1<br>tagger titangene &lt;titangene.tw@gmail.com&gt; 1586093941 +0800<br><br>version 0.1<br></code></pre></td></tr></table></figure><p>而這個 tag 物件才是真正指向 commit 物件的 ref。</p><p>再次使用 <code>git cat-file</code> 指令，就能確定 tag 物件的確是指向 <code>d835d6</code> 這個 commit 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t d835d6</span><br>commit<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p d835d6</span><br>tree aaff74984cccd156a469afa7d9ab10e4777beb24<br>author titangene &lt;titangene.tw@gmail.com&gt; 1586093778 +0800<br>committer titangene &lt;titangene.tw@gmail.com&gt; 1586093778 +0800<br><br>feat: a<br></code></pre></td></tr></table></figure><h3 id="使用底層指令建立-annotated-tag"><a class="header-anchor" href="#使用底層指令建立-annotated-tag"></a>使用底層指令建立 annotated tag</h3><p>建立 annotated tag 主要有兩個步驟：</p><ol><li>建立 tag 物件</li><li>建立 tag ref，此 tag ref 會指向剛剛建立的 tag 物件</li></ol><p>我之前在 <a href="https://titangene.github.io/article/git--blob-object.html#hash-object-%E8%A8%88%E7%AE%97%E7%89%A9%E4%BB%B6%E5%90%8D%E7%A8%B1%E7%9A%84%E6%BC%94%E7%AE%97%E6%B3%95">深入 Git：Git 物件儲存 - blob 物件</a> 這篇有提到建立 Git 物件的底層指令 <code>git hash-object</code>，以及這個底層指令的原理。</p><p>但是在使用 <code>git hash-object</code> 之前，必須要先準備好這個指令上的 <code>--stdin</code> option 要從 stdin (standard input，標準輸入) 讀取的內容，內容格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">object &lt;object-sha1&gt;<br>type &lt;object-type&gt;<br>tag &lt;tag-name&gt;<br>tagger &lt;tagger-name&gt; &lt;&lt;tagger-email&gt;&gt; &lt;timestamp&gt;<br><br>&lt;tag-message&gt;<br></code></pre></td></tr></table></figure><p>內容範例如下 (我先隨意將以下內容儲存在一個檔案內，任意檔名都可以，因為重點是檔案的內容)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim my-tag.txt</span><br><span class="hljs-meta">$</span><span class="bash"> cat my-tag.txt</span><br>object 61780798228d17af2d34fce4cfbdf35556832472<br>type blob<br>tag file-b<br>tagger titangene &lt;titangene.tw@gmail.com&gt; 1586097930 +0800<br><br>file b<br></code></pre></td></tr></table></figure><p>因為這次要建立的是 tag 物件，所以需要在 <code>git hash-object</code> 指令上加上 <code>-t</code> option，並且指定 <code>tag</code>，代表要建立 tag 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">hash</span>-object -t tag -w --stdin &lt; my-tag.txt</span><br>8785f7a44e2af5628544ecb0aa9dccf2adfa37ff<br></code></pre></td></tr></table></figure><p>這邊輸出的 <code>8785f7</code> 就是剛剛建立的 tag 物件的 SHA-1 值，我們用 <code>git cat-file</code> 來驗證一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 8785f7</span><br>tag<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 8785f7</span><br>object 61780798228d17af2d34fce4cfbdf35556832472<br>type blob<br>tag file-b<br>tagger titangene &lt;titangene.tw@gmail.com&gt; 1586097930 +0800<br><br>file b<br></code></pre></td></tr></table></figure><p>接著處理第二步驟，使用 <code>git update-ref</code> 底層指令建立 annotated tag 的 ref：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git update-ref refs/tags/file-b 8785f7a44e2af5628544ecb0aa9dccf2adfa37ff</span><br></code></pre></td></tr></table></figure><p>察看該 tag ref 的確是指向剛剛指定的 SHA-1 值 (在這邊就是 tag 物件)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/tags/file-b  </span><br>8785f7a44e2af5628544ecb0aa9dccf2adfa37ff<br></code></pre></td></tr></table></figure><h2 id="在-git-log-察看-tag"><a class="header-anchor" href="#在-git-log-察看-tag"></a>在 <code>git log</code> 察看 tag</h2><p>使用 <code>git log</code> 察看剛剛建立的 tag 都貼上哪個 commit 上面 (也就是那些 tag 都指向哪個 commit)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --decorate</span><br>32aa934 (HEAD -&gt; master, tag: v1.0-lw, tag: v1.0) feat: c<br>9b6d639 (tag: v0.2-lw) feat: b<br>d835d6b (tag: v0.1-lw, tag: v0.1) feat: a<br></code></pre></td></tr></table></figure><p>另外提一下 (雖然上面有介紹到)，不管是 lightweight tag 還是 annotated tag，如果是指向 commit 物件之外的其他 Git 物件 (也就是 blob 物件或 tree 物件，甚至是其他 tag 物件)，都無法在 <code>git log</code> 的輸出察看，只能透過 <code>git show</code> 或是透過 <code>cat</code> 和 <code>git cat-file</code> 指令來察看該 tag 是指向哪個 Git 物件。</p><p>下面以 annotated tag 為例，透過這些指令來找到名為 <code>file-b</code> 的 tag 指向 SHA-1 值為 <code>8785f7</code> 的 tag 物件，而該 tag 物件是指向 SHA-1 值為 <code>617807</code> 的 blob 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a file-c -m <span class="hljs-string">"file c"</span> f2ad6c</span><br><br><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/tags/file-c</span><br>febbaa9a5276f0321d72232c4bc3aa561bfc38c5<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t febbaa</span><br>tag<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p febbaa</span><br>object f2ad6c76f0115a6ba5b00456a849810e7ec0af20<br>type blob<br>tag file-c<br>tagger titangene &lt;titangene.tw@gmail.com&gt; 1586100520 +0800<br><br>file c<br></code></pre></td></tr></table></figure><h2 id="察看所有-tag"><a class="header-anchor" href="#察看所有-tag"></a>察看所有 tag</h2><p>執行 <code>git tag</code> 指令可以察看所有建立的 tag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>file-b<br>file-c<br>v0.1<br>v0.1-lw<br>v0.2-lw<br>v1.0<br>v1.0-lw<br></code></pre></td></tr></table></figure><h1 id="commit-vs-tag"><a class="header-anchor" href="#commit-vs-tag"></a>commit vs tag</h1><ul><li>commit 物件紀錄的指標只能是 tree 物件，不能是其他 Git 物件</li><li>tag 物件通常紀錄的指標是 commit 物件，當然也可以是其他 Git 物件，包括 tree 物件、blob 物件，甚至是其他 tag 物件</li></ul><h1 id="分支-vs-tag"><a class="header-anchor" href="#分支-vs-tag"></a>分支 vs tag</h1><p>那分支和 tag 都可以指向 commit 物件，那他們有何差別？</p><ul><li>分支：在提交新的 commit 時，會將分支指向該分支的末端，也就是新的 commit 物件</li><li>lightweight tag 和 annotated tag 這兩種 tag 都是永遠不會改變 tag 所指向的物件，只是提供更 friendlier 的名稱的標記而已<ul><li>lightweight tag：很像不會移動的分支，此 tag ref 只會指向一個特定的 Git 物件</li><li>annotated tag：此 tag ref 會指向 tag 物件，而 tag 物件會指向一個特定的 Git 物件</li></ul></li></ul><p>資料來源：</p><ul><li><a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Git-References" target="_blank" rel="noopener">Git Internals - Git References | Pro Git, 2/e</a></li><li><a href="https://git-scm.com/book/zh-tw/v2/Git-%E5%9F%BA%E7%A4%8E-%E6%A8%99%E7%B1%A4" target="_blank" rel="noopener">Git 基礎 - 標籤 | Pro Git, 2/e</a></li><li><a href="https://stackoverflow.com/questions/10986615/what-is-the-format-of-a-git-tag-object-and-how-to-calculate-its-sha" target="_blank" rel="noopener">hash - What is the format of a git tag object and how to calculate its SHA? - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇將深入探討 Git tag 是什麼？如何建立 tag？Git 是如何儲存 tag？與 commit 和分支的差別在哪？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>深入 Git：HEAD refs</title>
    <link href="https://titangene.github.io/article/git-head-ref.html"/>
    <id>https://titangene.github.io/article/git-head-ref.html</id>
    <published>2020-03-29T15:55:33.000Z</published>
    <updated>2020-03-29T15:57:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>本篇將深入探討 Git <code>HEAD</code> 是什麼？儲存在 repo 的哪裡？以及跟 <code>git branch</code> 和 <code>git checkout</code> 之間的關係。</p><a id="more"></a><p>上次提到的 <a href="https://titangene.github.io/article/git-branch-ref.html">Git 分支 ref</a>，可用來紀錄不同的工作過程，例如最常見的 <code>master</code> 和 <code>develop</code> 分支，<code>master</code> 分支通常用來紀錄發佈的版本，而 <code>develop</code> 分支通常用來紀錄正在開發的版本。</p><p>那 Git 是如何知道你正在哪一個分支？其實是透過 <code>HEAD</code> 檔案來紀錄的。這個檔案通常會放在 <code>.git</code> 路徑底下。</p><p>通常 <code>HEAD</code> 檔案是對當前所在分支的 symbolic reference <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，也就是紀錄你正在哪一個分支的檔案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/HEAD</span><br>ref: refs/heads/master<br></code></pre></td></tr></table></figure><p>如果執行 <code>git checkout</code> 來切換分支，Git 就會更新 <code>HEAD</code> 檔案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout</span><br>Switched to branch 'test'<br><span class="hljs-meta">$</span><span class="bash"> cat .git/HEAD</span><br>ref: refs/heads/test<br></code></pre></td></tr></table></figure><p>在執行 <code>git commit</code> 時，為何當前所在的分支會一直指向最新的 commit？這是因為 <code>HEAD</code> 會指向當前分支，而當前分支會指向該分支的末端，也就是說，當執行 <code>git commit</code> 時，Git 會建立新的 <a href="https://titangene.github.io/article/git-commit-object.html">commit 物件</a>，而分支會被更新成指向該分支的末端 (也就是新的 commit 物件)。</p><p>通常 <code>HEAD</code> 會指向當前分支，若 <code>HEAD</code> 檔案的內容為 Git 物件的 SHA-1 值時，則代表 <a href="https://git-scm.com/docs/git-checkout#_detached_head" target="_blank" rel="noopener">detached HEAD</a> 狀態。這種情況會在你使用 <code>git checkout</code> 切換至 tag、commit 或遠端分支時發生。在此狀態下，沒有分支會與 working tree 關聯。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout 665439e            </span><br>Note: checking out '665439e'.<br><br>You are in 'detached HEAD' state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make in this<br>state without impacting any branches by performing another checkout.<br><br>If you want to create a new branch to retain commits you create, you may<br>do so (now or later) by using -b with the checkout command again. Example:<br><br>  git checkout -b &lt;new-branch-name&gt;<br><br>HEAD is now at 665439e feat: a<br></code></pre></td></tr></table></figure><h2 id="手動編輯-HEAD-檔案模擬-checkout-分支"><a class="header-anchor" href="#手動編輯-HEAD-檔案模擬-checkout-分支"></a>手動編輯 <code>HEAD</code> 檔案模擬 checkout 分支</h2><p>我們來手動編輯此 <code>HEAD</code> 檔案，驗證改變 <code>HEAD</code> 檔案的內容就等同於在 <code>git checkout</code> 至某個分支。</p><p>假設目前正在 <code>test</code> 分支，然後將 <code>HEAD</code> 檔案的內容從 <code>ref: refs/heads/test</code> 變成 <code>ref: refs/heads/master</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch</span><br>* test<br>  master<br><br><span class="hljs-meta">$</span><span class="bash"> cat .git/HEAD</span><br>ref: refs/heads/test<br><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"ref: refs/heads/master"</span> &gt; .git/HEAD</span><br></code></pre></td></tr></table></figure><p>然後用 <code>git branch</code> 就能驗證現在已經「<code>checkout</code>」至 <code>master</code> 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch</span><br>  test<br>* master<br></code></pre></td></tr></table></figure><h2 id="使用-symbolic-ref-底層指令"><a class="header-anchor" href="#使用-symbolic-ref-底層指令"></a>使用 <code>symbolic-ref</code> 底層指令</h2><p>雖然剛剛有提到可以手動編輯 <code>HEAD</code> 檔案，但建議使用 Git 提供的底層指令 <a href="https://git-scm.com/docs/git-symbolic-ref" target="_blank" rel="noopener"><code>git symbolic-ref</code></a> 來編輯和讀取 <code>HEAD</code> 檔案：</p><p>讀取 <code>HEAD</code> 檔案 (察看當前所在分支)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git symbolic-ref HEAD</span><br>refs/heads/master<br></code></pre></td></tr></table></figure><p>加上 <code>--short</code> option 會只顯示分支名稱，不會顯示分支 ref 的路徑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git symbolic-ref HEAD --short</span><br>master<br></code></pre></td></tr></table></figure><p>設定 <code>HEAD</code> 檔案 (等同於 <code>git checkout &lt;branch&gt;</code> )：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git symbolic-ref HEAD refs/heads/<span class="hljs-built_in">test</span></span><br><span class="hljs-meta">$</span><span class="bash"> cat .git/HEAD</span><br>ref: refs/heads/test<br></code></pre></td></tr></table></figure><p>一定要用 <code>refs/</code> 為開頭的 ref 才能設定 <code>HEAD</code> 檔案，要不然會報錯：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git symbolic-ref HEAD <span class="hljs-built_in">test</span></span><br>fatal: Refusing to point HEAD outside of refs/<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References" target="_blank" rel="noopener">Git Internals - Git References | Pro Git, 2/e</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://git-scm.com/docs/gitglossary#def_symref" target="_blank" rel="noopener">Git - gitglossary Documentation</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇將深入探討 Git &lt;code&gt;HEAD&lt;/code&gt; 是什麼？儲存在 repo 的哪裡？以及跟 &lt;code&gt;git branch&lt;/code&gt; 和 &lt;code&gt;git checkout&lt;/code&gt; 之間的關係。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>深入 Git：分支 refs</title>
    <link href="https://titangene.github.io/article/git-branch-ref.html"/>
    <id>https://titangene.github.io/article/git-branch-ref.html</id>
    <published>2020-03-22T10:49:50.000Z</published>
    <updated>2020-03-29T14:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>本篇將深入探討 Git 分支到底是什麼？建立分支時到底建立了什麼？如何紀錄分支要指向哪個 commit？</p><a id="more"></a><p>Git 參考 (references 或 refs) 都存在 <code>.git/refs</code> 目錄內，目錄結構如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/refs/</span><br>.git/refs/<br>├── heads<br>└── tags<br><br>2 directories, 0 files<br></code></pre></td></tr></table></figure><p>因為「<a href="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/">深入 Git</a>」此文章系列都是探討如何用 Git 的底層指令來模擬 Git 高階指令的操作。在之前建立 <a href="https://titangene.github.io/article/git--blob-object.html">blob</a>、<a href="https://titangene.github.io/article/git-tree-object.html">tree</a> 和 <a href="https://titangene.github.io/article/git-commit-object.html">commit</a> 物件時，都還沒建立 Git refs，所以 <code>.git/refs</code> 目錄內的資料夾中，才沒有其他紀錄指標的檔案。</p><p>若用平常使用的高階指令就會幫你建立很多 Git refs，目錄可能像下面這樣：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/refs/</span><br>.git/refs/<br>├── heads<br>│   ├── develop<br>│   └── master<br>├── original<br>│   └── refs<br>│       └── heads<br>│           └── master<br>├── remotes<br>│   └── origin<br>│       ├── develop<br>│       └── master<br>└── tags<br>    └── v1.0<br></code></pre></td></tr></table></figure><p>那我們就開始試著利用底層指令來手動建立 Git refs 吧！</p><h2 id="建立分支-ref"><a class="header-anchor" href="#建立分支-ref"></a>建立分支 ref</h2><p>若沒有 Git refs，就要像這樣指定 commit 的 SHA-1 值才能看到歷史紀錄：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --decorate 200c91</span><br>200c91c second commit<br>9079eb3 first commit<br></code></pre></td></tr></table></figure><p>若有一個指標指向該 commit 的 SHA-1 值就不用再記住了，省很多麻煩。</p><p>而 <code>master</code> 就是最常見的指標，要建立分支的指標其實很簡單，只要在 <code>.git/refs/heads</code> 目錄內，建立該分支名稱的檔案，而檔案內容就是你要指定的 commit SHA-1 值，例如：我要將 <code>master</code> 分支指向 <code>200c91</code> 這個 commit 上，可執行以下指令建立分支 ref：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> 200c91c4acb82e529fb8205ea786a17cc10008b6 &gt; .git/refs/heads/master</span><br></code></pre></td></tr></table></figure><p>建立分支後，就可以使用剛剛建立的 head ref (分支頂端的 commit 的 named reference，通常儲存在 <code>.git/refs/heads</code> 目錄中) <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 來察看歷史紀錄：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --decorate master</span><br>200c91c (HEAD -&gt; master) second commit<br>9079eb3 first commit<br></code></pre></td></tr></table></figure><p>不過，不建議你自己編輯 ref 檔案。Git 提供 <code>git update-ref</code> 這個底層指令可讓你更新 ref (可不用輸入完整的 commit SHA-1 值，因為 Git 會自動找到對應的 Git 物件)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git update-ref refs/heads/master 200c91</span><br></code></pre></td></tr></table></figure><p>剛剛建立的 head ref 就是分支。分支只是一個指標 (不是像樹的分岔樹枝)，用來紀錄正在開發的分支的最新 commit (或 head) 的 SHA-1 值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/heads/master</span><br>200c91c4acb82e529fb8205ea786a17cc10008b6<br></code></pre></td></tr></table></figure><p>要察看此 repo 有哪些 Git ref，可用 Git 提供的 <code>git show-ref</code> 這個底層指令來察看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git show-ref</span><br>200c91c4acb82e529fb8205ea786a17cc10008b6 refs/heads/master<br></code></pre></td></tr></table></figure><p>所以你在執行 <code>git branch &lt;branch&gt;</code> 指令時，Git 基本上會執行 <code>git update-ref</code> 指令，將你當前所在分支的最後一個 commit 的 SHA-1 新增至你想建立的新 reference (也就是分支 ref)。</p><p>資料來源：</p><ul><li><a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References" target="_blank" rel="noopener">Git - Git References | Pro Git, 2/e</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefheadahead" target="_blank" rel="noopener">Git - gitglossary Documentation</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇將深入探討 Git 分支到底是什麼？建立分支時到底建立了什麼？如何紀錄分支要指向哪個 commit？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>深入 Git：Git 物件儲存 - commit 物件</title>
    <link href="https://titangene.github.io/article/git-commit-object.html"/>
    <id>https://titangene.github.io/article/git-commit-object.html</id>
    <published>2020-03-15T15:58:26.000Z</published>
    <updated>2020-03-22T15:51:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>本篇將深入探討 Git 如何運作，在執行 <code>git commit</code> 時，Git 會如何建立和儲存 commit 物件。</p><a id="more"></a><p>tree 物件會指向追蹤專案的不同 snapshot，若要取得這些 snapshot 就會遇到一些問題：</p><ul><li>必須記得這些 tree 物件的 SHA-1 值 (麻煩)</li><li>snapshot 是誰儲存的</li><li>snapshot 是何時儲存的</li><li>為何要儲存 snapshot</li></ul><p>以上這些就是 commit 物件為你儲存的資訊。</p><h2 id="準備"><a class="header-anchor" href="#準備"></a>準備</h2><p>下面會以這個檔案結構為範例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir demo</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> demo</span><br><span class="hljs-meta">$</span><span class="bash"> git init</span><br>Initialized empty Git repository in /home/titan/project/demo/.git/<br><span class="hljs-meta">$</span><span class="bash"> mkdir styles</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"index"</span> &gt; index.html</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"# README"</span> &gt; README.md</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"/* style */"</span> &gt; styles/main.css</span><br><br><span class="hljs-meta">$</span><span class="bash"> tree      </span><br>.<br>├── index.html<br>├── README.md<br>└── styles<br>    └── main.css<br><br>1 directories, 3 files<br></code></pre></td></tr></table></figure><h2 id="將第一個檔案加入-index，並建立-tree-物件"><a class="header-anchor" href="#將第一個檔案加入-index，並建立-tree-物件"></a>將第一個檔案加入 index，並建立 tree 物件</h2><p>先將 <code>index.html</code> 加入 index，接著將 index 寫至 tree 物件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat index.html</span><br>index<br><span class="hljs-meta">$</span><span class="bash"> git add index.html</span><br><span class="hljs-meta">$</span><span class="bash"> git write-tree</span><br>2dce93ea08ed9059be0a838c6bcf62b7b5c28907<br></code></pre></td></tr></table></figure><div class="info"><p>註：<code>git add</code> 看起來只是將檔案加入 index，但在 Git 的運作原理其實做了很多步驟，詳情可參閱我之前寫的這幾篇，本篇就不再重複說明這些內容：</p><ul><li><a href="https://titangene.github.io/article/git--blob-object.html">深入 Git：Git 物件儲存 - blob 物件</a></li><li><a href="https://titangene.github.io/article/git-tree-object.html">深入 Git：Git 物件儲存 - tree 物件</a></li><li><a href="https://titangene.github.io/article/git-index.html">深入 Git：index 檔案</a></li></ul></div><p>此時在 <code>.git/object</code> 目錄內，已經有兩個 Git 物件，分別為：</p><ul><li><code>9015a7</code> blob 物件：透過 <code>index.html</code> 此檔案產生的</li><li><code>2dce93</code> tree 物件：對應到專案根目錄</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/objects</span><br>.git/objects<br>├── 2d<br>│   └── ce93ea08ed9059be0a838c6bcf62b7b5c28907<br>├── 90<br>│   └── 15a7a32ca0681be64471d3ac2f8c1f24c1040d<br>├── info<br>└── pack<br><br>4 directories, 2 files<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 9015a7</span><br>blob<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 9015a7    </span><br>index<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 2dce93</span><br>tree<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 2dce93</span><br>100644 blob 9015a7a32ca0681be64471d3ac2f8c1f24c1040dindex.html<br></code></pre></td></tr></table></figure><h2 id="建立第一個-commit-物件"><a class="header-anchor" href="#建立第一個-commit-物件"></a>建立第一個 commit 物件</h2><p>要建立 commit 物件需使用 <code>git commit-tree</code> 指令，指定一個 tree 物件的 SHA-1 值以及前一個 commit 物件 (第一個 commit 不需要)。</p><p>下面使用剛剛建立的 <code>2dce93</code> 的 tree 物件來建立 commit 物件，並且提供 commit 訊息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'first commit'</span> | git commit-tree 2dce93</span><br>9079eb3c74f72f1409dc47ef5d7c8763dbd128f6<br></code></pre></td></tr></table></figure><p>commit 物件會根據建立的時間和作者的資訊而建立不同的 SHA-1 值。使用 <code>git cat-file</code> 指令察看剛剛建立的 commit 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 9079eb</span><br>commit<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 9079eb</span><br>tree 2dce93ea08ed9059be0a838c6bcf62b7b5c28907<br>author titangene &lt;titangene.tw@gmail.com&gt; 1584281436 +0800<br>committer titangene &lt;titangene.tw@gmail.com&gt; 1584281436 +0800<br><br>first commit<br></code></pre></td></tr></table></figure><p>commit 物件的格式包含以下內容：</p><ul><li>專案 snapshot 的頂層 tree：也就是專案根目錄對應的 tree 物件</li><li>author/committer 訊息：使用 <code>user.name</code> 和 <code>user.email</code> 的配置和 timestamp<ul><li>author 就是編輯檔案內容的人</li><li>committer 就是 commit 的人</li><li>通常 author 和 committer 會是同一個人</li><li>若透過 email 來發送 patch，就可能發生 author 和 committer 是不同人 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></li></ul></li><li>一個空行 (blank line)</li><li>commit 訊息</li></ul><h3 id="將另外兩個檔案加入-index，並建立-tree-物件"><a class="header-anchor" href="#將另外兩個檔案加入-index，並建立-tree-物件"></a>將另外兩個檔案加入 index，並建立 tree 物件</h3><p>接著將 <code>README.md</code> 和 <code>styles/main.css</code> 加入 index，接著再將 index 寫至 tree 物件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat README.md</span><br><span class="hljs-meta">#</span><span class="bash"> README</span><br><span class="hljs-meta">$</span><span class="bash"> git add README.md</span><br><br><span class="hljs-meta">$</span><span class="bash"> cat styles/main.css</span><br>/* style */<br><span class="hljs-meta">$</span><span class="bash"> git add styles/main.css</span><br><br><span class="hljs-meta">$</span><span class="bash"> git write-tree</span><br>563b8123edfdfd28aeb8bd6cde392a4be9adba2d<br></code></pre></td></tr></table></figure><p>此時在 <code>.git/object</code> 目錄內，多了 4 個 Git 物件，分別為：</p><ul><li><code>7e5960</code> blob 物件：透過 <code>README.md</code> 此檔案產生的</li><li><code>202479</code> blob 物件：透過 <code>styles/main.css</code> 此檔案產生的</li><li><code>0bb8d2</code> tree 物件：對應到 <code>styles</code> 目錄</li><li><code>563b81</code> tree 物件：對應到專案根目錄</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/objects</span><br>.git/objects<br>├── 0b<br>│   └── b8d2a25db76aec1c38bc948ba579959d443790<br>├── 20<br>│   └── 2479c888bf25f40895164be873c63f556a1b76<br>├── 2d<br>│   └── ce93ea08ed9059be0a838c6bcf62b7b5c28907<br>├── 56<br>│   └── 3b8123edfdfd28aeb8bd6cde392a4be9adba2d<br>├── 7e<br>│   └── 59600739c96546163833214c36459e324bad0a<br>├── 90<br>│   ├── 15a7a32ca0681be64471d3ac2f8c1f24c1040d<br>│   └── 79eb3c74f72f1409dc47ef5d7c8763dbd128f6<br>├── info<br>└── pack<br><br>8 directories, 7 files<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 7e5960</span><br>blob<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 7e5960</span><br><span class="hljs-meta">#</span><span class="bash"> README</span><br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 202479</span><br>blob<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 202479</span><br>/* style */<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 0bb8d2</span><br>tree<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 0bb8d2</span><br>100644 blob 202479c888bf25f40895164be873c63f556a1b76main.css<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 563b81</span><br>tree<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 563b81</span><br>100644 blob 7e59600739c96546163833214c36459e324bad0aREADME.md<br>100644 blob 9015a7a32ca0681be64471d3ac2f8c1f24c1040dindex.html<br>040000 tree 0bb8d2a25db76aec1c38bc948ba579959d443790styles<br></code></pre></td></tr></table></figure><h2 id="建立第二個-commit-物件"><a class="header-anchor" href="#建立第二個-commit-物件"></a>建立第二個 commit 物件</h2><p>接著使用剛剛建立的 <code>563b81</code> 的 tree 物件來建立第二個 commit，並且提供 commit 訊息和指定前一個 commit (也就是 parent commit)：</p><ul><li><code>-p &lt;parent&gt;</code>：指定 parent commit 的 ID，在此範例是第一個 commit 物件的 SHA-1 值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'second commit'</span> | git commit-tree 563b81 -p 9079eb</span><br>200c91c4acb82e529fb8205ea786a17cc10008b6<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 200c91</span><br>commit<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 200c91</span><br>tree 563b8123edfdfd28aeb8bd6cde392a4be9adba2d<br>parent 9079eb3c74f72f1409dc47ef5d7c8763dbd128f6<br>author titangene &lt;titangene.tw@gmail.com&gt; 1584285257 +0800<br>committer titangene &lt;titangene.tw@gmail.com&gt; 1584285257 +0800<br><br>second commit<br></code></pre></td></tr></table></figure><h2 id="編輯檔案後加入-index，並建立-tree-物件"><a class="header-anchor" href="#編輯檔案後加入-index，並建立-tree-物件"></a>編輯檔案後加入 index，並建立 tree 物件</h2><p>接著編輯 <code>index.html</code> 後，將變更加入 index，接著再將 index 寫至 tree 物件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat index.html</span><br>index<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'index v2'</span> &gt; index.html</span><br><span class="hljs-meta">$</span><span class="bash"> git add index.html</span><br><br><span class="hljs-meta">$</span><span class="bash"> git write-tree</span><br>bdaf4c7dc919738d7d59a27ef2ef3d5ff3107ae6<br></code></pre></td></tr></table></figure><p>此時在 <code>.git/object</code> 目錄內，多了 2 個 Git 物件，分別為：</p><ul><li><code>b2e53d</code> blob 物件：透過 <code>index.html</code> 此檔案產生的</li><li><code>bdaf4c</code> tree 物件：對應到專案根目錄</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t b2e53d</span><br>blob<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p b2e53d</span><br>index v2<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t bdaf4c</span><br>tree<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p bdaf4c</span><br>100644 blob 7e59600739c96546163833214c36459e324bad0a    README.md<br>100644 blob b2e53d55f22bdb2eafcdfaff9b1b37829309ae50    index.html<br>040000 tree 0bb8d2a25db76aec1c38bc948ba579959d443790    styles<br></code></pre></td></tr></table></figure><h2 id="建立第三個-commit-物件"><a class="header-anchor" href="#建立第三個-commit-物件"></a>建立第三個 commit 物件</h2><p>接著使用剛剛建立的 <code>bdaf4c</code> 的 tree 物件來建立第三個 commit，並且提供 commit 訊息和指定前一個 commit (也就是 parent commit)：</p><ul><li><code>-p &lt;parent&gt;</code>：指定 parent commit 的 ID，在此範例是第一個 commit 物件的 SHA-1 值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'third commit'</span> | git commit-tree bdaf4c -p 200c91</span><br>64fd0be6f2b66bc48d26c7c77cab62fab1477072<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 64fd0b</span><br>commit<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 64fd0b</span><br>tree bdaf4c7dc919738d7d59a27ef2ef3d5ff3107ae6<br>parent 200c91c4acb82e529fb8205ea786a17cc10008b6<br>author titangene &lt;titangene.tw@gmail.com&gt; 1584892171 +0800<br>committer titangene &lt;titangene.tw@gmail.com&gt; 1584892171 +0800<br><br>third commit<br></code></pre></td></tr></table></figure><h2 id="察看歷史紀錄"><a class="header-anchor" href="#察看歷史紀錄"></a>察看歷史紀錄</h2><p>不過到目前為止，都還無法透過 <code>git log</code> 指令來察看剛剛建立的 commit 歷史紀錄，這是因為我們從一開始就是使用底層指令 (plumbing 指令) 來模擬平常我們在用的指令 (porcelain 指令)，而在過程中都沒有建立 <code>master</code> 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span></span><br>fatal: your current branch 'master' does not have any commits yet<br></code></pre></td></tr></table></figure><p>但我們可在 <code>git log</code> 指令上，另外指定最後一個建立的 commit 物件，這樣就能看到剛剛建立的 Git 歷史紀錄了：</p><ul><li><code>--stat</code>：顯示每個 commit 的 diff 資訊 (diffstat)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span> 64fd0b</span><br>commit 64fd0be6f2b66bc48d26c7c77cab62fab1477072<br>Author: titangene &lt;titangene.tw@gmail.com&gt;<br>Date:   Sun Mar 22 23:49:31 2020 +0800<br><br>    third commit<br><br> index.html | 2 +-<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br><br>commit 200c91c4acb82e529fb8205ea786a17cc10008b6 (HEAD -&gt; master)<br>Author: titangene &lt;titangene.tw@gmail.com&gt;<br>Date:   Sun Mar 15 23:14:17 2020 +0800<br><br>    second commit<br><br> README.md       | 1 +<br> styles/main.css | 1 +<br> 2 files changed, 2 insertions(+)<br><br>commit 9079eb3c74f72f1409dc47ef5d7c8763dbd128f6<br>Author: titangene &lt;titangene.tw@gmail.com&gt;<br>Date:   Sun Mar 15 22:10:36 2020 +0800<br><br>    first commit<br><br> index.html | 1 +<br> 1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure><h2 id="Git-物件關聯圖"><a class="header-anchor" href="#Git-物件關聯圖"></a>Git 物件關聯圖</h2><p>以上這些就是 Git 在執行 <code>git add</code> 和 <code>git commit</code> 指令時所做的事情：</p><ol><li>儲存已變更檔案的 blob 物件</li><li>更新 index</li><li>利用 index 建立 tree 物件</li><li>建立指向頂層 tree 和 parent commit 的 commit 物件</li></ol><p>這些物件都存在 <code>.git/objects</code> 目錄內。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> find .git/objects -<span class="hljs-built_in">type</span> f</span><br>.git/objects/2d/ce93ea08ed9059be0a838c6bcf62b7b5c28907 # Tree: ./ dir v1<br>.git/objects/20/0c91c4acb82e529fb8205ea786a17cc10008b6 # Commit: second commit<br>.git/objects/20/2479c888bf25f40895164be873c63f556a1b76 # Blob: main.css<br>.git/objects/7e/59600739c96546163833214c36459e324bad0a # Blob: README.md<br>.git/objects/0b/b8d2a25db76aec1c38bc948ba579959d443790 # Tree: styles dir<br>.git/objects/90/79eb3c74f72f1409dc47ef5d7c8763dbd128f6 # Commit: first commit<br>.git/objects/90/15a7a32ca0681be64471d3ac2f8c1f24c1040d # Blob: index.html<br>.git/objects/56/3b8123edfdfd28aeb8bd6cde392a4be9adba2d # Tree: ./ dir v2<br></code></pre></td></tr></table></figure><p>下圖是這些 Git 物件的關聯圖：</p><p><img src="../images/git-commit-object/object-DAG.png" alt=""></p><div class="info"><p>雖然看起來很像目錄和子目錄的關係，但在 Git 中是沒有層級關係的，commit 物件形成<a href="https://zh.m.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE" target="_blank" rel="noopener">有向無環圖 (directed acyclic graph，DAG)</a>，commit 物件有 parent commit (有向)，並且 commit 物件的圖是無環的 (從開始到結束不會是同一個物件) <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。</p></div><p>資料來源：<a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Git-Objects#r_tree_objects" target="_blank" rel="noopener">10.2 Git Internals - Git Objects | Pro Git, 2/e</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History" target="_blank" rel="noopener">Git - Viewing the Commit History</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://git-scm.com/book/en/v2/Distributed-Git-Maintaining-a-Project#_git_am" target="_blank" rel="noopener">Git - Maintaining a Project</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefDAGaDAG" target="_blank" rel="noopener">Git - gitglossary Documentation</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇將深入探討 Git 如何運作，在執行 &lt;code&gt;git commit&lt;/code&gt; 時，Git 會如何建立和儲存 commit 物件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>深入 Git：index 檔案</title>
    <link href="https://titangene.github.io/article/git-index.html"/>
    <id>https://titangene.github.io/article/git-index.html</id>
    <published>2020-03-08T15:56:40.000Z</published>
    <updated>2020-03-08T18:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p><code>git add</code> 會將檔案加入 index，究竟 index 到底存在哪？其實，通常會放在 <code>.git/index</code>，本篇將深入探討此檔案式如何紀錄有哪些檔案被加入 index。</p><a id="more"></a><p>index 是一個二進位檔案，通常放在 <code>.git/index</code>，其中包含路徑名稱的排序列表、每個路徑名稱的權限和 blob 物件的 SHA-1 值。而 <code>git ls-files</code> 指令可顯示 index 的內容。</p><h2 id="透過-git-ls-files-來認識-index"><a class="header-anchor" href="#透過-git-ls-files-來認識-index"></a>透過 <code>git ls-files</code> 來認識 index</h2><p>使用 <code>git ls-files</code> 底層指令來察看 index 檔案，但指令預設只會顯示有哪些檔名，所以加上一些選項：</p><ul><li><code>-c</code>，<code>--cached</code>：預設選項，只在輸出顯示已暫存的檔案</li><li><code>-s</code>，<code>--stage</code>：在輸出中顯示 stage 內容的 mode bit、物件名稱和 stage number</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git ls-files -s</span><br>100644 9015a7a32ca0681be64471d3ac2f8c1f24c1040d 0index.html<br></code></pre></td></tr></table></figure><p>從上面輸出可得知：</p><ul><li><code>index.html</code> 的 file mode bits 為 <code>100644</code>，代表是 regular non-executable file</li><li><code>index.html</code> 的 blob 物件名稱為 <code>9015a7...</code></li><li>stage number 在合併衝突處理時會用到</li><li>檔案名稱</li></ul><p>file mode bits (6 位數) 是檔案權限的八進位表示法，也可以是以二進位的方式讀取。這邊的 <code>100644</code> ( <code>0b1000000110100100</code> ) 代表檔案是 regular non-executable file，檔案擁有者可以讀寫，檔案群組中的其他使用者可以讀取，而其他使用者也可以讀取。</p><p>這類似 Unix 的檔案屬性 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，用來表示該檔案的類型 (檔案、目錄、link) 和權限 (可讀、可寫、可執行)，以下是常見的 (用二進位和八進位表示) <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>：</p><ul><li><code>0100000000000000</code> ( <code>040000</code> )：Directory</li><li><code>1000000110100100</code> ( <code>100644</code> )：Regular non-executable file</li><li><code>1000000110110100</code> ( <code>100664</code> )：Regular non-executable group-writeable file</li><li><code>1000000111101101</code> ( <code>100755</code> )：Regular executable file</li><li><code>1010000000000000</code> ( <code>120000</code> )：Symbolic link</li><li><code>1110000000000000</code> ( <code>160000</code> )：Gitlink</li></ul><div class="info"><p>註：二進位表示法 <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><ul><li>前 4-bit：物件 type<ul><li><code>1000</code>：regular file</li><li><code>1010</code>：symbolic link</li><li><code>1110</code>：gitlink</li></ul></li><li>中間 3-bit：沒有使用</li><li>後面 9-bit：unix 權限<ul><li>regular file 只能用 <code>0755</code> 和 <code>0644</code></li><li>symbolic link 和 gitlink 在此 field 中的值為 <code>0</code></li></ul></li></ul><p>blob 物件只對 <code>100644</code>、<code>100664</code> 和 <code>100755</code> 這三種 mode 有效。</p></div><p>在 <code>git add</code> 指令期間沒有真正使用不同的 stage number，用於處理合併衝突：</p><ul><li><code>0</code>：normal，無衝突，一切正常</li><li><code>1</code>：base，共同 ancestor 版本</li><li><code>2</code>：ours，目標 ( <code>HEAD</code> ) 版本</li><li><code>3</code>：theris，被合併的版本</li></ul><h2 id="git-index-內部"><a class="header-anchor" href="#git-index-內部"></a><code>.git/index</code> 內部</h2><p>對 Git index 檔案 <code>.git/index</code> 進行位元轉儲 (bits dump)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> xxd -b -c 4 .git/index</span><br>00000000: 01000100 01001001 01010010 01000011  DIRC<br>00000004: 00000000 00000000 00000000 00000010  ....<br>00000008: 00000000 00000000 00000000 00000001  ....<br>0000000c: 01011110 01011011 11000111 10010001  ^[..<br>00000010: 00101111 00001011 00100011 00101010  /.#*<br>00000014: 01011110 01011011 11000111 10010001  ^[..<br>00000018: 00100111 00101111 10101000 11100000  '/..<br>0000001c: 00000000 00000000 00001000 00000100  ....<br>00000020: 00000000 10111000 00001101 01001111  ...O<br>00000024: 00000000 00000000 10000001 10100100  ....<br>00000028: 00000000 00000000 00000011 11101000  ....<br>0000002c: 00000000 00000000 00000011 11101000  ....<br>00000030: 00000000 00000000 00000000 00001011  ....<br>00000034: 10111011 11011110 11111001 00101010  ...*<br>00000038: 11101111 00001111 11101100 11111000  ....<br>0000003c: 00100111 00000100 01110000 10100110  '.p.<br>00000040: 00011111 11101000 10010101 00101010  ...*<br>00000044: 01101010 11111101 01011011 10011010  j.[.<br>00000048: 00000000 00001010 01101001 01101110  ..in<br>0000004c: 01100100 01100101 01111000 00101110  dex.<br>00000050: 01101000 01110100 01101101 01101100  html<br>00000054: 00000000 00000000 00000000 00000000  ....<br>00000058: 00000000 00000000 00000000 00000000  ....<br>0000005c: 00101000 01000001 00101101 00100001  (A-!<br>00000060: 00011010 10000111 01011011 00010011  ..[.<br>00000064: 01101111 01010010 10010111 01110010  oR.r<br>00000068: 11001010 01001100 01110011 11110011  .Ls.<br>0000006c: 10110011 11001100 00110011 00001000  ..3.<br></code></pre></td></tr></table></figure><p>或以十六進位轉儲 (hex dump) 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> xxd .git/index     </span><br>00000000: 4449 5243 0000 0002 0000 0001 5e5b c791  DIRC........^[..<br>00000010: 2f0b 232a 5e5b c791 272f a8e0 0000 0804  /.#*^[..'/......<br>00000020: 00b8 0d4f 0000 81a4 0000 03e8 0000 03e8  ...O............<br>00000030: 0000 000b bbde f92a ef0f ecf8 2704 70a6  .......*....'.p.<br>00000040: 1fe8 952a 6afd 5b9a 000a 696e 6465 782e  ...*j.[...index.<br>00000050: 6874 6d6c 0000 0000 0000 0000 2841 2d21  html........(A-!<br>00000060: 1a87 5b13 6f52 9772 ca4c 73f3 b3cc 3308  ..[.oR.r.Ls...3.<br></code></pre></td></tr></table></figure><p>index 檔案包含以下資訊：</p><ul><li>12-byte header</li><li>多個排序的 index entries</li><li>Extensions，它們通過簽名 (signature) 來識別</li><li>此 checksum 和之前的 index 檔案內容的 160-bit SHA-1</li></ul><h3 id="Header"><a class="header-anchor" href="#Header"></a>Header</h3><p>index 以 12-byte 的 header 開頭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 4449 5243 0000 0002 0000 0001<br></code></pre></td></tr></table></figure><p>由代表 “DirCache” 的 4-btye 簽名 “DIRC” ( <code>0x44495243</code> ) 組成<br>4-byte 是 Git index 格式的當前版本號 “2” ( <code>0x00000002</code> )<br>32-bit 的 index entries “1” ( <code>0x00000001</code> )</p><h3 id="Index-Entry"><a class="header-anchor" href="#Index-Entry"></a>Index Entry</h3><p>在 <code>index.html</code> 此 index entry 中包括：</p><h4 id="64-bit-ctime"><a class="header-anchor" href="#64-bit-ctime"></a>64-bit ctime</h4><p>ctime 是 change time，也就是檔案的 metadata 在最後修改的時間</p><ul><li>前面 32-bit：ctime seconds</li><li>後面 32-bit：ctime nanosecond fractions</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 5e5b c791 2f0b 232a<br></code></pre></td></tr></table></figure><p>可用 <code>stat</code> 指令來取得 <code>index.html</code> 的最後修改時間：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">stat</span> -c <span class="hljs-string">'ctime: %z (%Z)'</span> index.html</span><br>ctime: 2020-03-01 22:32:49.789259050 +0800 (1583073169)<br></code></pre></td></tr></table></figure><p>然後用下面指令驗證：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">'%x'</span> 1583073169</span><br><span class="hljs-meta">5e5bc791%</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">'%x'</span> 789259050</span><br><span class="hljs-meta">2f0b232a%</span><br></code></pre></td></tr></table></figure><h4 id="64-bit-mtime"><a class="header-anchor" href="#64-bit-mtime"></a>64-bit mtime</h4><p>mtime 是 modify time，也就是檔案的資料在最後修改的時間</p><ul><li>前面 32-bit：mtime seconds</li><li>後面 32-bit：mtime nanosecond fractions</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 5e5b c791 272f a8e0<br></code></pre></td></tr></table></figure><p>可用 <code>stat</code> 指令來取得 <code>index.html</code> 的最後修改時間：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">stat</span> -c <span class="hljs-string">'mtime: %y (%Y)'</span> index.html</span><br>mtime: 2020-03-01 22:32:49.657434848 +0800 (1583073169)<br></code></pre></td></tr></table></figure><p>然後用下面指令驗證：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">'%x'</span> 1583073169</span><br><span class="hljs-meta">5e5bc791%</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">'%x'</span> 657434848</span><br><span class="hljs-meta">272fa8e0%</span><br></code></pre></td></tr></table></figure><h4 id="32-bit-dev"><a class="header-anchor" href="#32-bit-dev"></a>32-bit dev</h4><p>檔案所在的裝置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 0000 0804<br></code></pre></td></tr></table></figure><p>可用 <code>stat</code> 指令來取得 <code>index.html</code> 檔案所在的裝置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">stat</span> -c <span class="hljs-string">'%D'</span> index.html</span><br>804<br></code></pre></td></tr></table></figure><h4 id="32-bit-ino"><a class="header-anchor" href="#32-bit-ino"></a>32-bit ino</h4><p>檔案 inode number：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 00b8 0d4f<br></code></pre></td></tr></table></figure><p>可用 <code>stat</code> 指令來取得 <code>index.html</code> 檔案所在的裝置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">stat</span> -c <span class="hljs-string">'%i'</span> index.html</span><br>12062031<br></code></pre></td></tr></table></figure><p>然後用下面指令驗證：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">'%x'</span> 12062031</span><br><span class="hljs-meta">b80d4f%</span><br></code></pre></td></tr></table></figure><h4 id="32-bit-mode"><a class="header-anchor" href="#32-bit-mode"></a>32-bit mode</h4><p>檔案權限以十六進位表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 0000 81a4<br>bin: 00000000 00000000 10000001 10100100<br></code></pre></td></tr></table></figure><p>可用 <code>stat</code> 指令來取得 <code>index.html</code> 檔案的權限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">stat</span> -c <span class="hljs-string">'%f'</span> index.html</span><br>81a4<br></code></pre></td></tr></table></figure><h4 id="32-bit-uid"><a class="header-anchor" href="#32-bit-uid"></a>32-bit uid</h4><p>當前使用者的 user identifier</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 0000 03e8<br></code></pre></td></tr></table></figure><p>可用 <code>stat</code> 指令來取得 <code>index.html</code> 檔案的 uid：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">stat</span> -c <span class="hljs-string">'%u'</span> index.html</span><br>1000<br></code></pre></td></tr></table></figure><p>然後用下面指令驗證：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">'%x'</span> 1000</span><br><span class="hljs-meta">3e8%</span><br></code></pre></td></tr></table></figure><h4 id="32-bit-gid"><a class="header-anchor" href="#32-bit-gid"></a>32-bit gid</h4><p>當前使用者的 group identifier</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 0000 03e8<br></code></pre></td></tr></table></figure><p>可用 <code>stat</code> 指令來取得 <code>index.html</code> 檔案的 gid：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">stat</span> -c <span class="hljs-string">'%g'</span> index.html</span><br>1000<br></code></pre></td></tr></table></figure><p>然後用下面指令驗證：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">'%x'</span> 1000</span><br><span class="hljs-meta">3e8%</span><br></code></pre></td></tr></table></figure><h4 id="32-bit-file-size"><a class="header-anchor" href="#32-bit-file-size"></a>32-bit file size</h4><p>檔案大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 0000 000b<br></code></pre></td></tr></table></figure><p>可用 <code>stat</code> 指令來取得 <code>index.html</code> 檔案的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">stat</span> -c <span class="hljs-string">'%s'</span> index.html</span><br>11<br></code></pre></td></tr></table></figure><p>然後用下面指令驗證：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">'%x'</span> 11</span><br><span class="hljs-meta">b%</span><br></code></pre></td></tr></table></figure><h4 id="160-bit-SHA-1-Object-ID"><a class="header-anchor" href="#160-bit-SHA-1-Object-ID"></a>160-bit SHA-1 Object ID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: bbde f92a ef0f ecf8 2704<br>     70a6 1fe8 952a 6afd 5b9a<br></code></pre></td></tr></table></figure><p>可用 <code>git hash-object</code> 指令來取得 <code>index.html</code> 檔案的 blob 物件 ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">hash</span>-object index.html</span><br>bbdef92aef0fecf8270470a61fe8952a6afd5b9a<br></code></pre></td></tr></table></figure><h4 id="16-bit-‘flags’-field"><a class="header-anchor" href="#16-bit-‘flags’-field"></a>16-bit ‘flags’ field</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 000a<br></code></pre></td></tr></table></figure><p>分為：</p><ul><li>1-bit：assume-valid flag</li><li>1-bit：extended flag (在版本 2 中必須為零)</li><li>2-bit：stage (合併期間)</li><li>如果 length 小於 0xFFF，則為 12-bit name length；否則，將 0xFFF 儲存在此 field 中</li></ul><h4 id="16-bit-field"><a class="header-anchor" href="#16-bit-field"></a>16-bit field</h4><p>(版本 3 或更新版) 當前面的 16-bit field 的 “extended flag” 為 1 時適用</p><ul><li>1-bit：為未來保留</li><li>1-bit：skip-worktree flag (用於 sparse checkout)</li><li>1-bit：intent-to-add flag (用於 <code>git add -N</code> )</li><li>13-bit：未使用，必須為零</li></ul><p>忽略此部份，因為我目前使用的 Git 的版本為 2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git --version</span><br>git version 2.17.1<br></code></pre></td></tr></table></figure><h4 id="檔案路徑"><a class="header-anchor" href="#檔案路徑"></a>檔案路徑</h4><ul><li>相對於 top level 目錄 (不包含斜線) 的 entry 路徑名稱 (可變長度)</li><li><code>/</code> 作為路徑分隔字元</li><li>不允許使用特殊路徑元件 <code>.</code>、<code>..</code> 和 <code>.git</code></li><li>不允許使用斜線</li><li>確切的編碼不確定，但 <code>.</code> 和 <code>/</code> 字元會以 7-bit ASCII 編碼，並且編碼不能包含 NUL byte (UNIX 路徑名稱)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 696e 6465 782e 6874 6d6c<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">printf</span> <span class="hljs-string">'index.html'</span> | xxd</span><br>00000000: 696e 6465 782e 6874 6d6c                 index.html<br></code></pre></td></tr></table></figure><h4 id="1-8-NUL-byte"><a class="header-anchor" href="#1-8-NUL-byte"></a>1-8 NUL byte</h4><p>使用 1-8 NUL byte 將 entry 填充為 8 byte 的倍數，同時保持名稱 NUL-terminated</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 0000 0000 0000 0000<br></code></pre></td></tr></table></figure><h3 id="Extensions"><a class="header-anchor" href="#Extensions"></a>Extensions</h3><p>忽略此部份，因本範例的 index 無 extensions。</p><h3 id="SHA-1-Index-Checksum"><a class="header-anchor" href="#SHA-1-Index-Checksum"></a>SHA-1 Index Checksum</h3><p>在 index 檔案內容的最後 160-bit 是 index checksum，是由這 160-bit 之前的 index 檔案內容透過 SHA-1 計算的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">hex: 2841 2d21 1a87 5b13 6f52<br>     9772 ca4c 73f3 b3cc 3308<br></code></pre></td></tr></table></figure><p>用下面指令驗證：</p><ul><li><code>head -c</code>：列印檔案的前幾個 byte</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/index | head -c92 | sha1sum </span><br>28412d211a875b136f529772ca4c73f3b3cc3308  -<br></code></pre></td></tr></table></figure><p>如果 index 損壞，就能透過此 SHA-1 Index Checksum 來確認，並會說明 index 檔案已損壞：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>error: bad index file sha1 signature<br>fatal: index file corrupt<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – 第五章、Linux 的檔案權限與目錄配置</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://stackoverflow.com/questions/737673/how-to-read-the-mode-field-of-git-ls-trees-output" target="_blank" rel="noopener">file permissions - How to read the mode field of git-ls-tree’s output - Stack Overflow</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/09.md" target="_blank" rel="noopener">30 天精通 Git 版本控管 第 09 天：比對檔案與版本差異 by 保哥</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://github.com/git/git/blob/master/Documentation/technical/index-format.txt#L63" target="_blank" rel="noopener">git/index-format.txt at master · git/git</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;git add&lt;/code&gt; 會將檔案加入 index，究竟 index 到底存在哪？其實，通常會放在 &lt;code&gt;.git/index&lt;/code&gt;，本篇將深入探討此檔案式如何紀錄有哪些檔案被加入 index。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>深入 Git：Git 物件儲存 - tree 物件</title>
    <link href="https://titangene.github.io/article/git-tree-object.html"/>
    <id>https://titangene.github.io/article/git-tree-object.html</id>
    <published>2020-03-01T15:58:39.000Z</published>
    <updated>2020-03-01T15:57:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>本篇將深入探討 Git 如何運作，Git 是如何建立和儲存 tree 物件。</p><a id="more"></a><p>之前講到 blob 物件是由檔案內容來產生的，那 Git 是如何知道這些檔案內容是分別存在哪個目錄內的檔案名稱中？</p><p>目錄名稱和檔案名稱就是由 tree 物件來管理。一個 tree 物件可以紀錄包含哪些 blob 物件 (也就是檔案內容)，以及該 blob 物件對應的檔案名稱，以及其他 tree 物件和其對應的目錄名稱。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -p</span><br></code></pre></td></tr></table></figure><p>Git 儲存內容的方式類似 Unix 檔案系統，所有內容在 Git 都儲存成 tree 物件和 blob 物件，tree 物件對應於 Unix directory entries (目錄項目)，而 blob 物件是對應 inode (記錄檔案的權限與相關屬性) <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 或檔案內容 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p><p>每個 tree 物件可包含一個或多個 tree entries，每個 tree entry 都包含一個指向 blob 物件或 subtree 的 SHA-1 指標 (hash 值) 以及關聯模式 (associated mode)、物件類型、檔名。例如：</p><p>先建立一個 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span><br>Initialized empty Git repository in /home/titan/project/demo/.git/<br><br><span class="hljs-meta">$</span><span class="bash"> mkdir styles</span><br><span class="hljs-meta">$</span><span class="bash"> touch index.html README.md styles/main.css</span><br><span class="hljs-meta">$</span><span class="bash"> git add .</span><br><span class="hljs-meta">$</span><span class="bash"> tree .git/objects</span><br>.git/objects<br>├── e6<br>│   └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391<br>├── info<br>└── pack<br><br>3 directories, 1 file<br><br><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">"init"</span>   </span><br>[master (root-commit) 158f5a2] init<br> 3 files changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 README.md<br> create mode 100644 index.html<br> create mode 100644 styles/main.css<br></code></pre></td></tr></table></figure><p><code>master^{tree}</code> 代表由 <code>master</code> 分支上的最後一次 commit 所指向的 tree 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree</span><br>.<br>├── index.html<br>├── README.md<br>└── styles<br>    └── main.css<br><br>1 directory, 3 files<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p master^&#123;tree&#125;</span><br>100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391README.md<br>100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391index.html<br>040000 tree c6d62294a2323c2047b43787d55a44ff8c94f565styles<br></code></pre></td></tr></table></figure><p><code>styles</code> 子目錄是指向另一個名為 <code>c6d622</code> 的 tree 物件，而這個 tree 物件又指向另一個名為 <code>e69de2</code> 的 blob 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -p c6d622</span><br>100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391main.css<br></code></pre></td></tr></table></figure><h2 id="建立-index"><a class="header-anchor" href="#建立-index"></a>建立 index</h2><p>初始化 Git repo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span><br>Initialized empty Git repository in /home/titan/project/git/pro-git/.git/<br><span class="hljs-meta">$</span><span class="bash"> tree .git        </span><br>.git<br>├── branches<br>├── config<br>├── description<br>├── HEAD<br>├── hooks<br>│   └── ...<br>├── info<br>│   └── exclude<br>├── objects<br>│   ├── info<br>│   └── pack<br>└── refs<br>    ├── heads<br>    └── tags<br><br>9 directories, 15 files<br></code></pre></td></tr></table></figure><p>建立專案需要的檔案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir styles</span><br><span class="hljs-meta">$</span><span class="bash"> touch index.html README.md styles/main.css</span><br><span class="hljs-meta">$</span><span class="bash"> tree</span><br>.<br>├── index.html<br>├── README.md<br>└── styles<br>    └── main.css<br><br>1 directory, 3 files<br></code></pre></td></tr></table></figure><p>現在 Git 還未追蹤這些檔案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status                      </span><br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use "git add &lt;file&gt;..." to include in what will be committed)<br><br>README.md<br>index.html<br>styles/<br><br>nothing added to commit but untracked files present (use "git add" to track)<br></code></pre></td></tr></table></figure><p>建立 blob 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">hash</span>-object -w index.html</span><br>9015a7a32ca0681be64471d3ac2f8c1f24c1040d<br><span class="hljs-meta">$</span><span class="bash"> tree .git/objects            </span><br>.git/objects<br>├── 90<br>│   └── 15a7a32ca0681be64471d3ac2f8c1f24c1040d<br>├── info<br>└── pack<br><br>3 directories, 1 file<br></code></pre></td></tr></table></figure><p>在將 commit 之前，Git 會根據 staging area (預存區或稱暫存區) 或 index 來建立 tree 物件，所以必須在建立 tree 物件之前，先暫存物件來建立 index。</p><p>使用 <code>update-index</code> 底層指令來為單一檔案建立 index。</p><p>因為 index 之前沒有該檔案，甚至連 index 都還沒建立 (也就是沒有 <code>.git/index</code> 檔案)，所以必須加上 <code>--add</code> 選項。另外，因為要增加的檔案還不在工作目錄中，而是在資料庫 (也就是 <code>.git/object</code> 目錄內) 中，所以需要加上 <code>--cacheinfo</code> 選項，<code>--cacheinfo</code> 選項後面必須指定相關 mode、物件 SHA-1 值、檔名。</p><div class="info"><p><code>git update-index</code> 指令：將 working tree 中的檔案內容註冊至 index</p><ul><li><code>--add</code>：<ul><li>如果指定的檔案不在 index 中，就會新增該檔案至 index</li><li>預設行為 (也就是不加上 <code>--add</code> 選項時) 會忽略新檔案</li></ul></li><li><code>--cacheinfo &lt;mode&gt; &lt;object&gt; &lt;path&gt;</code> 或 <code>--cacheinfo &lt;mode&gt;,&lt;object&gt;,&lt;path&gt;</code>：<ul><li>將指定的資訊直接插入 index</li><li>用於註冊不在當前工作目錄中的檔案。對於最小 checkout 合併很有用</li><li>為了向後相容，還可將這三個參數作為三個單獨的參數提供，但是鼓勵新的使用者使用單一參數形式</li></ul></li></ul></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git update-index --add --cacheinfo \</span><br>    100644 9015a7a32ca0681be64471d3ac2f8c1f24c1040d index.html<br><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use "git rm --cached &lt;file&gt;..." to unstage)<br><br>new file:   index.html<br><br>Untracked files:<br>  (use "git add &lt;file&gt;..." to include in what will be committed)<br><br>README.md<br>styles/<br></code></pre></td></tr></table></figure><p>這邊指定的 <code>100644</code> 是 mode，代表是個普通的檔案。這類似 Unix 的檔案屬性 <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，用來表示該檔案的類型 (檔案、目錄、link) 和權限 (可讀、可寫、可執行)，以下是常見的 (用二進位和八進位表示) <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>：</p><ul><li><code>0100000000000000</code> ( <code>040000</code> )：Directory</li><li><code>1000000110100100</code> ( <code>100644</code> )：Regular non-executable file</li><li><code>1000000110110100</code> ( <code>100664</code> )：Regular non-executable group-writeable file</li><li><code>1000000111101101</code> ( <code>100755</code> )：Regular executable file</li><li><code>1010000000000000</code> ( <code>120000</code> )：Symbolic link</li><li><code>1110000000000000</code> ( <code>160000</code> )：Gitlink</li></ul><div class="info"><p>註：<code>.git/index</code> 的二進位表示法 <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p><ul><li>前 4-bit：物件 type<ul><li><code>1000</code>：regular file</li><li><code>1010</code>：symbolic link</li><li><code>1110</code>：gitlink</li></ul></li><li>中間 3-bit：沒有使用</li><li>後面 9-bit：unix 權限<ul><li>regular file 只能用 <code>0755</code> 和 <code>0644</code></li><li>symbolic link 和 gitlink 在此 field 中的值為 <code>0</code></li></ul></li></ul><p>blob 物件只對 <code>100644</code>、<code>100664</code> 和 <code>100755</code> 這三種 mode 有效。</p></div><p>接著使用 <code>write-tree</code> 指令將 index 寫至 tree 物件中。不需要使用 <code>-w</code> 選項，如果該 tree 物件還不存在，則呼叫 <code>write-tree</code> 會根據 index 的狀態自動建立 tree 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git write-tree</span><br>2dce93ea08ed9059be0a838c6bcf62b7b5c28907<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 2dce93</span><br>100644 blob 9015a7a32ca0681be64471d3ac2f8c1f24c1040dindex.html<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 2dce93</span><br>tree<br></code></pre></td></tr></table></figure><p>如果使用 <code>index.html</code> 的第二版和一個新檔案來建立新的 tree 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'text'</span> &gt;&gt; index.html</span><br><span class="hljs-meta">$</span><span class="bash"> cat index.html </span><br>index<br>text<br><span class="hljs-meta">$</span><span class="bash"> git update-index index.html</span><br><span class="hljs-meta">$</span><span class="bash"> git update-index --add README.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status                           </span><br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use "git rm --cached &lt;file&gt;..." to unstage)<br><br>new file:   README.md<br>new file:   index.html<br><br>Untracked files:<br>  (use "git add &lt;file&gt;..." to include in what will be committed)<br><br>styles/<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/objects      </span><br>.git/objects<br>├── 2d<br>│   └── ce93ea08ed9059be0a838c6bcf62b7b5c28907<br>├── 70<br>│   └── f702d2c1492a9989a64c8e68bedf7c81052898<br>├── 7e<br>│   └── 59600739c96546163833214c36459e324bad0a<br>├── 90<br>│   └── 15a7a32ca0681be64471d3ac2f8c1f24c1040d<br>├── info<br>└── pack<br><br>6 directories, 4 files<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 70f702          </span><br>index<br>text<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 7e5960</span><br><span class="hljs-meta">#</span><span class="bash"> README</span><br></code></pre></td></tr></table></figure><p>建立 tree 物件 (將 staging area 的狀態或 index 紀錄到一個 tree 物件)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git write-tree</span><br>436d33ce00a9bbf0a1ce763b2c36330b6faf309b<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 436d33      </span><br>100644 blob 7e59600739c96546163833214c36459e324bad0aREADME.md<br>100644 blob 70f702d2c1492a9989a64c8e68bedf7c81052898index.html<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://linux.vbird.org/linux_basic/0230filesystem.php" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – 第七章、Linux 磁碟與檔案系統管理</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Git-Objects" target="_blank" rel="noopener">Git - Git Objects</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="http://linux.vbird.org/linux_basic/0210filepermission.php#filepermission_perm" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – 第五章、Linux 的檔案權限與目錄配置</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://stackoverflow.com/questions/737673/how-to-read-the-mode-field-of-git-ls-trees-output" target="_blank" rel="noopener">file permissions - How to read the mode field of git-ls-tree’s output - Stack Overflow</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/09.md" target="_blank" rel="noopener">30 天精通 Git 版本控管 第 09 天：比對檔案與版本差異 by 保哥</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p><a href="https://github.com/git/git/blob/master/Documentation/technical/index-format.txt#L63" target="_blank" rel="noopener">git/index-format.txt at master · git/git</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇將深入探討 Git 如何運作，Git 是如何建立和儲存 tree 物件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>處理 Git 斷行字元的問題</title>
    <link href="https://titangene.github.io/article/git-auto-crlf.html"/>
    <id>https://titangene.github.io/article/git-auto-crlf.html</id>
    <published>2020-02-23T15:42:23.000Z</published>
    <updated>2020-04-26T11:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>在使用 Git 的過程中，若在不同作業系統編輯同一個 repo 的檔案，可能就會發生斷行字元的問題。Git 在 config 提供了 <code>core.autocrlf</code> 選項並用 <code>.gitAttributes</code> 檔案來處理斷行字元的問題。</p><a id="more"></a><p>之前我在 Windows 建立一個專案，是用來專門放用 Markdown 檔案的筆記，而且是用 Git 來作版本控制。但最近我在這台筆電安裝完雙系統 (Windows 10 和 Ubuntu 18.04) 後，有時候會在 Ubuntu 開發並將過程寫成筆記，所以這個筆記專案就會需要在不同 OS 下編輯。</p><p>也因為以上需求讓我多學習到不同系統其實預設使用的文字檔案的斷行字元是不同的，Windows 是使用 CRLF ( <code>\r\n</code>，<code>0x0D 0x0A</code> )，而 Linux 則是使用 LF 字元 ( <code>\n</code>，<code>0x0A</code> )。也因如此，Windows 上的每個檔案的每一行結尾都會比 Liunx 還要多一個字元，也就是多了很多 CR ( <code>\r</code> ) 字元。</p><div class="info"><p>註：</p><ul><li>CR 是 Carriage Return 的意思，也就是 Enter 字元</li><li>LF 是 Line Feed 的意思，也就是真正的換行字元</li><li>macOS 的斷行字元也是 LF 字元 ( <code>\n</code>，<code>0x0A</code> )</li></ul></div><p>那為何會提到斷行字元？因為當我執行 <code>git status</code> 指令後，發現竟然檔案有被修改過，但我除了切換 OS 之外，根本沒有修改筆記啊！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Your branch is up to date with 'origin/master'.<br><br>Changes not staged for commit:<br>  (use "git add &lt;file&gt;..." to update what will be committed)<br>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)<br><br>        modified:   note.md<br><br>no changes added to commit (use "git add" and/or "git commit -a")<br></code></pre></td></tr></table></figure><p>其實這跟剛剛提到的斷行字元有關。如果用 <code>git diff</code> 指令就會看到筆記內的每行文字的結尾都多出了 <code>^M</code> 這個東西，而且有些編輯器 (例如：VS Code) 可能會看不出來：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs diff">$ git diff note.md<br>diff --git a/note.md b/note.md<br>index e27815a..6b5682e 100644<br><span class="hljs-comment">--- a/note.md</span><br><span class="hljs-comment">+++ b/note.md</span><br><span class="hljs-meta">@@ -1,5 +1,5 @@</span><br><span class="hljs-deletion">-Note</span><br><span class="hljs-deletion">-===</span><br><span class="hljs-deletion">-</span><br><span class="hljs-deletion">-something</span><br><span class="hljs-addition">+Note^M</span><br><span class="hljs-addition">+===^M</span><br><span class="hljs-addition">+^M</span><br><span class="hljs-addition">+something^M</span><br> This is the last line<br>\ No newline at end of file<br></code></pre></td></tr></table></figure><p>其實 <code>^M</code> 恰好是 vim 用來顯示 <code>0x0D</code> 的方式，而 <code>0x0D</code> 就是剛剛提到 Windows 檔案內的每一行結尾，都會比 Linux 多出 CR ( <code>\r</code> ) 這個字元。所以 <code>^M</code> 其實就等同於 CR ( <code>\r</code>，<code>0x0D</code> )。</p><div class="info"><p>註：</p><ul><li><code>^M</code> 其中的 <code>^</code> 代表 Ctrl，所以 <code>^M</code> 也就代表 <code>Ctrl + M</code> (也就是 Enter)</li><li><code>^M</code> 雖然看是兩個字元，但在終端機上實際只有一個字元。在大部分的終端機系統中，包括 Windows 的 cmd、Linux 和 FreeBSD 都可用 Ctrl 來表示 <code>^</code> 字元 (caret)</li><li><code>0x0D</code> 是以十六進位表示的 13，而 M 正好是英文字母中第 13 個字母</li></ul></div><p>不過，如果有多個檔案的每一行都要刪掉 <code>^M</code> 就會很麻煩，所以 Git 提供一種自動轉換斷行符號的功能：<code>core.autocrlf</code>。</p><p>那 Git 的自動轉換斷行符號功能到底做了什麼？</p><ul><li>當你執行 <code>git add</code> 將檔案加入 index 時，Git 可將 CRLF 自動傳成 LF。</li><li>當你執行 <code>git checkout</code> 將程式碼 checkout 出檔案系統時，Git 可將 LF 自動轉成 CRLF。</li></ul><p>如果要在全域設定可執行下面指令來設定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global core.autocrlf <span class="hljs-literal">true</span></span><br></code></pre></td></tr></table></figure><p>如果是要在各別的 repo 設定，就需要在 repo 的根目錄下建立一個名為 <code>.gitattributes</code> 的檔案，當這個檔案被 commit 至 repo 時，就會覆蓋 <code>core.autocrlf</code> 的設定，以確保管理此 repo 的協作者的設定一致。下面是 <code>.gitattributes</code> 這個檔案的範例模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain"># Set the default behavior, in case people don&#39;t have core.autocrlf set.<br>* text&#x3D;auto<br><br># Explicitly declare text files you want to always be normalized and converted<br># to native line endings on checkout.<br>*.c text<br>*.h text<br><br># Declare files that will always have CRLF line endings on checkout.<br>*.sln text eol&#x3D;crlf<br><br># Denote all files that are truly binary and should not be modified.<br>*.png binary<br>*.jpg binary<br></code></pre></td></tr></table></figure><p>此檔案的設定格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">pattern attr1 attr2 ...<br></code></pre></td></tr></table></figure><p><code>pattern</code> 和屬性的中間要以空格分隔。當 <code>pattern</code> 匹配相關路徑時，後面的屬性的設定會應用在那些路徑。</p><p><code>text</code> 這個屬性是用於啟用並控制行尾的正規化。正規化文字檔後，行尾會在 repo 中轉換為 LF。如果要控制工作目錄中使用的行尾樣式，請針對該檔案設定 <code>eol</code> 屬性 ( <code>eol</code> 就 end-of-line 的縮寫)，並且對所有文字檔設定 <code>core.eol</code> 變數。如果將 <code>core.autocrlf</code> 設為 <code>true</code> 或 <code>input</code> 會覆蓋 <code>core.eol</code> 的設定。</p><blockquote><p>詳情可參考 <a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener">Git - git-config Documentation</a> 文件中對於 <code>core.eol</code> 設定的定義。</p></blockquote><p><code>text=auto</code>：路徑被標記為自動轉換行尾。如果 Git 確定該內容為文字，那該檔案的行尾就會在 checkin 時轉換成 LF。當用 CRLF commit 檔案時，則不會進行轉換。</p><p>資料來源：</p><ul><li><a href="https://help.github.com/en/articles/configuring-git-to-handle-line-endings" target="_blank" rel="noopener">Configuring Git to handle line endings - GitHub Help</a></li><li><a href="https://blog.miniasp.com/post/2013/09/15/Git-for-Windows-Line-Ending-Conversion-Notes" target="_blank" rel="noopener">Git 在 Windows 平台處理斷行字元 (CRLF) 的注意事項 | The Will Will Web</a></li><li><a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII - Wiki</a></li><li><a href="https://stackoverflow.com/questions/5843495/what-does-m-character-mean-in-vim" target="_blank" rel="noopener">unix - What does ^M character mean in Vim? - Stack Overflow</a></li><li><a href="https://git-scm.com/docs/gitattributes" target="_blank" rel="noopener">Git - gitattributes Documentation</a></li><li><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes" target="_blank" rel="noopener">Git - Git Attributes</a></li><li><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration" target="_blank" rel="noopener">Git - Git Configuration</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;在使用 Git 的過程中，若在不同作業系統編輯同一個 repo 的檔案，可能就會發生斷行字元的問題。Git 在 config 提供了 &lt;code&gt;core.autocrlf&lt;/code&gt; 選項並用 &lt;code&gt;.gitAttributes&lt;/code&gt; 檔案來處理斷行字元的問題。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>深入 Git：Git 物件儲存 - blob 物件</title>
    <link href="https://titangene.github.io/article/git--blob-object.html"/>
    <id>https://titangene.github.io/article/git--blob-object.html</id>
    <published>2020-02-16T15:56:20.000Z</published>
    <updated>2020-03-16T03:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>本篇將深入探討 Git 如何運作，在執行 <code>git add</code> 將檔案加入 index 時，Git 會如何建立和儲存 blob 物件。</p><a id="more"></a><p>Git 是一個 content-addressable (按內容定址，按檔案內容定位) 的檔案系統，這代表 Git 的核心是一個 key-value data store (資料儲存) <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。我們只要提供檔案內容，Git 就會透過一些演算法計算成 key，未來就可透過該 key 來檢索出對應的內容。</p><p>Git 有四種 type (類型) 的物件：blob、tree、commit 和 tag。</p><p>下面會使用 <code>git hash-object</code> 這個底層指令來介紹物件名稱是如何產生的。</p><h2 id="手動建立-blob-物件"><a class="header-anchor" href="#手動建立-blob-物件"></a>手動建立 blob 物件</h2><p>首先，先執行 <code>git init</code> 初始化 repo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span><br>Initialized empty Git repository in /home/titan/project/git-demo/.git/<br></code></pre></td></tr></table></figure><p>初始化新的 repo 時，Git 會在 <code>.git</code> 目錄中初始化 <code>objects</code> 目錄，並在裡面建立 <code>pack</code> 和 <code>info</code> 子層的空目錄：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/objects</span><br>.git/objects<br>├── info<br>└── pack<br></code></pre></td></tr></table></figure><p>使用底層指令 <code>hash-object</code> 將資料儲存至 <code>.git</code> 目錄中，並獲得對應的 key (也就是物件名稱，或稱 SHA-1 值)。下面是 <code>hash-object</code> 的 option：</p><ul><li><code>-w</code>：<ul><li>將物件寫入至物件資料庫 (也就是 <code>.git/objects</code> 目錄內)，並輸出該物件的 key (也就是 SHA-1 checksum)</li><li>若不用此 option，就只會輸出 key，不會儲存物件</li></ul></li><li><code>--stdin</code>：<ul><li>從 stdin (standard input，標準輸入) 讀取內容</li><li>若不用此 option，<code>hash-object</code> 指令預設會從檔案中讀取，所以必須在 <code>hash-object</code> 指令之後加上指定的檔案路徑<ul><li>例如：<code>git hash-object README.md</code></li></ul></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'test content'</span> | git <span class="hljs-built_in">hash</span>-object -w --stdin</span><br>d670460b4b4aece5915caf5c68d12f560a9fe3e4<br></code></pre></td></tr></table></figure><p><code>hash-object</code> 指令會輸出 40 個字元的 checksum hash，這是個 SHA-1 hash (後面會介紹 <a href="#SHA-1">SHA-1</a>)，是由儲存的內容和 header 資訊所計算出來的 checksum。</p><p>在 Git 的儲存方式是一份內容就存成一個檔案，都放在 <code>.git/objects</code> 目錄內，子目錄為 SHA-1 的前 2 個字元，檔名為剩餘的 38 個字元。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/objects</span><br>.git/objects<br>├── d6<br>│   └── 70460b4b4aece5915caf5c68d12f560a9fe3e4<br>├── info<br>└── pack<br></code></pre></td></tr></table></figure><h2 id="使用-cat-file-指令察看物件資訊"><a class="header-anchor" href="#使用-cat-file-指令察看物件資訊"></a>使用 <code>cat-file</code> 指令察看物件資訊</h2><p>使用 <code>cat-file</code> 指令取得物件的內容，可用於檢查物件。使用 <code>-p</code> option 找出內容的 type 並輸出該內容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -p d67046</span><br>test content<br></code></pre></td></tr></table></figure><p>使用 <code>-t</code> option 可獲得該物件的 type：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t d67046</span><br>blob<br></code></pre></td></tr></table></figure><p>剛剛建立的 <code>d67046</code> 就是 Git 的 blob 物件。</p><h2 id="變更檔案內容後再次建立-blob-物件"><a class="header-anchor" href="#變更檔案內容後再次建立-blob-物件"></a>變更檔案內容後再次建立 blob 物件</h2><p>那如果變更檔案內容後，再建立 blob 物件又會如何？看下面範例：</p><p>先建立一個全新的專案，並使用 <code>git init</code> 初始化 Git repo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir git-demo-2</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> git-demo-2</span><br><span class="hljs-meta">$</span><span class="bash"> git init</span><br>Initialized empty Git repository in /home/titan/project/git-demo-2/.git/<br></code></pre></td></tr></table></figure><p>接著建立一個名為 <code>test.txt</code> 的檔案，內容為 <code>v1</code>，使用 <code>git hash-object</code> 建立的 blob 物件為 <code>626799</code>，後來將內容修改為 <code>v2</code>，再次建立的 blob 物件為 <code>8c1384</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'v1'</span> &gt; test.txt</span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">hash</span>-object -w test.txt</span><br>626799f0f85326a8c1fc522db584e86cdfccd51f<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 626799</span><br>blob<br><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'v2'</span> &gt; test.txt</span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">hash</span>-object -w test.txt</span><br>8c1384d825dbbe41309b7dc18ee7991a9085c46e<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 8c1384</span><br>blob<br></code></pre></td></tr></table></figure><p>可以看到當檔案內容不同時，就可以產生不同的 blob 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/objects</span><br>.git/objects<br>├── 62<br>│   └── 6799f0f85326a8c1fc522db584e86cdfccd51f<br>├── 8c<br>│   └── 1384d825dbbe41309b7dc18ee7991a9085c46e<br>├── info<br>└── pack<br></code></pre></td></tr></table></figure><h2 id="建立內容相同，但檔名不同的檔案"><a class="header-anchor" href="#建立內容相同，但檔名不同的檔案"></a>建立內容相同，但檔名不同的檔案</h2><p>當你建立檔案內容相同，但檔名不同的檔案時，在 repo 內也只會存一份，因為物件的名稱是由檔案內容來決定的，而不是依檔名決定。</p><p>不過，<code>git hash-object</code> 指令還是會重新產生同一個 blob 物件 (因為該物件的檔案時間被更新了)。範例如下：</p><p>在建立 <code>other-test.txt</code> 檔案之前，<code>.git/objects/8c/6799f...</code> 的檔案時間是 <code>23:38</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/objects</span><br>.git/objects<br>├── 62<br>│   └── 6799f0f85326a8c1fc522db584e86cdfccd51f<br>├── 8c<br>│   └── 1384d825dbbe41309b7dc18ee7991a9085c46e<br>├── info<br>└── pack<br><br><span class="hljs-meta">$</span><span class="bash"> ls -lR .git/objects</span><br>.git/objects:<br>總計 16<br>drwxr-xr-x 2 titan titan 4096  2月 16 23:39 62<br>drwxr-xr-x 2 titan titan 4096  2月 16 23:40 8c<br>drwxr-xr-x 2 titan titan 4096  2月 16 23:39 info<br>drwxr-xr-x 2 titan titan 4096  2月 16 23:39 pack<br><br>.git/objects/62:<br>總計 4<br>-r--r--r-- 1 titan titan 18  2月 16 23:38 6799f0f85326a8c1fc522db584e86cdfccd51f<br><br>.git/objects/8c:<br>總計 4<br>-r--r--r-- 1 titan titan 18  2月 16 23:39 1384d825dbbe41309b7dc18ee7991a9085c46e<br><br>...<br></code></pre></td></tr></table></figure><p>在建立 <code>other-test.txt</code> 檔案之後，<code>.git/objects/8c/6799f...</code> 的檔案時間變成 <code>23:40</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">'v2'</span> &gt; other-test.txt</span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">hash</span>-object -w other-test.txt</span><br>8c1384d825dbbe41309b7dc18ee7991a9085c46e<br><br><span class="hljs-meta">$</span><span class="bash"> tree .git/objects</span><br>.git/objects<br>├── 62<br>│   └── 6799f0f85326a8c1fc522db584e86cdfccd51f<br>├── 8c<br>│   └── 1384d825dbbe41309b7dc18ee7991a9085c46e<br>├── info<br>└── pack<br><br><span class="hljs-meta">$</span><span class="bash"> ls -lR .git/objects</span><br>.git/objects:<br>總計 16<br>drwxr-xr-x 2 titan titan 4096  2月 16 23:39 62<br>drwxr-xr-x 2 titan titan 4096  2月 16 23:40 8c<br>drwxr-xr-x 2 titan titan 4096  2月 16 23:39 info<br>drwxr-xr-x 2 titan titan 4096  2月 16 23:39 pack<br><br>.git/objects/62:<br>總計 4<br>-r--r--r-- 1 titan titan 18  2月 16 23:40 6799f0f85326a8c1fc522db584e86cdfccd51f<br><br>.git/objects/8c:<br>總計 4<br>-r--r--r-- 1 titan titan 18  2月 16 23:39 1384d825dbbe41309b7dc18ee7991a9085c46e<br><br>...<br></code></pre></td></tr></table></figure><h2 id="hash-object-計算物件名稱的演算法"><a class="header-anchor" href="#hash-object-計算物件名稱的演算法"></a><code>hash-object</code> 計算物件名稱的演算法</h2><p>那 Git 的物件名稱 (也就是 SHA-1) 是如何計算的？不同的 Git 物件有不同的計算方式，這邊先說明 blob 物件的部份。</p><p>Git 物件都是使用 <a href="https://www.zlib.net/" target="_blank" rel="noopener">zlib</a> 壓縮，物件名稱的 SHA-1 hash 值就是 header 加上檔案內容，演算法如下 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;type&gt; &lt;content_length&gt;\0&lt;content&gt;<br></code></pre></td></tr></table></figure><p>前面的 <code>&lt;type&gt; &lt;content_length&gt;\0</code> 代表 header，而 <code>&lt;content&gt;</code> 代表檔案內容。下面舉個例子：</p><p>建立名為 <code>hello.txt</code> 的檔案，檔案內容為 <code>hello</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> &gt; hello.txt</span><br></code></pre></td></tr></table></figure><p>使用 <code>cat</code> 指令並加上 <code>-A</code> 選項察看檔案內容：</p><ul><li><code>-A</code>：相當於 <code>-vET</code> 整合選項</li><li><code>-E</code>：將結尾的斷行字元以 <code>$</code> 顯示</li><li><code>-T</code>：將 TAB 字元以 <code>^I</code> 顯示</li><li><code>-v</code>：除了換行及 TAB 字元外，使用 <code>^</code> 及 <code>M-</code> 表示法顯示字元 (列出一些看不出來的特殊字元)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat -A hello.txt</span><br><span class="hljs-meta">hello%</span><br></code></pre></td></tr></table></figure><p>檔案內容的結尾 <code>%</code> 代表 LF (line Feed，<code>\n</code> )，我是在 Linux 建立 <code>hello.txt</code> 此檔案的，而 Linux 的換行字元是使用 LF 字元，所以在每一行的結尾才會多了 LF 這個字元。</p><p>所以依照上面建立物件名稱的演算法就會像這樣，下面分別代表：</p><ul><li><code>blob</code>：要建立的物件是 blob 物件</li><li><code>6</code>：檔案內容長度</li><li><code>\0</code>：Null 結束字元</li><li><code>hello\n</code>：檔案內容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">blob 6\0hello\n<br></code></pre></td></tr></table></figure><p>所以如果使用以下指令就能算出此 blob 物件的 SHA-1 hash 值：</p><ul><li><code>echo</code> 的 <code>-n</code> 選項：不輸出結尾的換行字元 (trailing newline)</li><li><code>sha1sum</code>：計算 SHA-1 值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"blob 6\0hello\n"</span> | sha1sum </span><br>ce013625030ba8dba906f756967f9e9ca394464a<br></code></pre></td></tr></table></figure><h2 id="實作-Git-物件名稱演算法"><a class="header-anchor" href="#實作-Git-物件名稱演算法"></a>實作 Git 物件名稱演算法</h2><p>如果用 Python 實作此演算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> zlib<br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> sha1<br><br>content = <span class="hljs-string">'hello\n'</span><br>header = <span class="hljs-string">'blob &#123;&#125;\0'</span>.format(len(content))<br>store = header + content<br>hash = sha1(store.encode(<span class="hljs-string">'utf-8'</span>)).hexdigest()<br><br>zlib_content = zlib.compress(store.encode(<span class="hljs-string">'utf-8'</span>))<br><br>path = <span class="hljs-string">'.git/objects/&#123;&#125;/&#123;&#125;'</span>.format(hash[:<span class="hljs-number">2</span>], hash[<span class="hljs-number">2</span>:])<br>os.makedirs(os.path.dirname(path), exist_ok=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">with</span> open(path, <span class="hljs-string">'wb+'</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(zlib_content)<br></code></pre></td></tr></table></figure><p>驗證剛剛實作的 blob 物件是否有效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -p ce0136</span><br>hello<br></code></pre></td></tr></table></figure><p>看到檔案內容就代表實作成功 😃。</p><h2 id="驗證-Git-物件"><a class="header-anchor" href="#驗證-Git-物件"></a>驗證 Git 物件</h2><p>Git 物件名稱可以用來檢查物件的 type 和物件內容是否一致，如果 Git 物件的檔案名稱或內容被惡意修改，就可以很容易的發現有錯誤。</p><p>Git 可用 <code>git fsck</code> 指令來如何驗證資料庫中的物件是否有效，如果驗證成功就會像這樣輸出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git fsck</span><br>Checking object directories: 100% (256/256), done.<br></code></pre></td></tr></table></figure><p>假設我惡意修改剛剛建立的 blob 物件，使用 <code>git fsck</code> 指令就會告知該物件有問題：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim .git/objects/ce/013625030ba8dba906f756967f9e9ca394464a</span><br><span class="hljs-meta">$</span><span class="bash"> git fsck                                                  </span><br>error: inflate: data stream error (incorrect header check)<br>error: unable to unpack header of .git/objects/ce/013625030ba8dba906f756967f9e9ca394464a<br>error: ce013625030ba8dba906f756967f9e9ca394464a: object corrupt or missing: .git/objects/ce/013625030ba8dba906f756967f9e9ca394464a<br>Checking object directories: 100% (256/256), done.<br>missing blob ce013625030ba8dba906f756967f9e9ca394464a<br></code></pre></td></tr></table></figure><h2 id="SHA-1"><a class="header-anchor" href="#SHA-1"></a>SHA-1</h2><p>SHA-1 (Secure Hash Algorithm 1) 是一種 hash (雜湊) 演算法，它可生成 160 bit (20 byte) 的 hash 值，通常以 40 個十六進位 (hex) 的數字表示 <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。</p><p>hash 演算法的特性 <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>：</p><ul><li>給定訊息很容易計算出 hash 值</li><li>很難用已知的 hash 值推算出原始訊息</li><li>很難修改訊息而 hash 值不變</li><li>很難讓不同的訊息有相同的 hash 值</li></ul><p>所以 Git 有以下優點 <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>：</p><ul><li>Git 可透過比較物件名稱 (也就是 SHA-1) 來快速確定兩個物件是否相同</li><li>在每個 repo 中都以相同的方式計算物件名稱，所以儲存在不同 repo 內的相同內容會以相同的名稱來儲存</li><li>可以透過檢查物件名稱來確認其內容的 SHA-1 hash 值，Git 可在讀取物件時檢查錯誤</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Git-Objects" target="_blank" rel="noopener">Git Internals - Git Objects | Pro Git 2/e</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://git-scm.com/docs/user-manual#object-details" target="_blank" rel="noopener">Git - user-manual Documentation</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://zh.wikipedia.org/wiki/SHA-1" target="_blank" rel="noopener">SHA-1 - Wiki</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8" target="_blank" rel="noopener">密碼雜湊函式 - Wiki</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://git-scm.com/docs/user-manual#the-object-database" target="_blank" rel="noopener">Git - user-manual Documentation</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇將深入探討 Git 如何運作，在執行 &lt;code&gt;git add&lt;/code&gt; 將檔案加入 index 時，Git 會如何建立和儲存 blob 物件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>Git - 刪除遠端分支 (以 GitHub、GitLab 為例)</title>
    <link href="https://titangene.github.io/article/git-delete-remote-branch.html"/>
    <id>https://titangene.github.io/article/git-delete-remote-branch.html</id>
    <published>2020-02-09T15:45:52.000Z</published>
    <updated>2020-02-09T15:43:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>本篇將介紹如何刪除 GitHub 或 GitLab 的遠端分支，以及透過是否可刪除遠端 <code>master</code> 分支 (雖然通常不會這樣做)，以了解如何在 GitHub 和 GitLab 修改預設分支。</p><a id="more"></a><p>如果某分支已合併至遠端的 <code>master</code> 分支 (或穩定版的分支) 時，可在 <code>git push</code> 指令加上 <code>--delete</code> 或 <code>-d</code> 選項來刪除遠端分支 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push &lt;remote&gt; --delete &lt;remoteBranchName&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git push &lt;remote&gt; -d &lt;remoteBranchName&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin --delete dev</span><br>To github.com:titangene/git-demo.git<br> - [deleted]         dev<br></code></pre></td></tr></table></figure><p>或是在 ref (在這邊指的是下面指令中的 <code>&lt;remoteBranchName&gt;</code> ) 之前加上冒號 ( <code>:</code> ) 也可以刪除遠端分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push &lt;remote&gt; :&lt;remoteBranchName&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin :dev</span><br>To github.com:titangene/git-demo.git<br> - [deleted]         dev<br></code></pre></td></tr></table></figure><p>此指令是在 <code>origin</code> repo 中找到與 <code>dev</code> match 的 ref (例如：<code>refs/heads/dev</code> )，然後將該遠端分支刪除 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，其實就是刪除遠端 server 上的分支指標。Git Server 會將資料保留一段時間，直到執行 GC (garbage collection，垃圾回收) 為止。所以如果誤刪了分支都很容易恢復。</p><h2 id="刪除多個遠端分支"><a class="header-anchor" href="#刪除多個遠端分支"></a>刪除多個遠端分支</h2><p>如果要刪除多個遠端分支，可直接將多個指定遠端分支加在後面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin -d feature master</span><br>To github.com:titangene/git-demo.git<br> - [deleted]         feature<br> - [deleted]         master<br></code></pre></td></tr></table></figure><h2 id="無法刪除的遠端分支"><a class="header-anchor" href="#無法刪除的遠端分支"></a>無法刪除的遠端分支</h2><p>通常預設會無法刪除遠端的 <code>master</code> 分支，因為遠端通常會將 <code>master</code> 分支作為預設分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin -d master</span><br>To github.com:titangene/git-demo.git<br> ! [remote rejected] master (refusing to delete the current branch: refs/heads/master)<br>error: failed to push some refs to 'git@github.com:titangene/git-demo.git'<br></code></pre></td></tr></table></figure><p>預設是無法刪除 GitHub 和 GitLab 遠端 repo 的 <code>master</code> 分支。</p><h2 id="刪除-GitHub-的遠端分支"><a class="header-anchor" href="#刪除-GitHub-的遠端分支"></a>刪除 GitHub 的遠端分支</h2><p>如果要刪除 GitHub 遠端 repo 的 <code>master</code> 分支，只要將該 repo 的預設分支改成其他分支，這樣就可以刪掉了。</p><p>在 repo 的「Settings &gt; Branches &gt; Default branch &gt; 將預設分支改為其他分支 &gt; Update」，如圖：</p><p><img src="../images/git-delete-remote-branch/2020-02-09-23-30-43.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin -d master</span><br>To github.com:titangene/git-demo.git<br> - [deleted]         master<br></code></pre></td></tr></table></figure><h2 id="刪除-GitLab-的遠端分支"><a class="header-anchor" href="#刪除-GitLab-的遠端分支"></a>刪除 GitLab 的遠端分支</h2><p>刪除 GitLab 遠端 repo 的 <code>master</code> 分支時，會發生以下錯誤，錯誤訊息中直接說明 <code>master</code> 分支是預設分支，所以無法刪除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push gitlab -d master</span><br>remote: GitLab: The default branch of a project cannot be deleted.<br>To gitlab.com:titangene/git-demo.git<br> ! [remote rejected] master (pre-receive hook declined)<br>error: failed to push some refs to 'git@gitlab.com:titangene/git-demo.git'<br></code></pre></td></tr></table></figure><p>在 repo 的「Settings &gt; Repository &gt; Default branch &gt; 將預設分支改為其他分支 &gt; Save changes」，如圖：</p><p><img src="../images/git-delete-remote-branch/2020-02-09-23-28-47.png" alt=""></p><p>那如果將預設分支改成其他分支呢？結果還是不能刪除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push gitlab -d master</span><br>remote: GitLab: You can only delete protected branches using the web interface.<br>To gitlab.com:titangene/git-demo.git<br> ! [remote rejected] master (pre-receive hook declined)<br>error: failed to push some refs to 'git@gitlab.com:titangene/git-demo.git'<br></code></pre></td></tr></table></figure><p>其實原因也寫在錯誤訊息內，因為 GitLab 會預設將 repo 的 <code>master</code> 分支設為受保護的分支 (protected branch) <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，所以才不能刪除。</p><p>如果要刪除受保護的分支，那就讓他不受保護就可以囉 XD。</p><p>在 repo 的「Settings &gt; Repository &gt; Protected Branches &gt; Unprotect <code>master</code> 分支」，如圖：</p><p><img src="../images/git-delete-remote-branch/2020-02-09-23-30-32.png" alt=""></p><p>設定後就可以刪除 <code>master</code> 分支了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push gitlab -d master</span><br>To gitlab.com:titangene/git-demo.git<br> - [deleted]         master<br></code></pre></td></tr></table></figure><h2 id="察看是否刪除遠端分支"><a class="header-anchor" href="#察看是否刪除遠端分支"></a>察看是否刪除遠端分支</h2><p>另外，如果用 <code>git branch -vv</code> 可以看到該分支已被刪除 (輸出訊息中的 <code>gone</code> )：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -vv</span><br>* dev    44fdaf6 [origin/dev: gone] feat: d<br>  master 49135dc [origin/master] feat: b<br></code></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches#_delete_branches" target="_blank" rel="noopener">Git - Remote Branches | Pro Git, 2/e</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://git-scm.com/docs/git-push#Documentation/git-push.txt-codegitpushoriginexperimentalcode" target="_blank" rel="noopener">Git - git-push Documentation</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://gitlab.com/help/user/permissions" target="_blank" rel="noopener">Permissions · User · Help · GitLab</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://gitlab.com/help/user/project/protected_branches" target="_blank" rel="noopener">Protected branches · Project · User · Help · GitLab</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇將介紹如何刪除 GitHub 或 GitLab 的遠端分支，以及透過是否可刪除遠端 &lt;code&gt;master&lt;/code&gt; 分支 (雖然通常不會這樣做)，以了解如何在 GitHub 和 GitLab 修改預設分支。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="GitHub" scheme="https://titangene.github.io/tags/github/"/>
    
      <category term="GitLab" scheme="https://titangene.github.io/tags/gitlab/"/>
    
      <category term="Branch" scheme="https://titangene.github.io/tags/branch/"/>
    
      <category term="Remote" scheme="https://titangene.github.io/tags/remote/"/>
    
  </entry>
  
  <entry>
    <title>重新認識 CSS - 總結 &amp; 系列目錄</title>
    <link href="https://titangene.github.io/article/css-series-catalog.html"/>
    <id>https://titangene.github.io/article/css-series-catalog.html</id>
    <published>2019-10-15T13:20:42.000Z</published>
    <updated>2020-02-09T16:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/css.png" alt=""></p><p>終於來到鐵人賽的最後一天！本篇對「重新認識 CSS」此系列做個總結，並整理此系列中的每篇文章可對應到哪些 CSS Spec。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><blockquote><p>「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。</p><p>在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。</p><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10228321" target="_blank" rel="noopener">重新認識 CSS - 總結 &amp; 系列目錄</a></p><p>「重新認識 CSS」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/2617" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><p>就如前言所說，經過這次的鐵人賽，透過看 spec 來學習 CSS 的真實面貌，而不是未經驗證或自行腦補來切版，讓自己能真正的「重新認識 CSS」。</p><p>這個月以來都是當天看 spec 當天寫文，所以每天都有鐵人賽的感覺。起初看 spec 的時候，腦中天旋地轉，好多以前重來沒看過的專有名詞，還好有<a href="https://ithelp.ithome.com.tw/2020ironman/signup/team/78" target="_blank" rel="noopener">好想工作室</a>的夥伴跟我一起討論 spec，加快我理解的速度。</p><p>我第一次寫連續這麼多天的文章，雖然沒有像以前參加鐵人賽的前輩們說的那樣：「到後面幾天就會不知道要寫什麼了」，所以建議我在開賽前，事先規劃好這 30 天要寫什麼。不過我也沒有特別事先安排寫文的順序，因為我原本就預計會按照 <a href="https://www.w3.org/TR/CSS22/Overview.html#minitoc" target="_blank" rel="noopener">CSS 2.2</a> 的大綱來啃 spec，所以我不怕沒有主題可以寫，只怕自己理解的速度跟不上發文的速度 QQ，還好最後成功完賽 😄。</p><p>雖然鐵人完賽了，但這只是我學習旅程的開始，如果未來還有後續的學習紀錄，都會分享在我的 blog「<a href="https://titangene.github.io/">Titangene Blog</a>」，歡迎大家來光顧。如果想知道我之前寫過哪些專案，可以到我的 <a href="https://github.com/titangene" target="_blank" rel="noopener">Github：titangene</a> 看看。</p><p>下面是我對於這次系列「重新認識 CSS」的整理，讓大家可以更快知道哪些內容可以對應到哪些 spec。</p><h2 id="簡介"><a class="header-anchor" href="#簡介"></a>簡介</h2><p>簡介 CSS，並說明如何在 HTML 使用 CSS。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-introduction.html">重新認識 CSS - CSS 簡介</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/html401/present/styles.html" target="_blank" rel="noopener">HTM 4.01 - 14. Style Sheets</a></li><li><a href="https://html.spec.whatwg.org/multipage/semantics.html#the-link-element" target="_blank" rel="noopener">HTML Living Standard - 4.2.4. The link element</a></li></ul></blockquote><h2 id="Selector"><a class="header-anchor" href="#Selector"></a>Selector</h2><p>Selector 是寫 CSS 時，必須掌握的東西，熟悉 selector 才會選到正確的元素。而此系列是依據 <a href="https://www.w3.org/TR/selectors-3/" target="_blank" rel="noopener">Selectors Level 3</a> 的分類來各別介紹的。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-selector-1.html">重新認識 CSS - Simple Selector &amp; Groups of selector</a></li><li><a href="https://titangene.github.io/article/css-attribute-selector.html">重新認識 CSS - Attribute selector (屬性選擇器)</a></li><li><a href="https://titangene.github.io/article/css-selector-pseudo-class-1.html">重新認識 CSS - Pseudo-class (偽類) (1)</a></li><li><a href="https://titangene.github.io/article/css-selector-pseudo-class-2.html">重新認識 CSS - Pseudo-class (偽類) (2)</a></li><li><a href="https://titangene.github.io/article/css-selector-pseudo-element.html">重新認識 CSS - Pseudo-element (偽元素)</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/selector.html" target="_blank" rel="noopener">CSS 2.2 - 5. Selectors</a></li><li><a href="https://www.w3.org/TR/CSS22/generate.html#before-after-content" target="_blank" rel="noopener">CSS 2.2 - 12.1. The :before and :after pseudo-elements</a></li><li><a href="https://www.w3.org/TR/selectors-3/" target="_blank" rel="noopener">Selectors Level 3</a></li><li><a href="https://www.w3.org/TR/selectors-4/" target="_blank" rel="noopener">Selectors Level 4</a></li><li><a href="https://www.w3.org/TR/css-pseudo-4/" target="_blank" rel="noopener">CSS Pseudo-Elements Module Level 4</a></li></ul></blockquote><h2 id="Values-Units"><a class="header-anchor" href="#Values-Units"></a>Values &amp; Units</h2><p>在開始認識 CSS 屬性之前，可以先認識屬性有哪些值和單位可以使用。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-attribute-value.html">重新認識 CSS - CSS 屬性值</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/syndata.html#values" target="_blank" rel="noopener">CSS 2.2 - 4.3. Values</a></li><li><a href="https://www.w3.org/TR/css-values-3/" target="_blank" rel="noopener">CSS Values and Units Module Level 3</a></li><li><a href="https://www.w3.org/TR/css-values-4/" target="_blank" rel="noopener">CSS Values and Units Module Level 4</a></li></ul></blockquote><h2 id="Assigning-property-values-Cascading-and-Inheritance"><a class="header-anchor" href="#Assigning-property-values-Cascading-and-Inheritance"></a>Assigning property values, Cascading, and Inheritance</h2><p>了解在 CSS 中，繼承和權重這些重要的觀念之後，接著就可以更深入的了解 CSS 是如何處理屬性值的。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-inheritance.html">重新認識 CSS - Inheritance (繼承)</a></li><li><a href="https://titangene.github.io/article/css-cascading-and-specificity.html">重新認識 CSS - Cascading &amp; Specificity</a></li><li><a href="https://titangene.github.io/article/css-value-processing.html">重新認識 CSS - CSS 如何處理屬性值</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/cascade.html" target="_blank" rel="noopener">CSS 2.2 - 6. Assigning property values, Cascading, and Inheritance</a></li><li><a href="https://www.w3.org/TR/css-cascade-3/" target="_blank" rel="noopener">CSS Cascading and Inheritance Level 3</a></li><li><a href="https://www.w3.org/TR/css-cascade-4/" target="_blank" rel="noopener">CSS Cascading and Inheritance Level 4</a></li></ul></blockquote><h2 id="media-import-rules"><a class="header-anchor" href="#media-import-rules"></a><code>@media</code> &amp; <code>@import</code> rules</h2><p>引入其他 CSS 檔案或在多個裝置、解析度、螢幕尺寸下要應用哪個 style sheet (樣式表)，就需要了解如何使用 <code>@media</code> 和 <code>@import</code>。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-media-type.html">重新認識 CSS - Media type</a></li><li><a href="https://titangene.github.io/article/css-media-query.html">重新認識 CSS - Media query</a></li><li><a href="https://titangene.github.io/article/css-import.html">重新認識 CSS - @import</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/media.html" target="_blank" rel="noopener">CSS 2.2 - 7. Media types</a></li><li><a href="https://www.w3.org/TR/css3-mediaqueries/" target="_blank" rel="noopener">Media Queries</a></li><li><a href="https://www.w3.org/TR/mediaqueries/" target="_blank" rel="noopener">Media Queries Level 4</a></li><li><a href="https://www.w3.org/TR/CSS22/cascade.html#at-import" target="_blank" rel="noopener">CSS 2.2 - 6.3 The @import rule</a></li></ul></blockquote><h2 id="Box-model"><a class="header-anchor" href="#Box-model"></a>Box model</h2><p>Box model 是用來描述 document tree 中的每個元素所產生的矩形框。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-box-model.html">重新認識 CSS - Box model (前傳)</a></li><li><a href="https://titangene.github.io/article/css-border.html">重新認識 CSS - Box model：border</a></li><li><a href="https://titangene.github.io/article/css-box-sizing.html">重新認識 CSS - box-sizing</a></li><li><a href="https://titangene.github.io/article/css-collapsing-margins.html">重新認識 CSS - Collapsing margins</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/box.html" target="_blank" rel="noopener">CSS 2.2 - 8. Box model</a></li><li><a href="https://www.w3.org/TR/css-box-3/" target="_blank" rel="noopener">CSS Box Model Module Level 3</a></li><li><a href="https://www.w3.org/TR/css-ui-3/#box-model" target="_blank" rel="noopener">CSS Basic User Interface Module Level 3 (CSS3 UI) - 3. Box Model addition</a></li><li><a href="https://www.w3.org/TR/css-backgrounds-3/#borders" target="_blank" rel="noopener">CSS Backgrounds and Borders Module Level 3 - 4. Borders</a></li></ul></blockquote><h2 id="Visual-formatting-model"><a class="header-anchor" href="#Visual-formatting-model"></a>Visual formatting model</h2><p>Visual formatting model 是用來描述 UA 會如何處理視覺媒體 (visual media) 的 document tree，document tree 中的每個元素都會根據 box model 來產生 0 個或多個 box。而這些 box 的位置和大小都是相對於稱為 containing block 的矩形框的邊緣計算的。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-containing-block.html">重新認識 CSS - Containing block</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/visuren.html#containing-block" target="_blank" rel="noopener">CSS 2.2 - 9.1.2. Containing blocks</a></li><li><a href="https://www.w3.org/TR/CSS22/visudet.html#containing-block-details" target="_blank" rel="noopener">CSS 2.2 - 10.1. Definition of “containing block”</a></li></ul></blockquote><h3 id="Controlling-box-generation"><a class="header-anchor" href="#Controlling-box-generation"></a>Controlling box generation</h3><p>元素產生的 box 的 type，可以使用 <code>display</code> 屬性來指定，而 box 的 type 會影響 box 在 visual formatting model 中的行為。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-box-generation-block-box.html">重新認識 CSS - Visual formatting model：Box generation (block)</a></li><li><a href="https://titangene.github.io/article/css-box-generation-inline-box.html">重新認識 CSS - Visual formatting model：Box generation (inline)</a></li><li><a href="https://titangene.github.io/article/css-display.html">重新認識 CSS - display</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/visuren.html#box-gen" target="_blank" rel="noopener">CSS 2.2 - 9.2. Controlling box generation</a></li><li><a href="https://www.w3.org/TR/css-display-3/" target="_blank" rel="noopener">CSS Display Module Level 3</a></li></ul></blockquote><h3 id="Formatting-context-Normal-flow"><a class="header-anchor" href="#Formatting-context-Normal-flow"></a>Formatting context &amp; Normal flow</h3><p>Normal flow 中的 box 屬於某種 formatting context，可是 block 或 inline，不同的 box 會參與不同的 formatting context。block-level box 會參與 BFC，inline-level box 會參與 IFC。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-formatting-context.html">重新認識 CSS - formatting context &amp; independent formatting context</a></li><li><a href="https://titangene.github.io/article/css-bfc.html">重新認識 CSS - Block formatting context (BFC)</a></li><li><a href="https://titangene.github.io/article/css-ifc.html">重新認識 CSS - Inline formatting context (IFC)</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/visuren.html#block-formatting" target="_blank" rel="noopener">CSS 2.2 - 9.4.1. Block formatting contexts</a></li><li><a href="https://www.w3.org/TR/CSS22/visuren.html#inline-formatting" target="_blank" rel="noopener">CSS 2.2 - 9.4.2. Inline formatting contexts</a></li><li><a href="https://www.w3.org/TR/css-display-3/" target="_blank" rel="noopener">CSS Display Module Level 3</a></li><li><a href="https://www.w3.org/TR/css-inline-3/" target="_blank" rel="noopener">CSS Inline Layout Module Level 3</a></li></ul></blockquote><h3 id="Positioning-schemes"><a class="header-anchor" href="#Positioning-schemes"></a>Positioning schemes</h3><p>在 CSS 2.2 中，<code>position</code> 和 <code>float</code> 屬性這些定位方案都可以對 box 進行佈局。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-position.html">重新認識 CSS - position</a></li><li><a href="https://titangene.github.io/article/css-float.html">重新認識 CSS - float</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/visuren.html#positioning-scheme" target="_blank" rel="noopener">CSS 2.2 - 9.3. Positioning schemes</a></li><li><a href="https://www.w3.org/TR/css-position-3/" target="_blank" rel="noopener">CSS Positioned Layout Module Level 3</a></li></ul></blockquote><h3 id="Layered-presentation"><a class="header-anchor" href="#Layered-presentation"></a>Layered presentation</h3><p>除了水平和垂直的位置之外，如果想讓 box 可以有類似圖層的概念來排版，就能使用 <code>z-index</code> 屬性，這些 box 可以沿著 z 軸來排列，讓一個 box 可以疊在另一個 box 的上面。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-z-index-and-stacking-context.html">重新認識 CSS - z-index &amp; stacking context</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/visuren.html#layers" target="_blank" rel="noopener">CSS 2.2 - 9.9. Layered presentation</a></li></ul></blockquote><h2 id="Visual-effects"><a class="header-anchor" href="#Visual-effects"></a>Visual effects</h2><p>當 block box 的內容超出 box 的 content edge 時，就可能會發生 overflow。使用 <code>overflow</code> 屬性就能指定超出的部份要如何處理 (例如：提供捲動機制來訪問被剪裁的內容)。而 <code>visibility</code> 屬性則可以指定是否要 render 由元素產生的 box，可用來顯示或隱藏 box。系列如下：</p><ul><li><a href="https://titangene.github.io/article/css-overflow.html">重新認識 CSS - overflow</a></li><li><a href="https://titangene.github.io/article/css-visibility.html">重新認識 CSS - visibility</a></li></ul><blockquote><p>對應 spec 的以下幾篇：</p><ul><li><a href="https://www.w3.org/TR/CSS22/visufx.html" target="_blank" rel="noopener">CSS 2.2 - 11. Visual effects</a></li><li><a href="https://www.w3.org/TR/CSS22/tables.html#dynamic-effects" target="_blank" rel="noopener">CSS 2.2 - 17.5.5. Dynamic row and column effects</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/css.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;終於來到鐵人賽的最後一天！本篇對「重新認識 CSS」此系列做個總結，並整理此系列中的每篇文章可對應到哪些 CSS Spec。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://titangene.github.io/categories/css/"/>
    
    
      <category term="IT 鐵人賽" scheme="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
</feed>
