<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Titangene Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://titangene.github.io/"/>
  <updated>2020-11-01T15:57:17.389Z</updated>
  <id>https://titangene.github.io/</id>
  
  <author>
    <name>Titangene</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 Vue 中使用 Lottie 動畫</title>
    <link href="https://titangene.github.io/article/vue-lottie.html"/>
    <id>https://titangene.github.io/article/vue-lottie.html</id>
    <published>2020-11-01T14:33:49.000Z</published>
    <updated>2020-11-01T15:57:17.389Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/vue.jpg" alt=""></p><p>本篇介紹如何在 Vue 中使用 Lottie 動畫，順便練習將套件包成 Vue component。</p><a id="more"></a><p>Lottie 是 Airbnb 開源的跨平台動畫 library，設計師用 Adobe After Effects 製作動畫，匯出 JSON 檔給工程師，工程師透過 Lottie</p><p>可用於 Android、iOS、Web 和 Windows，</p><p>設計師用 Adobe After Effects 製作動畫，接著使用 After Effects 的 extension：<a href="https://exchange.adobe.com/creativecloud.details.12557.html" target="_blank" rel="noopener">Bodymovin</a>，將動畫轉成 JSON 檔匯出，這樣就能在 mobile 若網頁上原生渲染動畫。</p><p>可選擇在 web 的 SVG、Canvas 或 HTML 上渲染動畫</p><p>設計師提供動畫<br>工程師套用</p><ul><li>設計師可以放心做動畫，只要轉成 JSON 給工程師</li><li>工程師不用花時間實作動畫，直接套用設計師提供的 JSON</li></ul><div class="info"><p>本篇不會說明設計師要處理的部份，只會說明工程師拿到 JSON 的動畫檔時，要怎麼引入該 JSON 讓動畫動起來。</p></div><p>免費下載其他人分享的動畫：<a href="https://lottiefiles.com/" target="_blank" rel="noopener">LottieFiles - Free animation files built for Lottie</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Home"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LottieAnimation</span></span><br><span class="hljs-tag">      <span class="hljs-attr">ref</span>=<span class="hljs-string">"loadingAnimation"</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:animationData</span>=<span class="hljs-string">"loadingAnimationData"</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"$refs.loadingAnimation.play()"</span>&gt;</span><br>      play<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"$refs.loadingAnimation.pause()"</span>&gt;</span><br>      pause<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"$refs.loadingAnimation.stop()"</span>&gt;</span><br>      stop<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>&lt;&lt;script&gt;<br>import loadingAnimationData from '@/assets/animations/loading-usr.json';<br><br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      loadingAnimationData<br>    &#125;;<br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"LottieAnimation"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"animationContainer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> lottie <span class="hljs-keyword">from</span> <span class="hljs-string">'lottie-web'</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="actionscript">  name: <span class="hljs-string">'LottieAnimation'</span>,</span><br>  props: &#123;<br>    animationData: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">Object</span>,</span><br><span class="actionscript">      required: <span class="hljs-literal">true</span></span><br>    &#125;,<br>    loop: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">Boolean</span>,</span><br><span class="actionscript">      <span class="hljs-keyword">default</span>: <span class="hljs-literal">true</span></span><br>    &#125;,<br>    autoPlay: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">Boolean</span>,</span><br><span class="actionscript">      <span class="hljs-keyword">default</span>: <span class="hljs-literal">true</span></span><br>    &#125;,<br>    rendererSettings: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">Object</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;&#125;)</span><br>    &#125;<br>  &#125;,<br>  data() &#123;<br><span class="actionscript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="actionscript">      animation: <span class="hljs-literal">null</span></span><br>    &#125;;<br>  &#125;,<br>  mounted() &#123;<br><span class="actionscript">    <span class="hljs-keyword">this</span>.animation = lottie.loadAnimation(&#123;</span><br><span class="actionscript">      container: <span class="hljs-keyword">this</span>.$refs.animationContainer,</span><br><span class="actionscript">      renderer: <span class="hljs-string">'svg'</span>,</span><br><span class="actionscript">      loop: <span class="hljs-keyword">this</span>.loop,</span><br><span class="actionscript">      autoplay: <span class="hljs-keyword">this</span>.autoPlay,</span><br><span class="actionscript">      animationData: <span class="hljs-keyword">this</span>.animationData,</span><br><span class="actionscript">      rendererSettings: <span class="hljs-keyword">this</span>.rendererSettings</span><br>    &#125;);<br><br><span class="actionscript">    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'animation-created'</span>, <span class="hljs-keyword">this</span>.animation);</span><br>  &#125;,<br>  beforeDestroy() &#123;<br><span class="actionscript">    <span class="hljs-keyword">this</span>.destroy();</span><br>  &#125;,<br>  methods: &#123;<br>    play() &#123;<br><span class="actionscript">      <span class="hljs-keyword">this</span>.animation?.play();</span><br>    &#125;,<br>    pause() &#123;<br><span class="actionscript">      <span class="hljs-keyword">this</span>.animation?.pause();</span><br>    &#125;,<br>    stop() &#123;<br><span class="actionscript">      <span class="hljs-keyword">this</span>.animation?.stop();</span><br>    &#125;,<br>    destroy() &#123;<br><span class="actionscript">      <span class="hljs-keyword">this</span>.animation?.destroy();</span><br>    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.LottieAnimation</span> &#123;</span><br>  width: 100%;<br>  height: 100%;<br><br>  overflow: hidden;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/vue.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇介紹如何在 Vue 中使用 Lottie 動畫，順便練習將套件包成 Vue component。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web-dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="Vue.js" scheme="https://titangene.github.io/tags/vue-js/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Animation" scheme="https://titangene.github.io/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 之旅 (27)：Promise.any() &amp; AggregateError</title>
    <link href="https://titangene.github.io/article/javascript-promise-any-aggregateerror.html"/>
    <id>https://titangene.github.io/article/javascript-promise-any-aggregateerror.html</id>
    <published>2020-10-12T06:55:20.000Z</published>
    <updated>2020-10-18T12:59:11.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/javascript.jpg" alt=""></p><p>本篇介紹 ES2021 (ES12) 提供的 <code>Promise.any()</code> 和 <code>AggregateError</code>。</p><a id="more"></a><blockquote><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10252463" target="_blank" rel="noopener">JavaScript 之旅 (27)：Promise.any() &amp; AggregateError</a></p><p>「JavaScript 之旅」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/3607" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><p>之前有介紹 ES2020 (ES11) 提供的 <code>Promise.allSettled()</code>，它不會發生短路，也就是都會等所有傳入的 Promise settled (即 fulfilled 或 rejected )，而本篇介紹的 <code>Promise.any()</code> 則是會因其中一個傳入的 Promise fulfilled 而發生短路。</p><p>例如：在 <code>Promise.any()</code> 傳入 3 的 Promise，只有第一個會立即 rejected，其餘的都會立即 fulfilled：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.any([<br>  <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Oops 1'</span>),<br>  <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK 1'</span>),<br>  <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK 2'</span>)<br>]);<br></code></pre></td></tr></table></figure><p>可以看到最後回傳的 Promise 會 fulfilled，因為 <code>Promise.any()</code> 只要其中一個 Promise fulfilled 就會發生短路，即會立即回傳該 Promise fulfilled：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(promise);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "OK 1"&#125;</span><br></code></pre></td></tr></table></figure><p>若所有傳入的 Promise 都 rejected，則會以 <code>AggregateError</code> rejected，並會保留所有 rejection reasons (即下面範例中的 <code>error.errors</code> )：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.any([<br>  <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Oops 1'</span>),<br>  <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Oops 2'</span>),<br>  <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Oops 3'</span>)<br>])<br>.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(error <span class="hljs-keyword">instanceof</span> AggregateError);<br>  <span class="hljs-built_in">console</span>.log(error.errors);<br>  <span class="hljs-built_in">console</span>.log(error.message);<br>  <span class="hljs-built_in">console</span>.log(error.stack);<br>&#125;);<br><br><span class="hljs-comment">// true</span><br><span class="hljs-comment">// ["Oops 1", "Oops 2", "Oops 3"]</span><br><span class="hljs-comment">// All promises were rejected</span><br><span class="hljs-comment">// AggregateError: All promises were rejected</span><br></code></pre></td></tr></table></figure><p>另外，你也可以自行建立新的 <code>AggregateError</code> 物件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 語法：AggregateError(errors, message)</span><br><span class="hljs-keyword">new</span> AggregateError([errorA, errorB, errorC], <span class="hljs-string">'error message'</span>);<br></code></pre></td></tr></table></figure><h1 id="使用情境"><a class="header-anchor" href="#使用情境"></a>使用情境</h1><p><code>Promise.any()</code> 很適合用在一次處理多個非同步，並且抓出第一個 fulfilled 的 Promise，只有當全部都 rejected 才進行錯誤處理。</p><p>例如：同時發多個 request，看哪一個 endpoint 回應最快，然後把該 endpoint 紀錄下來。而且只有當所有 request 都發失敗時，才會進行錯誤處理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> Base_URL = <span class="hljs-string">'https://jsonplaceholder.typicode.com'</span>;<br><br><span class="hljs-keyword">let</span> promises = [<br>  fetch(<span class="hljs-string">`<span class="hljs-subst">$&#123;Base_URL&#125;</span>/posts/1`</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'post'</span>),<br>  fetch(<span class="hljs-string">`<span class="hljs-subst">$&#123;Base_URL&#125;</span>/todos/1`</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'todo'</span>),<br>  fetch(<span class="hljs-string">`<span class="hljs-subst">$&#123;Base_URL&#125;</span>/comments/1`</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'comment'</span>)<br>];<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> first = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.any(promises);<br>  <span class="hljs-built_in">console</span>.log(first);<br><br>  <span class="hljs-comment">// 紀錄 log...</span><br>  <span class="hljs-comment">// Logger.log(first);</span><br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-built_in">console</span>.log(error.errors);<br><br>  <span class="hljs-comment">// 錯誤處理...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另一個適合的情境是你想<a href="https://ithelp.ithome.com.tw/articles/10250847" target="_blank" rel="noopener">動態 import</a> 一個模組，但有兩個來源可以 import，但你只需 import 最快的那一個即可，此時也很適合用 <code>Promise.any()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> lodash = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.any([<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://primary.example.com/lodash'</span>),<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://secondary.example.com/lodash'</span>),<br>]);<br></code></pre></td></tr></table></figure><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://github.com/tc39/proposal-promise-any" target="_blank" rel="noopener">tc39/proposal-promise-any: ECMAScript proposal: Promise.any</a></li><li><a href="https://v8.dev/features/promise-combinators" target="_blank" rel="noopener">Promise combinators · V8</a></li><li><a href="https://2ality.com/2019/12/promise-any.html" target="_blank" rel="noopener">ECMAScript feature: <code>Promise.any()</code> | 2ality</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇介紹 ES2021 (ES12) 提供的 &lt;code&gt;Promise.any()&lt;/code&gt; 和 &lt;code&gt;AggregateError&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://titangene.github.io/categories/javascript/"/>
    
    
      <category term="IT 鐵人賽" scheme="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
      <category term="ECMAScript" scheme="https://titangene.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 之旅 (22)：BigInt</title>
    <link href="https://titangene.github.io/article/javascript-bigint.html"/>
    <id>https://titangene.github.io/article/javascript-bigint.html</id>
    <published>2020-10-07T06:55:20.000Z</published>
    <updated>2020-10-08T01:15:34.666Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/javascript.jpg" alt=""></p><p>本篇介紹 ES2020 (ES11) 提供的 <code>BigInt</code>。</p><a id="more"></a><blockquote><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10250362" target="_blank" rel="noopener">JavaScript 之旅 (22)：BigInt</a></p><p>「JavaScript 之旅」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/3607" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><h1 id="過去-Number"><a class="header-anchor" href="#過去-Number"></a>過去 <code>Number</code></h1><p>在過去，只要 JavaScript 提到 primitive 就會想到 <code>String</code>、<code>Number</code>、<code>Boolean</code>，但其實還有在 ES6 提供的 <code>Symbol</code>，另外在 spec 的定義中還有 <code>Undefined</code>、<code>Null</code>。</p><p>除了以上這些，還有本篇要介紹的新 primitive：<code>BigInt</code>。</p><p>下面是 spec 對 <a href="https://www.ecma-international.org/ecma-262/#sec-primitive-value" target="_blank" rel="noopener">primitive value</a> 的定義：</p><p><img src="../images/javascript-bigint/2020-10-07-17-41-55.png" alt=""></p><p><code>Number</code> 只能安全地表示最大為 $2^{53}$ 的整數，但有時會有大整數的需求，例如：</p><ul><li>社群貼文 ID (例如：<a href="https://developer.twitter.com/en/docs/twitter-ids" target="_blank" rel="noopener">Twitter ID</a>)，在 JavaScript 只能用字串儲存</li><li>FinTech 會需要很大的整數，且需要有任意精度的整數來表示金額</li></ul><p>例如：在 JavaScript 竟然 <code>2 ** 53</code> 會等於 <code>2 ** 53 + 1</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span> ** <span class="hljs-number">53</span>;<br><span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span> ** <span class="hljs-number">53</span> + <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">console</span>.log(x);<br><span class="hljs-comment">// 9007199254740992</span><br><span class="hljs-built_in">console</span>.log(y);<br><span class="hljs-comment">// 9007199254740992</span><br><br><span class="hljs-built_in">console</span>.log(x === y);<br><span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> x);<br><span class="hljs-comment">// number</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> y);<br><span class="hljs-comment">// number</span><br></code></pre></td></tr></table></figure><p>很奇怪吧！所以這就是 <code>BigInt</code> 被提出的原因！</p><blockquote><p>為何會有這個現象是跟 <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754</a> 的浮點數定義有關，詳請可參閱 <a href="https://docs.google.com/presentation/d/1apPbAiv_-mJF35P31IjaII8UA6TwSynCA_zhfDEmgOE/edit#slide=id.g38a1897a56_0_97" target="_blank" rel="noopener">Daniel Ehrenberg 在 JSConf EU 2018 的 演講簡報</a> 和 <a href="https://www.youtube.com/watch?v=RiU5OzMZ7z8" target="_blank" rel="noopener">演講影片</a>。</p></blockquote><h1 id="現代的-BigInt"><a class="header-anchor" href="#現代的-BigInt"></a>現代的 <code>BigInt</code></h1><p><code>BigInt</code> 是一種可用來表示 arbitrary precision (任意精度，高精度) 的整數，也就是可以表示大於 $2^{53}$ 的整數。</p><p>例如：剛剛 <code>2 ** 53</code> 和 <code>2 ** 53 + 1</code> 的例子若改用 <code>BigInt</code> 就會如你預期的不一樣 (本來就不同啊 XD)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2n</span> ** <span class="hljs-number">53n</span>;<br><span class="hljs-keyword">let</span> y = <span class="hljs-number">2n</span> ** <span class="hljs-number">53n</span> + <span class="hljs-number">1n</span>;<br><br><span class="hljs-built_in">console</span>.log(x);<br><span class="hljs-comment">// 9007199254740992n</span><br><span class="hljs-built_in">console</span>.log(y);<br><span class="hljs-comment">// 9007199254740993n</span><br><br><span class="hljs-built_in">console</span>.log(x === y);<br><span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> x);<br><span class="hljs-comment">// bigint</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> y);<br><span class="hljs-comment">// bigint</span><br></code></pre></td></tr></table></figure><h2 id="語法"><a class="header-anchor" href="#語法"></a>語法</h2><p><code>BigInt</code> 的語法和 <code>Number</code> 直接寫整數不太一樣，<code>BigInt</code> literal (字面值) 是在整數的後面加上 <code>n</code> 後綴：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">9007199254740992n</span>;<br><br><span class="hljs-built_in">console</span>.log(x);<br><span class="hljs-comment">//9007199254740992n</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> x);<br><span class="hljs-comment">// bigint</span><br></code></pre></td></tr></table></figure><p>另一種方式是呼叫 constructor 來建立 <code>BigInt</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = BigInt(<span class="hljs-number">9007199254740992</span>);<br><br><span class="hljs-built_in">console</span>.log(x);<br><span class="hljs-comment">//9007199254740992n</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> x);<br><span class="hljs-comment">// bigint</span><br></code></pre></td></tr></table></figure><h2 id="各種運算子的數學運算"><a class="header-anchor" href="#各種運算子的數學運算"></a>各種運算子的數學運算</h2><p><code>BigInt</code> 在 <code>+</code>、<code>-</code>、<code>*</code>、<code>**</code> 和 <code>%</code> 的運算上跟 <code>Number</code> 差不多 (這邊說的差不多是指整數小於 $2^{53}$ 的情況下)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">9007199254740992n</span>;<br><br><span class="hljs-built_in">console</span>.log(x + <span class="hljs-number">1n</span>);<br><span class="hljs-comment">// 9007199254740993n</span><br><span class="hljs-built_in">console</span>.log(x - <span class="hljs-number">1n</span>);<br><span class="hljs-comment">// 9007199254740991n</span><br><span class="hljs-built_in">console</span>.log(x * <span class="hljs-number">2n</span>);<br><span class="hljs-comment">// 18014398509481984n</span><br><span class="hljs-built_in">console</span>.log(x * <span class="hljs-number">-2n</span>);<br><span class="hljs-comment">// -18014398509481984n</span><br><span class="hljs-built_in">console</span>.log(x ** <span class="hljs-number">2n</span>);<br><span class="hljs-comment">// 81129638414606681695789005144064n</span><br><span class="hljs-built_in">console</span>.log(x % <span class="hljs-number">10n</span>);<br><span class="hljs-comment">// 2n</span><br></code></pre></td></tr></table></figure><p>但在小數運算上跟 <code>Number</code> 不同，因為 <code>BigInt</code> 不是 <code>BigDecimals</code>，所以會 rounded towards 0，即不保留任何小數 (類似無條件捨去)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span> / <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 2.5</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">5n</span> / <span class="hljs-number">2n</span>);<br><span class="hljs-comment">// 2n</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span> / <span class="hljs-number">3</span>);<br><span class="hljs-comment">// 1.6666666666666667</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">5n</span> / <span class="hljs-number">3n</span>);<br><span class="hljs-comment">// 1n</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span> / <span class="hljs-number">4</span>);<br><span class="hljs-comment">// 1.25</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">5n</span> / <span class="hljs-number">4n</span>);<br><span class="hljs-comment">// 1n</span><br></code></pre></td></tr></table></figure><p>在 spec 中的 <a href="https://www.ecma-international.org/ecma-262/#sec-numeric-types-bigint-divide" target="_blank" rel="noopener"><code>BigInt::divide ( x, y )</code></a> 就有定義 rounded towards 0：</p><p><img src="../images/javascript-bigint/2020-10-07-23-23-36.png" alt=""></p><h2 id="數值比較"><a class="header-anchor" href="#數值比較"></a>數值比較</h2><p><code>BigInt</code> 不嚴格等於 (not strictly equal) <code>Number</code>，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0n</span> === <span class="hljs-number">0</span>);<br><span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0n</span> == <span class="hljs-number">0</span>);<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在 spec 中的「<a href="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison" target="_blank" rel="noopener">Strict Equality Comparison</a>」有定義：</p><ul><li>步驟 1：當兩個值的型別不同時，就會回傳 <code>false</code>，即不嚴格等於</li><li>步驟 2：其中一個值的型別為 <code>Number</code> 或 <code>BigInt</code> 就會回傳 <code>Type(x)::equal(x, y)</code></li></ul><p><img src="../images/javascript-bigint/2020-10-07-23-13-44.png" alt=""></p><p>若將上面範例中的 <code>0n</code> 帶入 spec，那 <code>0n</code> 就是 <code>x</code>，所以代表步驟 2 會去執行 <a href="https://www.ecma-international.org/ecma-262/#sec-numeric-types-bigint-equal" target="_blank" rel="noopener"><code>BigInt::equal (x, y)</code></a>，spec 的定義如下：只要兩個值的數學整數值相等時，就會回傳 <code>true</code>，否則回傳 <code>false</code></p><p><img src="../images/javascript-bigint/2020-10-07-23-18-08.png" alt=""></p><p>但可照常用 <code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code> 和 <code>&lt;=</code> 進行比較，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3n</span> &gt; <span class="hljs-number">2</span>);<br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3n</span> &lt; <span class="hljs-number">2</span>);<br><span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> &lt; <span class="hljs-number">3n</span>);<br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> &gt; <span class="hljs-number">3n</span>);<br><span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> &lt; <span class="hljs-number">2n</span>);<br><span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> &gt; <span class="hljs-number">2n</span>);<br><span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> &lt;= <span class="hljs-number">2n</span>);<br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> &gt;= <span class="hljs-number">2n</span>);<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="條件判斷"><a class="header-anchor" href="#條件判斷"></a>條件判斷</h2><p>若將 <code>BigInt</code> 強制轉型成 <code>Boolean</code>，行為會跟 <code>Number</code> 類似。</p><p>例如：<code>if</code> 陳述句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'if'</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'else'</span>)<br>&#125;<br><span class="hljs-comment">// else</span><br><br><br><span class="hljs-keyword">if</span> (<span class="hljs-number">0n</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'if'</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'else'</span>)<br>&#125;<br><span class="hljs-comment">// else</span><br></code></pre></td></tr></table></figure><p><a href="https://www.ecma-international.org/ecma-262/#sec-if-statement-runtime-semantics-evaluation" target="_blank" rel="noopener"><code>if</code> 陳述句</a>會將值進行 <code>ToBoolean()</code> 強制轉型，spec 定義如下：</p><p><img src="../images/javascript-bigint/2020-10-08-08-44-13.png" alt=""></p><p>例如：二元邏輯運算子 (binary logical operator) 的 <code>&amp;&amp;</code> 和 <code>||</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> || <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 10</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0n</span> || <span class="hljs-number">10n</span>);<br><span class="hljs-comment">// 10n</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0n</span> &amp;&amp; <span class="hljs-number">10n</span>);<br><span class="hljs-comment">// 0n</span><br></code></pre></td></tr></table></figure><p><a href="https://www.ecma-international.org/ecma-262/#sec-binary-logical-operators-runtime-semantics-evaluation" target="_blank" rel="noopener"><code>&amp;&amp;</code> 和 <code>||</code></a> 會將值進行 <code>ToBoolean()</code> 強制轉型，spec 定義如下：</p><p><img src="../images/javascript-bigint/2020-10-08-08-47-50.png" alt=""></p><p>例如：使用 <code>Boolean()</code> constructor：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>));<br><span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">10</span>));<br><span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0n</span>));<br><span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">10n</span>));<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><a href="https://www.ecma-international.org/ecma-262/#sec-boolean-constructor-boolean-value" target="_blank" rel="noopener"><code>Boolean()</code> constructor</a> 會將值進行 <code>ToBoolean()</code> 強制轉型，spec 定義如下：</p><p><img src="../images/javascript-bigint/2020-10-08-08-45-52.png" alt=""></p><p>例如：邏輯 NOT 運算子 (logical NOT operator) <code>!</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(!<span class="hljs-number">0</span>);<br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(!<span class="hljs-number">10</span>);<br><span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">console</span>.log(!<span class="hljs-number">0n</span>);<br><span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(!<span class="hljs-number">10n</span>);<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><a href="https://www.ecma-international.org/ecma-262/#sec-logical-not-operator" target="_blank" rel="noopener"><code>!</code></a> 會將值進行 <code>ToBoolean()</code> 強制轉型，spec 定義如下：</p><p><img src="../images/javascript-bigint/2020-10-08-08-50-19.png" alt=""></p><p>上面說的這些都將值進行 <code>ToBoolean()</code> 強制轉型，下面是 <a href="https://www.ecma-international.org/ecma-262/#sec-toboolean" target="_blank" rel="noopener"><code>ToBoolean()</code></a> 的定義：只有 <code>0n</code> 會回傳 <code>false</code>，其他都回傳 <code>true</code> (跟 <code>Number</code> 很像對吧？有興趣的可以看 <code>Number</code> 的部份)</p><p><img src="../images/javascript-bigint/2020-10-08-08-52-08.png" alt=""></p><p>所以這就是 <code>0n</code> 會變成 <code>false</code> 的原因！</p><h2 id="有些無法成功強制轉型，會拋出-exception"><a class="header-anchor" href="#有些無法成功強制轉型，會拋出-exception"></a>有些無法成功強制轉型，會拋出 exception</h2><p><code>BigInt</code> 不能和 unary <code>+</code> 運算子一起使用，需先用 <code>Number()</code> constructor 轉換：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(+<span class="hljs-number">1n</span>);<br><span class="hljs-comment">// TypeError: Cannot convert a BigInt value to a number</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-number">1n</span>));<br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>在 spec 是有定義的，因為 <a href="https://www.ecma-international.org/ecma-262/#sec-unary-plus-operator" target="_blank" rel="noopener">unary <code>+</code> 運算子</a>會進行 <code>ToNumber()</code> 的強制轉型：</p><p><img src="../images/javascript-bigint/2020-10-07-22-41-47.png" alt=""></p><p>但 <a href="https://www.ecma-international.org/ecma-262/#sec-tonumber" target="_blank" rel="noopener"><code>ToNumber()</code></a> 只要遇到 <code>BigInt</code> 就會拋出 <code>TypeError</code> exception：</p><p><img src="../images/javascript-bigint/2020-10-07-22-42-42.png" alt=""></p><h2 id="不能和-Number-一起使用"><a class="header-anchor" href="#不能和-Number-一起使用"></a>不能和 <code>Number</code> 一起使用</h2><p>不能和 <code>Number</code> 一起使用，否則會拋出 <code>TypeError</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1n</span> + <span class="hljs-number">2</span>);<br><span class="hljs-comment">// TypeError: Cannot mix BigInt and other types, use explicit conversions</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1n</span> * <span class="hljs-number">2</span>);<br><span class="hljs-comment">// TypeError: Cannot mix BigInt and other types, use explicit conversions</span><br></code></pre></td></tr></table></figure><p>若要和 <code>Number</code> 一起使用，請先用 <code>Number()</code> constructor 強制轉型 (即 explicit conversions) 成 <code>Number</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-number">1n</span>) + <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-number">1n</span>) * <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>下面是 <a href="https://www.ecma-international.org/ecma-262/#sec-addition-operator-plus" target="_blank" rel="noopener"><code>+</code> 運算子</a>在 spec 中的定義，其中的步驟 8 和 9 都會將 <code>+</code> 左右邊的兩個運算元進行 <code>ToNumeric()</code> 的強制轉型：</p><p><img src="../images/javascript-bigint/2020-10-07-22-51-23.png" alt=""></p><p>而下面是 <a href="https://www.ecma-international.org/ecma-262/#sec-tonumeric" target="_blank" rel="noopener"><code>ToNumeric()</code></a> 的定義，可以看到步驟 2，只要值為 <code>BigInt</code> 就直接回傳值，所以不會跑到步驟 3：</p><p><img src="../images/javascript-bigint/2020-10-07-22-54-27.png" alt=""></p><blockquote><p>步驟 1 的 <a href="https://www.ecma-international.org/ecma-262/#sec-toprimitive" target="_blank" rel="noopener"><code>ToPrimitive()</code></a> 只會對型別為 <code>Object</code> 的值才會有特殊行為，所以本篇會跳過這邊的細節 XD，<s>否則篇幅會更長</s>，在這裡可以簡單當作將 <code>BigInt</code> 型別的值傳給 <code>ToPrimitive()</code> 會回傳一樣的值，不會有任何強制轉型的行為。</p><p><img src="../images/javascript-bigint/2020-10-07-23-07-02.png" alt=""></p></blockquote><p>接著回到 <a href="https://www.ecma-international.org/ecma-262/#sec-addition-operator-plus" target="_blank" rel="noopener"><code>+</code> 運算子</a>的步驟 (圖重貼一次)：</p><ul><li>在步驟 8 和 9 時，其中一個值的型別為 <code>Number</code>，另一個為 <code>BigInt</code> (因為前面的範例是 <code>1n + 2</code> )</li><li>在步驟 10 只要兩個值的型別不同，就會拋出 <code>TypeError</code> exception</li></ul><p><img src="../images/javascript-bigint/2020-10-07-22-51-23.png" alt=""></p><p>所以這就是 <code>BigInt</code> 不能和 <code>Number</code> 一起使用的原因。</p><h2 id="可與-String-進行串接"><a class="header-anchor" href="#可與-String-進行串接"></a>可與 <code>String</code> 進行串接</h2><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1n</span> + <span class="hljs-string">'2'</span>);<br><span class="hljs-comment">// 12</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2'</span> + <span class="hljs-number">1n</span>);<br><span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><h2 id="BigInt-constructor-不能傳入-Number-或-String-型別的小數"><a class="header-anchor" href="#BigInt-constructor-不能傳入-Number-或-String-型別的小數"></a><code>BigInt()</code> constructor 不能傳入 <code>Number</code> 或 <code>String</code> 型別的小數</h2><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(BigInt(<span class="hljs-number">2.5</span>));<br><span class="hljs-comment">// RangeError: The number 2.5 cannot be converted to a BigInt because it is not an integer</span><br><span class="hljs-built_in">console</span>.log(BigInt(<span class="hljs-string">'2.5'</span>));<br><span class="hljs-comment">// SyntaxError: Cannot convert 2.5 to a BigInt</span><br></code></pre></td></tr></table></figure><p>下面是 <a href="https://www.ecma-international.org/ecma-262/#sec-bigint-constructor-number-value" target="_blank" rel="noopener"><code>BigInt()</code> constructor</a> 在 spec 的定義：</p><ul><li>步驟 2：將值進行 <code>ToPrimitive()</code> 強制轉型</li><li>步驟 3：若值的型別為 <code>Number</code>，則進行 <code>NumberToBigInt(prim)</code> 強制轉型</li><li>步驟 4：進行 <code>ToBigInt()</code> 強制轉型</li></ul><p><img src="../images/javascript-bigint/2020-10-07-23-36-42.png" alt=""></p><p>先來看為何不能傳入 <code>Number</code> 型別的小數？這跟步驟 3 有關，會進行 <code>NumberToBigInt(prim)</code> 強制轉型，spec 的定義如下：</p><ul><li>步驟 2：若值不是整數就會拋出 <code>RangeError</code> exception</li></ul><p><img src="../images/javascript-bigint/2020-10-07-23-39-43.png" alt=""></p><p>那為何不能傳入 <code>String</code> 型別的小數？這跟步驟 4 有關，會進行 <a href="https://www.ecma-international.org/ecma-262/#sec-tobigint" target="_blank" rel="noopener"><code>ToBigInt()</code></a> 強制轉型，spec 的定義如下：</p><ul><li>步驟 1：進行 <code>StringToBigInt()</code> 強制轉型</li><li>步驟 2：若強制轉型的結果為 <code>NaN</code>，會拋出 <code>SyntaxError</code> exception</li></ul><p><img src="../images/javascript-bigint/2020-10-08-09-09-48.png" alt=""></p><p>而下面是 <a href="https://www.ecma-international.org/ecma-262/#sec-stringtobigint" target="_blank" rel="noopener"><code>StringToBigInt()</code></a> 的定義：</p><ul><li>用 <a href="https://www.ecma-international.org/ecma-262/#prod-DecimalDigits" target="_blank" rel="noopener">DecimalDigits</a> 取代 <a href="https://www.ecma-international.org/ecma-262/#prod-StrUnsignedDecimalLiteral" target="_blank" rel="noopener">StrUnsignedDecimalLiteral</a> production，以不允許 <code>Infinity</code>、小數點或指數</li><li>若 <a href="https://www.ecma-international.org/ecma-262/#mathematical-value" target="_blank" rel="noopener">MV (mathematical value)</a> 為 <code>NaN</code>，則回傳 <code>NaN</code>，否則回傳與 MV 完全對應的 <code>BigInt</code>，而不是四捨五入成 <code>Number</code></li></ul><p><img src="../images/javascript-bigint/2020-10-08-08-16-33.png" alt=""></p><p>所以字串會透過 <code>StringToBigInt()</code> 強制轉行成 <code>NaN</code>，就會拋出 <code>SyntaxError</code> exception。</p><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://github.com/tc39/proposal-bigint" target="_blank" rel="noopener">tc39/proposal-bigint: Arbitrary precision integers in JavaScript</a></li><li><a href="https://2ality.com/2017/03/es-integer.html" target="_blank" rel="noopener">ECMAScript feature: BigInt - arbitrary precision integers | 2ality</a></li><li><a href="https://v8.dev/features/bigint" target="_blank" rel="noopener">BigInt: arbitrary-precision integers in JavaScript · V8</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇介紹 ES2020 (ES11) 提供的 &lt;code&gt;BigInt&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://titangene.github.io/categories/javascript/"/>
    
    
      <category term="IT 鐵人賽" scheme="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
      <category term="ECMAScript" scheme="https://titangene.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 之旅 (13)：Object Rest/Spread Properties</title>
    <link href="https://titangene.github.io/article/javascript-object-rest-spread-properties.html"/>
    <id>https://titangene.github.io/article/javascript-object-rest-spread-properties.html</id>
    <published>2020-09-28T06:55:20.000Z</published>
    <updated>2020-10-04T15:08:57.551Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/javascript.jpg" alt=""></p><p>本篇介紹 ES2018 (ES9) 提供的 object rest/spread properties。</p><a id="more"></a><blockquote><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10245719" target="_blank" rel="noopener">JavaScript 之旅 (13)：Object Rest/Spread Properties</a></p><p>「JavaScript 之旅」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/3607" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><p>在 ES6 時，引入了以下特性：</p><ul><li>用於陣列解構賦值的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">rest 元素</a></li><li>用於陣列字面值 (literal) 的 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener">spread 元素</a></li></ul><p>而此 <a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">提案</a> 是在 ES2018 (ES9) 引入了以下特性：</p><ul><li>用於物件解構賦值的 rest properties</li><li>用於物件字面值的 spread properties</li></ul><h1 id="Rest-Properties"><a class="header-anchor" href="#Rest-Properties"></a>Rest Properties</h1><p>rest properties 會收集剩餘的 own enumerable property keys，這些 key 都未被解構 pattern 選取。這些 key 和值會複製至新的物件上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; id, name, ...otherProps &#125; = &#123;<br>  id: <span class="hljs-number">1</span>,<br>  name: <span class="hljs-string">'Titan'</span>,<br>  sex: <span class="hljs-string">'Male'</span>,<br>  age: <span class="hljs-number">18</span><br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(id);<br><span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(name);<br><span class="hljs-comment">// Titan</span><br><span class="hljs-built_in">console</span>.log(otherProps);<br><span class="hljs-comment">// &#123;sex: "Male", age: 18&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Error"><a class="header-anchor" href="#Error"></a>Error</h2><p>有些情況下會報錯，例如：</p><h3 id="Runtime-Error"><a class="header-anchor" href="#Runtime-Error"></a>Runtime Error</h3><p>不能解構賦值 <code>null</code>，否則會出現 <code>TypeError</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> data = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> &#123; x, y, ...z &#125; = data;<br><span class="hljs-comment">// TypeError: Cannot destructure property 'x' of 'null' as it is null.</span><br></code></pre></td></tr></table></figure><p>解決方法就是給初始值，初始值為空物件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> data = <span class="hljs-literal">null</span> ?? &#123;&#125;;<br><span class="hljs-keyword">let</span> &#123; x, y, ...z &#125; = data;<br><br><span class="hljs-built_in">console</span>.log(x);<br><span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(y);<br><span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(z);<br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="Static-Error"><a class="header-anchor" href="#Static-Error"></a>Static Error</h3><p>rest property 一定要放在最後一個，否則會出現 <code>SyntaxError</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; ...x, y, z &#125; = &#123;&#125;;<br><span class="hljs-comment">// SyntaxError: Rest element must be last element</span><br></code></pre></td></tr></table></figure><p>並且只能有一個 rest property：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; x, ...y, ...z &#125; = &#123;&#125;;<br><span class="hljs-comment">// SyntaxError: Rest element must be last element</span><br></code></pre></td></tr></table></figure><h2 id="clone-物件"><a class="header-anchor" href="#clone-物件"></a>clone 物件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> post = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'xxx'</span>&#125;;<br><span class="hljs-keyword">let</span> &#123; ...clonedPost &#125; = post;<br><br><span class="hljs-built_in">console</span>.log(clonedPost);<br><span class="hljs-comment">// &#123;id: 1, title: "xxx"&#125;</span><br><span class="hljs-built_in">console</span>.log(post === clonedPost);<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>但不包含 prototype，只會複製 own enumerable property：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> post = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'xxx'</span>&#125;;<br><span class="hljs-keyword">let</span> extendedPost = <span class="hljs-built_in">Object</span>.create(post);<br>extendedPost.likeCount = <span class="hljs-number">666</span>;<br>extendedPost.shareCount = <span class="hljs-number">99</span>;<br><br><span class="hljs-keyword">let</span> &#123; ...clonedPost &#125; = extendedPost;<br><span class="hljs-built_in">console</span>.log(clonedPost);<br><span class="hljs-comment">// &#123;likeCount: 666, shareCount: 99&#125;</span><br></code></pre></td></tr></table></figure><h2 id="巢狀物件"><a class="header-anchor" href="#巢狀物件"></a>巢狀物件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> post = &#123;<br>  emoji: &#123; <span class="hljs-attr">like</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">love</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">wow</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">haha</span>: <span class="hljs-number">4</span> &#125;,<br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123;<br>  emoji: &#123; <span class="hljs-attr">like</span>: likeCount, ...otherEmojis &#125;,<br>&#125; = post;<br><br><span class="hljs-built_in">console</span>.log(likeCount);<br><span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(otherEmojis);<br><span class="hljs-comment">// &#123;love: 2, wow: 3, haha: 4&#125;</span><br></code></pre></td></tr></table></figure><h2 id="函數擴充額外的-option"><a class="header-anchor" href="#函數擴充額外的-option"></a>函數擴充額外的 option</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseFunc</span>(<span class="hljs-params">&#123; a, b &#125;</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`a: <span class="hljs-subst">$&#123;a&#125;</span>`</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`b: <span class="hljs-subst">$&#123;b&#125;</span>`</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapperFunc</span>(<span class="hljs-params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`x: <span class="hljs-subst">$&#123;x&#125;</span>`</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`y: <span class="hljs-subst">$&#123;y&#125;</span>`</span>);<br>  <span class="hljs-built_in">console</span>.log(restConfig);<br>  <span class="hljs-keyword">return</span> baseFunc(restConfig);<br>&#125;<br><br>wrapperFunc(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span>&#125;);<br><span class="hljs-comment">// x: 4</span><br><span class="hljs-comment">// y: 5</span><br><span class="hljs-comment">// &#123;a: 1, b: 2&#125;</span><br><span class="hljs-comment">// a: 1</span><br><span class="hljs-comment">// b: 2</span><br></code></pre></td></tr></table></figure><h2 id="重新組合物件"><a class="header-anchor" href="#重新組合物件"></a>重新組合物件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> assembled = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">4</span> &#125;;<br><span class="hljs-keyword">let</span> &#123; x, y, ...z &#125; = assembled;<br><span class="hljs-keyword">let</span> reassembled = &#123; x, ...z &#125;;<br><br><span class="hljs-built_in">console</span>.log(reassembled);<br><span class="hljs-comment">// &#123;x: 1, a: 3, b: 4&#125;</span><br></code></pre></td></tr></table></figure><hr><h1 id="Spread-Properties"><a class="header-anchor" href="#Spread-Properties"></a>Spread Properties</h1><p>物件 initializer 中的 spread properties 會將 own enumerable properties 從提供的物件複製到新建立的物件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> name = <span class="hljs-string">'Titan'</span>;<br><span class="hljs-keyword">let</span> otherProps = &#123;<br>  sex: <span class="hljs-string">'Male'</span>,<br>  age: <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-keyword">let</span> person = &#123; id, name, ...otherProps &#125;;<br><span class="hljs-built_in">console</span>.log(person);<br><span class="hljs-comment">// &#123;id: 1, name: "Titan", sex: "Male", age: 18&#125;</span><br></code></pre></td></tr></table></figure><p>若值為 <code>null</code> 或 <code>undefined</code> 會被忽略：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> emptyObject = &#123; ...null, ...undefined &#125;;<br><span class="hljs-built_in">console</span>.log(emptyObject);<br><span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="clone-物件-v2"><a class="header-anchor" href="#clone-物件-v2"></a>clone 物件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> post = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'xxx'</span>&#125;;<br><span class="hljs-keyword">let</span> clonedPost = &#123;...post&#125;;<br><br><span class="hljs-built_in">console</span>.log(clonedPost);<br><span class="hljs-comment">// &#123;id: 1, title: "xxx"&#125;</span><br><span class="hljs-built_in">console</span>.log(post === clonedPost);<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>過去可能會用 <code>Object.assign()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> post = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'xxx'</span>&#125;;<br><span class="hljs-keyword">let</span> clonedPost = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, post);<br><br><span class="hljs-built_in">console</span>.log(clonedPost);<br><span class="hljs-comment">// &#123;id: 1, title: "xxx"&#125;</span><br><span class="hljs-built_in">console</span>.log(post === clonedPost);<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="合併多個物件：預設-property-被更新值覆寫-property"><a class="header-anchor" href="#合併多個物件：預設-property-被更新值覆寫-property"></a>合併多個物件：預設 property 被更新值覆寫 property</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> initUser = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">age</span>: <span class="hljs-literal">null</span>&#125;;<br><span class="hljs-keyword">let</span> updateUser = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'Titan'</span>&#125;;<br><span class="hljs-keyword">let</span> user = &#123;...initUser, ...updateUser&#125;;<br><br><span class="hljs-built_in">console</span>.log(user);<br><span class="hljs-comment">// &#123;name: "Titan", age: null&#125;</span><br></code></pre></td></tr></table></figure><p>過去可能會用 <code>Object.assign()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> initUser = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">age</span>: <span class="hljs-literal">null</span>&#125;;<br><span class="hljs-keyword">let</span> updateUser = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'Titan'</span>&#125;;<br><span class="hljs-keyword">let</span> user = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, initUser, updateUser);<br><br><span class="hljs-built_in">console</span>.log(user);<br><span class="hljs-comment">// &#123;name: "Titan", age: null&#125;</span><br></code></pre></td></tr></table></figure><h2 id="合併-property"><a class="header-anchor" href="#合併-property"></a>合併 property</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> date = &#123;<span class="hljs-attr">from</span>: <span class="hljs-string">'2020-01-01'</span>, <span class="hljs-attr">to</span>: <span class="hljs-string">'2020-06-01'</span>&#125;;<br><span class="hljs-keyword">let</span> activity = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, ...date&#125;;<br><br><span class="hljs-built_in">console</span>.log(activity);<br><span class="hljs-comment">// &#123;id: 1, from: "2020-01-01", to: "2020-06-01"&#125;</span><br></code></pre></td></tr></table></figure><p>過去可能會用 <code>Object.assign()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> date = &#123;<span class="hljs-attr">from</span>: <span class="hljs-string">'2020-01-01'</span>, <span class="hljs-attr">to</span>: <span class="hljs-string">'2020-06-01'</span>&#125;;<br><span class="hljs-keyword">let</span> id = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> activity = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, &#123;id&#125;, date);<br><br><span class="hljs-built_in">console</span>.log(activity);<br><span class="hljs-comment">// &#123;id: 1, from: "2020-01-01", to: "2020-06-01"&#125;</span><br></code></pre></td></tr></table></figure><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">tc39/proposal-object-rest-spread: Rest/Spread Properties for ECMAScript</a></li><li><a href="https://exploringjs.com/es2018-es2019/ch_rest-spread-properties.html" target="_blank" rel="noopener">Rest/Spread Properties | Exploring ES2018 and ES2019</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇介紹 ES2018 (ES9) 提供的 object rest/spread properties。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://titangene.github.io/categories/javascript/"/>
    
    
      <category term="IT 鐵人賽" scheme="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
      <category term="ECMAScript" scheme="https://titangene.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 之旅 (8)：Promise.prototype.finally()</title>
    <link href="https://titangene.github.io/article/javascript-promise-finally.html"/>
    <id>https://titangene.github.io/article/javascript-promise-finally.html</id>
    <published>2020-09-23T06:55:20.000Z</published>
    <updated>2020-09-27T13:37:24.820Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/javascript.jpg" alt=""></p><p>本篇介紹 ES2018 (ES9) 提供的 <code>Promise.prototype.finally()</code>。</p><a id="more"></a><blockquote><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10242649" target="_blank" rel="noopener">JavaScript 之旅 (8)：Promise.prototype.finally()</a></p><p>「JavaScript 之旅」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/3607" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><p>下面是幾個非同步處理很常見的情境：</p><ul><li>進入某頁面時，會立即發 AJAX request，在拿到 response 之前都會顯示「正在載入…」的訊息，不管是拿到 response，還是發生錯誤，都會隱藏「正在載入…」</li><li>不管某個操作是否完成，都要紀錄 log</li><li>建立 DB 連線來搜尋資料時，不管是成功拿到，還是中途出現錯誤，都要關閉連線釋放資源</li></ul><p>以上情境都有一個共通點：不管做什麼事，最後都要做某件事。</p><p>也許你會想到 <code>try-finally</code>，會希望非同步處理的 <code>Promise</code> 上也有 finally 的功能 (我自己是沒想過啦 XD)，這就是今天要介紹的 <code>Promise.prototype.finally()</code>！</p><p>在過去原生的 <code>Promise</code> 沒有提供 finally 功能時，很多 library 都在非同步處理的 API 上實作了 <code>finally()</code> 方法，此方法是用來註冊一個在 promise settled 時 (即 fulfilled 或 rejected) invoke 用的 callback。</p><blockquote><p>更多 library 的實作可參閱：</p><ul><li><a href="http://bluebirdjs.com/docs/api/finally.html" target="_blank" rel="noopener">Bluebird#finally</a></li><li><a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback" target="_blank" rel="noopener">Q#finally</a></li><li><a href="https://github.com/cujojs/when/blob/master/docs/api.md#promisefinally" target="_blank" rel="noopener">when#finally</a></li><li><a href="https://api.jquery.com/jQuery.ajax/#jqXHR" target="_blank" rel="noopener">jQuery jqXHR#always</a></li></ul></blockquote><p>在 ES2018 (ES9) 提供了 <code>Promise.prototype.finally()</code> 新的 <code>Promise</code> method。當 promise settled 時 (即 fulfilled 或 rejected)，會執行指定的 callback。</p><h1 id="Promise-Chain"><a class="header-anchor" href="#Promise-Chain"></a>Promise Chain</h1><p>先說明什麼是 promise chain，因為之後會常常看到這個專有名詞。</p><p>將多個 <code>Promise</code> 串在一起，以表達一個序列的非同步執行步驟，而這個序列就是 promise chain。</p><p>那為何是 chain？因為每次在 <code>Promise</code> 上呼叫 <code>.then()</code>、<code>.catch()</code>、<code>.finally()</code> 等 <code>Promise</code> method 時，都會建立並回傳新的 <code>Promise</code>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Hi'</span>)<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Oops'</span>);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>  &#125;)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// OK</span><br><span class="hljs-comment">// Hi</span><br><span class="hljs-comment">// Oops</span><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><h1 id="Promise-prototype-finally-的回傳值永遠是-Promise"><a class="header-anchor" href="#Promise-prototype-finally-的回傳值永遠是-Promise"></a><code>Promise.prototype.finally()</code> 的回傳值永遠是 <code>Promise</code></h1><p><code>Promise.prototype.finally()</code> 的回傳值永遠是 <code>Promise</code> 物件，該 promise 可能會 fulfilled 或 rejected，那何時會 fulfilled？還是會 rejected？</p><p>先講結論：要看你的 promise chain 是怎麼寫的</p><ul><li>若 <code>.finally()</code> 的前一個 Promise 是 fulfilled，那 <code>.finally()</code> 回傳的 <code>Promise</code> 就會是 fulfilled</li><li>若 <code>.finally()</code> 的前一個 Promise 是 rejected，那 <code>.finally()</code> 回傳的 <code>Promise</code> 就會是 rejected</li></ul><p>先看幾個範例：</p><p>假設我先執行 <code>Promise.resolve('OK')</code>，該 promise 會立即 fulfilled，將 <code>OK</code> 傳給 <code>.then()</code> 的 callback，所以第一個輸出訊息會是 <code>OK</code>，接著執行 <code>.finally()</code>，並將 <code>.finally()</code> 的回傳值存在一個名為 <code>promiseA</code> 的變數：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseA = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(result);<br>  &#125;)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// OK</span><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><p>接著印出 <code>promiseA</code>，它是一個 <code>Promise</code> 物件，該 promise 已經 fulfilled 了，且 fulfilled 的值為 <code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(promiseA);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><br></code></pre></td></tr></table></figure><p>那為何 fulfilled 的值會是 <code>undefined</code>，因為在 promise chain 中，<code>.finally()</code> 的前一個 Promise 是 <code>.then()</code> 回傳的，而 <code>.then()</code> 的 callback 沒有回傳值，所以才會是 <code>undefined</code>。</p><blockquote><p>所以不要搞錯了，<code>promiseA</code> 存的不是 <code>Promise.resolve('OK')</code> 回傳的 <code>Promise</code> 物件，而是最後一個 promise chain 的。</p></blockquote><p>那再看下一個範例，這次拿到 <code>.then()</code> 這個步驟，一樣將的回傳值存起來，存在一個名為 <code>promiseB</code> 的變數：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseB = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><p>接著印出 <code>promiseB</code>，該 promise 一樣已經 fulfilled 了，但這次 fulfilled 的值是 <code>OK</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(promiseB);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "OK"&#125;</span><br></code></pre></td></tr></table></figure><p>為什麼會是 <code>OK</code>？因為在 promise chain 中，<code>.finally()</code> 的前一個 Promise 是 <code>Promise.resolve('OK')</code> 回傳的，該 <code>Promise</code> fulfilled 的值就是 <code>OK</code>，所以才會是 <code>OK</code>。</p><p>所以就如同前面結論說的，<code>.finally()</code> 回傳的 <code>Promise</code> 是 fulfilled 還是 rejected，是依據 promise chain 中前一個 Promise 來決定的。</p><h1 id="Promise-prototype-finally-的-callback"><a class="header-anchor" href="#Promise-prototype-finally-的-callback"></a><code>Promise.prototype.finally()</code> 的 callback</h1><h2 id="Promise-prototype-finally-的-callback-沒有-argument"><a class="header-anchor" href="#Promise-prototype-finally-的-callback-沒有-argument"></a><code>Promise.prototype.finally()</code> 的 callback 沒有 argument</h2><p><code>.then()</code> 和 <code>.catch()</code> 的 callback 會有 argument，而該 argument 是在 promise chain 中，前一個 Promise 的 fulfilled 值或 rejected 值。</p><p>但 <code>Promise.prototype.finally()</code> 的 callback 是沒有 argument 的，若你還是寫了 argument，其值也會是 <code>undefined</code>，不管 promise chain 中的前一個 Promise 的 fulfilled 或 rejected：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>  &#125;);<br><br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Oops'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>  &#125;);<br><br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h2 id="Promise-prototype-finally-的-callback-會被忽略-return"><a class="header-anchor" href="#Promise-prototype-finally-的-callback-會被忽略-return"></a><code>Promise.prototype.finally()</code> 的 callback 會被忽略 <code>return</code></h2><p><code>Promise.prototype.finally()</code> 的 callback 中的 <code>return</code> 會被忽略，但回傳的 <code>Promise</code> 的 fulfilled 值或 rejected 值會是 promise chain 中，前一個 Promise 的 fulfilled 值或 rejected 值。：</p><p>例如：<code>Promise.resolve('OK')</code> 會立即 fulfilled，接著在 <code>.finally()</code> 內 <code>return</code> 會被忽略，但 <code>.finally()</code> 回傳的 <code>Promise</code> 的 fulfilled 值會跟 <code>Promise.resolve('OK')</code> 回傳的 fulfilled 值相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally...'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'finally'</span>;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>若拆開 promise chain 就會更容易看出來：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseA = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>);<br><span class="hljs-built_in">console</span>.log(promiseA);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "OK"&#125;</span><br><br><br><span class="hljs-keyword">let</span> promiseB = promiseA.finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally...'</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">'finally'</span>;<br>&#125;);<br><span class="hljs-comment">// finally...</span><br><br><span class="hljs-built_in">console</span>.log(promiseB);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "OK"&#125;</span><br><br><br><span class="hljs-keyword">let</span> promiseC = promiseB.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;);<br><span class="hljs-comment">// OK</span><br><br><span class="hljs-built_in">console</span>.log(promiseC);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "undefined"&#125;</span><br></code></pre></td></tr></table></figure><p>promise rejected 的情況也一樣，你可以試著將上面的 <code>Promise.resolve('OK')</code> 改成 <code>Promise.reject('Oops')</code> 觀察看看。</p><h1 id="Promise-prototype-finally-vs-finally-clause"><a class="header-anchor" href="#Promise-prototype-finally-vs-finally-clause"></a><code>Promise.prototype.finally()</code> vs. <code>finally</code> clause</h1><p>先來看兩者的寫法。</p><p>下面是 <code>Promise.prototype.finally()</code> 的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(result);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>);<br>  &#125;)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// OK</span><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><p>而下面是 <code>try</code> 陳述句中 <code>finally</code> clause 的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK'</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>&#125;<br><br><span class="hljs-comment">// OK</span><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><p>兩者有些地方很相識，但用法和行為都不同，下面會提出它們的不同之處。</p><h2 id="return-值"><a class="header-anchor" href="#return-值"></a><code>return</code> 值</h2><p><code>Promise.prototype.finally()</code> 會回傳 <code>Promise</code>，該 <code>Promise</code> 可能會 fulfilled 或 rejected (前面有說明)。</p><p>而 <code>finally</code> 只是 <code>try</code> 陳述句中的 clause，若在 <code>finally</code> clause 內 <code>return</code> 某個值會成為 function 的回傳值。</p><p>例如：在 <code>func()</code> 函數中，<code>finally</code> clause 內 <code>return</code> 的 <code>func</code> 就成為此函數的回傳值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'try'</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'catch'</span>);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'func'</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> result = func();<br><span class="hljs-comment">// try</span><br><span class="hljs-comment">// finally</span><br><br><span class="hljs-built_in">console</span>.log(result);<br><span class="hljs-comment">// "func"</span><br></code></pre></td></tr></table></figure><h2 id="throw-值"><a class="header-anchor" href="#throw-值"></a><code>throw</code> 值</h2><p>若在 <code>finally</code> clause 內使用 <code>throw</code>，需要讓另一個 <code>try-catch</code> 來捕捉錯誤：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'try'</span>);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops'</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>  func();<br>&#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>  <span class="hljs-built_in">console</span>.log(error);<br>&#125;<br><br><span class="hljs-comment">// try</span><br><span class="hljs-comment">// finally</span><br><span class="hljs-comment">// Error: Oops</span><br><span class="hljs-comment">//     at func (&lt;anonymous&gt;:6:11)</span><br><span class="hljs-comment">//     at &lt;anonymous&gt;:11:3</span><br></code></pre></td></tr></table></figure><p>而在 <code>Promise.prototype.finally()</code> 的 callback 中使用 <code>throw</code>，會讓回傳的 <code>Promise</code> rejected：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseA = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(result);<br>  &#125;);<br><br><span class="hljs-comment">// OK</span><br><br><span class="hljs-built_in">console</span>.log(promiseA);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><br><br><br><span class="hljs-keyword">let</span> promiseB = promiseA.finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// finally</span><br><span class="hljs-comment">// Uncaught (in promise) Error: Oops</span><br><span class="hljs-comment">//     at &lt;anonymous&gt;:3:11</span><br><span class="hljs-comment">//     at &lt;anonymous&gt;</span><br><br><span class="hljs-built_in">console</span>.log(promiseB);<br><span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: Error: Oops</span><br><span class="hljs-comment">//     at &lt;anonymous&gt;:3:11</span><br><span class="hljs-comment">//     at &lt;anonymous&gt;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="一定會執行的-finally"><a class="header-anchor" href="#一定會執行的-finally"></a>一定會執行的 finally</h2><p><code>Promise.prototype.finally()</code> 和 <code>finally</code> clause 的其中一個共通點就是一定會執行。</p><h3 id="finally-clause-一定會在最後執行"><a class="header-anchor" href="#finally-clause-一定會在最後執行"></a><code>finally</code> clause 一定會在最後執行</h3><p>先來說明 <code>finally</code> clause。</p><p>在函數內的 <code>try</code> clause 或 <code>catch</code> clause 裡面 <code>return</code> 某個值，函數會在回傳該值之前，先執行 <code>finally</code> clause 內的程式碼 (所以 <code>finally</code> 就如其名，真的是「最後」)。</p><p>例如：在 <code>try</code> clause 內 <code>return</code> 值，不會在回傳後直接結束此函數的執行，而是會在回傳之前先執行 <code>finally</code> clause 內的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'try'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'func'</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'catch'</span>);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(func());<br><span class="hljs-comment">// try</span><br><span class="hljs-comment">// finally</span><br><span class="hljs-comment">// "func"</span><br></code></pre></td></tr></table></figure><p>另一個範例：在 <code>catch</code> clause 內 <code>return</code> 值，不會在回傳後直接結束此函數的執行，而是會在回傳之前先執行 <code>finally</code> clause 內的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'catch'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'func'</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(func());<br><span class="hljs-comment">// catch</span><br><span class="hljs-comment">// finally</span><br><span class="hljs-comment">// "func"</span><br></code></pre></td></tr></table></figure><h3 id="不管是-fulfilled-或-rejected，Promise-prototype-finally-的-callback-都會執行"><a class="header-anchor" href="#不管是-fulfilled-或-rejected，Promise-prototype-finally-的-callback-都會執行"></a>不管是 fulfilled 或 rejected，<code>Promise.prototype.finally()</code> 的 callback 都會執行</h3><p>不管 <code>Promise</code> 是 fulfilled 或 rejected 都會執行 <code>Promise.prototype.finally()</code> 的 callback。</p><p>例如：<code>Promise.resolve('OK')</code> 會回傳的 promise 立即 fulfilled 後，會執行 <code>.finally()</code> 的 callback：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseA = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// finally</span><br><br><span class="hljs-built_in">console</span>.log(promiseA);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "OK"&#125;</span><br></code></pre></td></tr></table></figure><p>另一個例子：<code>Promise.reject('Oops')</code> 會回傳的 promise 立即 rejected 後，會執行 <code>.finally()</code> 的 callback：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseB = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Oops'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-built_in">console</span>.log(promiseB);<br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><h1 id="Promise-prototype-finally-vs-Promise-prototype-then-func-func"><a class="header-anchor" href="#Promise-prototype-finally-vs-Promise-prototype-then-func-func"></a><code>Promise.prototype.finally()</code> vs. <code>Promise.prototype.then(func, func)</code></h1><p><code>.finally()</code> 和 <code>.then(onFinally, onFinally)</code> 很像，但有些差別。</p><p>因為沒有可靠的方法來確定 promise 是 fulfilled 或 rejected，所以 <code>.finally()</code> 的 callback 不會接收到任何 argument。代表這適用於不管是 fulfilled 還是 rejected 的情況。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;);<br><span class="hljs-comment">// Promise &#123;&lt;resolved&gt;: undefined&#125;</span><br><br><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;);<br><span class="hljs-comment">// Promise &#123;&lt;resolved&gt;: 2&#125;</span><br><br><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;);<br><span class="hljs-comment">// Promise &#123;&lt;resolved&gt;: undefined&#125;</span><br><br><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;);<br><span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: 3&#125;</span><br></code></pre></td></tr></table></figure><p><code>.finally()</code> 可避免在 <code>then()</code> 和 <code>catch()</code> handler 中有重複的程式碼，即在建立 inline 函數時，可以只傳一次，避免重複宣告或為它宣告變數。</p><h1 id="情境範例"><a class="header-anchor" href="#情境範例"></a>情境範例</h1><p>前面提到一些情境，就拿其中一個作為範例。</p><p>假設進入某頁面時，會立即發 AJAX request，在拿到 response 之前都會顯示「正在載入…」的訊息，不管是拿到 response，還是發生錯誤，都會隱藏「正在載入…」。</p><p>範例程式碼如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> isLoading = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> JSON_API = <span class="hljs-string">'https://jsonplaceholder.typicode.com/posts/1'</span>;<br><span class="hljs-keyword">let</span> HTML_API = <span class="hljs-string">'https://developer.mozilla.org/en-US/docs/Web'</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> fetch(url)<br>    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isLoading:'</span>, isLoading);<br><br>      <span class="hljs-keyword">const</span> contentType = response.headers.get(<span class="hljs-string">'Content-Type'</span>);<br>      <span class="hljs-keyword">if</span> (contentType?.includes(<span class="hljs-string">'application/json'</span>)) &#123;<br>        <span class="hljs-keyword">return</span> response.json();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`Oops, we haven't got JSON!`</span>);<br>      &#125;<br>    &#125;)<br>    .then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Success'</span>);<br>      <span class="hljs-keyword">return</span> json;<br>    &#125;)<br>    .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(error);<br>    &#125;)<br>    .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      isLoading = <span class="hljs-literal">false</span>;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isLoading:'</span>, isLoading);<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 試著換成 fetchData(HTML_API)</span><br>fetchData(JSON_API).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>之後會提到 <code>?.</code> Optional Chaining 運算子。</p></blockquote><p>若 API 的 <code>Content-Type</code> 是 <code>application/json</code> (即 <code>fetch(JSON_API)</code> 這個 AJAX response)，promise 就會 fulfilled 列印出 API 資料，並且在 finally 時將 <code>isLoading</code> 設為 <code>false</code>，所以輸出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetchData(JSON_API).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>&#125;);<br><br><span class="hljs-comment">// isLoading: true</span><br><span class="hljs-comment">// Success</span><br><span class="hljs-comment">// isLoading: false</span><br><span class="hljs-comment">// &#123;userId: 1, id: 1, title: "..."&#125;</span><br></code></pre></td></tr></table></figure><p>若 API 的 <code>Content-Type</code> 不是 <code>application/json</code> (即 <code>fetch(HTML_API)</code> 這個 AJAX response)，promise 就會 rejected 列印出錯誤訊息，並且在 finally 時將 <code>isLoading</code> 設為 <code>false</code>，所以輸出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetchData(HTML_API).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>&#125;);<br><br><span class="hljs-comment">// isLoading: true</span><br><span class="hljs-comment">// TypeError: Oops, we haven't got JSON!</span><br><span class="hljs-comment">// isLoading: false</span><br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>因為不管是 <code>.then()</code> 或 <code>.catch()</code> 都要執行 <code>isLoading = false</code>，那更好的作法就是統一在 <code>.finally()</code> 執行 <code>isLoading = false</code>，這樣就不用寫重複的邏輯了。</p><p>若上面的範例改用 <code>async</code> / <code>await</code> 的寫法也許會像這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> isLoading = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> JSON_API = <span class="hljs-string">'https://jsonplaceholder.typicode.com/posts/1'</span>;<br><span class="hljs-keyword">let</span> HTML_API = <span class="hljs-string">'https://developer.mozilla.org/en-US/docs/Web'</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isLoading:'</span>, isLoading);<br><br>    <span class="hljs-keyword">const</span> contentType = response.headers.get(<span class="hljs-string">'Content-Type'</span>);<br>    <span class="hljs-keyword">if</span> (contentType?.includes(<span class="hljs-string">'application/json'</span>)) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Success'</span>);<br>      <span class="hljs-keyword">return</span> response.json();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`Oops, we haven't got JSON!`</span>);<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    isLoading = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isLoading:'</span>, isLoading);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://github.com/tc39/proposal-promise-finally" target="_blank" rel="noopener">tc39/proposal-promise-finally</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇介紹 ES2018 (ES9) 提供的 &lt;code&gt;Promise.prototype.finally()&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://titangene.github.io/categories/javascript/"/>
    
    
      <category term="IT 鐵人賽" scheme="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
      <category term="ECMAScript" scheme="https://titangene.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 之旅 (5)：String method - padStart &amp; padEnd</title>
    <link href="https://titangene.github.io/article/javascript-string-padstart-padend.html"/>
    <id>https://titangene.github.io/article/javascript-string-padstart-padend.html</id>
    <published>2020-09-20T06:55:20.000Z</published>
    <updated>2020-09-20T12:05:58.534Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/javascript.jpg" alt=""></p><p>在字串的前綴或後綴補字元，是字串處理常見的需求，過去要自行處理，終於在 ES2017 (ES8) 新增了 <code>String.prototype.padStart()</code> 和 <code>String.prototype.padEnd()</code>，解決常見的需求！本篇來介紹它們，以及在 ECMAScript spec 是如何定義的，並附上 polyfill。</p><a id="more"></a><blockquote><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10240599" target="_blank" rel="noopener">JavaScript 之旅 (5)：String method - padStart &amp; padEnd</a></p><p>「JavaScript 之旅」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/3607" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><h1 id="前言"><a class="header-anchor" href="#前言"></a>前言</h1><p>pad strings 是一個很常見的需求，例如：</p><ul><li>檔名編號的前綴，例如：<code>final-001.md</code>、<code>final-066.md</code></li><li>流水號的前綴，例如：<code>000021</code>、<code>000456</code></li><li>日期、時間，例如：<code>2020-09-20</code>、<code>09:05</code></li><li>讓 console 的輸出可以對齊：<code>Error 001: xxx</code></li><li>固定位數的二進位數字或十六進位數字，例如：<code>0010</code>、<code>0x00FF</code></li></ul><p>那過去和現代是如何處理這個需求？讓我們繼續看下去…</p><h1 id="過去的補字元"><a class="header-anchor" href="#過去的補字元"></a>過去的補字元</h1><p>也許你會自己寫個 <code>padStart()</code> 來處理補字元這種字串處理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padStart</span>(<span class="hljs-params">string, targetLength, padString = <span class="hljs-string">' '</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">Array</span>(targetLength).join(padString) + string)<br>    .slice(-targetLength)<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(padStart(<span class="hljs-string">'18'</span>, <span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>));  <span class="hljs-comment">// 0018</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padStart</span>(<span class="hljs-params">string, targetLength, padString</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> padString.repeat(<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, targetLength - string.length)) + string;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(padStart(<span class="hljs-string">'18'</span>, <span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>));  <span class="hljs-comment">// 0018</span><br></code></pre></td></tr></table></figure><p>或者從 Stack Overflow 找到不錯的解法參考一下<s>直接複製貼上</s>？上面的範例都是我從 <a href="https://stackoverflow.com/questions/2686855/is-there-a-javascript-function-that-can-pad-a-string-to-get-to-a-determined-leng" target="_blank" rel="noopener">Stack Overflow</a> 參考的 XD。</p><blockquote><p>補充一個與 <code>padStart()</code> 有關的 npm 套件：<a href="https://www.npmjs.com/package/left-pad" target="_blank" rel="noopener"><code>left-pad</code></a>，當年發生了一些故事，詳情可參閱：</p><ul><li><a href="https://www.thenewslens.com/article/39189" target="_blank" rel="noopener">他一怒之下刪除 11 行程式碼 網際網路遭殃 - The News Lens 關鍵評論網</a></li><li><a href="https://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm" target="_blank" rel="noopener">The npm Blog — kik, left-pad, and npm</a></li></ul></blockquote><h1 id="現代的-padStart-和-padEnd"><a class="header-anchor" href="#現代的-padStart-和-padEnd"></a>現代的 <code>padStart</code> 和 <code>padEnd</code></h1><p>在 ES2017 (ES8) 新增了 <code>String.prototype.padStart()</code> 和 <code>String.prototype.padEnd()</code>，終於不用自己處理常見的字串處理需求了！</p><p>語法：</p><ul><li>第一個參數都是 <code>maxLength</code></li><li>第二個參數都是 <code>fillString</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.padStart(maxLength [, fillString])<br>string.padEnd(maxLength [, fillString])<br></code></pre></td></tr></table></figure><p>這些 String 方法都會重複 <code>fillString</code> 這個字串多次，直到字串的長度到 <code>maxLength</code> 為止。</p><p><code>String.prototype.padStart()</code> 是將重複的 <code>fillString</code> 字串加在原字串的前面，而 <code>String.prototype.padEnd()</code> 是加在原字串的後面。看一些簡單的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'18'</span>.padStart(<span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>));  <span class="hljs-comment">// "0018"</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'18'</span>.padEnd(<span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>));    <span class="hljs-comment">// "1800"</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'x'</span>.padStart(<span class="hljs-number">4</span>, <span class="hljs-string">'ab'</span>));  <span class="hljs-comment">// "abax"</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'x'</span>.padEnd(<span class="hljs-number">4</span>, <span class="hljs-string">'ab'</span>));    <span class="hljs-comment">// "xaba"</span><br></code></pre></td></tr></table></figure><p>若不使用第二個參數 (即 <code>fillString</code> )，預設會是 <code>&quot; &quot;</code> (U+0020)，也就是 space：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'18'</span>.padStart(<span class="hljs-number">4</span>));  <span class="hljs-comment">// "  18"</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'18'</span>.padEnd(<span class="hljs-number">4</span>));    <span class="hljs-comment">// "18  "</span><br></code></pre></td></tr></table></figure><p>若第二個參數為 <code>''</code> (空字串)，會回傳原字串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'18'</span>.padStart(<span class="hljs-number">4</span>, <span class="hljs-string">''</span>));  <span class="hljs-comment">// "18"</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'18'</span>.padEnd(<span class="hljs-number">4</span>, <span class="hljs-string">''</span>));    <span class="hljs-comment">// "18"</span><br></code></pre></td></tr></table></figure><p>若原字串的 length &gt;= 第一個參數的值 (即 <code>maxLength</code> )，則會回傳原字串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1234'</span>.padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>));  <span class="hljs-comment">// "1234"</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1234'</span>.padEnd(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>));    <span class="hljs-comment">// "1234"</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1234'</span>.padStart(<span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>));  <span class="hljs-comment">// "1234"</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1234'</span>.padEnd(<span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>));    <span class="hljs-comment">// "1234"</span><br></code></pre></td></tr></table></figure><p>若想在 Number 型別的值前面補 0，需要先將 Number 型別強制轉型成 String 型別：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n = <span class="hljs-number">18</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(n).padStart(<span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>));  <span class="hljs-comment">// "0018"</span><br></code></pre></td></tr></table></figure><p>否則會出現 <code>TypeError</code> 的錯誤 (因為 Number 沒有 <code>padStart</code> 和 <code>padEnd</code> 這些 method)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n = <span class="hljs-number">18</span>;<br><br><span class="hljs-built_in">console</span>.log(n.padStart(<span class="hljs-number">4</span>, <span class="hljs-string">'0'</span>));<br><span class="hljs-comment">// TypeError: n.padStart is not a function</span><br></code></pre></td></tr></table></figure><h1 id="Sepc-定義"><a class="header-anchor" href="#Sepc-定義"></a>Sepc 定義</h1><p>以下是 <a href="https://www.ecma-international.org/ecma-262/#sec-string.prototype.padstart" target="_blank" rel="noopener"><code>String.prototype.padStart()</code></a> 和 <a href="https://www.ecma-international.org/ecma-262/#sec-string.prototype.padend" target="_blank" rel="noopener"><code>String.prototype.padEnd()</code></a> 在 spec 中的定義：可以看到兩者的差異不大，但步驟 2 <code>StringPad()</code> 的最後一個傳入參數不一樣</p><p><img src="../images/javascript-string-padstart-padend/2020-09-20-12-55-51.png" alt=""></p><p>傳入 <code>start</code> 和 <code>end</code> 能幹嘛？我們接續看步驟 2 <a href="https://www.ecma-international.org/ecma-262/#sec-stringpad" target="_blank" rel="noopener"><code>StringPad()</code></a> 的定義：在步驟 11 和步驟 12 就是將 <code>fillString</code> concat 在原字串的前面或後面的關鍵 (看後面的 polyfill 會更好理解)</p><p><img src="../images/javascript-string-padstart-padend/2020-09-20-13-17-08.png" alt=""></p><h1 id="polyfill"><a class="header-anchor" href="#polyfill"></a>polyfill</h1><p>下面是從 <a href="https://github.com/tc39/proposal-string-pad-start-end/blob/master/polyfill.js" target="_blank" rel="noopener">TC39 的 <code>String.prototype.padStart()</code> 和 <code>String.prototype.padEnd()</code> 提案提供的 polyfill</a> 稍做修改的 (看過剛剛的 spec 定義後，應該知道兩者只差一個步驟不同，原本的 polyfill 是將 spec 中的 <code>StringPad()</code> 都在兩者上分別實作，因邏輯可重用，我就將它抽成額外的 function 了)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> RequireObjectCoercible = <span class="hljs-function"><span class="hljs-params">O</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (O === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> O === <span class="hljs-string">'undefined'</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'"this" value must not be null or undefined'</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> O;<br>&#125;;<br><span class="hljs-keyword">const</span> MAX_SAFE_INTEGER = <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER || <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> ToLength = <span class="hljs-function"><span class="hljs-params">argument</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> len = <span class="hljs-built_in">Number</span>(argument);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.isNaN(len) || len &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (len &gt; MAX_SAFE_INTEGER) &#123;<br>    <span class="hljs-keyword">return</span> MAX_SAFE_INTEGER;<br>  &#125;<br>  <span class="hljs-keyword">return</span> len;<br>&#125;;<br><br><span class="hljs-keyword">const</span> StringPad = <span class="hljs-function">(<span class="hljs-params">O, maxLength, fillString, placement</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> S = <span class="hljs-built_in">String</span>(O);<br>  <span class="hljs-keyword">const</span> intMaxLength = ToLength(maxLength);<br>  <span class="hljs-keyword">const</span> stringLength = ToLength(S.length);<br>  <span class="hljs-keyword">if</span> (intMaxLength &lt;= stringLength) &#123;<br>    <span class="hljs-keyword">return</span> S;<br>  &#125;<br>  <span class="hljs-keyword">let</span> filler = <span class="hljs-keyword">typeof</span> fillString === <span class="hljs-string">'undefined'</span> ? <span class="hljs-string">' '</span> : <span class="hljs-built_in">String</span>(fillString);<br>  <span class="hljs-keyword">if</span> (filler === <span class="hljs-string">''</span>) &#123;<br>    <span class="hljs-keyword">return</span> S;<br>  &#125;<br>  <span class="hljs-keyword">const</span> fillLen = intMaxLength - stringLength;<br>  <span class="hljs-keyword">while</span> (filler.length &lt; fillLen) &#123;<br>    <span class="hljs-keyword">const</span> fLen = filler.length;<br>    <span class="hljs-keyword">const</span> remainingCodeUnits = fillLen - fLen;<br>    <span class="hljs-keyword">if</span> (fLen &gt; remainingCodeUnits) &#123;<br>      filler += filler.slice(<span class="hljs-number">0</span>, remainingCodeUnits);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      filler += filler;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> truncatedStringFiller = filler.slice(<span class="hljs-number">0</span>, fillLen);<br>  <span class="hljs-keyword">if</span> (placement === <span class="hljs-string">'start'</span>) &#123;<br>    <span class="hljs-keyword">return</span> truncatedStringFiller + S;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> S + truncatedStringFiller;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">String</span>.prototype.padStart) &#123;<br>  <span class="hljs-built_in">String</span>.prototype.padStart = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padStart</span>(<span class="hljs-params">maxLength, fillString = <span class="hljs-string">' '</span></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> O = RequireObjectCoercible(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> StringPad(O, maxLength, fillString, <span class="hljs-string">'start'</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">String</span>.prototype.padEnd) &#123;<br>  <span class="hljs-built_in">String</span>.prototype.padEnd = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padEnd</span>(<span class="hljs-params">maxLength, fillString = <span class="hljs-string">' '</span></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> O = RequireObjectCoercible(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> StringPad(O, maxLength, fillString, <span class="hljs-string">'end'</span>);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其他 polyfill：</p><ul><li><code>String.prototype.padStart()</code><ul><li><a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.string.pad-start.js" target="_blank" rel="noopener">core-js</a></li><li><a href="https://github.com/es-shims/String.prototype.padStart/blob/main/implementation.js" target="_blank" rel="noopener">es-shims</a></li><li><a href="https://github.com/behnammodi/polyfill/blob/master/string.polyfill.js#L281" target="_blank" rel="noopener">behnammodi</a></li></ul></li><li><code>String.prototype.padEnd()</code><ul><li><a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.string.pad-end.js" target="_blank" rel="noopener">core-js</a></li><li><a href="https://github.com/es-shims/String.prototype.padEnd/blob/main/implementation.js" target="_blank" rel="noopener">es-shims</a></li><li><a href="https://github.com/behnammodi/polyfill/blob/master/string.polyfill.js#L258" target="_blank" rel="noopener">behnammodi</a></li></ul></li></ul></blockquote><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://github.com/tc39/proposal-string-pad-start-end" target="_blank" rel="noopener">tc39/proposal-string-pad-start-end</a></li><li><a href="https://www.ecma-international.org/ecma-262/#sec-string.prototype.padstart" target="_blank" rel="noopener">21.1.3.15 String.prototype.padStart(maxLength [, fillString]) | ECMAScript 2020 Language Specification</a></li><li><a href="https://www.ecma-international.org/ecma-262/#sec-string.prototype.padend" target="_blank" rel="noopener">21.1.3.14 String.prototype.padEnd(maxLength [, fillString]) | ECMAScript 2020 Language Specification</a></li><li><a href="https://exploringjs.com/es2016-es2017/ch_string-padding.html" target="_blank" rel="noopener">8. New string methods: padStart and padEnd | Exploring ES2016 and ES2017</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;在字串的前綴或後綴補字元，是字串處理常見的需求，過去要自行處理，終於在 ES2017 (ES8) 新增了 &lt;code&gt;String.prototype.padStart()&lt;/code&gt; 和 &lt;code&gt;String.prototype.padEnd()&lt;/code&gt;，解決常見的需求！本篇來介紹它們，以及在 ECMAScript spec 是如何定義的，並附上 polyfill。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://titangene.github.io/categories/javascript/"/>
    
    
      <category term="IT 鐵人賽" scheme="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
      <category term="ECMAScript" scheme="https://titangene.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 之旅 (4)：Object.keys() &amp; Object.values() &amp; Object.entries()</title>
    <link href="https://titangene.github.io/article/javascript-object-keys-values-entries.html"/>
    <id>https://titangene.github.io/article/javascript-object-keys-values-entries.html</id>
    <published>2020-09-19T08:30:56.000Z</published>
    <updated>2020-09-20T05:43:13.088Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/javascript.jpg" alt=""></p><p>有時要將 JS 物件轉成其他資料結構，所以需要迭代物件中的所有 property，過去會用 <code>for-in</code> 陳述句，但只想列舉 own property，就必須用 <code>hasOwnProperty()</code> 才能解決。後來 ES5 新增的 <code>Object.keys()</code> 解決了非 own property 的問題，但還是要手動透過 property name 來存取 value，不方便！終於在 ES2017 (ES8) 新增了 <code>Object.values()</code> 和 <code>Object.entries()</code>，可以直接取得 property value 了！</p><p>本篇來介紹 <code>Object.values()</code>、<code>Object.keys()</code> 和 <code>Object.entries()</code>，以及在 ECMAScript spec 是如何定義的。</p><a id="more"></a><blockquote><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10239942" target="_blank" rel="noopener">JavaScript 之旅 (4)：<code>Object.values()</code> &amp; <code>Object.entries()</code></a></p><p>「JavaScript 之旅」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/3607" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><h1 id="過去的-for-in-statement"><a class="header-anchor" href="#過去的-for-in-statement"></a>過去的 <code>for-in</code> statement</h1><p>在過去只能用 <code>for-in</code> statement (陳述句) 來迭代物件中的每個 enumerable (可列舉的) property (但會忽略 key 為 <code>Symbol</code> 的 property)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rectangle = &#123;<span class="hljs-attr">width</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">9</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> rectangle) &#123;<br>  <span class="hljs-built_in">console</span>.log(key, rectangle[key]);<br>&#125;<br><span class="hljs-comment">// width 16</span><br><span class="hljs-comment">// height 9</span><br></code></pre></td></tr></table></figure><p>而且 <code>for-in</code> 陳述句也會迭代到繼承的 enumerable property：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rectangle = &#123;<span class="hljs-attr">width</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">9</span>&#125;;<br><br><span class="hljs-keyword">let</span> customRectangle = <span class="hljs-built_in">Object</span>.create(rectangle);<br>customRectangle.color = <span class="hljs-string">'blue'</span>;<br>customRectangle.name = <span class="hljs-string">'myCustom'</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> customRectangle) &#123;<br>  <span class="hljs-built_in">console</span>.log(key, customRectangle[key]);<br>&#125;<br><span class="hljs-comment">// color blue</span><br><span class="hljs-comment">// name myCustom</span><br><span class="hljs-comment">// width 16</span><br><span class="hljs-comment">// height 9</span><br></code></pre></td></tr></table></figure><p>若不想列舉繼承的 property (即只列舉 own property)，可用 <code>Object.prototype.hasOwnProperty()</code> 來判斷：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> customRectangle) &#123;<br>  <span class="hljs-keyword">if</span> (customRectangle.hasOwnProperty(key)) &#123;<br>    <span class="hljs-built_in">console</span>.log(key, customRectangle[key]);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// color blue</span><br><span class="hljs-comment">// name myCustom</span><br></code></pre></td></tr></table></figure><blockquote><p>去查 spec 才發現，原來 <code>for-in</code> 陳述句在 <a href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf" target="_blank" rel="noopener">ES1 (spec 的定義在 p.54)</a> 就有了。</p></blockquote><h1 id="過度期的-Object-keys"><a class="header-anchor" href="#過度期的-Object-keys"></a>過度期的 <code>Object.keys()</code></h1><blockquote><p>若以只想取得物件中的所有 property key，那 <code>Object.keys()</code> 就很方便，但是，若想一次拿到 property key 和 property name，<s>應該</s>就可以說 <code>Object.keys()</code> 是過度期吧？因為以現代的角度來看，還有更方便的 <code>Object.entries()</code> (後面會介紹)。</p></blockquote><p>後來在 ES5 新增了 <code>Object.keys()</code>，<s>終於可以擺脫 <code>for-in</code> 陳述句了</s>，終於可以讓 JS 物件 (間接) 使用 Array method 了！</p><p><code>Object.keys()</code> 可直接取得所有 property name。看一個簡單的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> object = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(object));  <span class="hljs-comment">// ["a", "b", "c"]</span><br></code></pre></td></tr></table></figure><p>因為 <code>Object.keys()</code> 回傳的是陣列，而 JS 的陣列是迭代物件，所以可以使用 <code>for-of</code> 陳述句來迭代：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> object = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(object)) &#123;<br>  <span class="hljs-built_in">console</span>.log(key);<br>&#125;<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// b</span><br><span class="hljs-comment">// c</span><br></code></pre></td></tr></table></figure><p>當然也可以用 <code>Array.prototype.forEach()</code> 來迭代：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> object = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-built_in">Object</span>.keys(object).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(key);<br>&#125;);<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// b</span><br><span class="hljs-comment">// c</span><br></code></pre></td></tr></table></figure><p>如果接續剛剛的範例物件，若不想列舉繼承的 property，可用 <code>Object.keys()</code>，它會幫你自動忽略 <code>Object.prototype.hasOwnProperty()</code> 為 <code>false</code> 的 property：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rectangle = &#123;<span class="hljs-attr">width</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">9</span>&#125;;<br><br><span class="hljs-keyword">let</span> customRectangle = <span class="hljs-built_in">Object</span>.create(rectangle);<br>customRectangle.color = <span class="hljs-string">'blue'</span>;<br>customRectangle.name = <span class="hljs-string">'myCustom'</span>;<br><br><span class="hljs-built_in">Object</span>.keys(customRectangle).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(key, customRectangle[key]);<br>&#125;);<br><span class="hljs-comment">// color blue</span><br><span class="hljs-comment">// name myCustom</span><br></code></pre></td></tr></table></figure><blockquote><p>後面會說明為何 <code>Object.keys()</code> 不用我們手動處理 <code>Object.prototype.hasOwnProperty()</code>，spec 其實都有定義。</p></blockquote><p>而且 <code>Object.keys()</code> 還可搭配多個 Array method 做很多事。以一個情境為例：列出排序過的 property，並以 <code>,</code> 串接所有 property。</p><p>先利用 <code>Object.keys()</code> 取得所有 property name，然後透過 <code>Array.prototype.sort()</code> 排序 property name，再用 <code>Array.prototype.join()</code> 串接陣列中的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> letterCount = &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">let</span> letters = <span class="hljs-built_in">Object</span>.keys(letterCount)<br>  .sort()<br>  .join(<span class="hljs-string">', '</span>);<br><br><span class="hljs-built_in">console</span>.log(letters);  <span class="hljs-comment">// a, b, c</span><br></code></pre></td></tr></table></figure><p>若想知道此物件有幾個 property，可用 <code>Object.keys()</code> 搭配 <code>Array.length</code> 取得：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> object = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">let</span> propertyCount = <span class="hljs-built_in">Object</span>.keys(object).length;<br><span class="hljs-built_in">console</span>.log(propertyCount);  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h1 id="現代的-Object-values-和-Object-entries"><a class="header-anchor" href="#現代的-Object-values-和-Object-entries"></a>現代的 <code>Object.values()</code> 和 <code>Object.entries()</code></h1><p>後來在 ES2017 (ES8) 新增了 <code>Object.values()</code> 和 <code>Object.entries()</code>，終於可以取得 property value 了！以前的 <code>for-in</code> 陳述句和 <code>Object.keys()</code> 都還要自己透過原物件的 property name 來存取 property value。</p><p><code>Object.values()</code> 是直接取得所有 property value，並以陣列回傳。看一個簡單的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> object = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(object));  <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>而 <code>Object.entries()</code> 是直接取得所有 property 的 name 和 value，並以陣列回傳。看一個簡單的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> object = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(object));<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//   ["a", 1],</span><br><span class="hljs-comment">//   ["b", 2],</span><br><span class="hljs-comment">//   ["c", 3]</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><p><code>Object.values()</code> 和 <code>Object.entries()</code> 跟 <code>Object.keys()</code> 一樣，都不會迭代到繼承的 property：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> rectangle = &#123;<span class="hljs-attr">width</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">9</span>&#125;;<br><br><span class="hljs-keyword">let</span> customRectangle = <span class="hljs-built_in">Object</span>.create(rectangle);<br>customRectangle.color = <span class="hljs-string">'blue'</span>;<br>customRectangle.name = <span class="hljs-string">'myCustom'</span>;<br><br><span class="hljs-built_in">Object</span>.entries(customRectangle).forEach(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(key, value);<br>&#125;);<br><span class="hljs-comment">// color blue</span><br><span class="hljs-comment">// name myCustom</span><br></code></pre></td></tr></table></figure><blockquote><p>後面會說明為何 <code>Object.values()</code> 和 <code>Object.entries()</code> 都不用我們手動處理 <code>Object.prototype.hasOwnProperty()</code>，spec 其實都有定義。</p></blockquote><p>因為 <code>Object.values()</code> 和 <code>Object.entries()</code> 都是回傳陣列，而 JS 的陣列是迭代物件，所以可以使用 <code>for-of</code> 陳述句或 Array method 進行迭代：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> object = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(object)) &#123;<br>  <span class="hljs-built_in">console</span>.log(key, value);<br>&#125;<br><span class="hljs-comment">// a 1</span><br><span class="hljs-comment">// b 2</span><br><span class="hljs-comment">// c 3</span><br><br><span class="hljs-built_in">Object</span>.entries(object).forEach(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(key, value);<br>&#125;);<br><span class="hljs-comment">// a 1</span><br><span class="hljs-comment">// b 2</span><br><span class="hljs-comment">// c 3</span><br></code></pre></td></tr></table></figure><h2 id="物件轉陣列"><a class="header-anchor" href="#物件轉陣列"></a>物件轉陣列</h2><p><code>Object.values()</code> 和 <code>Object.entries()</code> 常會搭配 Array method 一起使用，因為 <code>Object.values()</code> 和 <code>Object.entries()</code> 的回傳值都是 Array。下面實際舉個例子：</p><p>假設原本的資料是一個物件，一個 property 代表一種水果，key 是水果名稱，value 是數量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruits = &#123;<br>  apple: <span class="hljs-number">2</span>,<br>  banana: <span class="hljs-number">3</span>,<br>  orange: <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如果想計算水果總數，可用 <code>Object.values()</code> 搭配 <code>Array.prototype.reduce()</code> 來處理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fruitTotal = <span class="hljs-built_in">Object</span>.values(fruits)<br>  .reduce(<span class="hljs-function">(<span class="hljs-params">accumulator, fruitCount</span>) =&gt;</span> accumulator + fruitCount);<br><br><span class="hljs-built_in">console</span>.log(fruitTotal);  <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>若希望後續處理資料比較方便，你可能會想更改資料結構，將一種水果變為一個物件，該物件有兩個 property，分別為 <code>name</code> 和 <code>count</code>，此時就可用 <code>Object.entries()</code> 來處理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruitBasket = <span class="hljs-built_in">Object</span>.entries(fruits)<br>  .map(<span class="hljs-function">(<span class="hljs-params">[fruitName, fruitCount]</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">name</span>: fruitName, <span class="hljs-attr">count</span>: fruitCount&#125;<br>  &#125;);<br><br><span class="hljs-built_in">console</span>.log(fruitBasket);<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//   &#123;name: "apple", count: 2&#125;,</span><br><span class="hljs-comment">//   &#123;name: "banana", count: 3&#125;,</span><br><span class="hljs-comment">//   &#123;name: "orange", count: 1&#125;</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><p>這個作法有一些好處：</p><ul><li>使用 <code>Object.entries()</code> 的回傳值 (即陣列)，可搭配各種 Array method 來滿足你的需求 (變成你想要的樣子)</li><li>因為 <code>Object.entries()</code> 是產生新的陣列，不會影響到原物件，所以後續不管你用的 Array method 是否會修改該陣列，都不會影響到原物件的資料 (夠 pure)</li></ul><h2 id="Object-物件轉-Map-物件"><a class="header-anchor" href="#Object-物件轉-Map-物件"></a><code>Object</code> 物件轉 <code>Map</code> 物件</h2><p>可用 <code>Object.entries()</code> 將物件轉成 <code>Map</code> 物件，將 <code>Object.entries()</code> 回傳的可迭代 entries 傳給 <code>new Map()</code> constructor 即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruits = &#123;<br>  apple: <span class="hljs-number">2</span>,<br>  banana: <span class="hljs-number">3</span>,<br>  orange: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> fruitMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Object</span>.entries(fruits));<br><br><span class="hljs-built_in">console</span>.log(fruitMap);<br><span class="hljs-comment">// Map(3) &#123;"apple" =&gt; 2, "banana" =&gt; 3, "orange" =&gt; 1&#125;</span><br><br><span class="hljs-built_in">console</span>.log(fruitMap.get(<span class="hljs-string">'orange'</span>));  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h1 id="Sepc-定義"><a class="header-anchor" href="#Sepc-定義"></a>Sepc 定義</h1><p>以下是 <a href="https://www.ecma-international.org/ecma-262/#sec-object.keys" target="_blank" rel="noopener"><code>Object.keys()</code></a> 在 spec 中的定義：</p><p><img src="../images/javascript-object-keys-values-entries/2020-09-19-15-10-54.png" alt=""></p><p>以下是 <a href="https://www.ecma-international.org/ecma-262/#sec-object.values" target="_blank" rel="noopener"><code>Object.values()</code></a> 在 spec 中的定義：</p><p><img src="../images/javascript-object-keys-values-entries/2020-09-19-15-09-25.png" alt=""></p><p>以下是 <a href="https://www.ecma-international.org/ecma-262/#sec-object.entries" target="_blank" rel="noopener"><code>Object.entries()</code></a> 在 spec 中的定義：</p><p><img src="../images/javascript-object-keys-values-entries/2020-09-19-15-10-10.png" alt=""></p><p><code>Object.values()</code>、<code>Object.keys()</code> 和 <code>Object.entries()</code> 都是在步驟 2 使用 <code>EnumerableOwnPropertyNames()</code>，而步驟 3 都是使用 <code>CreateArrayFromList()</code>。</p><p>我們先來看 <a href="https://www.ecma-international.org/ecma-262/#sec-enumerableownpropertynames" target="_blank" rel="noopener"><code>EnumerableOwnPropertyNames()</code></a> 的定義：</p><ul><li>步驟 4：迭代所有 own property，所以每次迭代的 <code>key</code> 就是 property name</li><li>步驟 4.a.i：取得某個 own property</li><li>步驟 4.a.ii：own property 不為 <code>undefined</code>，並且是可列舉的 (enumerable) 才會繼續下個步驟</li><li>步驟 4.a.ii.1：判斷 <code>kind</code> 為 key 時，會將該 <code>key</code> push 至 <code>properties</code> (即最後我們要取得的回傳值)</li><li>步驟 4.a.ii.2.a：取得為該 property name 的 property value</li><li>步驟 4.a.ii.2.b：判斷 <code>kind</code> 為 value 時，會將該 <code>value</code> push 至 <code>properties</code></li><li>步驟 4.a.ii.2.c.ii：將 <code>key</code> 和 <code>value</code> 組合成 <code>entry</code> (即 <code>[key, value]</code> )</li><li>步驟 4.a.ii.2.c.iii：將 <code>entry</code> push 至 <code>properties</code></li><li>最後回傳 <code>properties</code></li></ul><blockquote><p>所以步驟 4 就是我們不用手動處理 <code>Object.prototype.hasOwnProperty()</code> 的關鍵！</p></blockquote><p><img src="../images/javascript-object-keys-values-entries/2020-09-19-15-17-17.png" alt=""></p><p>回來看步驟 3 的 <a href="https://www.ecma-international.org/ecma-262/#sec-createarrayfromlist" target="_blank" rel="noopener"><code>CreateArrayFromList()</code></a>，下面是它的定義：簡單來說就是建立陣列，將每個 property value 放入陣列中：</p><p><img src="../images/javascript-object-keys-values-entries/2020-09-19-15-16-39.png" alt=""></p><h1 id="polyfill"><a class="header-anchor" href="#polyfill"></a>polyfill</h1><p>下面是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="noopener">MDN 提供的 <code>Object.entries()</code> 的 polyfill</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.entries) &#123;<br>  <span class="hljs-built_in">Object</span>.entries = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> ownProps = <span class="hljs-built_in">Object</span>.keys(obj),<br>        i = ownProps.length,<br>        resArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i); <span class="hljs-comment">// preallocate the Array</span><br>    <span class="hljs-keyword">while</span> (i--)<br>      resArray[i] = [ownProps[i], obj[ownProps[i]]];<br><br>    <span class="hljs-keyword">return</span> resArray;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其他 polyfill：</p><ul><li><code>Object.keys()</code><ul><li><a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/internals/object-keys-internal.js" target="_blank" rel="noopener">core-js</a></li><li><a href="https://github.com/es-shims/object-keys/blob/main/implementation.js" target="_blank" rel="noopener">es-shims</a></li></ul></li><li><code>Object.values()</code><ul><li><a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.object.values.js" target="_blank" rel="noopener">core-js</a></li><li><a href="https://github.com/es-shims/Object.values/blob/master/implementation.js" target="_blank" rel="noopener">es-shims</a></li><li><a href="https://github.com/tc39/proposal-object-values-entries/blob/master/polyfill.js" target="_blank" rel="noopener">tc39</a></li></ul></li><li><code>Object.entries()</code><ul><li><a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.object.entries.js" target="_blank" rel="noopener">core-js</a></li><li><a href="https://github.com/es-shims/Object.entries/blob/master/implementation.js" target="_blank" rel="noopener">es-shims</a></li><li><a href="https://github.com/tc39/proposal-object-values-entries/blob/master/polyfill.js" target="_blank" rel="noopener">tc39</a></li></ul></li></ul></blockquote><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://github.com/tc39/proposal-object-values-entries" target="_blank" rel="noopener">tc39/proposal-object-values-entries</a></li><li><a href="https://www.ecma-international.org/ecma-262/#sec-object.keys" target="_blank" rel="noopener">19.1.2.17 Object.keys(O) | ECMAScript 2020 Language Specification</a></li><li><a href="https://www.ecma-international.org/ecma-262/#sec-object.values" target="_blank" rel="noopener">19.1.2.22 Object.values(O) | ECMAScript 2020 Language Specification</a></li><li><a href="https://www.ecma-international.org/ecma-262/#sec-object.entries" target="_blank" rel="noopener">19.1.2.5 Object.entries(O) | ECMAScript 2020 Language Specification</a></li><li><a href="https://exploringjs.com/es2016-es2017/ch_object-entries-object-values.html" target="_blank" rel="noopener">7. Object.entries() and Object.values() | Exploring ES2016 and ES2017</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener">Object.keys() - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank" rel="noopener">Object.values() - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="noopener">Object.entries() - JavaScript | MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;有時要將 JS 物件轉成其他資料結構，所以需要迭代物件中的所有 property，過去會用 &lt;code&gt;for-in&lt;/code&gt; 陳述句，但只想列舉 own property，就必須用 &lt;code&gt;hasOwnProperty()&lt;/code&gt; 才能解決。後來 ES5 新增的 &lt;code&gt;Object.keys()&lt;/code&gt; 解決了非 own property 的問題，但還是要手動透過 property name 來存取 value，不方便！終於在 ES2017 (ES8) 新增了 &lt;code&gt;Object.values()&lt;/code&gt; 和 &lt;code&gt;Object.entries()&lt;/code&gt;，可以直接取得 property value 了！&lt;/p&gt;&lt;p&gt;本篇來介紹 &lt;code&gt;Object.values()&lt;/code&gt;、&lt;code&gt;Object.keys()&lt;/code&gt; 和 &lt;code&gt;Object.entries()&lt;/code&gt;，以及在 ECMAScript spec 是如何定義的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://titangene.github.io/categories/javascript/"/>
    
    
      <category term="IT 鐵人賽" scheme="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
      <category term="ECMAScript" scheme="https://titangene.github.io/tags/ecmascript/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 之旅 (3)：Exponentiation Operator (指數運算子)</title>
    <link href="https://titangene.github.io/article/javascript-exponentiation-operator.html"/>
    <id>https://titangene.github.io/article/javascript-exponentiation-operator.html</id>
    <published>2020-09-18T05:36:56.000Z</published>
    <updated>2020-09-18T04:20:05.760Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/javascript.jpg" alt=""></p><p>寫程式應該很常會用到指數運算，過去我們會用 <code>Math.pow()</code>，但在 ES2016 (ES7) 提供了 exponentiation operator (指數運算子) 的讓寫法更簡潔。那這兩個差在哪？讓我們從 ECMAScript spec 中一探究竟吧。</p><a id="more"></a><blockquote><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10239196" target="_blank" rel="noopener">JavaScript 之旅 (3)：Exponentiation Operator (指數運算子)</a></p><p>「JavaScript 之旅」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/3607" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><h1 id="過去的-Math-pow"><a class="header-anchor" href="#過去的-Math-pow"></a>過去的 <code>Math.pow()</code></h1><p>過去要進行指數運算 (即計算 a 的 n 次方，表達式為 $a^n$，a 為底數，n 為指數，通常指數寫成上標，放在底數的右邊)，常用的是 <code>Math.pow()</code> (應該不會想手動寫多個 <code>*</code> 運算子 (multiplicative operators) 吧？)。例如：</p><p>平方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.pow(x, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 4</span><br><br><span class="hljs-comment">// 等同於</span><br><span class="hljs-built_in">console</span>.log(x * x);           <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>三次方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.pow(x, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 8</span><br><br><span class="hljs-comment">// 等同於</span><br><span class="hljs-built_in">console</span>.log(x * x * x);       <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p>寫成函數可能像是這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> square = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">Math</span>.pow(x, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> cube = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">Math</span>.pow(x, <span class="hljs-number">3</span>);<br><br><span class="hljs-built_in">console</span>.log(square(<span class="hljs-number">6</span>));  <span class="hljs-comment">// 36</span><br><span class="hljs-built_in">console</span>.log(cube(<span class="hljs-number">3</span>));    <span class="hljs-comment">// 27</span><br></code></pre></td></tr></table></figure><h1 id="現代的-Exponentiation-Operator"><a class="header-anchor" href="#現代的-Exponentiation-Operator"></a>現代的 Exponentiation Operator</h1><p>在 ES2016 (ES7) 提供了 exponentiation operator (指數運算子)，用於指數運算。</p><p>exponentiation 運算子是一種 <a href="https://en.wikipedia.org/wiki/Infix_notation" target="_blank" rel="noopener">infix notation (中綴表示法)</a>，比用函數表示法還要更簡潔。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> square = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span> cube = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><div class="info"><p>註：有些程式語言會用 <code>^</code> 運算子來進行指數計算，但 JavaScript 的 <code>^</code> 運算子是 [bitwise XOR 運算子(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR</a>)來進行位元運算，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;          <span class="hljs-comment">// 00000000000000000000000000000101</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span>;          <span class="hljs-comment">// 00000000000000000000000000000011</span><br><br><span class="hljs-built_in">console</span>.log(a ^ b); <span class="hljs-comment">// 00000000000000000000000000000110</span><br></code></pre></td></tr></table></figure></div><p>若與 <code>NaN</code> 計算，結果都會是 <code>NaN</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> ** <span class="hljs-number">2</span>);  <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> ** <span class="hljs-literal">NaN</span>);  <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>若與 <code>undefined</code> 計畫，結果也都會是 <code>NaN</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> ** <span class="hljs-number">2</span>);  <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> ** <span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><blockquote><p>因為 exponentiation 運算子會將指數和底數值進行 <a href="http://www.ecma-international.org/ecma-262/#sec-tonumeric" target="_blank" rel="noopener"><code>ToNumeric()</code></a> 強制轉型，很像使用 <code>Number()</code> 的行為，如果你嘗試用 <code>Number(undefined)</code> 會得到 <code>NaN</code>。</p><p>後面會提到 spec 是如何定義的。</p></blockquote><p>若與 <code>null</code> 計算，<code>null</code> 會被 <a href="http://www.ecma-international.org/ecma-262/#sec-tonumeric" target="_blank" rel="noopener"><code>ToNumeric()</code></a> 強制轉型成 <code>0</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> ** <span class="hljs-number">2</span>);  <span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 大約等同於 Number(null) ** 2，所以 0 ** 2 的計算結果為 0</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> ** <span class="hljs-literal">null</span>);  <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 大約等同於 2 ** Number(null)，所以 2 ** 0 的計算結果為 1</span><br></code></pre></td></tr></table></figure><h2 id="Associativity"><a class="header-anchor" href="#Associativity"></a>Associativity</h2><p>exponentiation 運算子的 associativity 是右到左 (即 right-associative)，也就是說，下面兩個寫法是相同的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ** <span class="hljs-number">2</span>);    <span class="hljs-comment">// 512</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> ** (<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>));  <span class="hljs-comment">// 512</span><br><br><span class="hljs-comment">// 計算過程：</span><br><span class="hljs-comment">// 1. 2 ** 3 ** 2</span><br><span class="hljs-comment">// 2. 2 ** 9</span><br><span class="hljs-comment">// 3. 512</span><br></code></pre></td></tr></table></figure><p>所以會與下面的計算結果不同，因為你讓他先計算括號的結果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log((<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>) ** <span class="hljs-number">2</span>);  <span class="hljs-comment">// 64</span><br><br><span class="hljs-comment">// 計算過程：</span><br><span class="hljs-comment">// 1. (2 ** 3) ** 2</span><br><span class="hljs-comment">// 2. 8 ** 2</span><br><span class="hljs-comment">// 3. 64</span><br></code></pre></td></tr></table></figure><blockquote><p>後面會說 spec 是如何定義的。</p></blockquote><div class="info"><p>註：在程式語言中，<a href="https://en.wikipedia.org/wiki/Operator_associativity" target="_blank" rel="noopener">operator associativity</a> 是在沒有括號時，如何將有相同優先級的運算子進行分組，運算元要用哪種運算會取決於運算子的 associativity。</p><p>分為以下幾種：</p><ul><li>associative：可任意分組運算子</li><li>left-associative：運算子從左側分組</li><li>right-associative：運算子從右側分組</li><li>non-associative：運算子不能 chained，通常是因為 output typ 和 input type 不相容</li></ul><p>詳情可參閱 <a href="https://en.wikipedia.org/wiki/Operator_associativity" target="_blank" rel="noopener">Operator associativity - Wikipedia</a>。</p></div><h2 id="Unary-Operation-的用法"><a class="header-anchor" href="#Unary-Operation-的用法"></a>Unary Operation 的用法</h2><p>不過，exponentiation 運算子不能讓你在底數前面使用 unary operation (一元運算子，包括 <code>+</code>、<code>-</code>、<code>~</code>、<code>!</code>、<code>delete</code>、<code>void</code> 和 <code>typeof</code> )，否則會出現 <code>SyntaxError</code> 錯誤，所以以下都會是 <code>SyntaxError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span> n = <span class="hljs-number">3</span>;<br><br><span class="hljs-built_in">console</span>.log(+a ** n);<br><span class="hljs-built_in">console</span>.log(-a ** n);<br><span class="hljs-built_in">console</span>.log(~a ** n);<br><span class="hljs-built_in">console</span>.log(!a ** n);<br><span class="hljs-keyword">delete</span> a ** n;<br><span class="hljs-keyword">void</span> a ** n;<br><span class="hljs-keyword">typeof</span> a ** n;<br><br><span class="hljs-comment">// SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence</span><br></code></pre></td></tr></table></figure><p>例如：要把負數當作底數就不能像下面這樣直接寫負號：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span> n = <span class="hljs-number">3</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">-2</span> ** <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(-a ** n);<br><span class="hljs-comment">// SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence</span><br></code></pre></td></tr></table></figure><blockquote><p>上面是 Chrome 的錯誤訊息，已經提醒你要加上括號。</p></blockquote><p>而是要加上括號才能計算：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log((<span class="hljs-number">-2</span>) ** <span class="hljs-number">3</span>);  <span class="hljs-comment">// -8</span><br></code></pre></td></tr></table></figure><p>另一個範例：想將指數計算結果變為負數，也需要用括號：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(-(<span class="hljs-number">2</span> ** <span class="hljs-number">10</span>));  <span class="hljs-comment">// -1024</span><br></code></pre></td></tr></table></figure><h2 id="Assignment-Operator-的用法"><a class="header-anchor" href="#Assignment-Operator-的用法"></a>Assignment Operator 的用法</h2><p>exponentiation 運算子也有 assignment operator (賦值運算子)，語法是 <code>**=</code>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;<br><br>x **= <span class="hljs-number">3</span>;<br><span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p>等同於：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;<br><br>x = x ** <span class="hljs-number">3</span>;<br><span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><h1 id="Exponentiation-Operator-vs-Math-pow"><a class="header-anchor" href="#Exponentiation-Operator-vs-Math-pow"></a>Exponentiation Operator vs. <code>Math.pow()</code></h1><p>共通點：都可以計算幾次方</p><p>但有一些不同：exponentiation 運算子可以計算 <code>BigInt</code> 型別的值，但 <code>Math.pow()</code> 不行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2n</span> ** <span class="hljs-number">3n</span>);  <span class="hljs-comment">// 8n</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2n</span>, <span class="hljs-number">3n</span>));  <span class="hljs-comment">// TypeError: Cannot convert a BigInt value to a number</span><br></code></pre></td></tr></table></figure><h1 id="Sepc-定義"><a class="header-anchor" href="#Sepc-定義"></a>Sepc 定義</h1><h2 id="Exponentiation-Operator-的-spec-定義"><a class="header-anchor" href="#Exponentiation-Operator-的-spec-定義"></a>Exponentiation Operator 的 spec 定義</h2><p><a href="http://www.ecma-international.org/ecma-262/#sec-numeric-types" target="_blank" rel="noopener">exponentiation 運算子</a>是 ECMAScript 內建 Numeric 型別 (Number 和 BigInt 型別都是 Numeric 型別) 的 operation：</p><p><img src="../images/javascript-exponentiation-operator/2020-09-18-10-40-09.png" alt=""></p><p>下面是 <a href="http://www.ecma-international.org/ecma-262/#sec-numeric-types-number-exponentiate" target="_blank" rel="noopener"><code>Number::exponentiate</code> operation</a> 的定義：</p><p><img src="../images/javascript-exponentiation-operator/2020-09-18-10-44-34.png" alt=""></p><p>下面是 <a href="http://www.ecma-international.org/ecma-262/#sec-numeric-types-bigint-exponentiate" target="_blank" rel="noopener"><code>BigInt::exponentiate</code> operation</a> 的定義：</p><p><img src="../images/javascript-exponentiation-operator/2020-09-18-10-47-35.png" alt=""></p><p>接著從 spec 定義的<a href="http://www.ecma-international.org/ecma-262/#sec-exp-operator" target="_blank" rel="noopener">語法</a>可以看出，exponentiation 運算子的 associativity 是右到左 (即 right-associative)：</p><p><img src="../images/javascript-exponentiation-operator/2020-09-18-09-32-54.png" alt=""></p><p>下面是 spec 定義 <a href="http://www.ecma-international.org/ecma-262/#sec-exp-operator-runtime-semantics-evaluation" target="_blank" rel="noopener">exponentiation 運算子的計算過程</a>：</p><p><img src="../images/javascript-exponentiation-operator/2020-09-18-10-49-57.png" alt=""></p><p>從步驟 5 和 6 可以看到，exponentiation 運算子會把底數和指數進行 <code>ToNumeric()</code> 的強制轉型。</p><p>若我故意讓底數和指數是 String 型別的值時，exponentiation 運算子就會自動幫我強制轉型成 Number 型別：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2'</span> ** <span class="hljs-string">'3'</span>);  <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p>下面是 <a href="http://www.ecma-international.org/ecma-262/#sec-tonumeric" target="_blank" rel="noopener"><code>ToNumeric()</code></a> 的定義：</p><p><img src="../images/javascript-exponentiation-operator/2020-09-18-10-53-56.png" alt=""></p><blockquote><p>至於 <code>ToNumeric()</code> 在定義中提到的 <a href="http://www.ecma-international.org/ecma-262/#sec-toprimitive" target="_blank" rel="noopener"><code>ToPrimitive()</code></a> 和 <a href="http://www.ecma-international.org/ecma-262/#sec-tonumber" target="_blank" rel="noopener"><code>ToNumber()</code></a> 是 ECMAScript 強制轉型的定義了，這邊不會深入探討，有興趣的朋友可以看看，我有附上連結。</p></blockquote><p>若以簡化的方式來說，我們常用的 <a href="http://www.ecma-international.org/ecma-262/#sec-number-constructor-number-value" target="_blank" rel="noopener"><code>Number()</code> constructor</a> 的其中一個步驟就會使用到 spec 中定義的 <a href="http://www.ecma-international.org/ecma-262/#sec-tonumeric" target="_blank" rel="noopener"><code>ToNumeric()</code></a>：</p><p><img src="../images/javascript-exponentiation-operator/2020-09-18-11-33-13.png" alt=""></p><div class="info"><p>註：不知道看到這邊會不會亂掉 XD，有些是 spec 中定義的，我們是無法透過寫程式直接使用的，例如：<code>ToNumeric()</code>、<code>ToPrimitive()</code>、<code>ToNumber()</code> 都是。</p><p>而 <code>Number()</code> 才是我們真的可以使用的 constructor。</p><p>所以不要搞混囉！</p></div><h2 id="Math-pow-的-spec-定義"><a class="header-anchor" href="#Math-pow-的-spec-定義"></a><code>Math.pow()</code> 的 spec 定義</h2><p>接著來看 <a href="http://www.ecma-international.org/ecma-262/#sec-math.pow" target="_blank" rel="noopener"><code>Math.pow()</code></a> 在 spec 的定義：</p><p><img src="../images/javascript-exponentiation-operator/2020-09-18-11-38-47.png" alt=""></p><p>可以看到 <code>Math.pow()</code> 和 exponentiation 運算子對底數和指數值的處理不同：</p><ul><li><code>Math.pow()</code> 是進行 <a href="http://www.ecma-international.org/ecma-262/#sec-tonumber" target="_blank" rel="noopener"><code>ToNumber()</code></a> 的強制轉型</li><li>exponentiation 運算子則是進行 <a href="http://www.ecma-international.org/ecma-262/#sec-tonumeric" target="_blank" rel="noopener"><code>ToNumeric()</code></a> 的強制轉型</li></ul><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://github.com/tc39/proposal-exponentiation-operator" target="_blank" rel="noopener">tc39/proposal-exponentiation-operator</a></li><li><a href="http://www.ecma-international.org/ecma-262/#sec-numeric-types-number-exponentiate" target="_blank" rel="noopener">6.1.6.1.3 Number::exponentiate (base, exponent) | ECMAScript 2020 Language Specification</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Exponentiation" target="_blank" rel="noopener">Exponentiation (**) - JavaScript | MDN</a></li><li><a href="https://en.wikipedia.org/wiki/Infix_notation" target="_blank" rel="noopener">Infix notation - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Operator_associativity" target="_blank" rel="noopener">Operator associativity - Wikipedia</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;寫程式應該很常會用到指數運算，過去我們會用 &lt;code&gt;Math.pow()&lt;/code&gt;，但在 ES2016 (ES7) 提供了 exponentiation operator (指數運算子) 的讓寫法更簡潔。那這兩個差在哪？讓我們從 ECMAScript spec 中一探究竟吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://titangene.github.io/categories/javascript/"/>
    
    
      <category term="IT 鐵人賽" scheme="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
      <category term="ECMAScript" scheme="https://titangene.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 之旅 (2)：Array.prototype.includes()</title>
    <link href="https://titangene.github.io/article/javascript-array-includes.html"/>
    <id>https://titangene.github.io/article/javascript-array-includes.html</id>
    <published>2020-09-17T05:36:56.000Z</published>
    <updated>2020-09-17T05:45:33.804Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/javascript.jpg" alt=""></p><p>常會有找出陣列中是否包含某元素的需求，過去會使用 <code>Array.prototype.indexOf()</code> 來處理，但在 ES2016 (ES7) 提供了 <code>Array.prototype.includes()</code> 新的 Array method，更方便好用，那這兩個差在哪？解決過去的哪些問題？讓我們從 ECMAScript spec 中一探究竟吧。</p><a id="more"></a><blockquote><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10238101" target="_blank" rel="noopener">JavaScript 之旅 (2)：Array.prototype.includes()</a></p><p>「JavaScript 之旅」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/3607" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><h1 id="過去的-Array-prototype-indexOf"><a class="header-anchor" href="#過去的-Array-prototype-indexOf"></a>過去的 <code>Array.prototype.indexOf()</code></h1><p>若要確定陣列內是否包含某元素，過去常見的作法是使用 <code>Array.prototype.indexOf()</code>，你應該有看過這幾種寫法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">'JS'</span>, <span class="hljs-string">'ECMA'</span>, <span class="hljs-string">'TC39'</span>];<br><span class="hljs-keyword">let</span> searchElement = <span class="hljs-string">'ECMA'</span>;<br><br><span class="hljs-built_in">console</span>.log(array.indexOf(searchElement) !== <span class="hljs-number">-1</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(array.indexOf(searchElement) &gt;= <span class="hljs-number">0</span>);    <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">if</span> (~array.indexOf(searchElement)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'找到啦！'</span>);  <span class="hljs-comment">// 找到啦！</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'找不到 QQ'</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用 <code>Array.prototype.indexOf()</code> 回傳的 index 來確定陣列內是否包含該元素：</p><ul><li>回傳 <code>-1</code> 代表陣列內沒有該元素</li><li>否則就是找到的元素的 index 值</li></ul><p>但這些寫法有一些問題：</p><ul><li>不直覺：需透過 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank" rel="noopener"><code>Array.prototype.indexOf()</code></a> 來問該元素在陣列中第一次被找到的 index 為何，然後使用比較運算子 (即 <code>===</code>、<code>&gt;=</code> 等) 或位元運算子 (即 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT" target="_blank" rel="noopener"><code>~</code></a> ) 來確定該元素是否存在</li><li>寫法不統一：每個人對於比較運算子的使用習慣不同，有些人會用 <code>!== -1</code>，有些人會用 <code>&gt;= 0</code> … 等，但明明都是一樣的行為</li><li>不適用於 <code>NaN</code>：因為 <code>Array.prototype.indexOf()</code> 是用嚴格相等來比較，而 <code>NaN !== NaN</code> ( <code>NaN</code> 本來就不等於自己)，所以你無法在陣列中找出 <code>NaN</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log([<span class="hljs-literal">NaN</span>].indexOf(<span class="hljs-literal">NaN</span>) !== <span class="hljs-number">-1</span>);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h1 id="現代的-Array-prototype-includes"><a class="header-anchor" href="#現代的-Array-prototype-includes"></a>現代的 <code>Array.prototype.includes()</code></h1><p>於是在 ES2016 (ES7) 提供了 <code>Array.prototype.includes()</code> 新的 Array method，不用管陣列的 index，直接就會回傳是否包含該元素的 Boolean 值，<code>true</code> 代表包含，<code>false</code> 則代表不包含，非常直覺又方便：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">'JS'</span>, <span class="hljs-string">'ECMA'</span>, <span class="hljs-string">'TC39'</span>];<br><span class="hljs-keyword">let</span> searchElement = <span class="hljs-string">'ECMA'</span>;<br><br><span class="hljs-built_in">console</span>.log(array.includes(searchElement));  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>而且也可以解決 <code>NaN</code> 的問題：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log([<span class="hljs-literal">NaN</span>].includes(<span class="hljs-literal">NaN</span>));  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>後面會解釋 <code>Array.prototype.includes()</code> 是如何解決 <code>NaN</code> 的問題，spec 其實都有告訴你！</p></blockquote><p>另外為了一致性，<code>Array.prototype.includes()</code> 的參數用法跟 <code>Array.prototype.indexOf()</code> 的一樣，下面是他們的語法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.indexOf(searchElement[, fromIndex])<br><span class="hljs-built_in">Array</span>.prototype.includes(searchElement[, fromIndex])<br></code></pre></td></tr></table></figure><blockquote><p>註：<code>[, fromIndex]</code> 中的 <code>[]</code> 不是代表陣列，在語法表示法中代表的是可選參數，而 <code>Array.prototype.includes()</code> 和 <code>Array.prototype.indexOf()</code> 的可選參數 <code>fromIndex</code> 預設為 <code>0</code>，代表會從陣列的最前面開始尋找符合的元素。</p></blockquote><p>兩者實際使用的行為一樣 (除了剛剛提到的 <code>NaN</code> 之外)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-string">'JS'</span>, <span class="hljs-string">'ECMA'</span>, <span class="hljs-string">'TC39'</span>, <span class="hljs-string">'JS'</span>, <span class="hljs-string">'ECMA'</span>];<br><span class="hljs-keyword">let</span> searchElement = <span class="hljs-string">'JS'</span>;<br><br><span class="hljs-built_in">console</span>.log(array.indexOf(searchElement, <span class="hljs-number">2</span>) !== <span class="hljs-number">-1</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(array.includes(searchElement, <span class="hljs-number">2</span>));  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>關於為什麼 <code>includes()</code> 要命名成 <code>includes</code>，而不是 <code>has</code> 或 <code>contains</code>，可參閱 <a href="https://github.com/tc39/Array.prototype.includes#faqs" target="_blank" rel="noopener">tc39/Array.prototype.includes 的 FAQ</a>。</p></blockquote><h1 id="spec-定義"><a class="header-anchor" href="#spec-定義"></a>spec 定義</h1><h2 id="Array-prototype-indexOf-的-spec-定義"><a class="header-anchor" href="#Array-prototype-indexOf-的-spec-定義"></a><code>Array.prototype.indexOf()</code> 的 spec 定義</h2><p>先來看看 <a href="http://www.ecma-international.org/ecma-262/#sec-array.prototype.indexof" target="_blank" rel="noopener"><code>Array.prototype.indexOf()</code></a> 在 spec 的定義：</p><p><img src="../images/javascript-array-includes/2020-09-16-23-44-03.png" alt=""></p><p>大致上就是從陣列中找出與 <code>searchElement</code> match 的元素，用嚴格相等比較 (Strict Equality Comparison) 來確認 <code>searchElement</code> 是否與陣列中的某元素相同。</p><blockquote><p>在 spec 定義的 1~6 步驟明確說明，何時才會真正開始從陣列中尋找 match 的元素，在某些條件下會直接回傳 <code>-1</code>，例如：陣列的 length 等於 0，或是 <code>fromIndex</code> 的值大於陣列的 length 的時候。</p></blockquote><h2 id="Array-prototype-includes-的-spec-定義"><a class="header-anchor" href="#Array-prototype-includes-的-spec-定義"></a><code>Array.prototype.includes()</code> 的 spec 定義</h2><p>接著來看 <a href="http://www.ecma-international.org/ecma-262/#sec-array.prototype.includes" target="_blank" rel="noopener"><code>Array.prototype.includes()</code></a> 在 spec 的定義：</p><p><img src="../images/javascript-array-includes/2020-09-16-23-55-16.png" alt=""></p><p>大致上的定義和 <code>Array.prototype.indexOf()</code> 非常像，但有一些不同：</p><ul><li>回傳值變成 Boolean 值，而不是 index 值 (型別為 Number)</li><li>在比對 <code>searchElement</code> 是否 match 陣列中的元素時，使用的是 SameValueZero 演算法，而不是嚴格相等比較<ul><li>透過 SameValueZero 演算法可以找出陣列中的 <code>NaN</code> 元素</li></ul></li><li>不會跳過空缺的陣列元素 (即 empty slot)，而是視為 <code>undefined</code> (所以 <code>Array.prototype.indexOf()</code> 會跳過 empty slot，因為它在 spec 定義的步驟 9.a，只要沒有該 property 就會直接跳過，繼續比對下一個元素)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-built_in">console</span>.log(array);                   <span class="hljs-comment">// [empty × 3]</span><br><br><span class="hljs-built_in">console</span>.log(array.indexOf() !== <span class="hljs-number">-1</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(array.includes());        <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(array.indexOf(<span class="hljs-literal">undefined</span>) !== <span class="hljs-number">-1</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(array.includes(<span class="hljs-literal">undefined</span>));        <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>看完 <code>Array.prototype.indexOf()</code> 和 <code>Array.prototype.includes()</code> 的定義之後，讓我們更深入看前者使用的嚴格相等比較 (Strict Equality Comparison) 和後者使用的 SameValueZero 演算法在 spec 中是如何定義的。</p><h2 id="嚴格相等比較-vs-SameValueZero"><a class="header-anchor" href="#嚴格相等比較-vs-SameValueZero"></a>嚴格相等比較 vs. SameValueZero</h2><h3 id="嚴格相等比較-的-spec-定義"><a class="header-anchor" href="#嚴格相等比較-的-spec-定義"></a>嚴格相等比較 的 spec 定義</h3><p>先來看 <code>Array.prototype.indexOf()</code> 使用的<a href="http://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison" target="_blank" rel="noopener">嚴格相等比較 (Strict Equality Comparison)</a> 在 spec 的定義：</p><p><img src="../images/javascript-array-includes/2020-09-17-00-29-43.png" alt=""></p><p>嚴格相等比較會先比較型別是否相同，不同就回傳 <code>false</code>。</p><p>然後，如果型別是 <code>Number</code> 或 <code>BigInt</code> 就會直接進行值的比較。<a href="http://www.ecma-international.org/ecma-262/#sec-numeric-types-number-equal" target="_blank" rel="noopener"><code>Number::equal</code></a> 的定義如下：</p><p><img src="../images/javascript-array-includes/2020-09-17-00-34-22.png" alt=""></p><blockquote><p>在步驟 1 和 2 提到，只要值是 <code>NaN</code> 就會回傳 <code>false</code>，這就是 <code>NaN</code> 不等於 <code>NaN</code> 的原因</p></blockquote><p>回到嚴格相等比較的步驟 3：否則，其他型別會使用 <a href="http://www.ecma-international.org/ecma-262/#sec-samevaluenonnumeric" target="_blank" rel="noopener">SameValueNonNumeric</a> 演算法，spec 的定義如下：</p><p><img src="../images/javascript-array-includes/2020-09-17-00-35-30.png" alt=""></p><ul><li>值為 <code>null</code> 或 <code>undefined</code> 時會回傳 <code>true</code></li><li><code>String</code> 型別就比對字串</li><li><code>Boolean</code>、<code>Symbol</code> 和 <code>Object</code> 型別都是比較值是否相同 (但 Object 型別的值必須是同一個參考)</li></ul><p>如果元素的型別為 <code>Object</code>，值看起來相同，但參考不同時，<code>Array.prototype.indexOf()</code> 和 <code>Array.prototype.includes()</code> 都會找不到一樣的元素 (ECMAScript 表示：啊就真的不一樣啊)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [&#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">3</span>&#125;];<br><br><span class="hljs-built_in">console</span>.log(array.indexOf(&#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>&#125;) !== <span class="hljs-number">-1</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(array.includes(&#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>&#125;));        <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>如果是同一個物件參考，就會找到 match 的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> item = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> array = [&#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125;, item, &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">3</span>&#125;];<br><br><span class="hljs-built_in">console</span>.log(array.indexOf(item) !== <span class="hljs-number">-1</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(array.includes(item));        <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="SameValueZero-的-spec-定義"><a class="header-anchor" href="#SameValueZero-的-spec-定義"></a>SameValueZero 的 spec 定義</h3><p>接著來看 <code>Array.prototype.includes()</code> 使用的 SameValueZero 演算法在 spec 的定義：</p><p><img src="../images/javascript-array-includes/2020-09-17-13-11-51.png" alt=""></p><p>步驟 1 和嚴格相等比較一樣，會先比較型別是否相同，不同就回傳 <code>false</code>。</p><p>然後，如果型別是 <code>Number</code> 或 <code>BigInt</code> 就會進行 <code>Type(x)::sameValueZero(x, y)</code> 來比較。那 <code>Type(x)::sameValueZero(x, y)</code> 是啥？其實在 spec 內定義，<code>Number</code> 或 <code>BigInt</code> 型別都是 ECMAScript 內建的 Numeric 型別，而每種內建型別會定義很多 operations，其中的就是 <code>T::sameValueZero(x, y)</code>：</p><p><img src="../images/javascript-array-includes/2020-09-17-13-19-43.png" alt=""></p><blockquote><p>註：因為表格有太多內容了，所以我把這次不會提到的內容都變成 <code>...</code> 了。</p></blockquote><p>接著往下找就會看到詳細的定義：</p><p><img src="../images/javascript-array-includes/2020-09-17-13-21-34.png" alt=""></p><blockquote><p>在步驟 1 提到，只要兩個比較的值都是 <code>NaN</code>，就會回傳 <code>true</code>，這就是 <code>Array.prototype.includes()</code> 解決 <code>NaN</code> 不等於 <code>NaN</code> 這個問題的步驟。</p></blockquote><p>回到嚴格相等比較的步驟 3：否則，使用 <a href="http://www.ecma-international.org/ecma-262/#sec-samevaluenonnumeric" target="_blank" rel="noopener">SameValueNonNumeric</a> 演算法，因為上面提到了，就不重複說明囉。</p><h1 id="polyfill"><a class="header-anchor" href="#polyfill"></a>polyfill</h1><p>下面是 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill" target="_blank" rel="noopener">MDN 提供的 polyfill</a>，若跟 spec 相比可以發現簡化一些東西，但大致上的結果會相同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ref: https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.prototype.includes) &#123;<br>  <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Array</span>.prototype, <span class="hljs-string">'includes'</span>, &#123;<br>    value: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">searchElement, fromIndex</span>) </span>&#123;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'"this" is null or not defined'</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 1. Let O be ? ToObject(this value).</span><br>      <span class="hljs-keyword">var</span> o = <span class="hljs-built_in">Object</span>(<span class="hljs-keyword">this</span>);<br><br>      <span class="hljs-comment">// 2. Let len be ? LengthOfArrayLike(O)</span><br>      <span class="hljs-comment">//    即 Let len be ? ToLength(? Get(O, "length")).</span><br>      <span class="hljs-keyword">var</span> len = o.length &gt;&gt;&gt; <span class="hljs-number">0</span>;<br><br>      <span class="hljs-comment">// 3. If len is 0, return false.</span><br>      <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-comment">// 4. Let n be ? ToInteger(fromIndex).</span><br>      <span class="hljs-comment">// 5. Assert: If fromIndex is undefined, this n is 0.</span><br>      <span class="hljs-keyword">var</span> n = fromIndex | <span class="hljs-number">0</span>;<br><br>      <span class="hljs-comment">// 6. If n &gt;= 0, then</span><br>      <span class="hljs-comment">//   a. Let k be n.</span><br>      <span class="hljs-comment">// 7. Else n &lt; 0,</span><br>      <span class="hljs-comment">//   a. Let k be len + n.</span><br>      <span class="hljs-comment">//   b. If k &lt; 0, set k to 0.</span><br>      <span class="hljs-keyword">var</span> k = <span class="hljs-built_in">Math</span>.max(n &gt;= <span class="hljs-number">0</span> ? n : len - <span class="hljs-built_in">Math</span>.abs(n), <span class="hljs-number">0</span>);<br><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sameValueZero</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> (<br>          x === y || (<br>            <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> y === <span class="hljs-string">'number'</span> &amp;&amp;<br>            <span class="hljs-built_in">isNaN</span>(x) &amp;&amp; <span class="hljs-built_in">isNaN</span>(y)<br>          )<br>        );<br>      &#125;<br><br>      <span class="hljs-comment">// 8. Repeat, while k &lt; len</span><br>      <span class="hljs-keyword">while</span> (k &lt; len) &#123;<br>        <span class="hljs-comment">// a. Let elementK be the result of ? Get(O, ! ToString(k)).</span><br>        <span class="hljs-comment">// b. If SameValueZero(searchElement, elementK) is true, return true.</span><br>        <span class="hljs-keyword">if</span> (sameValueZero(o[k], searchElement)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// c. Set k to k + 1.</span><br>        k++;<br>      &#125;<br><br>      <span class="hljs-comment">// 9. Return false</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其他 polyfill：</p><ul><li><a href="https://github.com/zloirock/core-js/blob/master/packages/core-js/internals/array-includes.js" target="_blank" rel="noopener">core-js</a></li><li><a href="https://github.com/es-shims/array-includes/blob/main/implementation.js" target="_blank" rel="noopener">es-shims</a></li></ul></blockquote><h1 id="資料來源："><a class="header-anchor" href="#資料來源："></a>資料來源：</h1><ul><li><a href="https://github.com/tc39/Array.prototype.includes" target="_blank" rel="noopener">tc39/Array.prototype.includes</a></li><li><a href="https://tc39.es/ecma262/#sec-array.prototype.includes" target="_blank" rel="noopener">22.1.3.13 <code>Array.prototype.includes(searchElement[, fromIndex])</code> | ECMAScript 2021 Language Specification</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;常會有找出陣列中是否包含某元素的需求，過去會使用 &lt;code&gt;Array.prototype.indexOf()&lt;/code&gt; 來處理，但在 ES2016 (ES7) 提供了 &lt;code&gt;Array.prototype.includes()&lt;/code&gt; 新的 Array method，更方便好用，那這兩個差在哪？解決過去的哪些問題？讓我們從 ECMAScript spec 中一探究竟吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://titangene.github.io/categories/javascript/"/>
    
    
      <category term="IT 鐵人賽" scheme="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
      <category term="ECMAScript" scheme="https://titangene.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 之旅 (1)：介紹 ECMA、ECMAScript、JavaScript 和 TC39</title>
    <link href="https://titangene.github.io/article/javascript-ecmascript-tc39.html"/>
    <id>https://titangene.github.io/article/javascript-ecmascript-tc39.html</id>
    <published>2020-09-16T03:18:30.000Z</published>
    <updated>2020-09-20T12:25:45.530Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/javascript.jpg" alt=""></p><p>你很常聽到 ES6、ES7、ES2017 等這些名稱嗎？有聽過 ECMA 和 TC39 嗎？ECMAScript 和 JavaScript 又是什麼？規範要去哪裡看？下面會各別介紹。</p><a id="more"></a><blockquote><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10237660" target="_blank" rel="noopener">JavaScript 之旅 (1)：介紹 ECMA、ECMAScript、JavaScript 和 TC39</a></p><p>「JavaScript 之旅」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/3607" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><h1 id="ECMA"><a class="header-anchor" href="#ECMA"></a>ECMA</h1><p>ECMA 是 European Computer Manufacturers Association (歐洲電腦製造商協會) 的簡稱，協會在 1961 年正式成立，是資訊和通訊系統的標準組織。</p><p>後來為了因應國際化，在 1994 年將名稱改為 Ecma International (Ecma 國際)。</p><p>Ecma 國際負責的標準包括：</p><ul><li><a href="http://www.ecma-international.org/publications/standards/Ecma-119.htm" target="_blank" rel="noopener">ECMA-119：CD-ROM 格式</a></li><li><a href="http://www.ecma-international.org/publications/standards/Ecma-334.htm" target="_blank" rel="noopener">ECMA-334：C# 語言規範</a></li><li><a href="http://www.ecma-international.org/publications/standards/Ecma-408.htm" target="_blank" rel="noopener">ECMA-408：Dart 語言規範</a></li><li><a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank" rel="noopener">ECMA-404：JSON</a></li><li><a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="noopener">ECMA-262：ECMAScript 語言規範</a></li><li>… 等</li></ul><blockquote><p>想知道 Ecma 國際負責哪些標準可參閱：<a href="http://www.ecma-international.org/publications/standards/Standard.htm" target="_blank" rel="noopener">Ecma Standards - list</a></p></blockquote><blockquote><p>更多有關 ECMA 的歷史可參閱 <a href="https://www.ecma-international.org/memento/history.htm" target="_blank" rel="noopener">History of Ecma</a>。</p></blockquote><h1 id="ECMAScript-ECMA-262"><a class="header-anchor" href="#ECMAScript-ECMA-262"></a>ECMAScript &amp; ECMA-262</h1><p>ECMAScript 簡稱 ES，是一種通用的程式語言，由 Ecma 國際在 ECMA-262 進行標準化。ECMA-262 的第一版在 1997 年由 Ecma General Assembly 出版的。</p><p>ECMAScript 是由 Netscape 的 Brendan Eich 發明的，最早出現在 Netscape 的 Navigator 2.0 瀏覽器中。從 IE 3.0 開始，很多瀏覽器開始使用 ECMAScript。</p><p>ECMAScript 是 JavaScript 的標準，目的是讓不同瀏覽器之間能根據 spec 來實作。當 ECMAScript 發布第三版 (即 ES3) 之後，成為當時所有瀏覽器支援的程式語言。</p><p>以前只能在瀏覽器中使用 ECMAScript，後來也能在 Node.js 寫 server 應用和 service。</p><h1 id="ECMAScript-JavaScript"><a class="header-anchor" href="#ECMAScript-JavaScript"></a>ECMAScript &amp; JavaScript</h1><p>JavaScript 和 ECMAScript 都是程式語言，但不是一樣的東西。JavaScript 通常縮寫為 JS，是一種符合 ECMAScript spec 的程式語言。</p><p>ECMA-262 是 ECMAScript 的規範，而 JavaScript 只是其中一種實作和擴充的程式語言 (雖然 JavaScript 相容於 ECMAScript，但 JavaScript 還提供 ECMAScript 未定義的特性)。</p><p>而我們常聽到的 ES6，代表的是 ECMA-262 第 6 版 (ECMA-262 6th Edition)。</p><p>從 ES7 (ES2016) 開始，ECMAScript 會在每年釋出新版本，裡面包含已完成的新特性，而瀏覽器就會根據新特性來完成實作，開發者就能開始使用這些新特性。</p><h1 id="TC39"><a class="header-anchor" href="#TC39"></a>TC39</h1><p>Ecma 標準是由各種技術委員會管理的，而 TC39 就是其中一個 TC，是 Technical Committee (技術委員會) 的縮寫，TC 會處理特定的領域或主題。</p><p>TC39 主要負責將通用、跨平台與 vendor 無關的程式語言 ECMAScript 標準化，包括語言的 syntax、semantics 和 library 以及支援該語言的補充技術。</p><blockquote><p>詳情可參閱 <a href="https://www.ecma-international.org/memento/tc39.htm" target="_blank" rel="noopener">TC39 - ECMAScript</a>。</p></blockquote><blockquote><p>其實還有其他的 TC，詳情可參閱 <a href="https://www.ecma-international.org/memento/TCs&amp;TGs.htm" target="_blank" rel="noopener">Ecma Technical Committees and Task Groups</a>。</p></blockquote><h1 id="TC39-的提案流程"><a class="header-anchor" href="#TC39-的提案流程"></a>TC39 的提案流程</h1><p>Ecma TC39 委員會負責發展 ECMAScript 程式語言並撰寫 spec，要對 spec 進行修改的階段如下：</p><ul><li>stage 0 (Strawperson)：沒有作為正式提案提交的任何討論、想法，或是修改或新增提案都是此階段</li><li>stage 1 (Proposal)：補充理由、描述解決方案、用法的說明範例、提出潛在的 challenges、討論關鍵演算法、abstractions 和 semantics，在這個階段就會有 polyfill 或 demo</li><li>stage 2 (Draft)：用 spec 的方式來精確描述 syntax 和 semantics，此階段會有實驗性的實作</li><li>stage 3 (Candidate)：已完成 spec 的內容，需要大量使用者的使用和反饋才能進入 stage 4，但實作已經符合 spec 了</li><li>stage 4 (Finished)：已準備將提案加入正式的 ECMAScript 標準中，但需兩個相容的實作 (瀏覽器或 Node.js 等環境) 通過驗收測試。此階段的實作已穩定</li></ul><p>所以 stage 0 是想法階段，而 stage 1 至 3 都是在進行審查和討論，從 stage 2 開始會有接近正式 spec 的內容，最後的 stage 4 才是正式將提案納入 spec 中。</p><p>有些提案還沒到 stage 4 就能在瀏覽器使用了，而且也有對應的 polyfill 可以使用。</p><blockquote><p>TC39 的提案流程詳情可參閱 <a href="https://tc39.es/process-document/" target="_blank" rel="noopener">The TC39 Process</a>。</p></blockquote><h1 id="ECMAScript-提案"><a class="header-anchor" href="#ECMAScript-提案"></a>ECMAScript 提案</h1><p>各提案在哪個 stage，或是被放棄、撤回或拒絕的提案都可在 <a href="https://github.com/tc39/proposals/" target="_blank" rel="noopener">tc39/proposals: Tracking ECMAScript Proposals</a> 這裡找到。</p><p>若只想查看已完成的提案，可直接看 <a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" target="_blank" rel="noopener">Finished Proposals</a> 這份文件，這裡有從 ES2016 開始到最新的所有 Finished Proposals。</p><p><img src="../images/javascript-ecmascript-tc39/2020-09-16-11-04-33.png" alt=""></p><h1 id="ECMAScript-Spec"><a class="header-anchor" href="#ECMAScript-Spec"></a>ECMAScript Spec</h1><p>若要看 ECMAScript spec 主要有兩個地方：</p><ul><li>最新版、最準確的 spec，包含最新年度 snapshot 的內容以及所有已完成的提案 (即 stage 4 的提案)：<a href="http://www.ecma-international.org/ecma-262/" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/</a></li><li>過去發佈的 spec 版本：<a href="http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm" target="_blank" rel="noopener">Standard ECMA-262-archive</a>，例如：<ul><li><a href="http://www.ecma-international.org/ecma-262/5.1" target="_blank" rel="noopener">ECMAScript Language Specification - ECMA-262 Edition 5.1</a></li><li><a href="http://www.ecma-international.org/ecma-262/6.0" target="_blank" rel="noopener">ECMAScript 2015 Language Specification - ECMA-262 6th Edition</a></li><li><a href="http://www.ecma-international.org/ecma-262/7.0" target="_blank" rel="noopener">ECMAScript 2016 Language Specification - ECMA-262 7th Edition</a></li><li><a href="http://www.ecma-international.org/ecma-262/8.0" target="_blank" rel="noopener">ECMAScript 2017 Language Specification - ECMA-262 8th Edition</a></li><li><a href="http://www.ecma-international.org/ecma-262/9.0" target="_blank" rel="noopener">ECMAScript 2018 Language Specification - ECMA-262 9th Edition</a></li><li><a href="http://www.ecma-international.org/ecma-262/10.0" target="_blank" rel="noopener">ECMAScript 2019 Language Specification - ECMA-262 10th Edition</a></li></ul></li><li>包含 ECMA-262 當前草案的 spec：<a href="https://tc39.es/ecma262/" target="_blank" rel="noopener">https://tc39.es/ecma262/</a></li></ul><p>我個人常看的是<a href="https://tc39.es/ecma262/" target="_blank" rel="noopener">草案</a>那份，若想看某個功能的定義，也可以看看在各版本的 spec 中是如何定義的。</p><p>但 ECMA-262 的文件有一個缺點：沒有像 <a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="noopener">HTML Standard</a> 和 <a href="https://www.w3.org/TR/CSS22/" target="_blank" rel="noopener">CSS 2.2 Spec</a> 一樣提供分頁功能啊…，每次開 spec 都會卡一下 (找一個換電腦的理由 XD)。為了解決這個問題，我另外找了 <a href="https://read262.netlify.app/" target="_blank" rel="noopener">https://read262.netlify.app/</a> 這個網頁，它把<a href="https://tc39.es/ecma262/" target="_blank" rel="noopener">草案</a>那份的內容即時更新成分頁版的 spec，而且還提供目錄和好用的搜尋功能！</p><p><img src="../images/javascript-ecmascript-tc39/2020-09-16-11-04-41.png" alt=""></p><h1 id="瀏覽器-Node-js-的支援程度"><a class="header-anchor" href="#瀏覽器-Node-js-的支援程度"></a>瀏覽器 &amp; Node.js 的支援程度</h1><p>可參閱 <a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">ECMAScript 6 compatibility table</a> 和 <a href="https://node.green/" target="_blank" rel="noopener">Node.js ES2015/ES6, ES2016 and ES2017 support</a> 這兩個頁面的表格，列出各版本對各特性支援的程度：</p><p><img src="../images/javascript-ecmascript-tc39/2020-09-16-11-04-47.png" alt=""></p><p><img src="../images/javascript-ecmascript-tc39/2020-09-16-11-04-52.png" alt=""></p><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://en.wikipedia.org/wiki/Ecma_International" target="_blank" rel="noopener">Ecma International - Wikipedia</a></li><li><a href="http://www.ecma-international.org/publications/standards/Standard.htm" target="_blank" rel="noopener">Ecma Standards - list</a></li><li><a href="https://www.ecma-international.org/memento/history.htm" target="_blank" rel="noopener">History of Ecma</a></li><li><a href="https://www.ecma-international.org/memento/tc39.htm" target="_blank" rel="noopener">TC39 - ECMAScript</a></li><li><a href="https://tc39.es/process-document/" target="_blank" rel="noopener">The TC39 Process</a></li><li><a href="http://www.ecma-international.org/ecma-262/#sec-intro" target="_blank" rel="noopener">Introduction | ECMAScript 2020 Language Specification</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;你很常聽到 ES6、ES7、ES2017 等這些名稱嗎？有聽過 ECMA 和 TC39 嗎？ECMAScript 和 JavaScript 又是什麼？規範要去哪裡看？下面會各別介紹。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://titangene.github.io/categories/javascript/"/>
    
    
      <category term="IT 鐵人賽" scheme="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
      <category term="ECMAScript" scheme="https://titangene.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>GitLab Page 自動部署 Vue CLI 專案</title>
    <link href="https://titangene.github.io/article/vue-cli-gitlab-page-ci.html"/>
    <id>https://titangene.github.io/article/vue-cli-gitlab-page-ci.html</id>
    <published>2020-09-13T15:58:28.000Z</published>
    <updated>2020-09-13T16:26:01.574Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/vue.jpg" alt=""></p><p>手動將 Vue CLI build 出來，然後再 push 至遠端部署，這些步驟雖然很簡單，但這樣不是很有效率，所以應透過自動部署來處理。本篇介紹如何透過 GitLab CI/CD 來將 Vue CLI 專案自動部署至 GitLab Page。</p><a id="more"></a><h1 id="CI-CD-自動部署設定"><a class="header-anchor" href="#CI-CD-自動部署設定"></a>CI/CD 自動部署設定</h1><p>下面是參考 <a href="https://cli.vuejs.org/zh/guide/deployment.html#github-pages" target="_blank" rel="noopener">Vue CLI 文件</a> 提供的 GitLab Pages 自動部署的設定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// vue.config.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  publicPath: process.env.NODE_ENV === <span class="hljs-string">'production'</span> ? <span class="hljs-string">'/test-project/'</span> : <span class="hljs-string">'/'</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># .gitlab-ci.yml</span><br><span class="hljs-attr">pages:</span> <span class="hljs-comment"># 必須定義一個名為 pages 的 job</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">node:latest</span><br>  <span class="hljs-attr">stage:</span> <span class="hljs-string">deploy</span><br>  <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">yarn</span> <span class="hljs-string">install</span> <span class="hljs-string">--frozen-lockfile</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">yarn</span> <span class="hljs-string">build</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mv</span> <span class="hljs-string">public</span> <span class="hljs-string">public-vue</span> <span class="hljs-comment"># GitLab Pages 的鉤子設定在 public 檔案夾</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mv</span> <span class="hljs-string">dist</span> <span class="hljs-string">public</span> <span class="hljs-comment"># 重命名 dist 檔案夾 (npm run build 之後的輸出位置)</span><br>  <span class="hljs-attr">artifacts:</span><br>    <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">public</span> <span class="hljs-comment"># artifact path 一定要在 /public , 這樣 GitLab Pages 才能獲取</span><br>  <span class="hljs-attr">only:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><blockquote><p>GitLab CI/CD 設定詳情可參閱：</p><ul><li><a href="https://docs.gitlab.com/ee/ci/yaml/README.html" target="_blank" rel="noopener">GitLab CI/CD pipeline configuration reference | GitLab</a></li><li><a href="https://docs.gitlab.com/ee/user/project/pages/introduction.html#gitlab-ciyml-for-a-repository-where-theres-also-actual-code" target="_blank" rel="noopener">Exploring GitLab Pages | GitLab</a></li></ul></blockquote><p>原本 Vue CLI 文件提供的是 npm 的設定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">pages:</span> <span class="hljs-comment"># 必須定義一個名為 pages 的 job</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">node:latest</span><br>  <span class="hljs-attr">stage:</span> <span class="hljs-string">deploy</span><br>  <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">ci</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mv</span> <span class="hljs-string">public</span> <span class="hljs-string">public-vue</span> <span class="hljs-comment"># GitLab Pages 的鉤子設定在 public 檔案夾</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mv</span> <span class="hljs-string">dist</span> <span class="hljs-string">public</span> <span class="hljs-comment"># 重命名 dist 檔案夾 (npm run build 之後的輸出位置)</span><br>  <span class="hljs-attr">artifacts:</span><br>    <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">public</span> <span class="hljs-comment"># artifact path 一定要在 /public , 這樣 GitLab Pages 才能獲取</span><br>  <span class="hljs-attr">only:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h1 id="設定-GitLab-CI-CD-環境變數"><a class="header-anchor" href="#設定-GitLab-CI-CD-環境變數"></a>設定 GitLab CI/CD 環境變數</h1><p>在「Settings &gt; CI/CD &gt; Variables」頁面設定 CI/CD 要使用的環境變數：</p><p><img src="../images/vue-cli-gitlab-page-ci/Untitled.png" alt=""></p><blockquote><p>註：因專案有用到 <code>.env</code> 檔，但我使用的是 <code>.env.local</code>，未將環境設定檔 push 至 GitLab，所以需要在 GitLab Repo 設定 CI/CD 要使用的環境變數，若你有 push <code>.env.production</code> 至 GitLab 就能視情況跳過此步驟。</p></blockquote><h1 id="開始自動部署"><a class="header-anchor" href="#開始自動部署"></a>開始自動部署</h1><p>看到紅色框處的圖案就代表 CI/CD 正在自動部署中：</p><p><img src="../images/vue-cli-gitlab-page-ci/Untitled%201.png" alt=""></p><p>點擊進去後，點擊 Deploy 的 pages 可以查看部署進度：</p><p><img src="../images/vue-cli-gitlab-page-ci/Untitled%202.png" alt=""></p><p>等待一下…看到「Job succesed」就代表部署成功了！</p><p><img src="../images/vue-cli-gitlab-page-ci/Untitled%203.png" alt=""></p><h1 id="設定-GitLab-Page-發佈權限"><a class="header-anchor" href="#設定-GitLab-Page-發佈權限"></a>設定 GitLab Page 發佈權限</h1><p>到「Settings &gt; Pages」頁面會看到下圖的橘色提醒，會出現這個提醒是因為你的專案是 private，所以預設 GitLab Page 也會是 private 的。</p><p>若想讓專案保持 private，但 GitLab Page 卻要 public，那就依照橘色提醒的步驟來做：</p><p><img src="../images/vue-cli-gitlab-page-ci/Untitled%204.png" alt=""></p><p>到「Settings &gt; General &gt; Visibility」頁面點擊「Expand」展開設定：</p><p><img src="../images/vue-cli-gitlab-page-ci/Untitled%205.png" alt=""></p><p>將 Pages 的設定改為「Everyone」：</p><p><img src="../images/vue-cli-gitlab-page-ci/Untitled%206.png" alt=""></p><p>再回到「Settings &gt; Pages」頁面時，橘色提醒就會消失囉！接著就能進入部署好的 GitLab Page 看看是否成功！</p><p><img src="../images/vue-cli-gitlab-page-ci/Untitled%207.png" alt=""></p><h1 id="HTTPS：Mixed-Content"><a class="header-anchor" href="#HTTPS：Mixed-Content"></a>HTTPS：Mixed Content</h1><p>開啟頁面後，會在 DevTools 的 console 看到下圖的錯誤訊息，這代表你目前開的 GitLab Page 是 HTTPS 的 URL，但你的網站的內容中有夾雜 HTTP 的資源，所以才會有此錯誤。</p><p>像下圖的範例是有些 API 是 HTTP 的，所以才會出現「Mixed Content」的錯誤：</p><p><img src="../images/vue-cli-gitlab-page-ci/2020-09-13-23-56-56.png" alt=""></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Mixed Content:</span> <span class="hljs-string">The</span> <span class="hljs-string">page</span> <span class="hljs-string">at</span> <span class="hljs-string">'https://titangene.gitlab.io/test-project/'</span> <span class="hljs-string">was</span> <span class="hljs-string">loaded</span> <span class="hljs-string">over</span> <span class="hljs-string">HTTPS,</span> <span class="hljs-string">but</span> <span class="hljs-string">requested</span> <span class="hljs-string">an</span> <span class="hljs-string">insecure</span> <span class="hljs-string">XMLHttpRequest</span> <span class="hljs-string">endpoint</span> <span class="hljs-string">'http://xxx.com/api/posts'</span><span class="hljs-string">.</span> <span class="hljs-string">This</span> <span class="hljs-string">request</span> <span class="hljs-string">has</span> <span class="hljs-string">been</span> <span class="hljs-string">blocked;</span> <span class="hljs-string">the</span> <span class="hljs-string">content</span> <span class="hljs-string">must</span> <span class="hljs-string">be</span> <span class="hljs-string">served</span> <span class="hljs-string">over</span> <span class="hljs-string">HTTPS.</span><br></code></pre></td></tr></table></figure><p>要解決此問題的方法就是不要用 HTTPS。</p><p>所以請至「Settings &gt; Pages」頁面將「Force HTTPS」的設定取消打勾，這樣 GitLab Page 就不強制使用 HTTPS 了 (即預設會將 HTTP 自動重導向成 HTTPS)，設定後就能用 HTTP 查看頁面了！</p><p><img src="../images/vue-cli-gitlab-page-ci/Untitled%209.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/vue.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;手動將 Vue CLI build 出來，然後再 push 至遠端部署，這些步驟雖然很簡單，但這樣不是很有效率，所以應透過自動部署來處理。本篇介紹如何透過 GitLab CI/CD 來將 Vue CLI 專案自動部署至 GitLab Page。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web-dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="Vue.js" scheme="https://titangene.github.io/tags/vue-js/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="GitLab" scheme="https://titangene.github.io/tags/gitlab/"/>
    
      <category term="CI/CD" scheme="https://titangene.github.io/tags/ci-cd/"/>
    
      <category term="GitLab Page" scheme="https://titangene.github.io/tags/gitlab-page/"/>
    
  </entry>
  
  <entry>
    <title>BootstrapVue：環境建置 (引入全部元件/部分元件)</title>
    <link href="https://titangene.github.io/article/bootstrap-vue-env-import-components.html"/>
    <id>https://titangene.github.io/article/bootstrap-vue-env-import-components.html</id>
    <published>2020-09-06T15:58:28.000Z</published>
    <updated>2020-09-13T16:00:57.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/bootstrap-vue.jpg" alt=""></p><p>本篇介紹在 Vue CLI 環境中，要如何全部引入或部分引入 BootstrapVue 的 Vue plugin、元件、directive 和元件的樣式。</p><a id="more"></a><h1 id="前言"><a class="header-anchor" href="#前言"></a>前言</h1><p>BootstrapVue 是 Bootstrap 框架與 Vue.js 整合的套件，其中包含多種 Bootstrap 元件、網格系統 … 等東西。</p><p>若要部分引入 BootstrapVue 元件，就不建議使用 <a href="https://github.com/GregYankovoy/vue-cli-plugin-bootstrap-vue" target="_blank" rel="noopener">vue-cli-plugin-bootstrap-vue (Bootstrap-Vue Vue CLI 3 plugin)</a>，因為還需自己另外設定，乾脆自己手動建置環境。</p><h1 id="安裝套件"><a class="header-anchor" href="#安裝套件"></a>安裝套件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm i bootstrap-vue bootstrap</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add bootstrap-vue bootstrap</span><br></code></pre></td></tr></table></figure><h1 id="全部引入"><a class="header-anchor" href="#全部引入"></a>全部引入</h1><h2 id="註冊全部元件和-directive"><a class="header-anchor" href="#註冊全部元件和-directive"></a>註冊全部元件和 directive</h2><p>在 app 進入點註冊 BootstrapVue：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;<br><span class="hljs-keyword">import</span> &#123; BootstrapVue, IconsPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'bootstrap-vue'</span>;<br><br><span class="hljs-comment">// 安裝 BootstrapVue</span><br>Vue.use(BootstrapVue);<br><span class="hljs-comment">// 安裝 BootstrapVue icon components plugin (可選)</span><br>Vue.use(IconsPlugin);<br></code></pre></td></tr></table></figure><h2 id="引入全部元件的樣式"><a class="header-anchor" href="#引入全部元件的樣式"></a>引入全部元件的樣式</h2><p>import Bootstrap 和 BootstrapVue 的 <code>css</code> 檔：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">'bootstrap/dist/css/bootstrap.css'</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">'bootstrap-vue/dist/bootstrap-vue.css'</span>;<br></code></pre></td></tr></table></figure><p>或在自訂的 SCSS 檔內 (例如：<code>custom.scss</code> ) import Bootstrap 和 BootstrapVue 的 <code>scss</code> 檔：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// ====================================</span><br><span class="hljs-comment">// # Bootstrap</span><br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">'node_modules/bootstrap/scss/bootstrap'</span>;<br><br><span class="hljs-comment">// ====================================</span><br><span class="hljs-comment">// # BootstrapVue</span><br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">'node_modules/bootstrap-vue/src/index.scss'</span>;<br></code></pre></td></tr></table></figure><p>然後在 app 進入點引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">'./custom.scss'</span>;<br></code></pre></td></tr></table></figure><p>將所有 SCSS <code>@import</code> 至單個 SCSS 檔中，然後將該檔案 import 至專案中。預設單個 SCSS 檔 import 至專案，不會在檔案之間共享變數值和函數 (因可避免變數和函數的命名衝突)。</p><p>Webpack 和 Parcel 支援在 <code>scss</code> 模組前加上 <code>~</code> 來引入 <code>scss</code> 檔案：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap-vue'</span>;<br></code></pre></td></tr></table></figure><div class="info"><p>可用 <code>~</code> 引入是因為 sass-loader 使用 Sass 的自訂 importer 功能將所有 query 傳給 Webpack resloving engine，所以才能從 <code>node_modules</code> import Sass 模組。只需在前面加上 <code>~</code> 來告訴 Webpack 這不是 relative import。</p><p>資料來源：<a href="https://webpack.js.org/loaders/sass-loader/#resolving-import-at-rules" target="_blank" rel="noopener">sass-loader - Resolving import at-rules | webpack</a></p></div><h2 id="完整範例：引入全部元件"><a class="header-anchor" href="#完整範例：引入全部元件"></a>完整範例：引入全部元件</h2><p>引入全部樣式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// src/assets/scss/vendors/bootstrap-vue.scss</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap-vue'</span>;<br></code></pre></td></tr></table></figure><p>引入全部元件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/plugins/bootstrap-vue.js</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;<br><span class="hljs-keyword">import</span> &#123; BootstrapVue, IconsPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'bootstrap-vue'</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">'@/assets/scss/vendors/bootstrap-vue.scss'</span>;<br><br><span class="hljs-comment">// 安裝 BootstrapVue</span><br>Vue.use(BootstrapVue);<br><span class="hljs-comment">// 安裝 BootstrapVue icon components plugin (可選)</span><br>Vue.use(IconsPlugin);<br></code></pre></td></tr></table></figure><p>在 app 進入點：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/main.js</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router/IndexRouter'</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">'./plugins/bootstrap-vue.js'</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">'./assets/scss/main.scss'</span>;<br><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>;<br><br>Vue.config.productionTip = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  router,<br>  store,<br>  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)<br>&#125;).$mount(<span class="hljs-string">'#app'</span>);<br></code></pre></td></tr></table></figure><p>若有自訂的 Sass 檔，記得要 import 在 BootstrapVue 之後，這樣自訂的 Sass 變數、樣式等東西才會覆蓋 BootstrapVue 和 Bootstrap 的 Sass</p><h1 id="部分引入"><a class="header-anchor" href="#部分引入"></a>部分引入</h1><p>當你用 Vue CLI 來建置環境，就會使用到 module bundler，常見的就是 Webpack。你可以選擇引入所需的特定 component groups (plugins)、component 和/或 directives，利用 module bundler 提供的 tree shaking 功能來減少 bundle 的大小。</p><h2 id="註冊部分元件-directive"><a class="header-anchor" href="#註冊部分元件-directive"></a>註冊部分元件 directive</h2><h3 id="作為-Vue-plugin-import"><a class="header-anchor" href="#作為-Vue-plugin-import"></a>作為 Vue plugin import</h3><p>可從 <code>bootstrap-vue</code> 將 component groups 和 directives 作為 Vue plugin import。</p><p>import Vue plugin 的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入所有佈局元件，包括 &lt;b-container&gt;, &lt;b-row&gt;, &lt;b-col&gt;</span><br><span class="hljs-keyword">import</span> &#123; LayoutPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'bootstrap-vue'</span>;<br>Vue.use(LayoutPlugin);<br><br><span class="hljs-comment">// 引入 &lt;b-modal&gt; 元件和 v-b-modal directive</span><br><span class="hljs-keyword">import</span> &#123; ModalPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'bootstrap-vue'</span>;<br>Vue.use(ModalPlugin);<br><br><span class="hljs-comment">// 引入 &lt;b-card&gt; 元件和其所有 &lt;b-card-*&gt; 子元件</span><br><span class="hljs-keyword">import</span> &#123; CardPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'bootstrap-vue'</span>;<br>Vue.use(CardPlugin);<br><br><span class="hljs-comment">// 引入 v-b-scrollspy directive</span><br><span class="hljs-keyword">import</span> &#123; VBScrollspyPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'bootstrap-vue'</span>;<br>Vue.use(VBScrollspyPlugin);<br></code></pre></td></tr></table></figure><p>作為 plugin import 時，大部分都會 import 所有子元件和相關 directive。例如：import <code>&lt;b-nav&gt;</code> 時，還包含所有 <code>&lt;nav-*&gt;</code> 子元件和所有 dropdown 子元件。</p><p>plugin 中包含了元件和 shorthand aliases (簡寫別名，如果有的話)，詳情請參閱各元件和 directive 的文件 (通常在各元件文件的最底部有告訴你如何 import 獨立元件和 Vue plugin)：</p><p><img src="../images/bootstrap-vue-env-import-components/import-components-or-vue-plugin.png" alt=""></p><p>若要 import 多個元件和/或 directive，請將所有 import 都含在單一 <code>import</code> 陳述句內，以達到最佳的 tree shaking。</p><h3 id="引入單一元件"><a class="header-anchor" href="#引入單一元件"></a>引入單一元件</h3><p>以上是直接引入 Vue plugin 的做法，會一次 import 多個元件或 directive，而接著要介紹只 import 單一元件的做法。</p><p>以 BootstrapVue 的 <a href="https://bootstrap-vue.org/docs/components/button#importing-individual-components" target="_blank" rel="noopener">Button</a> 元件為例，就有 <code>&lt;b-button&gt;</code> 和 <code>&lt;b-button-close&gt;</code> 這兩個元件，所以 <code>ButtonPlugin</code> 包含了這兩個元件，原始碼如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bootstrap-vue/src/components/button/index.js</span><br><span class="hljs-keyword">import</span> &#123; BButton &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./button'</span><br><span class="hljs-keyword">import</span> &#123; BButtonClose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./button-close'</span><br><span class="hljs-keyword">import</span> &#123; pluginFactory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../utils/plugins'</span><br><br><span class="hljs-keyword">const</span> ButtonPlugin = <span class="hljs-comment">/*#__PURE__*/</span> pluginFactory(&#123;<br>  components: &#123;<br>    BButton,<br>    BBtn: BButton,<br>    BButtonClose,<br>    BBtnClose: BButtonClose<br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> &#123; ButtonPlugin, BButton, BButtonClose &#125;<br></code></pre></td></tr></table></figure><p>另外也可以看到 shorthand aliases：</p><ul><li><code>BBtn</code> 和 <code>BButton</code> 是同一個元件</li><li><code>BBtnClose</code> 和 <code>BButtonClose</code> 是同一個元件</li></ul><p>所以若要引入單一元件只要這樣引入即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入 &lt;b-button&gt; 元件</span><br><span class="hljs-keyword">import</span> &#123; BButton &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'bootstrap-vue'</span>;<br>Vue.component(<span class="hljs-string">'b-button'</span>, BButton);<br></code></pre></td></tr></table></figure><h2 id="範例：引入部分元件"><a class="header-anchor" href="#範例：引入部分元件"></a>範例：引入部分元件</h2><ul><li>有些元件比較單純，所以可以只 import 單一元件<ul><li>例如：只需要 <a href="https://bootstrap-vue.org/docs/components/button#importing-individual-components" target="_blank" rel="noopener">Button</a> 元件中的 <code>&lt;b-button&gt;</code> 元件</li></ul></li><li>而有些元件則比較複雜，有很多子元件或相依的 Vue plugin。若手動自己 import 會很麻煩，所以需要直接透過 Vue plugin 來 import<ul><li>例如：<a href="https://bootstrap-vue.org/docs/components/navbar#importing-as-a-plugin" target="_blank" rel="noopener">Navbar</a> 元件有很多子元件，且相依於 <code>NavPlugin</code>、<code>DropdownPlugin</code> 和 <code>CollapsePlugin</code></li></ul></li></ul><p>從 <a href="https://bootstrap-vue.org/docs/components/navbar#importing-as-a-plugin" target="_blank" rel="noopener">Navbar</a> 元件的原始碼可以看到這些很多子元件和相依的 Vue plugin：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bootstrap-vue/src/components/navbar/index.js</span><br><span class="hljs-keyword">import</span> &#123; BNavbar &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./navbar'</span><br><span class="hljs-keyword">import</span> &#123; BNavbarNav &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./navbar-nav'</span><br><span class="hljs-keyword">import</span> &#123; BNavbarBrand &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./navbar-brand'</span><br><span class="hljs-keyword">import</span> &#123; BNavbarToggle &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./navbar-toggle'</span><br><span class="hljs-keyword">import</span> &#123; NavPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../nav'</span><br><span class="hljs-keyword">import</span> &#123; CollapsePlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../collapse'</span><br><span class="hljs-keyword">import</span> &#123; DropdownPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../dropdown'</span><br><span class="hljs-keyword">import</span> &#123; pluginFactory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../utils/plugins'</span><br><br><span class="hljs-keyword">const</span> NavbarPlugin = <span class="hljs-comment">/*#__PURE__*/</span> pluginFactory(&#123;<br>  components: &#123;<br>    BNavbar,<br>    BNavbarNav,<br>    BNavbarBrand,<br>    BNavbarToggle,<br>    BNavToggle: BNavbarToggle<br>  &#125;,<br>  plugins: &#123;<br>    NavPlugin,<br>    CollapsePlugin,<br>    DropdownPlugin<br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> &#123; NavbarPlugin, BNavbar, BNavbarNav, BNavbarBrand, BNavbarToggle &#125;<br></code></pre></td></tr></table></figure><p>所以若要使用 Button 元件和 Navbar 元件就會這樣 import：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/plugins/bootstrap-vue.js</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">'@/assets/scss/bootstrap.scss'</span>;<br><br><span class="hljs-comment">// 引入 &lt;b-button&gt; 元件</span><br><span class="hljs-keyword">import</span> &#123; BButton &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'bootstrap-vue'</span>;<br>Vue.component(<span class="hljs-string">'b-button'</span>, BButton);<br><br><span class="hljs-comment">// 引入 Navbar 元件：&lt;b-navbar&gt;，</span><br><span class="hljs-comment">// 和 Navbar 的子元件，包括：&lt;b-navbar-nav&gt;, &lt;b-navbar-brand&gt;, &lt;b-navbar-toggle&gt;，</span><br><span class="hljs-comment">// 以及其相依的 Vue plugin，包括：NavPlugin, CollapsePlugin, DropdownPlugin</span><br><span class="hljs-comment">// - NavPlugin 包括：&lt;b-nav&gt;, &lt;b-nav-item&gt;, &lt;b-nav-text&gt;,</span><br><span class="hljs-comment">//                  &lt;b-nav-form&gt;, &lt;b-nav-item-dropdown&gt;</span><br><span class="hljs-comment">// - CollapsePlugin 包括：&lt;b-collapse&gt;</span><br><span class="hljs-comment">// - DropdownPlugin 包括：&lt;b-dropdown&gt;, &lt;b-dropdown-item&gt;,</span><br><span class="hljs-comment">//                       &lt;b-dropdown-item-button&gt;, &lt;b-dropdown-divider&gt;,</span><br><span class="hljs-comment">//                       &lt;b-dropdown-form&gt;, &lt;b-dropdown-text&gt;,</span><br><span class="hljs-comment">//                       &lt;b-dropdown-group&gt;, &lt;b-dropdown-header&gt;</span><br><span class="hljs-keyword">import</span> &#123; NavbarPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'bootstrap-vue'</span>;<br>Vue.use(NavbarPlugin);<br></code></pre></td></tr></table></figure><h2 id="引入部分元件的樣式"><a class="header-anchor" href="#引入部分元件的樣式"></a>引入部分元件的樣式</h2><ul><li>要部分引入 BootstrapVue 的樣式，請參閱 <a href="https://github.com/twbs/bootstrap/blob/main/scss/bootstrap.scss" target="_blank" rel="noopener">bootstrap/scss/bootstrap.scss</a></li><li>要部分引入 Bootstrap 的樣式，請參閱 <a href="https://github.com/bootstrap-vue/bootstrap-vue/blob/dev/src/components/index.scss" target="_blank" rel="noopener">bootstrap-vue/src/components/index.scss</a></li></ul><p>建議手動引入相依元件的樣式！</p><p>但是，有些元件若有仔細看原始碼，就會發現不需要引入所有的相依元件，以 Navbar 元件為例，原本可能要這樣引入：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap-vue/src/components/navbar'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap-vue/src/components/nav'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap-vue/src/components/dropdown'</span>;<br></code></pre></td></tr></table></figure><p>但若詳細看這些相依元件的樣式原始碼，就會找到重複的引入。</p><p>Navbar 元件的樣式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// bootstrap-vue/src/components/navbar/index.scss</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">"navbar"</span>;<br><br><span class="hljs-comment">// bootstrap-vue/src/components/navbar/_navbar.scss</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">"../dropdown/index"</span>;<br></code></pre></td></tr></table></figure><p>Nav 元件的樣式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// bootstrap-vue/src/components/nav/index.scss</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">"nav-item-dropdown"</span>;<br><br><span class="hljs-comment">// bootstrap-vue/src/components/navbar/_nav-item-dropdown.scss</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">"../dropdown/index"</span>;<br></code></pre></td></tr></table></figure><p>Dropdown 元件的樣式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// bootstrap-vue/src/components/dropdown/index.scss</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">"dropdown"</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">"dropdown-form"</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">"dropdown-text"</span>;<br></code></pre></td></tr></table></figure><p>可以從上面這些元件看得出來，其實 Navbar 和 Nav 元件都引用了 Dropdown 元件的樣式，所以只需要引入 Navbar 元件的樣式即可。</p><h2 id="範例：引入部分元件的樣式"><a class="header-anchor" href="#範例：引入部分元件的樣式"></a>範例：引入部分元件的樣式</h2><ul><li>Bootstrap<ul><li>前面是 Bootstrap 基本要引入的：<ul><li><code>functions</code>、<code>variables</code>、<code>mixins</code></li><li><code>root</code>：在 root 元素 (即 <code>html</code> 元素) 上的設定，只設定 CSS 變數而已</li><li><code>reboot</code> (可選)：Bootstrap 的 reset CSS</li></ul></li><li>Bootstrap 網格 (可選)：<code>grid</code></li><li>Bootstrap 元件的樣式</li><li>Bootstrap 的 <code>utilities</code> (可選)</li></ul></li><li>BootstrapVue 元件的樣式</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// src/assets/scss/vendors/bootstrap-vue.scss</span><br><br><span class="hljs-comment">// ====================================</span><br><span class="hljs-comment">// # Bootstrap</span><br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/functions'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/variables'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/mixins'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/root'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/reboot'</span>;<br><br><span class="hljs-comment">// Bootstrap 網格</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/grid'</span>;<br><br><span class="hljs-comment">// Bootstrap 元件</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/transitions'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/dropdown'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/nav'</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/navbar'</span>;<br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap/scss/utilities'</span>;<br><br><span class="hljs-comment">// ====================================</span><br><span class="hljs-comment">// # BootstrapVue</span><br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">'~bootstrap-vue/src/components/navbar'</span>;<br></code></pre></td></tr></table></figure><p>資料來源：<a href="https://bootstrap-vue.org/docs" target="_blank" rel="noopener">Getting Started | BootstrapVue</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/bootstrap-vue.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇介紹在 Vue CLI 環境中，要如何全部引入或部分引入 BootstrapVue 的 Vue plugin、元件、directive 和元件的樣式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web-dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="Vue.js" scheme="https://titangene.github.io/tags/vue-js/"/>
    
      <category term="Bootstrap" scheme="https://titangene.github.io/tags/bootstrap/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>推薦 Chrome Extension：翻譯篇 - 新同文堂</title>
    <link href="https://titangene.github.io/article/recommend-chrome-extension-4.html"/>
    <id>https://titangene.github.io/article/recommend-chrome-extension-4.html</id>
    <published>2020-08-29T23:17:20.000Z</published>
    <updated>2020-08-29T23:16:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/chrome-extension.jpg" alt=""></p><p>本篇推薦我常用的 Chrome 翻譯 Extension：新同文堂。它不是像 Google 翻譯那樣單純的英翻中或簡轉繁，而是可以自訂指定的簡中用語轉成繁中用語，並能在任何/指定頁面自動將中國用語轉成台灣用語。</p><a id="more"></a><blockquote><p>其他推薦 Chrome Extension 相關文章可參閱 <a href="https://titangene.github.io/tags/chrome-extension/">推薦 Chrome Extension 系列文章</a>。</p></blockquote><p><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="noopener">Google 翻譯</a> Extension 沒什麼好介紹的，大家都很熟悉了，但有一些缺點：</p><ul><li>近期的英翻中大多都是中國用語，與我們日常使用的用語不同</li><li>只能簡中轉成繁中，但無法將中國用語轉成台灣用語</li></ul><p>雖然常看這些用語已經能在腦中自動翻譯了，但在閱讀上還是會有一些不習慣。</p><p>如果網頁能自動轉換成台灣用語那就太好啦！而「新同文堂」就能解決這個問題！</p><h1 id="新同文堂"><a class="header-anchor" href="#新同文堂"></a>新同文堂</h1><p>下載連結：<a href="https://chrome.google.com/webstore/detail/new-tong-wen-tang/ldmgbgaoglmaiblpnphffibpbfchjaeg" target="_blank" rel="noopener">新同文堂</a></p><p>功能：</p><ul><li>自訂指定的簡中用語轉成繁中用語</li><li>開啟任何/指定頁面都能自動將中國用語轉成台灣用語</li></ul><p>「一般設定」內有很多可以選項設定，包括是否啟動自動轉換、標點符號轉換、字型轉換…等：</p><p><img src="../images/recommend-chrome-extension-4/2020-08-29-23-35-52.png" alt=""></p><p>「自訂轉換規則」則是可自訂哪些網站是否要套用繁簡轉換的規則：</p><p><img src="../images/recommend-chrome-extension-4/2020-08-29-23-38-34.png" alt=""></p><p>而「自訂詞彙」就是可依你習換的用語來設定：</p><p><img src="../images/recommend-chrome-extension-4/2020-08-29-23-41-26.png" alt=""></p><p>像下面就是我自訂的詞彙，歡迎大家匯入使用：</p><script src="https://gist.github.com/titangene/8f015e54607f74bef8bf985fd426005f.js"></script><p>另外，也可參考其他人的設定：</p><ul><li><a href="https://github.com/doggy8088/newtongwen-settings" target="_blank" rel="noopener">doggy8088/newtongwen-settings</a></li><li><a href="https://github.com/pjchender/cn2tw4programmer/blob/master/src/terms/_newTongWenTang.json" target="_blank" rel="noopener">cn2tw4programmer/_newTongWenTang.json at master · pjchender/cn2tw4programmer</a></li></ul><p>實際用起來會像下圖這樣，上面是原本的中國用語，下面是透過新同文堂自動轉為台灣用語：</p><p><img src="../images/recommend-chrome-extension-4/2020-08-30-00-00-10.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/chrome-extension.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇推薦我常用的 Chrome 翻譯 Extension：新同文堂。它不是像 Google 翻譯那樣單純的英翻中或簡轉繁，而是可以自訂指定的簡中用語轉成繁中用語，並能在任何/指定頁面自動將中國用語轉成台灣用語。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://titangene.github.io/categories/tools/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Chrome" scheme="https://titangene.github.io/tags/chrome/"/>
    
      <category term="Chrome Extension" scheme="https://titangene.github.io/tags/chrome-extension/"/>
    
  </entry>
  
  <entry>
    <title>推薦 Chrome Extension：YouTube 篇</title>
    <link href="https://titangene.github.io/article/recommend-chrome-extension-3.html"/>
    <id>https://titangene.github.io/article/recommend-chrome-extension-3.html</id>
    <published>2020-08-23T15:51:20.000Z</published>
    <updated>2020-08-23T15:50:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/chrome-extension.jpg" alt=""></p><p>本篇推薦一些我常用的 Chrome Extension，包含自動重播 YouTube 影片，以及把 YouTube 影片變成漂浮視窗，能讓你邊看影片時還能邊看其他內容。</p><a id="more"></a><blockquote><p>其他推薦 Chrome Extension 相關文章可參閱 <a href="https://titangene.github.io/tags/chrome-extension/">推薦 Chrome Extension 系列文章</a>。</p></blockquote><h1 id="Looper-for-YouTube-自動重播"><a class="header-anchor" href="#Looper-for-YouTube-自動重播"></a>Looper for YouTube - 自動重播</h1><p>下載連結：<a href="https://chrome.google.com/webstore/detail/looper-for-youtube/iggpfpnahkgpnindfkdncknoldgnccdg" target="_blank" rel="noopener">Looper for YouTube - 自動重播</a></p><p>功能：</p><ul><li>自動重播 YouTube 影片</li><li>可自訂重播幾次</li><li>可自訂重播某片段</li><li>可自訂影片在重播時的畫質</li></ul><p>我常用 YouTube 來聽歌，若希望重播某首音樂來讓自己進入心流狀態，那此 extension 就能輕鬆達到這個需求，讓你不用手動重新播放 YouTube，專住在要做的事上。</p><p>按下「自動重播」就會無限次的自動重播該 YouTube 影片，此時 YouTube 播放清單的自動播放就會被禁用：</p><p><img src="../images/recommend-chrome-extension-3/2020-08-23-23-10-18.png" alt=""></p><p>也可自訂重播幾次，以及重播某片段：</p><p><img src="../images/recommend-chrome-extension-3/2020-08-23-23-11-28.png" alt=""></p><p>在選項內還有其他設定，包括影片在重播時的畫質：</p><p><img src="../images/recommend-chrome-extension-3/2020-08-23-23-12-43.png" alt=""></p><h1 id="Mini-Y"><a class="header-anchor" href="#Mini-Y"></a>Mini Y</h1><p>下載連結：<a href="https://chrome.google.com/webstore/detail/mini-y/acphfpihfjpgnihkgelafhmjeoodbehp" target="_blank" rel="noopener">Mini Y</a></p><p>功能：將 YouTube 影片變成漂浮視窗</p><p>你在播放 YouTube 影片時有以下需求嗎：</p><ul><li>邊看影片，邊看影片底下的敘述內容 (例如：音樂歌詞)</li><li>邊看影片，邊看影片底下的留言</li><li>邊看影片，邊看右側的推薦影片</li></ul><p>這個 extension 就解決了這些需求！</p><p>當你將畫面往下捲動，它會將 YouTube 影片變成漂浮視窗放在一側：</p><p><img src="../images/recommend-chrome-extension-3/2020-08-23-23-43-20.png" alt=""></p><p>而且你在 hover 該漂浮影片時，可讓你自由選擇漂浮視窗要改變的大小：</p><p><img src="../images/recommend-chrome-extension-3/2020-08-23-23-34-30.png" alt=""></p><p>而且還可隨意將漂浮視窗拖曳至你喜歡的位置：</p><p><img src="../images/recommend-chrome-extension-3/2020-08-23-23-37-38.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/chrome-extension.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇推薦一些我常用的 Chrome Extension，包含自動重播 YouTube 影片，以及把 YouTube 影片變成漂浮視窗，能讓你邊看影片時還能邊看其他內容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://titangene.github.io/categories/tools/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Chrome" scheme="https://titangene.github.io/tags/chrome/"/>
    
      <category term="Chrome Extension" scheme="https://titangene.github.io/tags/chrome-extension/"/>
    
  </entry>
  
  <entry>
    <title>推薦 Chrome Extension：新分頁篇</title>
    <link href="https://titangene.github.io/article/recommend-chrome-extension-2.html"/>
    <id>https://titangene.github.io/article/recommend-chrome-extension-2.html</id>
    <published>2020-08-16T15:38:24.000Z</published>
    <updated>2020-08-16T15:37:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/chrome-extension.jpg" alt=""></p><p>本篇推薦一些我常用的 Chrome Extension，包含隨機風景照的新分頁、隨機小知識的新分頁，以及能列出訂閱技術文章的新分頁。</p><a id="more"></a><blockquote><p>其他推薦 Chrome Extension 相關文章可參閱 <a href="https://titangene.github.io/tags/chrome-extension/">推薦 Chrome Extension 系列文章</a>。</p></blockquote><h1 id="新分頁"><a class="header-anchor" href="#新分頁"></a>新分頁</h1><p>「起始分頁」就是當你打新分頁時，顯示的那個分頁。</p><p>預設的新分頁很簡潔<s>簡陋</s>，有 Google 搜尋、常用頁面。沒了…</p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-21-39-06.png" alt=""></p><p>當然你可以點擊右下角的「自訂」來設定背景、快速鍵 (設定捷徑、常看的網站)、顏色和主題：</p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-21-42-40.png" alt=""></p><p>每次只能看純顏色的背景，或是一樣的背景圖，看膩了還要自己換！</p><p>有沒有會幫你自動換漂亮風景照的工具？那我最推的就是「Unsplash Instant」。</p><h2 id="Unsplash-Instant"><a class="header-anchor" href="#Unsplash-Instant"></a>Unsplash Instant</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/unsplash-instant/pejkokffkapolfffcgbmdmhdelanoaih" target="_blank" rel="noopener">Unsplash Instant</a></p><p>功能：</p><ul><li>隨機照片：每次開新分頁都會看到不同的照片</li><li>下載照片：若看到喜歡的照片，可下載至電腦，甚至設為桌布</li></ul><p>Unsplash 是蠻有名的高解析度免費圖庫平台，每張照片採用的授權很自由，任何人都可將照片自由使用至任何目的 (免費下載和使用、用於商業和非商業目的、不需許可)。</p><p>而這個 extension 就是由 Unsplash 官方推出的！只要安裝此 extension，你開的新分頁就會是隨機漂亮的照片了！</p><p><img src="../images/recommend-chrome-extension-2/unsplash-instant.gif" alt=""></p><p>如果你不小心將快速開啟的新分頁關閉了，不用擔心，此 extension 有提供歷史紀錄，可以讓你看前兩張照片：</p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-22-03-49.png" alt=""></p><p>若要下載照片，只要點擊右上角的「Download」即可。若要查看原照片連結，只要點擊左上角的 icon 即可跳至該連結。</p><p>剛剛介紹了美化的新分頁，那接著來介紹能讓你提昇開發技能的 extension。</p><h2 id="30-Seconds-of-Knowledge"><a class="header-anchor" href="#30-Seconds-of-Knowledge"></a>30 Seconds of Knowledge</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/30-seconds-of-knowledge/mmgplondnjekobonklacmemikcnhklla" target="_blank" rel="noopener">30 Seconds of Knowledge</a></p><p>功能：</p><ul><li>提供多種程式語言的知識：包含 C++、CSS、JavaScript、PHP、Python、Ruby、React、Ramda、面試題等</li><li>隨機小知識：每次開新分頁都會看到不同的知識，就如其名，只需要 30 秒就能閱讀完並理解</li><li>儲存 snippet：若看到不錯的小知識，可儲存下來之後閱讀</li></ul><p><img src="../images/recommend-chrome-extension-2/2020-08-16-22-33-54.png" alt=""></p><p>儲存下來的 snippet 會放在右下角的選單 icon，裡面的第一個 icon：</p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-22-46-33.png" alt=""></p><p>像下圖就是我儲存的 snippet：</p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-22-48-07.png" alt=""></p><p>此 extension 也提供一些設定，包括：</p><ul><li>選擇要看的程式語言主題</li><li>主題：暗/亮</li><li>字體大小</li></ul><p><img src="../images/recommend-chrome-extension-2/2020-08-16-22-36-22.png" alt=""></p><p>若覺得小知識不能滿足你，你想訂閱更多文章和新的技術資訊，那「daily.dev」一定很適合你！</p><h2 id="daily-dev-News-for-Busy-Developers"><a class="header-anchor" href="#daily-dev-News-for-Busy-Developers"></a>daily.dev - News for Busy Developers</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/dailydev-news-for-busy-de/jlmpjdjjbgclbocgajdjefcidcncaied" target="_blank" rel="noopener">daily.dev - News for Busy Developers</a></p><p>功能：</p><ul><li>隨時接收最新的文章和技術資訊：新文章都會列在新分頁上</li><li>可選擇要訂閱的網站或 tag</li><li><a href="https://github.com/dailydotdev/daily" target="_blank" rel="noopener">開源</a>：若有 bug，歡迎大家貢獻</li></ul><p><img src="../images/recommend-chrome-extension-2/2020-08-16-23-00-31.png" alt=""></p><p>左邊的選單可讓你選擇要訂閱的來源，可以是網站或 tag：</p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-23-02-01.png" alt=""></p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-23-11-22.png" alt=""></p><p>若有喜歡或是想稍後閱讀的文章，可加入書籤保存：</p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-23-16-29.png" alt=""></p><p>像下圖就是我保存的文章：</p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-23-19-53.png" alt=""></p><p>有一些是付費功能，例如：自己新增來源，可以是 blog 或 RSS 網址。歡迎大家把我的「Titangene Blog」的 RSS 網址訂閱起來 XD：<a href="https://titangene.github.io/atom.xml">https://titangene.github.io/atom.xml</a></p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-23-04-48.png" alt=""></p><p><img src="../images/recommend-chrome-extension-2/2020-08-16-23-08-05.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/chrome-extension.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇推薦一些我常用的 Chrome Extension，包含隨機風景照的新分頁、隨機小知識的新分頁，以及能列出訂閱技術文章的新分頁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://titangene.github.io/categories/tools/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Chrome" scheme="https://titangene.github.io/tags/chrome/"/>
    
      <category term="Chrome Extension" scheme="https://titangene.github.io/tags/chrome-extension/"/>
    
  </entry>
  
  <entry>
    <title>推薦 Chrome Extension：Markdown &amp; 頁面主題篇</title>
    <link href="https://titangene.github.io/article/recommend-chrome-extension-1.html"/>
    <id>https://titangene.github.io/article/recommend-chrome-extension-1.html</id>
    <published>2020-08-09T15:56:36.000Z</published>
    <updated>2020-08-16T15:25:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/chrome-extension.jpg" alt=""></p><p>本篇推薦一些我常用的 Chrome Extension，包含複製分頁的 Markdown 格式的連結、將頁面變為暗主題。</p><a id="more"></a><blockquote><p>其他推薦 Chrome Extension 相關文章可參閱 <a href="https://titangene.github.io/tags/chrome-extension/">推薦 Chrome Extension 系列文章</a>。</p></blockquote><h1 id="Markdown"><a class="header-anchor" href="#Markdown"></a>Markdown</h1><h2 id="Copy-as-Markdown"><a class="header-anchor" href="#Copy-as-Markdown"></a>Copy as Markdown</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/fkeaekngjflipcockcnpobkpbbfbhmdn" target="_blank" rel="noopener">Copy as Markdown</a></p><p>功能：</p><ul><li>複製當前分頁的 Markdown 格式的連結</li><li>複製該視窗的所有分頁的 Markdown 格式的連結</li></ul><p>點擊 Extension 的圖案，可看到多種選項功能。其中的「Current tab link」選項會將該分頁連結的 Markdown 格式複製至剪貼簿。</p><p>假設要複製此 blog 文章的連結，剪貼簿內儲存的連結格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">[重新認識 CSS - 總結 &amp; 系列目錄 | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-series-catalog.html)<br></code></pre></td></tr></table></figure><p>此 Extension 會將頁面標題 (即 <code>&lt;title&gt;</code> 標籤的內容) 和連結變為 Markdown 格式。</p><p><img src="../images/recommend-chrome-extension-1/copy-as-markdown.png" alt=""></p><p>還有更厲害的！點擊「All tab link (n)」選項會複製該視窗的所有分頁連結，並以 Markdown 的無序清單的形式 (即 <code>*</code> ) 複製至剪貼簿。</p><p>以上圖為例，此視窗開了 3 個分頁，所以我點擊「All tab link (n)」選項會複製以下內容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">* [重新認識 CSS - 總結 &amp; 系列目錄 | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-series-catalog.html)<br>* [Git - 刪除遠端分支 (以 GitHub、GitLab 為例) | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git-delete-remote-branch.html)<br>* [深入 Git：Git 物件儲存 - blob 物件 | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git--blob-object.html)<br></code></pre></td></tr></table></figure><p>如果只想要複製標題或連結而已，可以點擊「All tab title」或「All tab URL」選項。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">* 重新認識 CSS - 總結 &amp; 系列目錄 | Titangene Blog<br>* Git - 刪除遠端分支 (以 GitHub、GitLab 為例) | Titangene Blog<br>* 深入 Git：Git 物件儲存 - blob 物件 | Titangene Blog<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">* https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-series-catalog.html<br>* https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git-delete-remote-branch.html<br>* https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git--blob-object.html<br></code></pre></td></tr></table></figure><p>寫 Markdown 筆記時，若想一次複製多個分頁的連結，並且是 Markdown 格式，用了這個「Copy as Markdown」Extension 就不用自己手動打了！</p><h2 id="拷貝為-Markdown"><a class="header-anchor" href="#拷貝為-Markdown"></a>拷貝為 Markdown</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/copy-as-markdown/dgoenpnkphkichnohepecnmpmihnabdg" target="_blank" rel="noopener">拷貝為 Markdown</a></p><p>功能：將選取的內容轉為 Markdown 格式</p><p>假設我要複製以下選取的內容，並且可以取得 Markdown 格式，只要選取該內容後，並點擊 Extension 的圖案，就會將內容複製至剪貼簿：</p><p><img src="../images/recommend-chrome-extension-1/copy-markdown.png" alt=""></p><p>複製的內容如下。可以看到連標題 (即 <code>##</code> )、無序列表 (即 <code>*</code> )、引用 (即 <code>&gt;</code> ) 都能自動轉成 Markdown 格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">## Assigning property values, Cascading, and Inheritance<br><br>瞭解在 CSS 中，繼承和權重這些重要的觀念之後，接著就可以更深入的瞭解 CSS 是如何處理屬性值的。系列如下：<br><br>* [重新認識 CSS - Inheritance (繼承)](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-inheritance.html)<br>* [重新認識 CSS - Cascading &amp; Specificity](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-cascading-and-specificity.html)<br>* [重新認識 CSS - CSS 如何處理屬性值](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-value-processing.html)<br><br>&gt; 對應 spec 的以下幾篇：<br>&gt;<br>&gt; * [CSS 2.2 - 6. Assigning property values, Cascading, and Inheritance](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;CSS22&#x2F;cascade.html)<br>&gt; * [CSS Cascading and Inheritance Level 3](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css-cascade-3&#x2F;)<br>&gt; * [CSS Cascading and Inheritance Level 4](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css-cascade-4&#x2F;)<br></code></pre></td></tr></table></figure><h1 id="頁面主題"><a class="header-anchor" href="#頁面主題"></a>頁面主題</h1><h2 id="Dark-Reader"><a class="header-anchor" href="#Dark-Reader"></a>Dark Reader</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh" target="_blank" rel="noopener">Dark Reader</a></p><p>功能：將頁面變成暗主題、護眼模式</p><p>點擊 Extension 的圖案會開啟設定視窗，點擊左上角的按鈕就可以啟用暗主題。</p><p>它會自動偵測需要改變的顏色，大致上的目標是黑底白字。</p><p>像下圖就是 Google 搜尋頁面的暗主題模式，你也可以自訂亮度、對比度等設定。</p><p>你可對每個網站設定不同的設定，例如：A 網站要開啟暗主題，但 B 網站關閉暗主題。</p><p><img src="../images/recommend-chrome-extension-1/dark-reader.png" alt=""></p><h2 id="Stylus"><a class="header-anchor" href="#Stylus"></a>Stylus</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne" target="_blank" rel="noopener">Stylus</a></p><p>功能：在各自頁面自訂 CSS 樣式，即客製化主題</p><p>之前在「<a href="https://titangene.github.io/article/hackmd-dark-theme.html">套用自訂 HackMD 暗主題</a>」就有提供這個 Extension，當時我為 HackMD 客製化了暗主題。</p><p>當然你也可以在你希望的網頁上自訂 CSS，例如：</p><ul><li>頁面的字太小，所以自己設定 <code>font-size</code> 放大</li><li>文章連結沒有底線，看不出與無連結文字的差別，所以自己為設定了 <code>a { text-decoration: underline; }</code></li><li>…等</li></ul><p>那如何各別網站設定自訂的 CSS 呢？只要點擊 Extension 的圖案，並點擊「編寫樣式給：」下面的網址連結，就會為該網站開啟自訂 CSS 的編輯器：</p><p><img src="../images/recommend-chrome-extension-1/stylus-1.png" alt=""></p><p>接著就可以開始寫自訂 CSS 了。像下圖是我自訂本 blog 的背景顏色改為灰黑色，只要儲存就能成功套用：</p><p><img src="../images/recommend-chrome-extension-1/stylus-2.png" alt=""></p><p>如果想將自己自訂的 CSS 分享給別人，可將設定上傳至 <a href="https://userstyles.org/" target="_blank" rel="noopener">Userstyles.org</a> 這個網站讓別人下載套用。</p><h2 id="Medium-Code-Highlighter"><a class="header-anchor" href="#Medium-Code-Highlighter"></a>Medium Code Highlighter</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/medium-code-highlighter/apdaagmhepellbjjbnaljaocodjjjjfd" target="_blank" rel="noopener">Medium Code Highlighter</a></p><p>功能：highlight Medium 文章內的程式碼</p><p>找資料時，常會看到 Medium 的文章，但他的程式碼區塊沒有提供 code highlight 功能。</p><p>使用此 Extension 就能 highlight Medium 文章內的程式碼：</p><p><img src="../images/recommend-chrome-extension-1/medium-code-highlighter-1.png" alt=""></p><p>而且還能自己選主題：</p><p><img src="../images/recommend-chrome-extension-1/medium-code-highlighter-2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/chrome-extension.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇推薦一些我常用的 Chrome Extension，包含複製分頁的 Markdown 格式的連結、將頁面變為暗主題。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://titangene.github.io/categories/tools/"/>
    
    
      <category term="Markdown" scheme="https://titangene.github.io/tags/markdown/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Chrome" scheme="https://titangene.github.io/tags/chrome/"/>
    
      <category term="Chrome Extension" scheme="https://titangene.github.io/tags/chrome-extension/"/>
    
      <category term="Theme" scheme="https://titangene.github.io/tags/theme/"/>
    
  </entry>
  
  <entry>
    <title>Jest：DOM 測試 (jQuery)</title>
    <link href="https://titangene.github.io/article/jest-jquery-dom-testing.html"/>
    <id>https://titangene.github.io/article/jest-jquery-dom-testing.html</id>
    <published>2020-08-02T15:55:10.000Z</published>
    <updated>2020-08-02T15:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>若用 Jest 來測試直接操作 DOM 的程式碼，最大好處是不用安裝額外的套件就可以測試，因為 Jest 附帶了 <code>jsdom</code>，它是用來模擬 DOM 環境，讓你很像在瀏覽器上呼叫 DOM API，進而觀察 DOM 的操作是否符合預期，也就代表測畫面不用真的開啟瀏覽器，不用等待畫面渲染就可以進行測試。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><h1 id="寫範例程式碼"><a class="header-anchor" href="#寫範例程式碼"></a>寫範例程式碼</h1><p>本篇會用下面程式碼作為範例：</p><ul><li><code>fetchCurrentUser.js</code>：發送 request，並將收到的資料進行解析處理</li><li><code>displayUser.js</code>：在按鈕上註冊 <code>click</code> 事件，點擊按鈕後會發 API，並將資料顯示在畫面上</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/fetchCurrentUser.js</span><br><span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseJSON</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    fullName: user.firstName + <span class="hljs-string">' '</span> + user.lastName,<br>    loggedIn: <span class="hljs-literal">true</span>,<br>  &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchCurrentUser</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> $.ajax(&#123;<br>    success: <span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> callback(parseJSON(user)),<br>    type: <span class="hljs-string">'GET'</span>,<br>    url: <span class="hljs-string">'http://example.com/currentUser'</span>,<br>  &#125;);<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = fetchCurrentUser;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/displayUser.js</span><br><span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>);<br><span class="hljs-keyword">const</span> fetchCurrentUser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./fetchCurrentUser.js'</span>);<br><br>$(<span class="hljs-string">'#button'</span>).click(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  fetchCurrentUser(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> loggedText = <span class="hljs-string">'Logged '</span> + (user.loggedIn ? <span class="hljs-string">'In'</span> : <span class="hljs-string">'Out'</span>);<br>    $(<span class="hljs-string">'#username'</span>).text(user.fullName + <span class="hljs-string">' - '</span> + loggedText);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="建立測試"><a class="header-anchor" href="#建立測試"></a>建立測試</h1><p>被測試的函數在 <code>#button</code> DOM 元素上新增一個事件監聽器，所以需要設定 DOM 來進行測試。</p><p>Jest 附帶了 <code>jsdom</code>，它模擬一個 DOM 環境，很像瀏覽器，代表呼叫的每個 DOM API 都可像在瀏覽器中觀察的方式一樣。</p><p>mock <code>fetchCurrentUser.js</code> 可讓測試不用真的發出請求，可 reslove 成 local mock data，快速進行測試。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/displayUser.test.js</span><br>jest.mock(<span class="hljs-string">'../src/fetchCurrentUser'</span>);<br><br>it(<span class="hljs-string">'點擊按鈕後顯示使用者已登入'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 設定 document body</span><br>  <span class="hljs-built_in">document</span>.body.innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;span id="username"&gt;&lt;/span&gt;</span><br><span class="hljs-string">    &lt;button id="button"&gt;&lt;/button&gt;`</span>;<br><br>  <span class="hljs-comment">// 此 module 有 side-effect</span><br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/displayUser'</span>);<br><br>  <span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>);<br>  <span class="hljs-keyword">const</span> fetchCurrentUser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/fetchCurrentUser'</span>);<br><br>  <span class="hljs-comment">// 告訴 fetchCurrentUser mock 函數自動使用一些資料來 invoke callback</span><br>  fetchCurrentUser.mockImplementation(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>    callback(&#123;<br>      fullName: <span class="hljs-string">'Titan'</span>,<br>      loggedIn: <span class="hljs-literal">true</span>,<br>    &#125;);<br>  &#125;);<br><br>  <span class="hljs-comment">// 點擊前的 DOM</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.body.innerHTML);<br><br>  <span class="hljs-comment">// 使用 jQuery 模擬點擊按鈕</span><br>  $(<span class="hljs-string">'#button'</span>).click();<br><br>  <span class="hljs-comment">// 點擊後的 DOM</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.body.innerHTML);<br><br>  <span class="hljs-comment">// Assert fetchCurrentUser 函數已被呼叫，</span><br>  <span class="hljs-comment">// 且 span#username 的 inner text 已按預期更新了</span><br>  expect(fetchCurrentUser).toBeCalled();<br>  expect($(<span class="hljs-string">'#username'</span>).text()).toEqual(<span class="hljs-string">'Titan - Logged In'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>下面測試為何要用 <code>$.ajax.mock.calls[0][0].success()</code> 的方式測，而不是直接 mock <code>src/fetchCurrentUser.js</code> 檔案內的 <code>parseJSON</code>？</p><p>因為 <code>src/fetchCurrentUser.js</code> 檔案內的 <code>parseJSON</code> 沒有 export，所以不能 mock，而且 mock 就失去測試的意義了，該測試就是為了確定 <code>$.ajax</code> 發出請求拿到的使用者資料透過 <code>parseJSON</code> 處理後是否會得到正確的資料 (API 會回傳使用者的 <code>firstName</code> 和 <code>lastName</code>，而 <code>parseJSON</code> 是負責把名字組合成 <code>fullName</code> 和是否登入的狀態 <code>loggedIn</code> )。</p><div class="info"><p>註：Jest 官方文件提供的 <a href="https://github.com/facebook/jest/tree/master/examples/jquery/" target="_blank" rel="noopener">examples/jquery</a> 範例內原本沒有以下內容，因視需求而修改的：</p><ul><li>為了讓將 mock 過的 <code>$.ajax()</code> 在每個測試執行前都被清乾淨 (不保留前一個測試使用個的痕跡)，所以需要在 <code>beforeEach()</code> 內加上 <code>$.ajax.mockClear()</code></li><li>原本範例內的每個測試都 require 了 <code>jquery</code> 和 <code>fetchCurrentUser.js</code>，為了簡化測試檔，把這些 require 統一放在測試檔的最上面</li><li>可用與 <code>expect(callback.mock.calls[0][0]).toEqual()</code> 行為一致的 <code>expect(callback).toBeCalledWith()</code> 但更簡潔的</li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/fetchCurrentUser.test.js</span><br><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">'jquery'</span>;<br><span class="hljs-keyword">const</span> fetchCurrentUser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/fetchCurrentUser'</span>);<br><br>jest.mock(<span class="hljs-string">'jquery'</span>);<br><br>beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  jest.resetModules();<br>  $.ajax.mockClear();<br>&#125;);<br><br>it(<span class="hljs-string">'用正確的參數呼叫 $.ajax'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 呼叫要測試的函數</span><br>  <span class="hljs-keyword">const</span> dummyCallback = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;;<br>  fetchCurrentUser(dummyCallback);<br><br>  <span class="hljs-comment">// 確保在前兩行有正確的呼叫 $.ajax</span><br>  <span class="hljs-comment">// 不在意 $.ajax 的請求結果，只驗證呼叫 $.ajax 時傳的參數是否正確</span><br>  expect($.ajax).toBeCalledWith(&#123;<br>    success: expect.any(<span class="hljs-built_in">Function</span>),<br>    type: <span class="hljs-string">'GET'</span>,<br>    url: <span class="hljs-string">'http://example.com/currentUser'</span>,<br>  &#125;);<br>&#125;);<br><br>it(<span class="hljs-string">'$.ajax 請求完成後呼叫 callback'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 為 callback 建立一個 mock function</span><br>  <span class="hljs-keyword">const</span> callback = jest.fn();<br>  fetchCurrentUser(callback);<br><br>  <span class="hljs-comment">// 模擬 `$.ajax` 執行自己的 callback</span><br>  <span class="hljs-comment">// 第一次呼叫的第一個參數</span><br>  $.ajax.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].success(&#123;<br>    firstName: <span class="hljs-string">'Bobby'</span>,<br>    lastName: <span class="hljs-string">'Marley'</span>,<br>  &#125;);<br><br>  <span class="hljs-comment">// assert 模擬 `$.ajax` 呼叫的 callback 傳入的 arg</span><br>  <span class="hljs-comment">// 第一次呼叫的第一個參數</span><br>  expect(callback.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).toEqual(&#123;<br>    fullName: <span class="hljs-string">'Bobby Marley'</span>,<br>    loggedIn: <span class="hljs-literal">true</span>,<br>  &#125;);<br>  expect(callback).toBeCalledWith(&#123;<br>    fullName: <span class="hljs-string">'Bobby Marley'</span>,<br>    loggedIn: <span class="hljs-literal">true</span>,<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在 <code>fetchCurrentUser.test.js</code> 測試檔內我自己加了一個測試，用來測使用者點擊按鈕後是否正確的呼叫 <code>fetchCurrentUser()</code>，並且裡面呼叫的 <code>$.ajax()</code> 是否有正確的呼叫 <code>success</code> 內的 <code>callback</code> (即 <code>success: user =&gt; callback(parseJSON(user))</code> )。</p><p>但為了不讓 <code>$.ajax()</code> 發出真的請求，所以用 <code>$.ajax = jest.fn()</code> mock，接著再透過 <code>$.ajax.mock.calls[0][0].success({...})</code> 的方式呼叫 <code>success</code> 內的 <code>callback</code>。</p><p>不過，這個測試比較複雜，因為測試檔的最上面使用了 <code>jest.mock('jquery')</code>，讓整個測試檔都 mock 了 jQuery，但在 <code>require('../src/displayUser')</code> 要綁定按鈕點擊事件時需要用真的 jQuery，所以才需要用 <code>jest.unmock('jquery')</code> unmock jQuery。</p><p>除了綁定按鈕點擊事件要用真的 jQuery，觸發點擊事件後顯示使用者已登入的 <code>$('#username').text()</code> 也要用真的 jQuery (因本測試會用 <code>span#username</code> 的 <code>innerText</code> 來驗證測試)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/fetchCurrentUser.test.js</span><br><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">'jquery'</span>;<br><span class="hljs-keyword">const</span> fetchCurrentUser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/fetchCurrentUser'</span>);<br><br>jest.mock(<span class="hljs-string">'jquery'</span>);<br><br>beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  jest.resetModules();<br>  $.ajax.mockClear();<br>&#125;);<br><br>it(<span class="hljs-string">'點擊按鈕發出 $.ajax 請求，請求完成後顯示使用者已登入'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 設定 document body</span><br>  <span class="hljs-built_in">document</span>.body.innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;span id="username"&gt;&lt;/span&gt;</span><br><span class="hljs-string">    &lt;button id="button"&gt;&lt;/button&gt;`</span>;<br><br>  <span class="hljs-comment">// 使用 `jest.unmock(...)` 後，require 的模組都會是真的，不是 mock 的</span><br>  <span class="hljs-comment">// 因測試檔的最上面 mock 了 jQuery，而 `displayUser.js` 內</span><br>  <span class="hljs-comment">// 需要跑真的 jQuery，所以需要 unmock jQuery，</span><br>  jest.unmock(<span class="hljs-string">'jquery'</span>);<br><br>  <span class="hljs-comment">// 此 module 有 side-effect</span><br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/displayUser'</span>);<br><br>  <span class="hljs-comment">// 觸發點擊事件內要執行真的 `$(...).text()`，所以需要真的 jQuery</span><br>  <span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>);<br><br>  <span class="hljs-comment">// 但只有 `$.ajax` 需要 mock</span><br>  $.ajax = jest.fn();<br>  <span class="hljs-comment">// 模擬點擊按鈕</span><br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'button'</span>).click();<br><br>  <span class="hljs-comment">// 模擬 `$.ajax` 執行自己的 callback</span><br>  <span class="hljs-comment">// 第一次呼叫的第一個參數</span><br>  $.ajax.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].success(&#123;<br>    firstName: <span class="hljs-string">'Bobby'</span>,<br>    lastName: <span class="hljs-string">'Marley'</span>,<br>  &#125;);<br><br>  <span class="hljs-comment">// Assert span#username 的 inner text 已按預期更新了 (畫面顯示使用者已登入)</span><br>  expect($(<span class="hljs-string">'#username'</span>).text()).toEqual(<span class="hljs-string">'Bobby Marley - Logged In'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/tutorial-jquery" target="_blank" rel="noopener">DOM Manipulation · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;若用 Jest 來測試直接操作 DOM 的程式碼，最大好處是不用安裝額外的套件就可以測試，因為 Jest 附帶了 &lt;code&gt;jsdom&lt;/code&gt;，它是用來模擬 DOM 環境，讓你很像在瀏覽器上呼叫 DOM API，進而觀察 DOM 的操作是否符合預期，也就代表測畫面不用真的開啟瀏覽器，不用等待畫面渲染就可以進行測試。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="mock" scheme="https://titangene.github.io/tags/mock/"/>
    
      <category term="DOM" scheme="https://titangene.github.io/tags/dom/"/>
    
      <category term="jQuery" scheme="https://titangene.github.io/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Manual Mocks</title>
    <link href="https://titangene.github.io/article/jest-manual-mocks.html"/>
    <id>https://titangene.github.io/article/jest-manual-mocks.html</id>
    <published>2020-07-26T15:59:04.000Z</published>
    <updated>2020-07-26T16:00:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>manual mock 是用於透過 mock 資料來對功能進行 stub out。例如：若你不想存取網站或 DB 之類的遠端資源，可能需要使用 fake data 來 manual mock 這些功能，以確保可以快速測試且不會出錯。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><h1 id="Mocking-user-modules"><a class="header-anchor" href="#Mocking-user-modules"></a>Mocking user modules</h1><p>manual mock 是透過將模組寫在相鄰該模組的 <code>__mocks__/</code> 子目錄內來定義的。例如：要在 <code>models</code> 目錄 mock 一個名為 <code>user</code> 的模組，請建立名為 <code>user.js</code> 的檔案，並將該檔案放在 <code>models/__mocks__</code> 目錄中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">.<br>├── models<br>│   ├── __mocks__<br>│   │   └── user.js<br>│   └── user.js<br>└── main.js<br></code></pre></td></tr></table></figure><div class="info"><p><code>__mocks__</code> 資料夾會區分大小寫 (case-sensitive)，所以在某些 OS 上命名成 <code>__MOCKS__</code> 會失效。</p></div><h2 id="範例"><a class="header-anchor" href="#範例"></a>範例</h2><p>完整目錄如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── src<br>│   ├── controllers<br>│   │   ├── __mocks__<br>│   │   │   └── user.js<br>│   │   └── user.js<br>│   ├── models<br>│   │   ├── index.js<br>│   │   └── user.js<br>│   ├── setup.js<br>│   └── main.js<br>└── __tests__<br>    └── userMocked.test.js<br></code></pre></td></tr></table></figure><p>在 <code>src/controllers/user.js</code> 內提供取得第一個使用者資訊的 <code>getFirstUser()</code> (從 DB 拿出來的資料)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/controllers/user.js</span><br><span class="hljs-keyword">const</span> User = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../models'</span>).User;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-keyword">async</span> getFirstUser() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> userId = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> models.user.findByPk(userId);<br>      <span class="hljs-keyword">return</span> user;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-built_in">console</span>.log(error.message);<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>接著在 <code>src/controllers</code> 目錄內新增 <code>__mocks__</code> 子目錄，並在裡面建立名為 <code>user.js</code> 的檔案，內容如下，manual mock 的內容就是回傳固定的 fake data，讓每次執行測試不用真的去讀取資料庫的資料：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/controllers/__mocks__/user.js</span><br><span class="hljs-keyword">const</span> User = jest.createMockFromModule(<span class="hljs-string">'../user'</span>);<br><br>User.getFirstUser = <span class="hljs-keyword">async</span> () =&gt; (&#123;<br>  name: <span class="hljs-string">'Mock name'</span>,<br>  age: <span class="hljs-number">87</span><br>&#125;);<br><br><span class="hljs-built_in">module</span>.exports = User;<br></code></pre></td></tr></table></figure><p>測試要引入 manual mock 的模組時，記得要呼叫 <code>jest.mock('./moduleName')</code>，其餘測試寫法就跟平時一樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/userMocked.test.js</span><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/controllers/user'</span>;<br><br>jest.mock(<span class="hljs-string">'../src/controllers/user'</span>);<br><br>it(<span class="hljs-string">'if user model is mocked'</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> expected = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'Mock name'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">87</span>&#125;;<br><br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> User.getFirstUser();<br><br>  expect(user).toMatchObject(expected);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Mocking-Node-modules"><a class="header-anchor" href="#Mocking-Node-modules"></a>Mocking Node modules</h1><p>若要 mock 的模組是 Node 模組 (例如：<code>lodash</code> )，則 mock 應放在與 <code>node_modules</code> 相鄰的 <code>__mocks__</code> 目錄中 (除非你將 <a href="https://jestjs.io/docs/en/configuration#roots-arraystring" target="_blank" rel="noopener"><code>roots</code></a> 配置為指向專案 root 目錄以外的資料夾)，並且會被自動 mock。無需明確呼叫 <code>jest.mock('./moduleName')</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">.<br>├── __mocks__<br>│   └── lodash.js<br>├── node_modules<br>│   └── lodash<br>│       └── lodash.js<br>└── main.js<br></code></pre></td></tr></table></figure><p>可以透過在目錄結構中建立一個與 scoped module 名稱 match 的檔案來 mock scoped module。例如：若要 mock 名為 <code>@scope/project-name</code> 的 scoped module，請建立名為 <code>__mocks__/@scope/project-name.js</code> 的檔案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">.<br>├── __mocks__<br>│   └── @scope<br>│       └── project-name.js<br>├── node_modules<br>│   └── @scope<br>│       └── project-name<br>└── main.js<br></code></pre></td></tr></table></figure><div class="warning"><p>警告：若要 mock Node 的核心模組 (例如：<code>fs</code> 或 <code>path</code> )，必須要明確呼叫 (例如：<code>jest.mock('path')</code> )，因為預設不會 mock 核心 Node 模組。</p></div><h1 id="例如"><a class="header-anchor" href="#例如"></a>例如</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">.<br>├── config<br>├── __mocks__<br>│   └── fs.js<br>├── models<br>│   ├── __mocks__<br>│   │   └── user.js<br>│   └── user.js<br>├── node_modules<br>└── views<br></code></pre></td></tr></table></figure><p>當給定模組有 manual mock 時，Jest 的模組系統會在明確呼叫 <code>jest.mock('moduleName')</code> 時使用該模組。</p><p>但是，當配置的 <code>automock</code> 設為 <code>true</code> 時，即使未呼叫 <code>jest.mock('moduleName')</code>，也會用 manual mock implementation 來取代自動建立的 mock。</p><p>若要取消 mock，需要在應該使用實際模組 implementation 的測試中顯式明確呼叫 <a href="https://jestjs.io/docs/en/jest-object#jestunmockmodulename" target="_blank" rel="noopener"><code>jest.unmock('moduleName')</code></a>。</p><div class="info"><p>為了正確的 mock，Jest 需要 <code>jest.mock('moduleName')</code> 與 <code>require</code> / <code>import</code> 陳述句在同一個 scope 內。</p></div><p>例如：有一個模組可提供給定目錄中所有檔案的摘要。這裡使用核心 (內建) <code>fs</code> 模組：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// fileSummarizer.js</span><br><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">summarizeFilesInDirectorySync</span>(<span class="hljs-params">directory</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> fs.readdirSync(directory).map(<span class="hljs-function"><span class="hljs-params">fileName</span> =&gt;</span> (&#123;<br>    directory,<br>    fileName,<br>  &#125;));<br>&#125;<br><br>exports.summarizeFilesInDirectorySync = summarizeFilesInDirectorySync;<br></code></pre></td></tr></table></figure><p>由於我們希望測試避免實際對硬碟進行存取 (因為會很慢且脆弱)，所以會透過擴充自動 mock 來為 <code>fs</code> 模組建立 manual mock。我們的 manual mock 會實作可用於測試的 <code>fs</code> API 的自訂版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __mocks__/fs.js</span><br><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<br><br><span class="hljs-keyword">const</span> fs = jest.createMockFromModule(<span class="hljs-string">'fs'</span>);<br><br><span class="hljs-comment">// 這是自訂函數，測試可在 setup 過程中使用此函數</span><br><span class="hljs-comment">// 來指定使用任何 `fs` API 時 mock filesystem 上的檔案應該為何</span><br><span class="hljs-keyword">let</span> mockFiles = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__setMockFiles</span>(<span class="hljs-params">newMockFiles</span>) </span>&#123;<br>  mockFiles = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">in</span> newMockFiles) &#123;<br>    <span class="hljs-keyword">const</span> dir = path.dirname(file);<br><br>    <span class="hljs-keyword">if</span> (!mockFiles[dir]) &#123;<br>      mockFiles[dir] = [];<br>    &#125;<br>    mockFiles[dir].push(path.basename(file));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 自訂版的 `readdirSync` 透過</span><br><span class="hljs-comment">// 從`__setMockFiles` 設定的指定 mocked 檔案列表中讀取</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readdirSync</span>(<span class="hljs-params">directoryPath</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> mockFiles[directoryPath] || [];<br>&#125;<br><br>fs.__setMockFiles = __setMockFiles;<br>fs.readdirSync = readdirSync;<br><br><span class="hljs-built_in">module</span>.exports = fs;<br></code></pre></td></tr></table></figure><p>現在我們來寫測試。請注意，由於它是核心 Node 模組，所以需要明確告知我們要 mock <code>fs</code> 模組 (也就是需明確呼叫 <code>jest.mock('fs')</code> )：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/FileSummarizer-test.js</span><br><span class="hljs-meta">'use strict'</span>;<br><br>jest.mock(<span class="hljs-string">'fs'</span>);<br><br>describe(<span class="hljs-string">'listFilesInDirectorySync'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> MOCK_FILE_INFO = &#123;<br>    <span class="hljs-string">'/path/to/file1.js'</span>: <span class="hljs-string">'console.log("file1 contents");'</span>,<br>    <span class="hljs-string">'/path/to/file2.txt'</span>: <span class="hljs-string">'file2 contents'</span>,<br>  &#125;;<br><br>  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在每次測試之前 setup 一些 mocked out 檔案資訊</span><br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).__setMockFiles(MOCK_FILE_INFO);<br>  &#125;);<br><br>  test(<span class="hljs-string">'includes all files in the directory in the summary'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> FileSummarizer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../FileSummarizer'</span>);<br>    <span class="hljs-keyword">const</span> fileSummary = FileSummarizer.summarizeFilesInDirectorySync(<br>      <span class="hljs-string">'/path/to'</span>,<br>    );<br><br>    expect(fileSummary.length).toBe(<span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>此範例的 mock 是用 <a href="https://jestjs.io/docs/en/jest-object#jestcreatemockfrommodulemodulename" target="_blank" rel="noopener"><code>jest.createMockFromModule</code></a> 來生成自動 mock，並覆蓋預設的行為 (也就是大部份都是真的，但少部份是假的)。推薦此方法，但不強迫。若不想使用自動 mock，則可從 mock 檔案中 export 自己的函數。完全 manual mock 的一個缺點是它們是手動的，代表必須在模組 mocking changes 時隨時手動更新它們。所以最好在滿足你的需求時使用或擴充自動 mock。</p><p>為了確保 manual mock 和實際實作保持同步，在 export manual mock 模組之前，請在 manual mock 中使用 <a href="https://jestjs.io/docs/en/jest-object#jestrequireactualmodulename" target="_blank" rel="noopener"><code>jest.requireActual(moduleName)</code></a> 使用真實的模組，並用 mock 函數對其進行變更，這可能會很有用。</p><blockquote><p>範例程式碼：<a href="https://github.com/facebook/jest/tree/master/examples/manual-mocks" target="_blank" rel="noopener">examples/manual-mocks</a>。</p></blockquote><h1 id="與-ES-模組引入一起使用"><a class="header-anchor" href="#與-ES-模組引入一起使用"></a>與 ES 模組引入一起使用</h1><p>若你正在使用 ES 模組 imports，通常會傾向將 <code>import</code> 陳述句放在測試檔案的最上面。但通常你需要指示 Jest 在模組使用 mock 之前使用它。所以 Jest 會自動將 <code>jest.mock</code> 呼叫 hoist 至模組的最上面 (在 import 之前)。</p><blockquote><p>詳情可參閱 <a href="https://github.com/kentcdodds/how-jest-mocking-works" target="_blank" rel="noopener">kentcdodds/how-jest-mocking-works</a>。</p></blockquote><h1 id="JSDOM-中未實作的-mock-方法"><a class="header-anchor" href="#JSDOM-中未實作的-mock-方法"></a>JSDOM 中未實作的 mock 方法</h1><p>若某些程式碼使用的方法尚未實作 JSDOM (Jest 使用的 DOM implementation)，則不易於測試。</p><p>例如：<code>Window.matchMedia()</code> 的情況。Jest 會回傳 <code>TypeError: window.matchMedia is not a function</code>，不能正確執行測試。</p><p>在這種情況下，在測試檔案中 mock <code>matchMedia</code> 應該可以解決此問題：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/matchMedia.mock.js</span><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">'matchMedia'</span>, &#123;<br>  writable: <span class="hljs-literal">true</span>,<br>  value: jest.fn().mockImplementation(<span class="hljs-function"><span class="hljs-params">query</span> =&gt;</span> (&#123;<br>    matches: <span class="hljs-literal">false</span>,<br>    media: query,<br>    onchange: <span class="hljs-literal">null</span>,<br>    addListener: jest.fn(),     <span class="hljs-comment">// deprecated</span><br>    removeListener: jest.fn(),  <span class="hljs-comment">// deprecated</span><br>    addEventListener: jest.fn(),<br>    removeEventListener: jest.fn(),<br>    dispatchEvent: jest.fn(),<br>  &#125;)),<br>&#125;);<br></code></pre></td></tr></table></figure><div class="info"><p><code>matchMedia.mock.js</code> 這個檔案放哪都可以，但記得配置要設成 <code>testEnvironment: &quot;jsdom&quot;</code>。</p></div><ul><li>若在測試中 invoked 的函數 (或方法) 中使用 <code>window.matchMedia()</code>，則此方法可以運作</li><li>若在測試檔案中直接執行 <code>window.matchMedia()</code>，Jest 會出現相同的錯誤</li></ul><p>所以解決方案是將 manual mock 放在獨立的檔案中，並在測試之前將其包含在測試檔案中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/useMatchMedia.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useMatchMedia</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.matchMedia(<span class="hljs-string">'xx'</span>).matches;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/userMocked.test.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">"./matchMedia.mock"</span>; <span class="hljs-comment">// 必須在測試檔案之前 import</span><br><span class="hljs-keyword">import</span> useMatchMedia <span class="hljs-keyword">from</span> <span class="hljs-string">"../src/useMatchMedia"</span>;<br><br>it(<span class="hljs-string">'use matchMedia()'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 在這裡測試 method...</span><br>  expect(useMatchMedia()).toBeFalsy();<br>&#125;);<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/manual-mocks" target="_blank" rel="noopener">Manual Mocks · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;manual mock 是用於透過 mock 資料來對功能進行 stub out。例如：若你不想存取網站或 DB 之類的遠端資源，可能需要使用 fake data 來 manual mock 這些功能，以確保可以快速測試且不會出錯。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="mock" scheme="https://titangene.github.io/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Timer Mocks</title>
    <link href="https://titangene.github.io/article/jest-timer-mocks.html"/>
    <id>https://titangene.github.io/article/jest-timer-mocks.html</id>
    <published>2020-07-19T14:05:04.000Z</published>
    <updated>2020-07-19T14:04:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>常用的 native timer 包括 <code>setTimeout</code>、<code>setInterval</code>、<code>clearTimeout</code>、<code>clearInterval</code> 等，用到這些 timer 的函數可以說是依賴於真實流逝的時間。如果 timer 要跑幾秒後才會觸發，或是要確認某函數是否在固定週期內被呼叫幾次，你不可能真的去等待 timer 跑完才能驗證結果吧，那根本是浪費時間。所以應該要使用 mock 函數來 mock 掉那些 timer 函數，透過 Jest 提供的功能來控制時間，其中就有時間快轉的功能，減少測試要等待的時間。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><h1 id="啟動-fake-timer"><a class="header-anchor" href="#啟動-fake-timer"></a>啟動 fake timer</h1><p>要在 Jest 使用 mock 過的 timer，可透過呼叫 <code>jest.useFakeTimers()</code> 來啟動 fake timer，之後就可以用 fake timer 來控制時間。</p><p>假設有一個 <code>timerGame()</code> 函數，呼叫該函數時，會先列印 <code>'Ready....go!'</code>，接著至少過了 1 秒後才會列印 <code>&quot;Time's up -- stop!&quot;</code>，並且呼叫傳入的 callback：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/timerGame.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timerGame</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Ready....go!'</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Time's up -- stop!"</span>);<br>    callback &amp;&amp; callback();<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果測試這樣寫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/timerGame.test.js</span><br><span class="hljs-keyword">import</span> &#123; timerGame &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/timerGame'</span>;<br><br>jest.useFakeTimers();<br><br>describe(<span class="hljs-string">'執行一次 timer'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'等待 1 秒後結束遊戲'</span>, () =&gt; &#123;<br>    timerGame();<br><br>    expect(setTimeout).toBeCalledTimes(<span class="hljs-number">1</span>);<br>    expect(setTimeout).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>), <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>測試只有測到 <code>timerGame()</code> 的以下內容：</p><ul><li><code>setTimeout</code> 被呼叫幾次 (即 <code>toBeCalledTimes(number)</code> )</li><li>最後一次呼叫 <code>setTimeout</code> 的 argument 為何 (即 <code>lastCalledWith(arg1, arg2, ...)</code> )：<ul><li>第一個 argument 可以是任何函數</li><li>第二個 argument 一定是 <code>1000</code> 豪秒</li></ul></li></ul><p>所以 <code>timerGame()</code> 內的 <code>console.log(&quot;Time's up -- stop!&quot;)</code> 那行都還沒執行就測試通過了 (所以才只輸出 <code>'Ready....go!'</code> 這行)。</p><p>若在一個檔案或 <code>describe</code> 區塊中執行多個測試，就可在每個測試之前手動呼叫 <code>jest.useFakeTimers()</code>，或是使用 <code>beforeEach</code> 之類的 <a href="https://titangene.github.io/article/jest-setup-teardown.html">setup 函數</a>。否則會讓內部使用的 timer 未被 reset。</p><p>如果沒有 reset timer，可能會像這個測試一樣很奇怪：</p><ul><li>第一個 <code>it</code> 區塊的測試很正常，只呼叫一次 <code>timerGame()</code>，所以 <code>setTimeout</code> 只被呼叫過一次</li><li>但第二個 <code>it</code> 區塊的測試被第一個 <code>it</code> 區塊使用的 <code>setTimeout</code> 所污染，明明 <code>timerGame()</code> 只呼叫過一次，竟然 assert <code>setTimeout</code> 不是被呼叫過一次 ，而是兩次</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/resetTimer.test.js</span><br><span class="hljs-keyword">import</span> &#123; timerGame &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/timerGame'</span>;<br><br>describe(<span class="hljs-string">'每個測試都只呼叫一次 `timerGame()`'</span>, () =&gt; &#123;<br>  describe(<span class="hljs-string">'未在每個測試執行前 reset timer'</span>, () =&gt; &#123;<br>    <span class="hljs-comment">// 不建議直接在 `describe` 區塊內呼叫 `jest.useFakeTimers()`</span><br>    <span class="hljs-comment">// 應在 Setup and Teardown 時 reset timer</span><br>    jest.useFakeTimers();<br><br>    it(<span class="hljs-string">'setTimeout 的呼叫次數應為 1 次'</span>, () =&gt; &#123;<br>      timerGame();<br><br>      expect(setTimeout).toBeCalledTimes(<span class="hljs-number">1</span>);<br>      expect(setTimeout).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>), <span class="hljs-number">1000</span>);<br>    &#125;);<br><br>    it(<span class="hljs-string">'setTimeout 的呼叫次數應為 2 次，setTimeout 的呼叫次數會因前面的測試未 reset timer 而影響'</span>, () =&gt; &#123;<br>      timerGame();<br><br>      expect(setTimeout).not.toBeCalledTimes(<span class="hljs-number">1</span>);<br>      expect(setTimeout).toBeCalledTimes(<span class="hljs-number">2</span>);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>所以應在 setup (即 <code>beforeEach()</code> ) 和 teardown (即 <code>afterEach()</code> ) 時 reset timer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/resetTimer.test.js</span><br><span class="hljs-keyword">import</span> &#123; timerGame &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/timerGame'</span>;<br><br><span class="hljs-comment">// 不建議在測試檔案的全域使用 `jest.useFakeTimers()`</span><br><span class="hljs-comment">// 應在 Setup and Teardown 時 reset timer</span><br><span class="hljs-comment">// jest.useFakeTimers();</span><br><br>describe(<span class="hljs-string">'每個測試都只呼叫一次 `timerGame()`'</span>, () =&gt; &#123;<br>  describe(<span class="hljs-string">'有在每個測試執行前 reset timer'</span>, () =&gt; &#123;<br>    beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      jest.useFakeTimers();<br>    &#125;);<br><br>    it(<span class="hljs-string">'setTimeout 的呼叫次數應為 1 次'</span>, () =&gt; &#123;<br>      timerGame();<br><br>      expect(setTimeout).toBeCalledTimes(<span class="hljs-number">1</span>);<br>      expect(setTimeout).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>), <span class="hljs-number">1000</span>);<br>    &#125;);<br><br>    it(<span class="hljs-string">'setTimeout 的呼叫次數應為 1 次，setTimeout 的呼叫次數不會受前面的測試影響'</span>, () =&gt; &#123;<br>      timerGame();<br><br>      expect(setTimeout).toBeCalledTimes(<span class="hljs-number">1</span>);<br>    &#125;);<br><br>    afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      jest.clearAllTimers();<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><div class="info"><h2 id="使用-jest-useFakeTimers-的建議"><a class="header-anchor" href="#使用-jest-useFakeTimers-的建議"></a>使用 <code>jest.useFakeTimers()</code> 的建議</h2><p>不應在以下位置使用 <code>jest.useFakeTimers()</code>：</p><ul><li>測試檔案的全域呼叫</li><li>直接在 <code>describe</code> 區塊內呼叫</li></ul><p>建議在 <a href="https://titangene.github.io/article/jest-setup-teardown.html">setup 和 teardown</a> 時 reset timer。當然可以放在 <code>it</code> 或 <code>test</code> 區塊內，或是在 setup 和 teardown 呼叫，但需重複寫很多次，很麻煩。</p></div><p>下面是 <code>jest.useFakeTimers(implementation?: 'modern' | 'legacy')</code> 的介紹：</p><ul><li>指定 Jest 使用 fake 的標準 timer 函數，包括：<ul><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>clearTimeout</code></li><li><code>clearInterval</code></li><li><code>nextTick</code></li><li><code>setImmediate</code></li><li><code>clearImmediate</code></li></ul></li><li>若使用 <code>'modern'</code> 作為 argument，則會使用 <a href="https://github.com/sinonjs/fake-timers" target="_blank" rel="noopener">@sinonjs/fake-timers</a> 來作為 implementation，而不是 Jest 自己的 fake timer</li><li>也可 mock 其他 timer，例如：<code>Date</code></li><li><code>'modern'</code> 是 Jest 27 的預設行為 (目前我使用的環境是 Jest 25，所以是用 <code>legacy</code> )</li><li>回傳用於 chaining 的 <code>jest</code> 物件</li></ul><p>上面提到的 <code>'modern'</code> 和 <code>legacy</code> 是 <code>jest.config.js</code> 內的 <code>timers</code> config：</p><ul><li>預設為 <code>&quot;real&quot;</code></li><li>設為 <code>&quot;legacy&quot;</code> 或 <code>&quot;fake&quot;</code> 時，允許對函數使用 fake timer。當程式碼設定了不想在測試中等待的 long timeout，fake timer 就很好用</li><li>設為 <code>&quot;modern&quot;</code> 時，會將 <a href="https://github.com/sinonjs/fake-timers" target="_blank" rel="noopener"><code>@sinonjs/fake-timers</code></a> 作為實作，而不是 Jest 自己的舊實作。Jest 27 會預設此設定</li></ul><p>在 Jest 15 開始才將 <code>timers</code> config 預設成 <code>&quot;real&quot;</code>。可透過在配置中指定 <code>timers: &quot;fake&quot;</code> 或呼叫 <code>jest.useRealTimers()</code> 和 <code>jest.useFakeTimers()</code> 全域開關來覆蓋此設定。</p><h1 id="執行所有-timer"><a class="header-anchor" href="#執行所有-timer"></a>執行所有 timer</h1><p>若要測試 assert 在 1 秒後呼叫 callback，可在測試中使用 Jest 的 timer 控制 API <code>jest.runAllTimers()</code> 來快轉時間：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/timerGame.test.js</span><br>describe(<span class="hljs-string">'執行所有 timer'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'1 秒後呼叫 callback'</span>, () =&gt; &#123;<br>    jest.useFakeTimers();<br><br>    <span class="hljs-keyword">const</span> callback = jest.fn();<br><br>    timerGame(callback);<br><br>    <span class="hljs-comment">// 此時 callback 應該還沒被呼叫</span><br>    expect(callback).not.toBeCalled();<br><br>    <span class="hljs-comment">// 快轉直到執行完所有 timer</span><br>    jest.runAllTimers();<br><br>    <span class="hljs-comment">// 現在 callback 已被呼叫</span><br>    expect(callback).toBeCalled();<br>    expect(callback).toBeCalledTimes(<span class="hljs-number">1</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><div class="info"><p><code>jest.runAllTimers()</code>：</p><ul><li>用盡 macro-task queue (即由 <code>setTimeout()</code>、<code>setInterval()</code> 和 <code>setImmediate()</code> 排隊 (queued) 的所有 task) 和 micro-task queue (通常會透過 <code>process.nextTick</code> interfaced 至 node)</li><li>呼叫此 API 時，會執行所有 pending macro-tasks 和 micro-tasks。若這些 task 本身安排了 (schedule) 新 task，這些 task 就會不斷的耗盡 (exhausted)，直到 queue 中沒有其他 task 為止</li><li>通常在測試期間同步執行 <code>setTimeout</code> 很有用，以便同步 assert 某些行為，但這些行為只會在 <code>setTimeout()</code> 或 <code>setInterval()</code> 的 callback 執行後才發生</li></ul></div><h1 id="執行-pending-timer"><a class="header-anchor" href="#執行-pending-timer"></a>執行 pending timer</h1><p>假設有遞迴的 timer，會在自己的 callback 中設定一個新的 timer。若執行所有 timer 就會變成無限迴圈，所以不能用像是 <code>jest.runAllTimers()</code>，但可用 <code>jest.runOnlyPendingTimers()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/infiniteTimerGame.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">infiniteTimerGame</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Ready....go!'</span>);<br><br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Time's up! 5 seconds before the next game starts..."</span>);<br>    callback &amp;&amp; callback();<br><br>    <span class="hljs-comment">// 在 5 秒內安排下一場比賽</span><br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      infiniteTimerGame(callback);<br>    &#125;, <span class="hljs-number">5000</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/infiniteTimerGame.test.js</span><br><span class="hljs-keyword">import</span> &#123; infiniteTimerGame &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/infiniteTimerGame'</span>;<br><br>describe(<span class="hljs-string">'infiniteTimerGame'</span>, () =&gt; &#123;<br>  test(<span class="hljs-string">'在 1 秒後安排 5 秒 timer'</span>, () =&gt; &#123;<br>    jest.useFakeTimers();<br><br>    <span class="hljs-keyword">const</span> callback = jest.fn();<br>    infiniteTimerGame(callback);<br><br>    <span class="hljs-comment">// 此時應該只有呼叫一次 `setTimeout` 才能在 1 秒內安排遊戲結束</span><br>    expect(setTimeout).toBeCalledTimes(<span class="hljs-number">1</span>);<br>    expect(setTimeout).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>), <span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// 快轉並只耗盡當前 pending timer</span><br>    <span class="hljs-comment">// (但此過程中不會建立任何新的 timer)</span><br>    jest.runOnlyPendingTimers();<br><br>    <span class="hljs-comment">// 此時，1 秒的 timer 應該觸發了 callback</span><br>    expect(callback).toBeCalled();<br><br>    <span class="hljs-comment">// 並且應該已建立一個新的 timer，可在 5 秒內開始遊戲</span><br>    expect(setTimeout).toBeCalledTimes(<span class="hljs-number">2</span>);<br>    expect(setTimeout).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>), <span class="hljs-number">5000</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="依時間-advance-提前-timer"><a class="header-anchor" href="#依時間-advance-提前-timer"></a>依時間 advance (提前) timer</h1><p><code>jest.advanceTimersByTime(msToRun)</code>：</p><ul><li>Jest 22.0.0 將 <code>runTimersToTime()</code> (但還可以當作 alias 使用) 重新命名成 <code>advanceTimersByTime()</code></li><li>只會執行 macro task queue (即由 <code>setTimeout()</code> 或 <code>setInterval()</code> 和 <code>setImmediate()</code> 排隊 (queued) 的所有 task)</li><li>呼叫時，所有 timer 都會被提前 <code>msToRun</code> 豪秒</li><li>透過 <code>setTimeout()</code> 或 <code>setInterval()</code> 排隊 (queued)，並在此時間範圍 (time frame) 內執行的所有 pending “macro-tasks” 都會被執行</li><li>如果這些是 macro-tasks 計劃 (schedule) 在同一時間範圍內執行的新 macro-tasks，就會一直執行這些 macro-tasks，直到 queue 中沒有其他應該在 <code>msToRun</code> 毫秒內執行的 macro-tasks 為止</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/advanceTimersByTime.test.js</span><br>describe(<span class="hljs-string">'Advance Timers by Time'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'1 秒後透過 `advanceTimersByTime` 呼叫 callback'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> callback = jest.fn();<br>    timerGame(callback);<br><br>    <span class="hljs-comment">// 此時 callback 應該還沒被呼叫</span><br>    expect(callback).not.toBeCalled();<br><br>    <span class="hljs-comment">// 快轉直到執行完所有 timer</span><br>    jest.advanceTimersByTime(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// 現在 callback 已被呼叫</span><br>    expect(callback).toBeCalled();<br>    expect(callback).toHaveBeenCalledTimes(<span class="hljs-number">1</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>可用 <code>jest.clearAllTimers()</code> 從 timer 系統中刪除所有 pending timer，也就是若 scheduled (安排了) 任何 timer (但尚未執行)，可被清除並永遠沒有機會執行它們。</p><h1 id="其他"><a class="header-anchor" href="#其他"></a>其他</h1><ul><li><code>jest.useRealTimers()</code><ul><li>指定 Jest 使用標準 timer 函數的實際版本</li><li>回傳用於 chaining 的 <code>jest</code> 物件</li></ul></li><li><code>jest.runAllTicks()</code>：<ul><li>耗盡 micro-task queue (通常會透過 <code>process.nextTick</code> interfaced 至 node)</li><li>呼叫此 API 時，會執行透過 <code>process.nextTick</code> 排隊 (queued) 的所有 pending micro-tasks</li><li>若這些 micro-tasks 安排了 (schedule) 新 task，這些 task 就會不斷的耗盡 (exhausted)，直到 queue 中沒有其他 micro-tasks 為止</li></ul></li><li><code>jest.runAllImmediates()</code>：<ul><li>耗盡由 <code>setImmediate()</code> 排隊 (queued) 的所有 tasks</li><li>注意：使用 modern fake timers implementation 時，此函數不可用</li></ul></li><li><code>jest.runOnlyPendingTimers()</code>：<ul><li>只執行當前 pending macro-tasks (即只執行 <code>setTimeout()</code> 或 <code>setInterval()</code> 至目前為止已 queued (排隊) 的 task)</li><li>若任何當前 pending macro-tasks 安排了 (schedule) 新 task，這些新 task 就不會透過 <code>jest.runOnlyPendingTimers()</code> 呼叫執行</li></ul></li><li><code>jest.advanceTimersToNextTimer(steps?)</code>：<ul><li>將所有 timer 提前所需的毫秒數，以便只執行下一個 timeouts/intervals</li><li>可提供 <code>steps</code> arg，執行下一次 timeouts/intervals 的 <code>steps</code> 數</li></ul></li><li><code>jest.getTimerCount()</code>：<ul><li>回傳仍在執行的 fake timer 數量</li></ul></li><li><code>jest.setSystemTime()</code>：<ul><li>設定 fake timer 使用的當前系統時間</li><li>模擬使用者在 program 執行時變更系統時鐘</li><li>會影響當前時間，但不會導致像是 timers to fire (定時觸發)</li><li>會完全照原樣觸發 (fire)，而無需呼叫 <code>jest.setSystemTime()</code></li><li>注意：此函數只在使用 modern fake timers implementation 時可用</li></ul></li><li><code>jest.getRealSystemTime()</code>：<ul><li>在 mock 時間時，也會 mock <code>Date.now()</code></li><li>若想存取實際的當前時間，可 invoke 此函數</li><li>注意：此函數只在使用 modern fake timers implementation 時可用</li></ul></li><li><code>jest.setTimeout(timeout)</code>：<ul><li>設定測試和 hook 之前/之後的預設 timeout interval (單位為豪秒)</li><li>會影響從中呼叫此函數的測試檔案</li><li>若未呼叫此方法，預設 timeout interval 為 5 秒</li><li>注意：若要為所有測試檔案設定 timeout，可在 <code>setupFilesAfterEnv</code> 中設定</li></ul></li><li><code>jest.retryTimes(numTestRetries)</code>：<ul><li>n 次執行失敗的測試，直到它們通過或直到最大重試次數用完為止</li><li>只適用於 <a href="https://github.com/facebook/jest/tree/master/packages/jest-circus" target="_blank" rel="noopener"><code>jest-circus</code></a></li><li>回傳用於 chaining 的 <code>jest</code> 物件</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">jest.retryTimes(<span class="hljs-number">3</span>);<br>test(<span class="hljs-string">'will fail'</span>, () =&gt; &#123;<br>  expect(<span class="hljs-literal">true</span>).toBe(<span class="hljs-literal">false</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/timer-mocks" target="_blank" rel="noopener">Timer Mocks · Jest</a></li><li><a href="https://jestjs.io/blog/2016/09/01/jest-15.html" target="_blank" rel="noopener">Jest 15.0: New Defaults for Jest · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;常用的 native timer 包括 &lt;code&gt;setTimeout&lt;/code&gt;、&lt;code&gt;setInterval&lt;/code&gt;、&lt;code&gt;clearTimeout&lt;/code&gt;、&lt;code&gt;clearInterval&lt;/code&gt; 等，用到這些 timer 的函數可以說是依賴於真實流逝的時間。如果 timer 要跑幾秒後才會觸發，或是要確認某函數是否在固定週期內被呼叫幾次，你不可能真的去等待 timer 跑完才能驗證結果吧，那根本是浪費時間。所以應該要使用 mock 函數來 mock 掉那些 timer 函數，透過 Jest 提供的功能來控制時間，其中就有時間快轉的功能，減少測試要等待的時間。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="mock" scheme="https://titangene.github.io/tags/mock/"/>
    
      <category term="timer" scheme="https://titangene.github.io/tags/timer/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Snapshot 測試</title>
    <link href="https://titangene.github.io/article/jest-snapshot-testing.html"/>
    <id>https://titangene.github.io/article/jest-snapshot-testing.html</id>
    <published>2020-07-12T15:58:31.000Z</published>
    <updated>2020-07-12T16:14:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>若想確保 UI 不會因意外修改而產生 bug，snapshot 測試就是一個很好用的工具。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><h1 id="使用-Jest-進行-snapshot-測試"><a class="header-anchor" href="#使用-Jest-進行-snapshot-測試"></a>使用 Jest 進行 snapshot 測試</h1><p>如果想測試一個 UI 元件，要測的是產生的元素 (可序列化的值，即 HTML 原始碼)，而不是需要花時間渲染出來的畫面 (圖形 UI)。</p><p>下面以連結元件為例，呼叫 <code>rendererLinkElement()</code>，並傳入 URL 和連結名稱就可以取得 renderer 回傳的 HTML：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/linkElement.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rendererLinkElement</span>(<span class="hljs-params">url, linkName</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;a href="<span class="hljs-subst">$&#123;url&#125;</span>"&gt;<span class="hljs-subst">$&#123;linkName&#125;</span>&lt;/a&gt;`</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rendererLinkElement;<br></code></pre></td></tr></table></figure><p>這邊使用 Jest 提供的 <code>toMatchSnapshot()</code> 進行測試：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/externalSnapshots.test.js</span><br>describe(<span class="hljs-string">'external snapshots'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'render the link element of the Titangene Blog home page'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://titangene.github.io/'</span>;<br>    <span class="hljs-keyword">const</span> linkName = <span class="hljs-string">'Titangene Blog'</span>;<br><br>    <span class="hljs-keyword">const</span> actual = rendererLinkElement(url, linkName);<br><br>    expect(actual).toMatchSnapshot();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>執行測試：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/externalSnapshots.test.js</span><br> PASS  __tests__/externalSnapshots.test.js<br>  external snapshots<br>    ✓ render the link element of the Titangene Blog home page (3ms)<br><br> › 1 snapshot written.<br>Snapshot Summary<br> › 1 snapshot written from 1 test suite.<br><br>Test Suites: 1 passed, 1 total<br>Tests:       1 passed, 1 total<br>Snapshots:   1 written, 1 total<br>Time:        0.657s, estimated 1s<br>Ran all test suites matching /.\/__tests__\/externalSnapshots.test.js/i.<br></code></pre></td></tr></table></figure><p>第一次執行此測試時，Jest 會在 <code>__tests__</code> 目錄內建立 <code>__snapshots__</code> 目錄，裡面建立一個 snapshot 檔案，檔名會是測試檔的名稱再加上 <code>.snap</code> (例如：<code>externalSnapshots.test.js.snap</code> )，內容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Jest Snapshot v1, https://goo.gl/fbAQLP</span><br><br>exports[<span class="hljs-string">`renders correctly 1`</span>] = <span class="hljs-string">`"&lt;a href=\\"https://titangene.github.io/\\"&gt;Titangene Blog&lt;/a&gt;"`</span>;<br></code></pre></td></tr></table></figure><p>之後再次執行測試就會將 render 的輸出與之前的 snapshot 進行比較：</p><ul><li>若 match，測試就會通過</li><li>若不 match，測試就會失敗<ul><li>可能是程式有 bug，或是實作發生變化，需要更新 snapshot</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/linkElement.test.js</span><br> PASS  __tests__/linkElement.test.js<br>  ✓ renders correctly (4ms)<br><br>Test Suites: 1 passed, 1 total<br>Tests:       1 passed, 1 total<br>Snapshots:   1 passed, 1 total<br>Time:        0.777s, estimated 2s<br>Ran all test suites matching /.\/__tests__\/linkElement.test.js/i.<br></code></pre></td></tr></table></figure><div class="info"><p>snapshot 應與修改的程式碼一起 commit，並在 code review 中進行 review。</p><p>註：Jest 內建提供 <a href="https://github.com/facebook/jest/tree/master/packages/pretty-format" target="_blank" rel="noopener"><code>pretty-format</code></a> 套件，可讓任何 JavaScript 值變成 human-readable 的字串 (序列化 JavaScript 內建型別值)，而 snapshot 就使用了此套件，所以 snapshot 才能在 code review 過程具有可讀性。</p></div><h1 id="更新-snapshot"><a class="header-anchor" href="#更新-snapshot"></a>更新 snapshot</h1><p>剛剛提到，若程式的實作發生變化，snapshot 與程式執行結果可能會不 match，測試就會失敗。</p><p>假設不是因為 bug，是你現在修改的執行結果的確是你要的，但 snapshot 還是之前的預期結果，而你想將 snapshot 換成新的預期結果，這就需要更新 snapshot。</p><p>下面就舉個情境，假設我想將測試修改成這樣：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs diff">it('renders correctly', () =&gt; &#123;<br><span class="hljs-deletion">-  const url = 'https://titangene.github.io/';</span><br><span class="hljs-deletion">-  const linkName = 'Titangene Blog';</span><br><span class="hljs-addition">+  const url = 'https://www.google.com/';</span><br><span class="hljs-addition">+  const linkName = 'Google';</span><br><br>  const actual = rendererLinkElement(url, linkName);<br><br>  expect(actual).toMatchSnapshot();<br>&#125;);<br></code></pre></td></tr></table></figure><p>再次執行測試就會失敗，因為之前 snapshot 儲存的跟現在修改的不 match：</p><p><img src="../images/jest-snapshot-testing/2020-07-13-00-05-47.png" alt=""></p><p>使用 <code>--updateSnapshot</code> (或 <code>-u</code> ) option 就能為失敗的測試重新建立新的 snapshot (通過的測試不會重新建立)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> jest --updateSnapshot</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/linkElement.test.js -u</span><br> PASS  __tests__/linkElement.test.js<br>  ✓ renders correctly (4ms)<br><br> › 1 snapshot updated.<br>Snapshot Summary<br> › 1 snapshot updated from 1 test suite.<br><br>Test Suites: 1 passed, 1 total<br>Tests:       1 passed, 1 total<br>Snapshots:   1 updated, 1 total<br>Time:        0.794s, estimated 1s<br>Ran all test suites matching /.\/__tests__\/linkElement.test.js/i.<br></code></pre></td></tr></table></figure><p>若要指定哪個測試需要重新產生 snapshot，可加上 <code>--testNamePattern=&lt;regex&gt;</code> option：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ jest -u --testNamePattern=<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">regex</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="互動式-snapshot-模式"><a class="header-anchor" href="#互動式-snapshot-模式"></a>互動式 snapshot 模式</h1><p>在 watch 模式下，按 <code>i</code> 鍵進入互動式 snapshot 模式 (只有在有 failed snapshot 時，才會看到 <code>i</code> 這個選項)：</p><p><img src="../images/jest-snapshot-testing/2020-07-13-00-13-55.png" alt=""></p><p>此互動式 snapshot 模式是用 failed snapshot 和 failed output，此模式會各別看每個 snapshot，有以下功能：</p><ul><li><code>u</code> (update)：更新失敗的 snapshot</li><li><code>s</code> (skip)：跳過當前測試 (跳至下一個測試)</li><li><code>q</code> (quit)：離開互動式 snapshot 模式</li><li><code>Enter</code>：觸發測試執行 (重跑單前測試)</li></ul><p>只要還有一個 failed snapshot 未更新，就能按 <code>r</code> 鍵重新回到互動式 snapshot 模式：</p><p><img src="../images/jest-snapshot-testing/2020-07-13-00-05-59.png" alt=""></p><p>更新所有 failed snapshot 後，就可按 <code>Enter</code> 回到 watch 模式：</p><p><img src="../images/jest-snapshot-testing/2020-07-13-00-06-03.png" alt=""></p><blockquote><p>可是奇怪的是，原本我執行 Jest 時有指定某個目錄內的測試，當我從互動式 snapshot 模式回到 watch 模式時，竟然之前的指令就失效，所以還會多測其他目錄內的測試 (目前猜測是未被 Git 追蹤的測試檔都會被執行)。</p></blockquote><h1 id="Inline-Snapshots"><a class="header-anchor" href="#Inline-Snapshots"></a>Inline Snapshots</h1><p>inline snapshot 和 external snapshot ( <code>.snap</code> 檔案) 的行為相同，但 inline snapshot 會把 snapshot value 自動寫回原始碼中。不用切換至外部檔案來確保寫入正確的值。</p><div class="warning"><p>inline snapshot 是由 <a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a> 提供支援，所以必須安裝 Prettier 才能用 inline snapshot。寫測試檔時，請遵守你的 Prettier 配置。</p><p>若你在 Jest 找不到的地方安裝 Prettier，則可用 <a href="https://jestjs.io/docs/en/configuration#prettierpath-string" target="_blank" rel="noopener"><code>prettierPath</code></a> 配置屬性來告訴 Jest。</p><p>如果未安裝 Prettier 就使用 <code>toMatchInlineSnapshot()</code>，會輸出以下錯誤訊息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">FAIL  __tests__/inlineSnapshots.test.js<br> ● Test suite failed to run<br><br>   Cannot find module 'prettier' from 'setup_jest_globals.js'<br><br>     at Resolver.resolveModule (node_modules/jest-resolve/build/index.js:296:11)<br></code></pre></td></tr></table></figure></div><p>安裝 Prettier：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add prettier --dev --exact</span><br></code></pre></td></tr></table></figure><p>一開始寫測試時，不帶 argument 呼叫 <code>toMatchInlineSnapshot()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/inlineSnapshots.test.js</span><br><span class="hljs-keyword">import</span> rendererLinkElement <span class="hljs-keyword">from</span> <span class="hljs-string">"../src/linkElement"</span>;<br><br>describe(<span class="hljs-string">"inline snapshots"</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">"render the link element of the Titangene Blog home page"</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">"https://titangene.github.io/"</span>;<br>    <span class="hljs-keyword">const</span> linkName = <span class="hljs-string">"Titangene Blog"</span>;<br><br>    <span class="hljs-keyword">const</span> actual = rendererLinkElement(url, linkName);<br><br>    expect(actual).toMatchInlineSnapshot();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>執行測試時，Jest 會對 <code>tree</code> 進行評估，且 snapshot 會寫入 <code>toMatchInlineSnapshot()</code> 的 argument：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest .__tests__/inlineSnapshots.test.js</span><br> PASS  __tests__/inlineSnapshots.test.js<br>  inline snapshots<br>    ✓ render the link element of the Titangene Blog home page (12ms)<br><br> › 1 snapshot written.<br>Snapshot Summary<br> › 1 snapshot written from 1 test suite.<br><br>Test Suites: 1 passed, 1 total<br>Tests:       1 passed, 1 total<br>Snapshots:   1 written, 1 total<br>Time:        0.909s, estimated 1s<br>Ran all test suites matching /.\/__tests__\/inlineSnapshots.test.js/i.<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe(<span class="hljs-string">"inline snapshots"</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">"render the link element of the Titangene Blog home page"</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">"https://titangene.github.io/"</span>;<br>    <span class="hljs-keyword">const</span> linkName = <span class="hljs-string">"Titangene Blog"</span>;<br><br>    <span class="hljs-keyword">const</span> actual = rendererLinkElement(url, linkName);<br><br>    expect(actual).toMatchInlineSnapshot(<br>      <span class="hljs-string">`"&lt;a href=\\"https://titangene.github.io/\\"&gt;Titangene Blog&lt;/a&gt;"`</span><br>    );<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>也可在指令使用 <code>--updateSnapshot</code> (或 <code>-u</code> ) option 或在 <code>--watch</code> 模式下按 <code>u</code> 鍵來更新 snapshot。</p><h1 id="Property-Matchers"><a class="header-anchor" href="#Property-Matchers"></a>Property Matchers</h1><p>有時 snapshot 的物件中會有生成一些 field (例如：ID 和 Date)，若對這些物件進行 snapshot，就會在執行時常常發生 snapshot 失敗。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/propertyMatchers.test.js</span><br>describe(<span class="hljs-string">'Property Matchers'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'will fail every time'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> user = &#123;<br>      name: <span class="hljs-string">'Titan'</span>,<br>      createdAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>      id: <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">20</span>)<br>    &#125;;<br><br>    <span class="hljs-built_in">console</span>.log(user);<br><br>    expect(user).toMatchSnapshot();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>像上面的測試執行第二次時，snapshot 就會失敗：</p><p><img src="../images/jest-snapshot-testing/2020-07-13-00-06-17.png" alt=""></p><p>所以 Jest 允許你對任何 property 提供 asymmetric matcher。Jest 會在寫入 snapshot 或測試 snapshot 之前，檢查 matcher，然後將 snapshot 儲存至 snapshot 檔案中，而不是 received value：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/propertyMatchers.test.js</span><br>describe(<span class="hljs-string">'Property Matchers'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'will check the matchers and pass'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> user = &#123;<br>      name: <span class="hljs-string">'Titan'</span>,<br>      createdAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>      id: <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">20</span>)<br>    &#125;;<br><br>    <span class="hljs-built_in">console</span>.log(user);<br><br>    expect(user).toMatchSnapshot(&#123;<br>      createdAt: expect.any(<span class="hljs-built_in">Date</span>),<br>      id: expect.any(<span class="hljs-built_in">Number</span>),<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><div class="info"><p>asymmetric matcher：在 <a href="https://jasmine.github.io/tutorials/custom_argument_matchers" target="_blank" rel="noopener">Jasmine</a> 也稱為 argument matcher，可用於建立自己的自訂 matcher 來封裝測試邏輯。</p></div><p>下面是 snapshot 儲存的內容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/__snapshots__/propertyMatchers.test.js.snap</span><br>exports[<span class="hljs-string">`Property Matchers will check the matchers and pass 1`</span>] = <span class="hljs-string">`</span><br><span class="hljs-string">Object &#123;</span><br><span class="hljs-string">  "createdAt": Any&lt;Date&gt;,</span><br><span class="hljs-string">  "id": Any&lt;Number&gt;,</span><br><span class="hljs-string">  "name": "Titan",</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure><p>任何非 matcher 的 givin value，會被被明確地檢查並儲存至 snapshot，例如下面測試中的 <code>name</code> property：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/propertyMatchers.test.js</span><br>describe(<span class="hljs-string">'Property Matchers'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'will check the values and pass'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> user = &#123;<br>      name: <span class="hljs-string">'Titan'</span>,<br>      createdAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>      id: <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">20</span>)<br>    &#125;;<br><br>    <span class="hljs-built_in">console</span>.log(user);<br><br>    expect(user).toMatchSnapshot(&#123;<br>      name: <span class="hljs-string">'Titan'</span>,<br>      createdAt: expect.any(<span class="hljs-built_in">Date</span>),<br>      id: expect.any(<span class="hljs-built_in">Number</span>),<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>下面是 snapshot 儲存的內容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/__snapshots__/propertyMatchers.test.js.snap</span><br>exports[<span class="hljs-string">`Property Matchers will check the values and pass 1`</span>] = <span class="hljs-string">`</span><br><span class="hljs-string">Object &#123;</span><br><span class="hljs-string">  "createdAt": Any&lt;Date&gt;,</span><br><span class="hljs-string">  "id": Any&lt;Number&gt;,</span><br><span class="hljs-string">  "name": "Titan",</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/snapshot-testing" target="_blank" rel="noopener">Snapshot Testing · Jest</a></li><li><a href="https://jestjs.io/blog/2016/07/27/jest-14.html" target="_blank" rel="noopener">Jest 14.0: React Tree Snapshot Testing · Jest</a></li><li><a href="https://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/" target="_blank" rel="noopener">Testing with Jest Snapshots: First Impressions | benmccormick.org</a></li><li><a href="https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074" target="_blank" rel="noopener">Use Jest’s Snapshot Testing Feature from @kentcdodds on @eggheadio</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;若想確保 UI 不會因意外修改而產生 bug，snapshot 測試就是一個很好用的工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="snapshot" scheme="https://titangene.github.io/tags/snapshot/"/>
    
  </entry>
  
</feed>
