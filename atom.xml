<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Titangene Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://titangene.github.io/"/>
  <updated>2020-08-11T15:35:28.565Z</updated>
  <id>https://titangene.github.io/</id>
  
  <author>
    <name>Titangene</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推薦 Chrome Extension：Markdown &amp; 頁面主題篇</title>
    <link href="https://titangene.github.io/article/recommend-chrome-extension-1.html"/>
    <id>https://titangene.github.io/article/recommend-chrome-extension-1.html</id>
    <published>2020-08-09T15:56:36.000Z</published>
    <updated>2020-08-11T15:35:28.565Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/chrome-extension.jpg" alt=""></p><p>本篇推薦一些我常用的 Chrome Extension，包含複製分頁的 Markdown 格式的連結、將頁面變為暗主題。</p><a id="more"></a><blockquote><p>其他推薦 Chrome Extension 相關文章可參閱 <a href="https://titangene.github.io/tags/chrome-extension/">推薦 Chrome Extension 系列文章</a>。</p></blockquote><h1 id="Markdown"><a class="header-anchor" href="#Markdown"></a>Markdown</h1><h2 id="Copy-as-Markdown"><a class="header-anchor" href="#Copy-as-Markdown"></a>Copy as Markdown</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/fkeaekngjflipcockcnpobkpbbfbhmdn" target="_blank" rel="noopener">Copy as Markdown</a></p><p>功能：</p><ul><li>複製當前分頁的 Markdown 格式的連結</li><li>複製該視窗的所有分頁的 Markdown 格式的連結</li></ul><p>點擊 Extension 的圖案，可看到多種選項功能。其中的「Current tab link」選項會將該分頁連結的 Markdown 格式複製至剪貼簿。</p><p>假設要複製此 blog 文章的連結，剪貼簿內儲存的連結格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">[重新認識 CSS - 總結 &amp; 系列目錄 | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-series-catalog.html)<br></code></pre></td></tr></table></figure><p>此 Extension 會將頁面標題 (即 <code>&lt;title&gt;</code> 標籤的內容) 和連結變為 Markdown 格式。</p><p><img src="../images/recommend-chrome-extension-1/copy-as-markdown.png" alt=""></p><p>還有更厲害的！點擊「All tab link (n)」選項會複製該視窗的所有分頁連結，並以 Markdown 的無序清單的形式 (即 <code>*</code> ) 複製至剪貼簿。</p><p>以上圖為例，此視窗開了 3 個分頁，所以我點擊「All tab link (n)」選項會複製以下內容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">* [重新認識 CSS - 總結 &amp; 系列目錄 | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-series-catalog.html)<br>* [Git - 刪除遠端分支 (以 GitHub、GitLab 為例) | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git-delete-remote-branch.html)<br>* [深入 Git：Git 物件儲存 - blob 物件 | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git--blob-object.html)<br></code></pre></td></tr></table></figure><p>如果只想要複製標題或連結而已，可以點擊「All tab title」或「All tab URL」選項。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">* 重新認識 CSS - 總結 &amp; 系列目錄 | Titangene Blog<br>* Git - 刪除遠端分支 (以 GitHub、GitLab 為例) | Titangene Blog<br>* 深入 Git：Git 物件儲存 - blob 物件 | Titangene Blog<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">* https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-series-catalog.html<br>* https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git-delete-remote-branch.html<br>* https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git--blob-object.html<br></code></pre></td></tr></table></figure><p>寫 Markdown 筆記時，若想一次複製多個分頁的連結，並且是 Markdown 格式，用了這個「Copy as Markdown」Extension 就不用自己手動打了！</p><h2 id="拷貝為-Markdown"><a class="header-anchor" href="#拷貝為-Markdown"></a>拷貝為 Markdown</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/copy-as-markdown/dgoenpnkphkichnohepecnmpmihnabdg" target="_blank" rel="noopener">拷貝為 Markdown</a></p><p>功能：將選取的內容轉為 Markdown 格式</p><p>假設我要複製以下選取的內容，並且可以取得 Markdown 格式，只要選取該內容後，並點擊 Extension 的圖案，就會將內容複製至剪貼簿：</p><p><img src="../images/recommend-chrome-extension-1/copy-markdown.png" alt=""></p><p>複製的內容如下。可以看到連標題 (即 <code>##</code> )、無序列表 (即 <code>*</code> )、引用 (即 <code>&gt;</code> ) 都能自動轉成 Markdown 格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">## Assigning property values, Cascading, and Inheritance<br><br>瞭解在 CSS 中，繼承和權重這些重要的觀念之後，接著就可以更深入的瞭解 CSS 是如何處理屬性值的。系列如下：<br><br>* [重新認識 CSS - Inheritance (繼承)](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-inheritance.html)<br>* [重新認識 CSS - Cascading &amp; Specificity](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-cascading-and-specificity.html)<br>* [重新認識 CSS - CSS 如何處理屬性值](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-value-processing.html)<br><br>&gt; 對應 spec 的以下幾篇：<br>&gt;<br>&gt; * [CSS 2.2 - 6. Assigning property values, Cascading, and Inheritance](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;CSS22&#x2F;cascade.html)<br>&gt; * [CSS Cascading and Inheritance Level 3](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css-cascade-3&#x2F;)<br>&gt; * [CSS Cascading and Inheritance Level 4](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css-cascade-4&#x2F;)<br></code></pre></td></tr></table></figure><h1 id="頁面主題"><a class="header-anchor" href="#頁面主題"></a>頁面主題</h1><h2 id="Dark-Reader"><a class="header-anchor" href="#Dark-Reader"></a>Dark Reader</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh" target="_blank" rel="noopener">Dark Reader</a></p><p>功能：將頁面變成暗主題、護眼模式</p><p>點擊 Extension 的圖案會開啟設定視窗，點擊左上角的按鈕就可以啟用暗主題。</p><p>它會自動偵測需要改變的顏色，大致上的目標是黑底白字。</p><p>像下圖就是 Google 搜尋頁面的暗主題模式，你也可以自訂亮度、對比度等設定。</p><p>你可對每個網站設定不同的設定，例如：A 網站要開啟暗主題，但 B 網站關閉暗主題。</p><p><img src="../images/recommend-chrome-extension-1/dark-reader.png" alt=""></p><h2 id="Stylus"><a class="header-anchor" href="#Stylus"></a>Stylus</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne" target="_blank" rel="noopener">Stylus</a></p><p>功能：在各自頁面自訂 CSS 樣式，即客製化主題</p><p>之前在「<a href="https://titangene.github.io/article/hackmd-dark-theme.html">套用自訂 HackMD 暗主題</a>」就有提供這個 Extension，當時我為 HackMD 客製化了暗主題。</p><p>當然你也可以在你希望的網頁上自訂 CSS，例如：</p><ul><li>頁面的字太小，所以自己設定 <code>font-size</code> 放大</li><li>文章連結沒有底線，看不出與無連結文字的差別，所以自己為設定了 <code>a { text-decoration: underline; }</code></li><li>…等</li></ul><p>那如何各別網站設定自訂的 CSS 呢？只要點擊 Extension 的圖案，並點擊「編寫樣式給：」下面的網址連結，就會為該網站開啟自訂 CSS 的編輯器：</p><p><img src="../images/recommend-chrome-extension-1/stylus-1.png" alt=""></p><p>接著就可以開始寫自訂 CSS 了。像下圖是我自訂本 blog 的背景顏色改為灰黑色，只要儲存就能成功套用：</p><p><img src="../images/recommend-chrome-extension-1/stylus-2.png" alt=""></p><p>如果想將自己自訂的 CSS 分享給別人，可將設定上傳至 <a href="https://userstyles.org/" target="_blank" rel="noopener">Userstyles.org</a> 這個網站讓別人下載套用。</p><h2 id="Medium-Code-Highlighter"><a class="header-anchor" href="#Medium-Code-Highlighter"></a>Medium Code Highlighter</h2><p>下載連結：<a href="https://chrome.google.com/webstore/detail/medium-code-highlighter/apdaagmhepellbjjbnaljaocodjjjjfd" target="_blank" rel="noopener">Medium Code Highlighter</a></p><p>功能：highlight Medium 文章內的程式碼</p><p>找資料時，常會看到 Medium 的文章，但他的程式碼區塊沒有提供 code highlight 功能。</p><p>使用此 Extension 就能 highlight Medium 文章內的程式碼：</p><p><img src="../images/recommend-chrome-extension-1/medium-code-highlighter-1.png" alt=""></p><p>而且還能自己選主題：</p><p><img src="../images/recommend-chrome-extension-1/medium-code-highlighter-2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/chrome-extension.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇推薦一些我常用的 Chrome Extension，包含複製分頁的 Markdown 格式的連結、將頁面變為暗主題。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://titangene.github.io/categories/tools/"/>
    
    
      <category term="Markdown" scheme="https://titangene.github.io/tags/markdown/"/>
    
      <category term="Chrome" scheme="https://titangene.github.io/tags/chrome/"/>
    
      <category term="Chrome Extension" scheme="https://titangene.github.io/tags/chrome-extension/"/>
    
      <category term="Theme" scheme="https://titangene.github.io/tags/theme/"/>
    
  </entry>
  
  <entry>
    <title>Jest：DOM 測試 (jQuery)</title>
    <link href="https://titangene.github.io/article/jest-jquery-dom-testing.html"/>
    <id>https://titangene.github.io/article/jest-jquery-dom-testing.html</id>
    <published>2020-08-02T15:55:10.000Z</published>
    <updated>2020-08-02T15:54:34.300Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>若用 Jest 來測試直接操作 DOM 的程式碼，最大好處是不用安裝額外的套件就可以測試，因為 Jest 附帶了 <code>jsdom</code>，它是用來模擬 DOM 環境，讓你很像在瀏覽器上呼叫 DOM API，進而觀察 DOM 的操作是否符合預期，也就代表測畫面不用真的開啟瀏覽器，不用等待畫面渲染就可以進行測試。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><h1 id="寫範例程式碼"><a class="header-anchor" href="#寫範例程式碼"></a>寫範例程式碼</h1><p>本篇會用下面程式碼作為範例：</p><ul><li><code>fetchCurrentUser.js</code>：發送 request，並將收到的資料進行解析處理</li><li><code>displayUser.js</code>：在按鈕上註冊 <code>click</code> 事件，點擊按鈕後會發 API，並將資料顯示在畫面上</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/fetchCurrentUser.js</span><br><span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseJSON</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    fullName: user.firstName + <span class="hljs-string">' '</span> + user.lastName,<br>    loggedIn: <span class="hljs-literal">true</span>,<br>  &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchCurrentUser</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> $.ajax(&#123;<br>    success: <span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> callback(parseJSON(user)),<br>    type: <span class="hljs-string">'GET'</span>,<br>    url: <span class="hljs-string">'http://example.com/currentUser'</span>,<br>  &#125;);<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = fetchCurrentUser;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/displayUser.js</span><br><span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>);<br><span class="hljs-keyword">const</span> fetchCurrentUser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./fetchCurrentUser.js'</span>);<br><br>$(<span class="hljs-string">'#button'</span>).click(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  fetchCurrentUser(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> loggedText = <span class="hljs-string">'Logged '</span> + (user.loggedIn ? <span class="hljs-string">'In'</span> : <span class="hljs-string">'Out'</span>);<br>    $(<span class="hljs-string">'#username'</span>).text(user.fullName + <span class="hljs-string">' - '</span> + loggedText);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="建立測試"><a class="header-anchor" href="#建立測試"></a>建立測試</h1><p>被測試的函數在 <code>#button</code> DOM 元素上新增一個事件監聽器，所以需要設定 DOM 來進行測試。</p><p>Jest 附帶了 <code>jsdom</code>，它模擬一個 DOM 環境，很像瀏覽器，代表呼叫的每個 DOM API 都可像在瀏覽器中觀察的方式一樣。</p><p>mock <code>fetchCurrentUser.js</code> 可讓測試不用真的發出請求，可 reslove 成 local mock data，快速進行測試。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/displayUser.test.js</span><br>jest.mock(<span class="hljs-string">'../src/fetchCurrentUser'</span>);<br><br>it(<span class="hljs-string">'點擊按鈕後顯示使用者已登入'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 設定 document body</span><br>  <span class="hljs-built_in">document</span>.body.innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;span id="username"&gt;&lt;/span&gt;</span><br><span class="hljs-string">    &lt;button id="button"&gt;&lt;/button&gt;`</span>;<br><br>  <span class="hljs-comment">// 此 module 有 side-effect</span><br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/displayUser'</span>);<br><br>  <span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>);<br>  <span class="hljs-keyword">const</span> fetchCurrentUser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/fetchCurrentUser'</span>);<br><br>  <span class="hljs-comment">// 告訴 fetchCurrentUser mock 函數自動使用一些資料來 invoke callback</span><br>  fetchCurrentUser.mockImplementation(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>    callback(&#123;<br>      fullName: <span class="hljs-string">'Titan'</span>,<br>      loggedIn: <span class="hljs-literal">true</span>,<br>    &#125;);<br>  &#125;);<br><br>  <span class="hljs-comment">// 點擊前的 DOM</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.body.innerHTML);<br><br>  <span class="hljs-comment">// 使用 jQuery 模擬點擊按鈕</span><br>  $(<span class="hljs-string">'#button'</span>).click();<br><br>  <span class="hljs-comment">// 點擊後的 DOM</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.body.innerHTML);<br><br>  <span class="hljs-comment">// Assert fetchCurrentUser 函數已被呼叫，</span><br>  <span class="hljs-comment">// 且 span#username 的 inner text 已按預期更新了</span><br>  expect(fetchCurrentUser).toBeCalled();<br>  expect($(<span class="hljs-string">'#username'</span>).text()).toEqual(<span class="hljs-string">'Titan - Logged In'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>下面測試為何要用 <code>$.ajax.mock.calls[0][0].success()</code> 的方式測，而不是直接 mock <code>src/fetchCurrentUser.js</code> 檔案內的 <code>parseJSON</code>？</p><p>因為 <code>src/fetchCurrentUser.js</code> 檔案內的 <code>parseJSON</code> 沒有 export，所以不能 mock，而且 mock 就失去測試的意義了，該測試就是為了確定 <code>$.ajax</code> 發出請求拿到的使用者資料透過 <code>parseJSON</code> 處理後是否會得到正確的資料 (API 會回傳使用者的 <code>firstName</code> 和 <code>lastName</code>，而 <code>parseJSON</code> 是負責把名字組合成 <code>fullName</code> 和是否登入的狀態 <code>loggedIn</code> )。</p><div class="info"><p>註：Jest 官方文件提供的 <a href="https://github.com/facebook/jest/tree/master/examples/jquery/" target="_blank" rel="noopener">examples/jquery</a> 範例內原本沒有以下內容，因視需求而修改的：</p><ul><li>為了讓將 mock 過的 <code>$.ajax()</code> 在每個測試執行前都被清乾淨 (不保留前一個測試使用個的痕跡)，所以需要在 <code>beforeEach()</code> 內加上 <code>$.ajax.mockClear()</code></li><li>原本範例內的每個測試都 require 了 <code>jquery</code> 和 <code>fetchCurrentUser.js</code>，為了簡化測試檔，把這些 require 統一放在測試檔的最上面</li><li>可用與 <code>expect(callback.mock.calls[0][0]).toEqual()</code> 行為一致的 <code>expect(callback).toBeCalledWith()</code> 但更簡潔的</li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/fetchCurrentUser.test.js</span><br><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">'jquery'</span>;<br><span class="hljs-keyword">const</span> fetchCurrentUser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/fetchCurrentUser'</span>);<br><br>jest.mock(<span class="hljs-string">'jquery'</span>);<br><br>beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  jest.resetModules();<br>  $.ajax.mockClear();<br>&#125;);<br><br>it(<span class="hljs-string">'用正確的參數呼叫 $.ajax'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 呼叫要測試的函數</span><br>  <span class="hljs-keyword">const</span> dummyCallback = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;;<br>  fetchCurrentUser(dummyCallback);<br><br>  <span class="hljs-comment">// 確保在前兩行有正確的呼叫 $.ajax</span><br>  <span class="hljs-comment">// 不在意 $.ajax 的請求結果，只驗證呼叫 $.ajax 時傳的參數是否正確</span><br>  expect($.ajax).toBeCalledWith(&#123;<br>    success: expect.any(<span class="hljs-built_in">Function</span>),<br>    type: <span class="hljs-string">'GET'</span>,<br>    url: <span class="hljs-string">'http://example.com/currentUser'</span>,<br>  &#125;);<br>&#125;);<br><br>it(<span class="hljs-string">'$.ajax 請求完成後呼叫 callback'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 為 callback 建立一個 mock function</span><br>  <span class="hljs-keyword">const</span> callback = jest.fn();<br>  fetchCurrentUser(callback);<br><br>  <span class="hljs-comment">// 模擬 `$.ajax` 執行自己的 callback</span><br>  <span class="hljs-comment">// 第一次呼叫的第一個參數</span><br>  $.ajax.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].success(&#123;<br>    firstName: <span class="hljs-string">'Bobby'</span>,<br>    lastName: <span class="hljs-string">'Marley'</span>,<br>  &#125;);<br><br>  <span class="hljs-comment">// assert 模擬 `$.ajax` 呼叫的 callback 傳入的 arg</span><br>  <span class="hljs-comment">// 第一次呼叫的第一個參數</span><br>  expect(callback.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).toEqual(&#123;<br>    fullName: <span class="hljs-string">'Bobby Marley'</span>,<br>    loggedIn: <span class="hljs-literal">true</span>,<br>  &#125;);<br>  expect(callback).toBeCalledWith(&#123;<br>    fullName: <span class="hljs-string">'Bobby Marley'</span>,<br>    loggedIn: <span class="hljs-literal">true</span>,<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在 <code>fetchCurrentUser.test.js</code> 測試檔內我自己加了一個測試，用來測使用者點擊按鈕後是否正確的呼叫 <code>fetchCurrentUser()</code>，並且裡面呼叫的 <code>$.ajax()</code> 是否有正確的呼叫 <code>success</code> 內的 <code>callback</code> (即 <code>success: user =&gt; callback(parseJSON(user))</code> )。</p><p>但為了不讓 <code>$.ajax()</code> 發出真的請求，所以用 <code>$.ajax = jest.fn()</code> mock，接著再透過 <code>$.ajax.mock.calls[0][0].success({...})</code> 的方式呼叫 <code>success</code> 內的 <code>callback</code>。</p><p>不過，這個測試比較複雜，因為測試檔的最上面使用了 <code>jest.mock('jquery')</code>，讓整個測試檔都 mock 了 jQuery，但在 <code>require('../src/displayUser')</code> 要綁定按鈕點擊事件時需要用真的 jQuery，所以才需要用 <code>jest.unmock('jquery')</code> unmock jQuery。</p><p>除了綁定按鈕點擊事件要用真的 jQuery，觸發點擊事件後顯示使用者已登入的 <code>$('#username').text()</code> 也要用真的 jQuery (因本測試會用 <code>span#username</code> 的 <code>innerText</code> 來驗證測試)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/fetchCurrentUser.test.js</span><br><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">'jquery'</span>;<br><span class="hljs-keyword">const</span> fetchCurrentUser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/fetchCurrentUser'</span>);<br><br>jest.mock(<span class="hljs-string">'jquery'</span>);<br><br>beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  jest.resetModules();<br>  $.ajax.mockClear();<br>&#125;);<br><br>it(<span class="hljs-string">'點擊按鈕發出 $.ajax 請求，請求完成後顯示使用者已登入'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 設定 document body</span><br>  <span class="hljs-built_in">document</span>.body.innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;span id="username"&gt;&lt;/span&gt;</span><br><span class="hljs-string">    &lt;button id="button"&gt;&lt;/button&gt;`</span>;<br><br>  <span class="hljs-comment">// 使用 `jest.unmock(...)` 後，require 的模組都會是真的，不是 mock 的</span><br>  <span class="hljs-comment">// 因測試檔的最上面 mock 了 jQuery，而 `displayUser.js` 內</span><br>  <span class="hljs-comment">// 需要跑真的 jQuery，所以需要 unmock jQuery，</span><br>  jest.unmock(<span class="hljs-string">'jquery'</span>);<br><br>  <span class="hljs-comment">// 此 module 有 side-effect</span><br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/displayUser'</span>);<br><br>  <span class="hljs-comment">// 觸發點擊事件內要執行真的 `$(...).text()`，所以需要真的 jQuery</span><br>  <span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>);<br><br>  <span class="hljs-comment">// 但只有 `$.ajax` 需要 mock</span><br>  $.ajax = jest.fn();<br>  <span class="hljs-comment">// 模擬點擊按鈕</span><br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'button'</span>).click();<br><br>  <span class="hljs-comment">// 模擬 `$.ajax` 執行自己的 callback</span><br>  <span class="hljs-comment">// 第一次呼叫的第一個參數</span><br>  $.ajax.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].success(&#123;<br>    firstName: <span class="hljs-string">'Bobby'</span>,<br>    lastName: <span class="hljs-string">'Marley'</span>,<br>  &#125;);<br><br>  <span class="hljs-comment">// Assert span#username 的 inner text 已按預期更新了 (畫面顯示使用者已登入)</span><br>  expect($(<span class="hljs-string">'#username'</span>).text()).toEqual(<span class="hljs-string">'Bobby Marley - Logged In'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/tutorial-jquery" target="_blank" rel="noopener">DOM Manipulation · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;若用 Jest 來測試直接操作 DOM 的程式碼，最大好處是不用安裝額外的套件就可以測試，因為 Jest 附帶了 &lt;code&gt;jsdom&lt;/code&gt;，它是用來模擬 DOM 環境，讓你很像在瀏覽器上呼叫 DOM API，進而觀察 DOM 的操作是否符合預期，也就代表測畫面不用真的開啟瀏覽器，不用等待畫面渲染就可以進行測試。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="mock" scheme="https://titangene.github.io/tags/mock/"/>
    
      <category term="DOM" scheme="https://titangene.github.io/tags/dom/"/>
    
      <category term="jQuery" scheme="https://titangene.github.io/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Manual Mocks</title>
    <link href="https://titangene.github.io/article/jest-manual-mocks.html"/>
    <id>https://titangene.github.io/article/jest-manual-mocks.html</id>
    <published>2020-07-26T15:59:04.000Z</published>
    <updated>2020-07-26T16:00:27.192Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>manual mock 是用於透過 mock 資料來對功能進行 stub out。例如：若你不想存取網站或 DB 之類的遠端資源，可能需要使用 fake data 來 manual mock 這些功能，以確保可以快速測試且不會出錯。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><h1 id="Mocking-user-modules"><a class="header-anchor" href="#Mocking-user-modules"></a>Mocking user modules</h1><p>manual mock 是透過將模組寫在相鄰該模組的 <code>__mocks__/</code> 子目錄內來定義的。例如：要在 <code>models</code> 目錄 mock 一個名為 <code>user</code> 的模組，請建立名為 <code>user.js</code> 的檔案，並將該檔案放在 <code>models/__mocks__</code> 目錄中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">.<br>├── models<br>│   ├── __mocks__<br>│   │   └── user.js<br>│   └── user.js<br>└── main.js<br></code></pre></td></tr></table></figure><div class="info"><p><code>__mocks__</code> 資料夾會區分大小寫 (case-sensitive)，所以在某些 OS 上命名成 <code>__MOCKS__</code> 會失效。</p></div><h2 id="範例"><a class="header-anchor" href="#範例"></a>範例</h2><p>完整目錄如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── src<br>│   ├── controllers<br>│   │   ├── __mocks__<br>│   │   │   └── user.js<br>│   │   └── user.js<br>│   ├── models<br>│   │   ├── index.js<br>│   │   └── user.js<br>│   ├── setup.js<br>│   └── main.js<br>└── __tests__<br>    └── userMocked.test.js<br></code></pre></td></tr></table></figure><p>在 <code>src/controllers/user.js</code> 內提供取得第一個使用者資訊的 <code>getFirstUser()</code> (從 DB 拿出來的資料)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/controllers/user.js</span><br><span class="hljs-keyword">const</span> User = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../models'</span>).User;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-keyword">async</span> getFirstUser() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> userId = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> models.user.findByPk(userId);<br>      <span class="hljs-keyword">return</span> user;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-built_in">console</span>.log(error.message);<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>接著在 <code>src/controllers</code> 目錄內新增 <code>__mocks__</code> 子目錄，並在裡面建立名為 <code>user.js</code> 的檔案，內容如下，manual mock 的內容就是回傳固定的 fake data，讓每次執行測試不用真的去讀取資料庫的資料：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/controllers/__mocks__/user.js</span><br><span class="hljs-keyword">const</span> User = jest.createMockFromModule(<span class="hljs-string">'../user'</span>);<br><br>User.getFirstUser = <span class="hljs-keyword">async</span> () =&gt; (&#123;<br>  name: <span class="hljs-string">'Mock name'</span>,<br>  age: <span class="hljs-number">87</span><br>&#125;);<br><br><span class="hljs-built_in">module</span>.exports = User;<br></code></pre></td></tr></table></figure><p>測試要引入 manual mock 的模組時，記得要呼叫 <code>jest.mock('./moduleName')</code>，其餘測試寫法就跟平時一樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/userMocked.test.js</span><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/controllers/user'</span>;<br><br>jest.mock(<span class="hljs-string">'../src/controllers/user'</span>);<br><br>it(<span class="hljs-string">'if user model is mocked'</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> expected = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'Mock name'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">87</span>&#125;;<br><br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> User.getFirstUser();<br><br>  expect(user).toMatchObject(expected);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Mocking-Node-modules"><a class="header-anchor" href="#Mocking-Node-modules"></a>Mocking Node modules</h1><p>若要 mock 的模組是 Node 模組 (例如：<code>lodash</code> )，則 mock 應放在與 <code>node_modules</code> 相鄰的 <code>__mocks__</code> 目錄中 (除非你將 <a href="https://jestjs.io/docs/en/configuration#roots-arraystring" target="_blank" rel="noopener"><code>roots</code></a> 配置為指向專案 root 目錄以外的資料夾)，並且會被自動 mock。無需明確呼叫 <code>jest.mock('./moduleName')</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">.<br>├── __mocks__<br>│   └── lodash.js<br>├── node_modules<br>│   └── lodash<br>│       └── lodash.js<br>└── main.js<br></code></pre></td></tr></table></figure><p>可以透過在目錄結構中建立一個與 scoped module 名稱 match 的檔案來 mock scoped module。例如：若要 mock 名為 <code>@scope/project-name</code> 的 scoped module，請建立名為 <code>__mocks__/@scope/project-name.js</code> 的檔案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">.<br>├── __mocks__<br>│   └── @scope<br>│       └── project-name.js<br>├── node_modules<br>│   └── @scope<br>│       └── project-name<br>└── main.js<br></code></pre></td></tr></table></figure><div class="warning"><p>警告：若要 mock Node 的核心模組 (例如：<code>fs</code> 或 <code>path</code> )，必須要明確呼叫 (例如：<code>jest.mock('path')</code> )，因為預設不會 mock 核心 Node 模組。</p></div><h1 id="例如"><a class="header-anchor" href="#例如"></a>例如</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">.<br>├── config<br>├── __mocks__<br>│   └── fs.js<br>├── models<br>│   ├── __mocks__<br>│   │   └── user.js<br>│   └── user.js<br>├── node_modules<br>└── views<br></code></pre></td></tr></table></figure><p>當給定模組有 manual mock 時，Jest 的模組系統會在明確呼叫 <code>jest.mock('moduleName')</code> 時使用該模組。</p><p>但是，當配置的 <code>automock</code> 設為 <code>true</code> 時，即使未呼叫 <code>jest.mock('moduleName')</code>，也會用 manual mock implementation 來取代自動建立的 mock。</p><p>若要取消 mock，需要在應該使用實際模組 implementation 的測試中顯式明確呼叫 <a href="https://jestjs.io/docs/en/jest-object#jestunmockmodulename" target="_blank" rel="noopener"><code>jest.unmock('moduleName')</code></a>。</p><div class="info"><p>為了正確的 mock，Jest 需要 <code>jest.mock('moduleName')</code> 與 <code>require</code> / <code>import</code> 陳述句在同一個 scope 內。</p></div><p>例如：有一個模組可提供給定目錄中所有檔案的摘要。這裡使用核心 (內建) <code>fs</code> 模組：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// fileSummarizer.js</span><br><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">summarizeFilesInDirectorySync</span>(<span class="hljs-params">directory</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> fs.readdirSync(directory).map(<span class="hljs-function"><span class="hljs-params">fileName</span> =&gt;</span> (&#123;<br>    directory,<br>    fileName,<br>  &#125;));<br>&#125;<br><br>exports.summarizeFilesInDirectorySync = summarizeFilesInDirectorySync;<br></code></pre></td></tr></table></figure><p>由於我們希望測試避免實際對硬碟進行存取 (因為會很慢且脆弱)，所以會透過擴充自動 mock 來為 <code>fs</code> 模組建立 manual mock。我們的 manual mock 會實作可用於測試的 <code>fs</code> API 的自訂版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __mocks__/fs.js</span><br><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<br><br><span class="hljs-keyword">const</span> fs = jest.createMockFromModule(<span class="hljs-string">'fs'</span>);<br><br><span class="hljs-comment">// 這是自訂函數，測試可在 setup 過程中使用此函數</span><br><span class="hljs-comment">// 來指定使用任何 `fs` API 時 mock filesystem 上的檔案應該為何</span><br><span class="hljs-keyword">let</span> mockFiles = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__setMockFiles</span>(<span class="hljs-params">newMockFiles</span>) </span>&#123;<br>  mockFiles = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">in</span> newMockFiles) &#123;<br>    <span class="hljs-keyword">const</span> dir = path.dirname(file);<br><br>    <span class="hljs-keyword">if</span> (!mockFiles[dir]) &#123;<br>      mockFiles[dir] = [];<br>    &#125;<br>    mockFiles[dir].push(path.basename(file));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 自訂版的 `readdirSync` 透過</span><br><span class="hljs-comment">// 從`__setMockFiles` 設定的指定 mocked 檔案列表中讀取</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readdirSync</span>(<span class="hljs-params">directoryPath</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> mockFiles[directoryPath] || [];<br>&#125;<br><br>fs.__setMockFiles = __setMockFiles;<br>fs.readdirSync = readdirSync;<br><br><span class="hljs-built_in">module</span>.exports = fs;<br></code></pre></td></tr></table></figure><p>現在我們來寫測試。請注意，由於它是核心 Node 模組，所以需要明確告知我們要 mock <code>fs</code> 模組 (也就是需明確呼叫 <code>jest.mock('fs')</code> )：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/FileSummarizer-test.js</span><br><span class="hljs-meta">'use strict'</span>;<br><br>jest.mock(<span class="hljs-string">'fs'</span>);<br><br>describe(<span class="hljs-string">'listFilesInDirectorySync'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> MOCK_FILE_INFO = &#123;<br>    <span class="hljs-string">'/path/to/file1.js'</span>: <span class="hljs-string">'console.log("file1 contents");'</span>,<br>    <span class="hljs-string">'/path/to/file2.txt'</span>: <span class="hljs-string">'file2 contents'</span>,<br>  &#125;;<br><br>  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在每次測試之前 setup 一些 mocked out 檔案資訊</span><br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).__setMockFiles(MOCK_FILE_INFO);<br>  &#125;);<br><br>  test(<span class="hljs-string">'includes all files in the directory in the summary'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> FileSummarizer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../FileSummarizer'</span>);<br>    <span class="hljs-keyword">const</span> fileSummary = FileSummarizer.summarizeFilesInDirectorySync(<br>      <span class="hljs-string">'/path/to'</span>,<br>    );<br><br>    expect(fileSummary.length).toBe(<span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>此範例的 mock 是用 <a href="https://jestjs.io/docs/en/jest-object#jestcreatemockfrommodulemodulename" target="_blank" rel="noopener"><code>jest.createMockFromModule</code></a> 來生成自動 mock，並覆蓋預設的行為 (也就是大部份都是真的，但少部份是假的)。推薦此方法，但不強迫。若不想使用自動 mock，則可從 mock 檔案中 export 自己的函數。完全 manual mock 的一個缺點是它們是手動的，代表必須在模組 mocking changes 時隨時手動更新它們。所以最好在滿足你的需求時使用或擴充自動 mock。</p><p>為了確保 manual mock 和實際實作保持同步，在 export manual mock 模組之前，請在 manual mock 中使用 <a href="https://jestjs.io/docs/en/jest-object#jestrequireactualmodulename" target="_blank" rel="noopener"><code>jest.requireActual(moduleName)</code></a> 使用真實的模組，並用 mock 函數對其進行變更，這可能會很有用。</p><blockquote><p>範例程式碼：<a href="https://github.com/facebook/jest/tree/master/examples/manual-mocks" target="_blank" rel="noopener">examples/manual-mocks</a>。</p></blockquote><h1 id="與-ES-模組引入一起使用"><a class="header-anchor" href="#與-ES-模組引入一起使用"></a>與 ES 模組引入一起使用</h1><p>若你正在使用 ES 模組 imports，通常會傾向將 <code>import</code> 陳述句放在測試檔案的最上面。但通常你需要指示 Jest 在模組使用 mock 之前使用它。所以 Jest 會自動將 <code>jest.mock</code> 呼叫 hoist 至模組的最上面 (在 import 之前)。</p><blockquote><p>詳情可參閱 <a href="https://github.com/kentcdodds/how-jest-mocking-works" target="_blank" rel="noopener">kentcdodds/how-jest-mocking-works</a>。</p></blockquote><h1 id="JSDOM-中未實作的-mock-方法"><a class="header-anchor" href="#JSDOM-中未實作的-mock-方法"></a>JSDOM 中未實作的 mock 方法</h1><p>若某些程式碼使用的方法尚未實作 JSDOM (Jest 使用的 DOM implementation)，則不易於測試。</p><p>例如：<code>Window.matchMedia()</code> 的情況。Jest 會回傳 <code>TypeError: window.matchMedia is not a function</code>，不能正確執行測試。</p><p>在這種情況下，在測試檔案中 mock <code>matchMedia</code> 應該可以解決此問題：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/matchMedia.mock.js</span><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">'matchMedia'</span>, &#123;<br>  writable: <span class="hljs-literal">true</span>,<br>  value: jest.fn().mockImplementation(<span class="hljs-function"><span class="hljs-params">query</span> =&gt;</span> (&#123;<br>    matches: <span class="hljs-literal">false</span>,<br>    media: query,<br>    onchange: <span class="hljs-literal">null</span>,<br>    addListener: jest.fn(),     <span class="hljs-comment">// deprecated</span><br>    removeListener: jest.fn(),  <span class="hljs-comment">// deprecated</span><br>    addEventListener: jest.fn(),<br>    removeEventListener: jest.fn(),<br>    dispatchEvent: jest.fn(),<br>  &#125;)),<br>&#125;);<br></code></pre></td></tr></table></figure><div class="info"><p><code>matchMedia.mock.js</code> 這個檔案放哪都可以，但記得配置要設成 <code>testEnvironment: &quot;jsdom&quot;</code>。</p></div><ul><li>若在測試中 invoked 的函數 (或方法) 中使用 <code>window.matchMedia()</code>，則此方法可以運作</li><li>若在測試檔案中直接執行 <code>window.matchMedia()</code>，Jest 會出現相同的錯誤</li></ul><p>所以解決方案是將 manual mock 放在獨立的檔案中，並在測試之前將其包含在測試檔案中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/useMatchMedia.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useMatchMedia</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.matchMedia(<span class="hljs-string">'xx'</span>).matches;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/userMocked.test.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">"./matchMedia.mock"</span>; <span class="hljs-comment">// 必須在測試檔案之前 import</span><br><span class="hljs-keyword">import</span> useMatchMedia <span class="hljs-keyword">from</span> <span class="hljs-string">"../src/useMatchMedia"</span>;<br><br>it(<span class="hljs-string">'use matchMedia()'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 在這裡測試 method...</span><br>  expect(useMatchMedia()).toBeFalsy();<br>&#125;);<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/manual-mocks" target="_blank" rel="noopener">Manual Mocks · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;manual mock 是用於透過 mock 資料來對功能進行 stub out。例如：若你不想存取網站或 DB 之類的遠端資源，可能需要使用 fake data 來 manual mock 這些功能，以確保可以快速測試且不會出錯。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="mock" scheme="https://titangene.github.io/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Timer Mocks</title>
    <link href="https://titangene.github.io/article/jest-timer-mocks.html"/>
    <id>https://titangene.github.io/article/jest-timer-mocks.html</id>
    <published>2020-07-19T14:05:04.000Z</published>
    <updated>2020-07-19T14:04:15.794Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>常用的 native timer 包括 <code>setTimeout</code>、<code>setInterval</code>、<code>clearTimeout</code>、<code>clearInterval</code> 等，用到這些 timer 的函數可以說是依賴於真實流逝的時間。如果 timer 要跑幾秒後才會觸發，或是要確認某函數是否在固定週期內被呼叫幾次，你不可能真的去等待 timer 跑完才能驗證結果吧，那根本是浪費時間。所以應該要使用 mock 函數來 mock 掉那些 timer 函數，透過 Jest 提供的功能來控制時間，其中就有時間快轉的功能，減少測試要等待的時間。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><h1 id="啟動-fake-timer"><a class="header-anchor" href="#啟動-fake-timer"></a>啟動 fake timer</h1><p>要在 Jest 使用 mock 過的 timer，可透過呼叫 <code>jest.useFakeTimers()</code> 來啟動 fake timer，之後就可以用 fake timer 來控制時間。</p><p>假設有一個 <code>timerGame()</code> 函數，呼叫該函數時，會先列印 <code>'Ready....go!'</code>，接著至少過了 1 秒後才會列印 <code>&quot;Time's up -- stop!&quot;</code>，並且呼叫傳入的 callback：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/timerGame.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timerGame</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Ready....go!'</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Time's up -- stop!"</span>);<br>    callback &amp;&amp; callback();<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果測試這樣寫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/timerGame.test.js</span><br><span class="hljs-keyword">import</span> &#123; timerGame &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/timerGame'</span>;<br><br>jest.useFakeTimers();<br><br>describe(<span class="hljs-string">'執行一次 timer'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'等待 1 秒後結束遊戲'</span>, () =&gt; &#123;<br>    timerGame();<br><br>    expect(setTimeout).toBeCalledTimes(<span class="hljs-number">1</span>);<br>    expect(setTimeout).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>), <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>測試只有測到 <code>timerGame()</code> 的以下內容：</p><ul><li><code>setTimeout</code> 被呼叫幾次 (即 <code>toBeCalledTimes(number)</code> )</li><li>最後一次呼叫 <code>setTimeout</code> 的 argument 為何 (即 <code>lastCalledWith(arg1, arg2, ...)</code> )：<ul><li>第一個 argument 可以是任何函數</li><li>第二個 argument 一定是 <code>1000</code> 豪秒</li></ul></li></ul><p>所以 <code>timerGame()</code> 內的 <code>console.log(&quot;Time's up -- stop!&quot;)</code> 那行都還沒執行就測試通過了 (所以才只輸出 <code>'Ready....go!'</code> 這行)。</p><p>若在一個檔案或 <code>describe</code> 區塊中執行多個測試，就可在每個測試之前手動呼叫 <code>jest.useFakeTimers()</code>，或是使用 <code>beforeEach</code> 之類的 <a href="https://titangene.github.io/article/jest-setup-teardown.html">setup 函數</a>。否則會讓內部使用的 timer 未被 reset。</p><p>如果沒有 reset timer，可能會像這個測試一樣很奇怪：</p><ul><li>第一個 <code>it</code> 區塊的測試很正常，只呼叫一次 <code>timerGame()</code>，所以 <code>setTimeout</code> 只被呼叫過一次</li><li>但第二個 <code>it</code> 區塊的測試被第一個 <code>it</code> 區塊使用的 <code>setTimeout</code> 所污染，明明 <code>timerGame()</code> 只呼叫過一次，竟然 assert <code>setTimeout</code> 不是被呼叫過一次 ，而是兩次</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/resetTimer.test.js</span><br><span class="hljs-keyword">import</span> &#123; timerGame &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/timerGame'</span>;<br><br>describe(<span class="hljs-string">'每個測試都只呼叫一次 `timerGame()`'</span>, () =&gt; &#123;<br>  describe(<span class="hljs-string">'未在每個測試執行前 reset timer'</span>, () =&gt; &#123;<br>    <span class="hljs-comment">// 不建議直接在 `describe` 區塊內呼叫 `jest.useFakeTimers()`</span><br>    <span class="hljs-comment">// 應在 Setup and Teardown 時 reset timer</span><br>    jest.useFakeTimers();<br><br>    it(<span class="hljs-string">'setTimeout 的呼叫次數應為 1 次'</span>, () =&gt; &#123;<br>      timerGame();<br><br>      expect(setTimeout).toBeCalledTimes(<span class="hljs-number">1</span>);<br>      expect(setTimeout).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>), <span class="hljs-number">1000</span>);<br>    &#125;);<br><br>    it(<span class="hljs-string">'setTimeout 的呼叫次數應為 2 次，setTimeout 的呼叫次數會因前面的測試未 reset timer 而影響'</span>, () =&gt; &#123;<br>      timerGame();<br><br>      expect(setTimeout).not.toBeCalledTimes(<span class="hljs-number">1</span>);<br>      expect(setTimeout).toBeCalledTimes(<span class="hljs-number">2</span>);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>所以應在 setup (即 <code>beforeEach()</code> ) 和 teardown (即 <code>afterEach()</code> ) 時 reset timer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/resetTimer.test.js</span><br><span class="hljs-keyword">import</span> &#123; timerGame &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/timerGame'</span>;<br><br><span class="hljs-comment">// 不建議在測試檔案的全域使用 `jest.useFakeTimers()`</span><br><span class="hljs-comment">// 應在 Setup and Teardown 時 reset timer</span><br><span class="hljs-comment">// jest.useFakeTimers();</span><br><br>describe(<span class="hljs-string">'每個測試都只呼叫一次 `timerGame()`'</span>, () =&gt; &#123;<br>  describe(<span class="hljs-string">'有在每個測試執行前 reset timer'</span>, () =&gt; &#123;<br>    beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      jest.useFakeTimers();<br>    &#125;);<br><br>    it(<span class="hljs-string">'setTimeout 的呼叫次數應為 1 次'</span>, () =&gt; &#123;<br>      timerGame();<br><br>      expect(setTimeout).toBeCalledTimes(<span class="hljs-number">1</span>);<br>      expect(setTimeout).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>), <span class="hljs-number">1000</span>);<br>    &#125;);<br><br>    it(<span class="hljs-string">'setTimeout 的呼叫次數應為 1 次，setTimeout 的呼叫次數不會受前面的測試影響'</span>, () =&gt; &#123;<br>      timerGame();<br><br>      expect(setTimeout).toBeCalledTimes(<span class="hljs-number">1</span>);<br>    &#125;);<br><br>    afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      jest.clearAllTimers();<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><div class="info"><h2 id="使用-jest-useFakeTimers-的建議"><a class="header-anchor" href="#使用-jest-useFakeTimers-的建議"></a>使用 <code>jest.useFakeTimers()</code> 的建議</h2><p>不應在以下位置使用 <code>jest.useFakeTimers()</code>：</p><ul><li>測試檔案的全域呼叫</li><li>直接在 <code>describe</code> 區塊內呼叫</li></ul><p>建議在 <a href="https://titangene.github.io/article/jest-setup-teardown.html">setup 和 teardown</a> 時 reset timer。當然可以放在 <code>it</code> 或 <code>test</code> 區塊內，或是在 setup 和 teardown 呼叫，但需重複寫很多次，很麻煩。</p></div><p>下面是 <code>jest.useFakeTimers(implementation?: 'modern' | 'legacy')</code> 的介紹：</p><ul><li>指定 Jest 使用 fake 的標準 timer 函數，包括：<ul><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>clearTimeout</code></li><li><code>clearInterval</code></li><li><code>nextTick</code></li><li><code>setImmediate</code></li><li><code>clearImmediate</code></li></ul></li><li>若使用 <code>'modern'</code> 作為 argument，則會使用 <a href="https://github.com/sinonjs/fake-timers" target="_blank" rel="noopener">@sinonjs/fake-timers</a> 來作為 implementation，而不是 Jest 自己的 fake timer</li><li>也可 mock 其他 timer，例如：<code>Date</code></li><li><code>'modern'</code> 是 Jest 27 的預設行為 (目前我使用的環境是 Jest 25，所以是用 <code>legacy</code> )</li><li>回傳用於 chaining 的 <code>jest</code> 物件</li></ul><p>上面提到的 <code>'modern'</code> 和 <code>legacy</code> 是 <code>jest.config.js</code> 內的 <code>timers</code> config：</p><ul><li>預設為 <code>&quot;real&quot;</code></li><li>設為 <code>&quot;legacy&quot;</code> 或 <code>&quot;fake&quot;</code> 時，允許對函數使用 fake timer。當程式碼設定了不想在測試中等待的 long timeout，fake timer 就很好用</li><li>設為 <code>&quot;modern&quot;</code> 時，會將 <a href="https://github.com/sinonjs/fake-timers" target="_blank" rel="noopener"><code>@sinonjs/fake-timers</code></a> 作為實作，而不是 Jest 自己的舊實作。Jest 27 會預設此設定</li></ul><p>在 Jest 15 開始才將 <code>timers</code> config 預設成 <code>&quot;real&quot;</code>。可透過在配置中指定 <code>timers: &quot;fake&quot;</code> 或呼叫 <code>jest.useRealTimers()</code> 和 <code>jest.useFakeTimers()</code> 全域開關來覆蓋此設定。</p><h1 id="執行所有-timer"><a class="header-anchor" href="#執行所有-timer"></a>執行所有 timer</h1><p>若要測試 assert 在 1 秒後呼叫 callback，可在測試中使用 Jest 的 timer 控制 API <code>jest.runAllTimers()</code> 來快轉時間：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/timerGame.test.js</span><br>describe(<span class="hljs-string">'執行所有 timer'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'1 秒後呼叫 callback'</span>, () =&gt; &#123;<br>    jest.useFakeTimers();<br><br>    <span class="hljs-keyword">const</span> callback = jest.fn();<br><br>    timerGame(callback);<br><br>    <span class="hljs-comment">// 此時 callback 應該還沒被呼叫</span><br>    expect(callback).not.toBeCalled();<br><br>    <span class="hljs-comment">// 快轉直到執行完所有 timer</span><br>    jest.runAllTimers();<br><br>    <span class="hljs-comment">// 現在 callback 已被呼叫</span><br>    expect(callback).toBeCalled();<br>    expect(callback).toBeCalledTimes(<span class="hljs-number">1</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><div class="info"><p><code>jest.runAllTimers()</code>：</p><ul><li>用盡 macro-task queue (即由 <code>setTimeout()</code>、<code>setInterval()</code> 和 <code>setImmediate()</code> 排隊 (queued) 的所有 task) 和 micro-task queue (通常會透過 <code>process.nextTick</code> interfaced 至 node)</li><li>呼叫此 API 時，會執行所有 pending macro-tasks 和 micro-tasks。若這些 task 本身安排了 (schedule) 新 task，這些 task 就會不斷的耗盡 (exhausted)，直到 queue 中沒有其他 task 為止</li><li>通常在測試期間同步執行 <code>setTimeout</code> 很有用，以便同步 assert 某些行為，但這些行為只會在 <code>setTimeout()</code> 或 <code>setInterval()</code> 的 callback 執行後才發生</li></ul></div><h1 id="執行-pending-timer"><a class="header-anchor" href="#執行-pending-timer"></a>執行 pending timer</h1><p>假設有遞迴的 timer，會在自己的 callback 中設定一個新的 timer。若執行所有 timer 就會變成無限迴圈，所以不能用像是 <code>jest.runAllTimers()</code>，但可用 <code>jest.runOnlyPendingTimers()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/infiniteTimerGame.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">infiniteTimerGame</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Ready....go!'</span>);<br><br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Time's up! 5 seconds before the next game starts..."</span>);<br>    callback &amp;&amp; callback();<br><br>    <span class="hljs-comment">// 在 5 秒內安排下一場比賽</span><br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      infiniteTimerGame(callback);<br>    &#125;, <span class="hljs-number">5000</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/infiniteTimerGame.test.js</span><br><span class="hljs-keyword">import</span> &#123; infiniteTimerGame &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/infiniteTimerGame'</span>;<br><br>describe(<span class="hljs-string">'infiniteTimerGame'</span>, () =&gt; &#123;<br>  test(<span class="hljs-string">'在 1 秒後安排 5 秒 timer'</span>, () =&gt; &#123;<br>    jest.useFakeTimers();<br><br>    <span class="hljs-keyword">const</span> callback = jest.fn();<br>    infiniteTimerGame(callback);<br><br>    <span class="hljs-comment">// 此時應該只有呼叫一次 `setTimeout` 才能在 1 秒內安排遊戲結束</span><br>    expect(setTimeout).toBeCalledTimes(<span class="hljs-number">1</span>);<br>    expect(setTimeout).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>), <span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// 快轉並只耗盡當前 pending timer</span><br>    <span class="hljs-comment">// (但此過程中不會建立任何新的 timer)</span><br>    jest.runOnlyPendingTimers();<br><br>    <span class="hljs-comment">// 此時，1 秒的 timer 應該觸發了 callback</span><br>    expect(callback).toBeCalled();<br><br>    <span class="hljs-comment">// 並且應該已建立一個新的 timer，可在 5 秒內開始遊戲</span><br>    expect(setTimeout).toBeCalledTimes(<span class="hljs-number">2</span>);<br>    expect(setTimeout).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>), <span class="hljs-number">5000</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="依時間-advance-提前-timer"><a class="header-anchor" href="#依時間-advance-提前-timer"></a>依時間 advance (提前) timer</h1><p><code>jest.advanceTimersByTime(msToRun)</code>：</p><ul><li>Jest 22.0.0 將 <code>runTimersToTime()</code> (但還可以當作 alias 使用) 重新命名成 <code>advanceTimersByTime()</code></li><li>只會執行 macro task queue (即由 <code>setTimeout()</code> 或 <code>setInterval()</code> 和 <code>setImmediate()</code> 排隊 (queued) 的所有 task)</li><li>呼叫時，所有 timer 都會被提前 <code>msToRun</code> 豪秒</li><li>透過 <code>setTimeout()</code> 或 <code>setInterval()</code> 排隊 (queued)，並在此時間範圍 (time frame) 內執行的所有 pending “macro-tasks” 都會被執行</li><li>如果這些是 macro-tasks 計劃 (schedule) 在同一時間範圍內執行的新 macro-tasks，就會一直執行這些 macro-tasks，直到 queue 中沒有其他應該在 <code>msToRun</code> 毫秒內執行的 macro-tasks 為止</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/advanceTimersByTime.test.js</span><br>describe(<span class="hljs-string">'Advance Timers by Time'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'1 秒後透過 `advanceTimersByTime` 呼叫 callback'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> callback = jest.fn();<br>    timerGame(callback);<br><br>    <span class="hljs-comment">// 此時 callback 應該還沒被呼叫</span><br>    expect(callback).not.toBeCalled();<br><br>    <span class="hljs-comment">// 快轉直到執行完所有 timer</span><br>    jest.advanceTimersByTime(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// 現在 callback 已被呼叫</span><br>    expect(callback).toBeCalled();<br>    expect(callback).toHaveBeenCalledTimes(<span class="hljs-number">1</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>可用 <code>jest.clearAllTimers()</code> 從 timer 系統中刪除所有 pending timer，也就是若 scheduled (安排了) 任何 timer (但尚未執行)，可被清除並永遠沒有機會執行它們。</p><h1 id="其他"><a class="header-anchor" href="#其他"></a>其他</h1><ul><li><code>jest.useRealTimers()</code><ul><li>指定 Jest 使用標準 timer 函數的實際版本</li><li>回傳用於 chaining 的 <code>jest</code> 物件</li></ul></li><li><code>jest.runAllTicks()</code>：<ul><li>耗盡 micro-task queue (通常會透過 <code>process.nextTick</code> interfaced 至 node)</li><li>呼叫此 API 時，會執行透過 <code>process.nextTick</code> 排隊 (queued) 的所有 pending micro-tasks</li><li>若這些 micro-tasks 安排了 (schedule) 新 task，這些 task 就會不斷的耗盡 (exhausted)，直到 queue 中沒有其他 micro-tasks 為止</li></ul></li><li><code>jest.runAllImmediates()</code>：<ul><li>耗盡由 <code>setImmediate()</code> 排隊 (queued) 的所有 tasks</li><li>注意：使用 modern fake timers implementation 時，此函數不可用</li></ul></li><li><code>jest.runOnlyPendingTimers()</code>：<ul><li>只執行當前 pending macro-tasks (即只執行 <code>setTimeout()</code> 或 <code>setInterval()</code> 至目前為止已 queued (排隊) 的 task)</li><li>若任何當前 pending macro-tasks 安排了 (schedule) 新 task，這些新 task 就不會透過 <code>jest.runOnlyPendingTimers()</code> 呼叫執行</li></ul></li><li><code>jest.advanceTimersToNextTimer(steps?)</code>：<ul><li>將所有 timer 提前所需的毫秒數，以便只執行下一個 timeouts/intervals</li><li>可提供 <code>steps</code> arg，執行下一次 timeouts/intervals 的 <code>steps</code> 數</li></ul></li><li><code>jest.getTimerCount()</code>：<ul><li>回傳仍在執行的 fake timer 數量</li></ul></li><li><code>jest.setSystemTime()</code>：<ul><li>設定 fake timer 使用的當前系統時間</li><li>模擬使用者在 program 執行時變更系統時鐘</li><li>會影響當前時間，但不會導致像是 timers to fire (定時觸發)</li><li>會完全照原樣觸發 (fire)，而無需呼叫 <code>jest.setSystemTime()</code></li><li>注意：此函數只在使用 modern fake timers implementation 時可用</li></ul></li><li><code>jest.getRealSystemTime()</code>：<ul><li>在 mock 時間時，也會 mock <code>Date.now()</code></li><li>若想存取實際的當前時間，可 invoke 此函數</li><li>注意：此函數只在使用 modern fake timers implementation 時可用</li></ul></li><li><code>jest.setTimeout(timeout)</code>：<ul><li>設定測試和 hook 之前/之後的預設 timeout interval (單位為豪秒)</li><li>會影響從中呼叫此函數的測試檔案</li><li>若未呼叫此方法，預設 timeout interval 為 5 秒</li><li>注意：若要為所有測試檔案設定 timeout，可在 <code>setupFilesAfterEnv</code> 中設定</li></ul></li><li><code>jest.retryTimes(numTestRetries)</code>：<ul><li>n 次執行失敗的測試，直到它們通過或直到最大重試次數用完為止</li><li>只適用於 <a href="https://github.com/facebook/jest/tree/master/packages/jest-circus" target="_blank" rel="noopener"><code>jest-circus</code></a></li><li>回傳用於 chaining 的 <code>jest</code> 物件</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">jest.retryTimes(<span class="hljs-number">3</span>);<br>test(<span class="hljs-string">'will fail'</span>, () =&gt; &#123;<br>  expect(<span class="hljs-literal">true</span>).toBe(<span class="hljs-literal">false</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/timer-mocks" target="_blank" rel="noopener">Timer Mocks · Jest</a></li><li><a href="https://jestjs.io/blog/2016/09/01/jest-15.html" target="_blank" rel="noopener">Jest 15.0: New Defaults for Jest · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;常用的 native timer 包括 &lt;code&gt;setTimeout&lt;/code&gt;、&lt;code&gt;setInterval&lt;/code&gt;、&lt;code&gt;clearTimeout&lt;/code&gt;、&lt;code&gt;clearInterval&lt;/code&gt; 等，用到這些 timer 的函數可以說是依賴於真實流逝的時間。如果 timer 要跑幾秒後才會觸發，或是要確認某函數是否在固定週期內被呼叫幾次，你不可能真的去等待 timer 跑完才能驗證結果吧，那根本是浪費時間。所以應該要使用 mock 函數來 mock 掉那些 timer 函數，透過 Jest 提供的功能來控制時間，其中就有時間快轉的功能，減少測試要等待的時間。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="mock" scheme="https://titangene.github.io/tags/mock/"/>
    
      <category term="timer" scheme="https://titangene.github.io/tags/timer/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Snapshot 測試</title>
    <link href="https://titangene.github.io/article/jest-snapshot-testing.html"/>
    <id>https://titangene.github.io/article/jest-snapshot-testing.html</id>
    <published>2020-07-12T15:58:31.000Z</published>
    <updated>2020-07-12T16:14:01.980Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>若想確保 UI 不會因意外修改而產生 bug，snapshot 測試就是一個很好用的工具。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><h1 id="使用-Jest-進行-snapshot-測試"><a class="header-anchor" href="#使用-Jest-進行-snapshot-測試"></a>使用 Jest 進行 snapshot 測試</h1><p>如果想測試一個 UI 元件，要測的是產生的元素 (可序列化的值，即 HTML 原始碼)，而不是需要花時間渲染出來的畫面 (圖形 UI)。</p><p>下面以連結元件為例，呼叫 <code>rendererLinkElement()</code>，並傳入 URL 和連結名稱就可以取得 renderer 回傳的 HTML：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/linkElement.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rendererLinkElement</span>(<span class="hljs-params">url, linkName</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;a href="<span class="hljs-subst">$&#123;url&#125;</span>"&gt;<span class="hljs-subst">$&#123;linkName&#125;</span>&lt;/a&gt;`</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rendererLinkElement;<br></code></pre></td></tr></table></figure><p>這邊使用 Jest 提供的 <code>toMatchSnapshot()</code> 進行測試：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/externalSnapshots.test.js</span><br>describe(<span class="hljs-string">'external snapshots'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'render the link element of the Titangene Blog home page'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://titangene.github.io/'</span>;<br>    <span class="hljs-keyword">const</span> linkName = <span class="hljs-string">'Titangene Blog'</span>;<br><br>    <span class="hljs-keyword">const</span> actual = rendererLinkElement(url, linkName);<br><br>    expect(actual).toMatchSnapshot();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>執行測試：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/externalSnapshots.test.js</span><br> PASS  __tests__/externalSnapshots.test.js<br>  external snapshots<br>    ✓ render the link element of the Titangene Blog home page (3ms)<br><br> › 1 snapshot written.<br>Snapshot Summary<br> › 1 snapshot written from 1 test suite.<br><br>Test Suites: 1 passed, 1 total<br>Tests:       1 passed, 1 total<br>Snapshots:   1 written, 1 total<br>Time:        0.657s, estimated 1s<br>Ran all test suites matching /.\/__tests__\/externalSnapshots.test.js/i.<br></code></pre></td></tr></table></figure><p>第一次執行此測試時，Jest 會在 <code>__tests__</code> 目錄內建立 <code>__snapshots__</code> 目錄，裡面建立一個 snapshot 檔案，檔名會是測試檔的名稱再加上 <code>.snap</code> (例如：<code>externalSnapshots.test.js.snap</code> )，內容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Jest Snapshot v1, https://goo.gl/fbAQLP</span><br><br>exports[<span class="hljs-string">`renders correctly 1`</span>] = <span class="hljs-string">`"&lt;a href=\\"https://titangene.github.io/\\"&gt;Titangene Blog&lt;/a&gt;"`</span>;<br></code></pre></td></tr></table></figure><p>之後再次執行測試就會將 render 的輸出與之前的 snapshot 進行比較：</p><ul><li>若 match，測試就會通過</li><li>若不 match，測試就會失敗<ul><li>可能是程式有 bug，或是實作發生變化，需要更新 snapshot</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/linkElement.test.js</span><br> PASS  __tests__/linkElement.test.js<br>  ✓ renders correctly (4ms)<br><br>Test Suites: 1 passed, 1 total<br>Tests:       1 passed, 1 total<br>Snapshots:   1 passed, 1 total<br>Time:        0.777s, estimated 2s<br>Ran all test suites matching /.\/__tests__\/linkElement.test.js/i.<br></code></pre></td></tr></table></figure><div class="info"><p>snapshot 應與修改的程式碼一起 commit，並在 code review 中進行 review。</p><p>註：Jest 內建提供 <a href="https://github.com/facebook/jest/tree/master/packages/pretty-format" target="_blank" rel="noopener"><code>pretty-format</code></a> 套件，可讓任何 JavaScript 值變成 human-readable 的字串 (序列化 JavaScript 內建型別值)，而 snapshot 就使用了此套件，所以 snapshot 才能在 code review 過程具有可讀性。</p></div><h1 id="更新-snapshot"><a class="header-anchor" href="#更新-snapshot"></a>更新 snapshot</h1><p>剛剛提到，若程式的實作發生變化，snapshot 與程式執行結果可能會不 match，測試就會失敗。</p><p>假設不是因為 bug，是你現在修改的執行結果的確是你要的，但 snapshot 還是之前的預期結果，而你想將 snapshot 換成新的預期結果，這就需要更新 snapshot。</p><p>下面就舉個情境，假設我想將測試修改成這樣：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs diff">it('renders correctly', () =&gt; &#123;<br><span class="hljs-deletion">-  const url = 'https://titangene.github.io/';</span><br><span class="hljs-deletion">-  const linkName = 'Titangene Blog';</span><br><span class="hljs-addition">+  const url = 'https://www.google.com/';</span><br><span class="hljs-addition">+  const linkName = 'Google';</span><br><br>  const actual = rendererLinkElement(url, linkName);<br><br>  expect(actual).toMatchSnapshot();<br>&#125;);<br></code></pre></td></tr></table></figure><p>再次執行測試就會失敗，因為之前 snapshot 儲存的跟現在修改的不 match：</p><p><img src="../images/jest-snapshot-testing/2020-07-13-00-05-47.png" alt=""></p><p>使用 <code>--updateSnapshot</code> (或 <code>-u</code> ) option 就能為失敗的測試重新建立新的 snapshot (通過的測試不會重新建立)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> jest --updateSnapshot</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/linkElement.test.js -u</span><br> PASS  __tests__/linkElement.test.js<br>  ✓ renders correctly (4ms)<br><br> › 1 snapshot updated.<br>Snapshot Summary<br> › 1 snapshot updated from 1 test suite.<br><br>Test Suites: 1 passed, 1 total<br>Tests:       1 passed, 1 total<br>Snapshots:   1 updated, 1 total<br>Time:        0.794s, estimated 1s<br>Ran all test suites matching /.\/__tests__\/linkElement.test.js/i.<br></code></pre></td></tr></table></figure><p>若要指定哪個測試需要重新產生 snapshot，可加上 <code>--testNamePattern=&lt;regex&gt;</code> option：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ jest -u --testNamePattern=<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">regex</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="互動式-snapshot-模式"><a class="header-anchor" href="#互動式-snapshot-模式"></a>互動式 snapshot 模式</h1><p>在 watch 模式下，按 <code>i</code> 鍵進入互動式 snapshot 模式 (只有在有 failed snapshot 時，才會看到 <code>i</code> 這個選項)：</p><p><img src="../images/jest-snapshot-testing/2020-07-13-00-13-55.png" alt=""></p><p>此互動式 snapshot 模式是用 failed snapshot 和 failed output，此模式會各別看每個 snapshot，有以下功能：</p><ul><li><code>u</code> (update)：更新失敗的 snapshot</li><li><code>s</code> (skip)：跳過當前測試 (跳至下一個測試)</li><li><code>q</code> (quit)：離開互動式 snapshot 模式</li><li><code>Enter</code>：觸發測試執行 (重跑單前測試)</li></ul><p>只要還有一個 failed snapshot 未更新，就能按 <code>r</code> 鍵重新回到互動式 snapshot 模式：</p><p><img src="../images/jest-snapshot-testing/2020-07-13-00-05-59.png" alt=""></p><p>更新所有 failed snapshot 後，就可按 <code>Enter</code> 回到 watch 模式：</p><p><img src="../images/jest-snapshot-testing/2020-07-13-00-06-03.png" alt=""></p><blockquote><p>可是奇怪的是，原本我執行 Jest 時有指定某個目錄內的測試，當我從互動式 snapshot 模式回到 watch 模式時，竟然之前的指令就失效，所以還會多測其他目錄內的測試 (目前猜測是未被 Git 追蹤的測試檔都會被執行)。</p></blockquote><h1 id="Inline-Snapshots"><a class="header-anchor" href="#Inline-Snapshots"></a>Inline Snapshots</h1><p>inline snapshot 和 external snapshot ( <code>.snap</code> 檔案) 的行為相同，但 inline snapshot 會把 snapshot value 自動寫回原始碼中。不用切換至外部檔案來確保寫入正確的值。</p><div class="warning"><p>inline snapshot 是由 <a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a> 提供支援，所以必須安裝 Prettier 才能用 inline snapshot。寫測試檔時，請遵守你的 Prettier 配置。</p><p>若你在 Jest 找不到的地方安裝 Prettier，則可用 <a href="https://jestjs.io/docs/en/configuration#prettierpath-string" target="_blank" rel="noopener"><code>prettierPath</code></a> 配置屬性來告訴 Jest。</p><p>如果未安裝 Prettier 就使用 <code>toMatchInlineSnapshot()</code>，會輸出以下錯誤訊息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">FAIL  __tests__/inlineSnapshots.test.js<br> ● Test suite failed to run<br><br>   Cannot find module 'prettier' from 'setup_jest_globals.js'<br><br>     at Resolver.resolveModule (node_modules/jest-resolve/build/index.js:296:11)<br></code></pre></td></tr></table></figure></div><p>安裝 Prettier：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add prettier --dev --exact</span><br></code></pre></td></tr></table></figure><p>一開始寫測試時，不帶 argument 呼叫 <code>toMatchInlineSnapshot()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/inlineSnapshots.test.js</span><br><span class="hljs-keyword">import</span> rendererLinkElement <span class="hljs-keyword">from</span> <span class="hljs-string">"../src/linkElement"</span>;<br><br>describe(<span class="hljs-string">"inline snapshots"</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">"render the link element of the Titangene Blog home page"</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">"https://titangene.github.io/"</span>;<br>    <span class="hljs-keyword">const</span> linkName = <span class="hljs-string">"Titangene Blog"</span>;<br><br>    <span class="hljs-keyword">const</span> actual = rendererLinkElement(url, linkName);<br><br>    expect(actual).toMatchInlineSnapshot();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>執行測試時，Jest 會對 <code>tree</code> 進行評估，且 snapshot 會寫入 <code>toMatchInlineSnapshot()</code> 的 argument：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest .__tests__/inlineSnapshots.test.js</span><br> PASS  __tests__/inlineSnapshots.test.js<br>  inline snapshots<br>    ✓ render the link element of the Titangene Blog home page (12ms)<br><br> › 1 snapshot written.<br>Snapshot Summary<br> › 1 snapshot written from 1 test suite.<br><br>Test Suites: 1 passed, 1 total<br>Tests:       1 passed, 1 total<br>Snapshots:   1 written, 1 total<br>Time:        0.909s, estimated 1s<br>Ran all test suites matching /.\/__tests__\/inlineSnapshots.test.js/i.<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe(<span class="hljs-string">"inline snapshots"</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">"render the link element of the Titangene Blog home page"</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">"https://titangene.github.io/"</span>;<br>    <span class="hljs-keyword">const</span> linkName = <span class="hljs-string">"Titangene Blog"</span>;<br><br>    <span class="hljs-keyword">const</span> actual = rendererLinkElement(url, linkName);<br><br>    expect(actual).toMatchInlineSnapshot(<br>      <span class="hljs-string">`"&lt;a href=\\"https://titangene.github.io/\\"&gt;Titangene Blog&lt;/a&gt;"`</span><br>    );<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>也可在指令使用 <code>--updateSnapshot</code> (或 <code>-u</code> ) option 或在 <code>--watch</code> 模式下按 <code>u</code> 鍵來更新 snapshot。</p><h1 id="Property-Matchers"><a class="header-anchor" href="#Property-Matchers"></a>Property Matchers</h1><p>有時 snapshot 的物件中會有生成一些 field (例如：ID 和 Date)，若對這些物件進行 snapshot，就會在執行時常常發生 snapshot 失敗。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/propertyMatchers.test.js</span><br>describe(<span class="hljs-string">'Property Matchers'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'will fail every time'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> user = &#123;<br>      name: <span class="hljs-string">'Titan'</span>,<br>      createdAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>      id: <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">20</span>)<br>    &#125;;<br><br>    <span class="hljs-built_in">console</span>.log(user);<br><br>    expect(user).toMatchSnapshot();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>像上面的測試執行第二次時，snapshot 就會失敗：</p><p><img src="../images/jest-snapshot-testing/2020-07-13-00-06-17.png" alt=""></p><p>所以 Jest 允許你對任何 property 提供 asymmetric matcher。Jest 會在寫入 snapshot 或測試 snapshot 之前，檢查 matcher，然後將 snapshot 儲存至 snapshot 檔案中，而不是 received value：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/propertyMatchers.test.js</span><br>describe(<span class="hljs-string">'Property Matchers'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'will check the matchers and pass'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> user = &#123;<br>      name: <span class="hljs-string">'Titan'</span>,<br>      createdAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>      id: <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">20</span>)<br>    &#125;;<br><br>    <span class="hljs-built_in">console</span>.log(user);<br><br>    expect(user).toMatchSnapshot(&#123;<br>      createdAt: expect.any(<span class="hljs-built_in">Date</span>),<br>      id: expect.any(<span class="hljs-built_in">Number</span>),<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><div class="info"><p>asymmetric matcher：在 <a href="https://jasmine.github.io/tutorials/custom_argument_matchers" target="_blank" rel="noopener">Jasmine</a> 也稱為 argument matcher，可用於建立自己的自訂 matcher 來封裝測試邏輯。</p></div><p>下面是 snapshot 儲存的內容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/__snapshots__/propertyMatchers.test.js.snap</span><br>exports[<span class="hljs-string">`Property Matchers will check the matchers and pass 1`</span>] = <span class="hljs-string">`</span><br><span class="hljs-string">Object &#123;</span><br><span class="hljs-string">  "createdAt": Any&lt;Date&gt;,</span><br><span class="hljs-string">  "id": Any&lt;Number&gt;,</span><br><span class="hljs-string">  "name": "Titan",</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure><p>任何非 matcher 的 givin value，會被被明確地檢查並儲存至 snapshot，例如下面測試中的 <code>name</code> property：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/propertyMatchers.test.js</span><br>describe(<span class="hljs-string">'Property Matchers'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'will check the values and pass'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> user = &#123;<br>      name: <span class="hljs-string">'Titan'</span>,<br>      createdAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>      id: <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">20</span>)<br>    &#125;;<br><br>    <span class="hljs-built_in">console</span>.log(user);<br><br>    expect(user).toMatchSnapshot(&#123;<br>      name: <span class="hljs-string">'Titan'</span>,<br>      createdAt: expect.any(<span class="hljs-built_in">Date</span>),<br>      id: expect.any(<span class="hljs-built_in">Number</span>),<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>下面是 snapshot 儲存的內容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/__snapshots__/propertyMatchers.test.js.snap</span><br>exports[<span class="hljs-string">`Property Matchers will check the values and pass 1`</span>] = <span class="hljs-string">`</span><br><span class="hljs-string">Object &#123;</span><br><span class="hljs-string">  "createdAt": Any&lt;Date&gt;,</span><br><span class="hljs-string">  "id": Any&lt;Number&gt;,</span><br><span class="hljs-string">  "name": "Titan",</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/snapshot-testing" target="_blank" rel="noopener">Snapshot Testing · Jest</a></li><li><a href="https://jestjs.io/blog/2016/07/27/jest-14.html" target="_blank" rel="noopener">Jest 14.0: React Tree Snapshot Testing · Jest</a></li><li><a href="https://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/" target="_blank" rel="noopener">Testing with Jest Snapshots: First Impressions | benmccormick.org</a></li><li><a href="https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074" target="_blank" rel="noopener">Use Jest’s Snapshot Testing Feature from @kentcdodds on @eggheadio</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;若想確保 UI 不會因意外修改而產生 bug，snapshot 測試就是一個很好用的工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="snapshot" scheme="https://titangene.github.io/tags/snapshot/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Mock 函數</title>
    <link href="https://titangene.github.io/article/jest-mock-function.html"/>
    <id>https://titangene.github.io/article/jest-mock-function.html</id>
    <published>2020-07-05T15:59:41.000Z</published>
    <updated>2020-07-05T15:59:08.196Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>Jest 提供的 mock 函數可讓你自行決定要 mock 到什麼程度，並且可讓你在呼叫該 mock 函數之後，捕捉呼叫的次數、傳入的參數、使用 <code>new</code> 實例化的 instance，以及你指定要回傳的值，我們可透過這些資訊來測試 mock 函數是否如預期的呼叫。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><p>有兩種方法來 mock 函數：</p><ul><li>在測試程式碼中使用 mock 函數</li><li>使用<a href="https://jestjs.io/docs/en/manual-mocks" target="_blank" rel="noopener">手動 mock</a> 來覆蓋依賴模組</li></ul><h1 id="使用-mock-函數"><a class="header-anchor" href="#使用-mock-函數"></a>使用 mock 函數</h1><p><code>jest.fn(implementation)</code>：新回傳一個未使用的 mock 函數 ( <code>implementation</code> 為可選的 mock 實作)</p><p>若要測試下面 <code>forEach()</code>，可用 mock 函數，並檢查 mock 的狀態，以確保按預期 invoke callback：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/forEach.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span>(<span class="hljs-params">items, callback</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> items) &#123;<br>    callback(item);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/forEach.test.js</span><br><span class="hljs-keyword">import</span> forEach <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/forEach'</span>;<br><br>test(<span class="hljs-string">'forEach'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> mockCallback = jest.fn(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-number">42</span> + x);<br>  forEach([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], mockCallback);<br><br>  <span class="hljs-built_in">console</span>.log(mockCallback.mock.calls);  <span class="hljs-comment">// [[0], [1]]</span><br><br>  expect(mockCallback.mock.calls.length).toBe(<span class="hljs-number">2</span>);<br><br>  expect(mockCallback.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-number">0</span>);<br>  expect(mockCallback.mock.calls[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-number">1</span>);<br><br>  expect(mockCallback.mock.results[<span class="hljs-number">0</span>].value).toBe(<span class="hljs-number">42</span>);<br>  expect(mockCallback.mock.results[<span class="hljs-number">1</span>].value).toBe(<span class="hljs-number">43</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="mock-property"><a class="header-anchor" href="#mock-property"></a><code>.mock</code> property</h1><p>所有 mock 函數都有 <code>.mock</code> property，用來儲存如何呼叫函數和回傳函數的資料，此 property 也會追蹤每個呼叫的 <code>this</code> 值：</p><p><code>mockFn.mock.calls</code>：</p><ul><li>回傳一個陣列</li><li>包含對此 mock 函數所有呼叫的呼叫 argument，此陣列中的每個項目都是在呼叫過程中傳遞的 argument 陣列</li><li>例如：有一個 mock 函數被呼叫兩次，第一次被呼叫的 argument 為 <code>f('arg1', 'arg2')</code>，第二次為 <code>f('arg3', 'arg4')</code>，那此 <code>f.mock.calls</code> 會回傳 <code>[['arg1', 'arg2'], ['arg3', 'arg4']]</code></li></ul><p><code>mockFn.mock.results</code>：</p><ul><li>回傳一個陣列</li><li>包含對此 mock 函數所有呼叫的結果，此陣列中的每個項目都是一個包含 <code>type</code> 和 <code>value</code> property 的物件<ul><li><code>type</code> 為以下任一種：<ul><li><code>return</code>：透過正常回傳已完成的呼叫</li><li><code>throw</code>：透過拋出一個值來完成呼叫</li><li><code>incomplete</code>：呼叫尚未完成。若從 mock 函數本身內部或從 mock 呼叫的函數內部測試結果，則會發生這種狀況</li></ul></li><li><code>value</code>：<ul><li>包含拋出的值或回傳值</li><li>當 <code>type === 'incomplete'</code> 時，值為定義</li></ul></li></ul></li></ul><p><code>mockFn.mock.instances</code>：</p><ul><li>回傳一個陣列</li><li>包含使用 <code>new</code> 從此 mock 函數實例化的所有物件 instance</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/mockProperty.test.js</span><br>it(<span class="hljs-string">'mock property'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> fooMockFunction = jest<br>    .fn(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>      <span class="hljs-keyword">let</span> tmp = <span class="hljs-keyword">this</span>.x || <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">return</span> tmp + x + y;<br>    &#125;);<br><br>  <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> fooMockFunction(<span class="hljs-string">'first arg'</span>, <span class="hljs-string">'second arg'</span>);<br>  <span class="hljs-built_in">console</span>.log(a);    <span class="hljs-comment">// mockConstructor &#123;&#125;</span><br>  <span class="hljs-built_in">console</span>.log(a.x);  <span class="hljs-comment">// undefined</span><br><br>  <span class="hljs-keyword">const</span> b = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>&#125;;<br>  <span class="hljs-keyword">const</span> bound = fooMockFunction.bind(b, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>  <span class="hljs-built_in">console</span>.log(bound());  <span class="hljs-comment">// 17</span><br><br>  <span class="hljs-built_in">console</span>.log(fooMockFunction.mock);<br>  <span class="hljs-comment">// &#123;</span><br>  <span class="hljs-comment">//   calls: [ [ 1, 2 ], [ 3, 4 ] ],</span><br>  <span class="hljs-comment">//   instances: [ mockConstructor &#123;&#125;, &#123; x: 10 &#125; ],</span><br>  <span class="hljs-comment">//   invocationCallOrder: [ 1, 2 ],</span><br>  <span class="hljs-comment">//   results: [</span><br>  <span class="hljs-comment">//     &#123; type: 'return', value: 3; &#125;,</span><br>  <span class="hljs-comment">//     &#123; type: 'return', value: 17 &#125;</span><br>  <span class="hljs-comment">//   ]</span><br>  <span class="hljs-comment">// &#125;</span><br><br>  <span class="hljs-built_in">console</span>.log(fooMockFunction.mock.instances[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// mockConstructor &#123;&#125;</span><br>  <span class="hljs-built_in">console</span>.log(fooMockFunction.mock.instances[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// &#123; x: 10 &#125;</span><br><br>  <span class="hljs-comment">// 呼叫幾次</span><br>  expect(fooMockFunction.mock.calls.length).toBe(<span class="hljs-number">2</span>);<br><br>  <span class="hljs-comment">// 第幾次呼叫的第幾個 arg</span><br>  expect(fooMockFunction.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-string">'first arg'</span>);<br>  expect(fooMockFunction.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]).toBe(<span class="hljs-string">'second arg'</span>);<br>  expect(fooMockFunction.mock.calls[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-number">3</span>);<br>  expect(fooMockFunction.mock.calls[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]).toBe(<span class="hljs-number">4</span>);<br><br>  <span class="hljs-comment">// 第幾次呼叫的回傳值</span><br>  expect(fooMockFunction.mock.results[<span class="hljs-number">1</span>].value).toBe(<span class="hljs-number">17</span>);<br><br>  <span class="hljs-comment">// 此 mock 函數被實例化的次數</span><br>  expect(fooMockFunction.mock.instances.length).toBe(<span class="hljs-number">2</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="mock-回傳值"><a class="header-anchor" href="#mock-回傳值"></a>mock 回傳值</h1><p>使用 mock 函數在測試期間將測試值注入至程式碼中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/mockReturnValues.test.js</span><br>test(<span class="hljs-string">'mock return values'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> myMock = jest.fn();<br>  <span class="hljs-built_in">console</span>.log(myMock());  <span class="hljs-comment">// undefined</span><br><br>  myMock<br>    .mockReturnValueOnce(<span class="hljs-number">10</span>)<br>    .mockReturnValueOnce(<span class="hljs-string">'x'</span>)<br>    .mockReturnValue(<span class="hljs-literal">true</span>);<br><br>  expect(myMock()).toBe(<span class="hljs-number">10</span>);<br>  expect(myMock()).toBe(<span class="hljs-string">'x'</span>);<br>  expect(myMock()).toBe(<span class="hljs-literal">true</span>);<br>  expect(myMock()).toBe(<span class="hljs-literal">true</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>這種寫法可避免需要複雜的 stub 來重新建立實際元件的行為，利於在使用前將值直接注入到測試中。</p><div class="info"><p>Test stub：回傳固定值的實作</p><p>資料來源：<a href="http://teddy-chen-tw.blogspot.com/2014/09/test-double2.html" target="_blank" rel="noopener">搞笑談軟工: Test Double（2）：五種替身簡介</a></p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'mock return values'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> myMock = jest.fn();<br>  <span class="hljs-built_in">console</span>.log(myMock());  <span class="hljs-comment">// undefined</span><br><br>  myMock<br>    .mockReturnValueOnce(<span class="hljs-number">10</span>)<br>    .mockReturnValueOnce(<span class="hljs-string">'x'</span>)<br>    .mockReturnValue(<span class="hljs-literal">true</span>);<br><br>  expect(myMock()).toBe(<span class="hljs-number">10</span>);<br>  expect(myMock()).toBe(<span class="hljs-string">'x'</span>);<br>  expect(myMock()).toBe(<span class="hljs-literal">true</span>);<br>  expect(myMock()).toBe(<span class="hljs-literal">true</span>);<br>&#125;);<br><br>test(<span class="hljs-string">'filter mock function return values'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> filterTestFn = jest.fn();<br><br>  filterTestFn<br>    .mockReturnValueOnce(<span class="hljs-literal">true</span>)<br>    .mockReturnValueOnce(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">const</span> result = [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>].filter(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> filterTestFn(num));<br>  expect(result).toMatchObject([<span class="hljs-number">11</span>]);<br>  expect(filterTestFn.mock.calls[<span class="hljs-number">0</span>]).toMatchObject([<span class="hljs-number">11</span>]);<br>  expect(filterTestFn.mock.calls[<span class="hljs-number">1</span>]).toMatchObject([<span class="hljs-number">12</span>]);<br>&#125;);<br></code></pre></td></tr></table></figure><p>儘量避免在沒有直接測試的函數內部實作邏輯。</p><h1 id="mocking-模組"><a class="header-anchor" href="#mocking-模組"></a>mocking 模組</h1><p>假設有一個從 API fetch 使用者的 class，該 class 使用 <a href="https://github.com/axios/axios" target="_blank" rel="noopener"><code>axios</code></a> 呼叫 API，然後回傳包含所有使用者的 <code>data</code> 屬性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/users.js</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Users</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> all() &#123;<br>    <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<br>      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.data);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Users;<br></code></pre></td></tr></table></figure><p>若要在不實際打 API 的情況下測試該方法，可用 <code>jest.mock()</code> 自動 mock <code>axios</code> 模組。</p><p>接著使用 <code>mockResolvedValue()</code> 來 mock <code>axios.get</code>。只要測試呼叫了 <code>axios.get()</code>，就會回傳 fake response，以便於我們來 assert 資料：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/mockingModule.test.js</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;<br><span class="hljs-keyword">import</span> Users <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/users'</span>;<br><br>jest.mock(<span class="hljs-string">'axios'</span>);<br><br>test(<span class="hljs-string">'should fetch users'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> expected = [&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'Titan'</span>&#125;];<br>  <span class="hljs-keyword">const</span> response = &#123;<span class="hljs-attr">data</span>: expected&#125;;<br><br>  axios.get.mockResolvedValue(response);<br>  <span class="hljs-comment">// 上一行等同於：</span><br>  <span class="hljs-comment">// axios.get.mockImplementation(() =&gt; Promise.resolve(resp))</span><br><br>  <span class="hljs-keyword">return</span> Users.all()<br>    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> expect(data).toEqual(expected));<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Mock-Implementations"><a class="header-anchor" href="#Mock-Implementations"></a>Mock Implementations</h1><p>指定回傳值，以及完全替換 mock 函數的實作，可透過 <code>jest.fn</code> 或 <code>mock</code> 函數上的 <code>mockImplementationOnce()</code> 來完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/mockImplementation.test.js</span><br>describe(<span class="hljs-string">'使用 `jest.fn()` 建立 mock 函數'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'mock 函數'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> myMockFn = jest.fn(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> callback(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>));<br>    myMockFn(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(val));<br><br>    expect(myMockFn).toBeCalledTimes(<span class="hljs-number">1</span>);<br>    expect(myMockFn).lastCalledWith(expect.any(<span class="hljs-built_in">Function</span>));<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>可用 <code>mockImplementationOnce()</code> 來定義 mock 函數的預設實作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/mockImplementation.test.js</span><br><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/foo'</span>;<br><br>jest.mock(<span class="hljs-string">'../src/foo'</span>);<br><br>describe(<span class="hljs-string">'mock module'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'mock foo module'</span>, () =&gt; &#123;<br>    foo.mockImplementation(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">42</span>);<br>    foo();<br><br>    expect(foo).toBeCalledTimes(<span class="hljs-number">1</span>);<br>    expect(foo).toReturnWith(<span class="hljs-number">42</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>若要讓 mock 函數多次呼叫會產生不同的結果，也可用 <code>mockImplementationOnce()</code> 來定義。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/mockImplementation.test.js</span><br>describe(<span class="hljs-string">'mock 函數呼叫多次時，會產生不同的結果'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'第一次呼叫回傳 `true`，第二次回傳 `false`，之後都不回傳'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> myMockFn = jest.fn()<br>      .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> callback(<span class="hljs-literal">true</span>))<br>      .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> callback(<span class="hljs-literal">false</span>));<br><br>    myMockFn(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value);<br>    myMockFn(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value);<br>    myMockFn(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value);<br>    myMockFn(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value);<br><br>    expect(myMockFn).toBeCalledTimes(<span class="hljs-number">4</span>);<br>    expect(myMockFn).nthReturnedWith(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    expect(myMockFn).nthReturnedWith(<span class="hljs-number">2</span>, <span class="hljs-literal">false</span>);<br>    expect(myMockFn).nthReturnedWith(<span class="hljs-number">3</span>);<br>    expect(myMockFn).nthReturnedWith(<span class="hljs-number">4</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>當 mock 函數執行完 <code>mockImplementationOnce()</code> 定義的實作時，會執行 <code>jest.fn</code> (若已定義) 的預設實作集合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/mockImplementation.test.js</span><br>describe(<span class="hljs-string">'mock 函數呼叫多次時，會產生不同的結果'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'第一次呼叫回傳 `first call`，第二次回傳 `second call`，之後都回傳 `default`'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> myMockFn = jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'default'</span>)<br>      .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'first call'</span>)<br>      .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'second call'</span>);<br><br>    myMockFn();<br>    myMockFn();<br>    myMockFn();<br>    myMockFn();<br><br>    expect(myMockFn).toBeCalledTimes(<span class="hljs-number">4</span>);<br>    expect(myMockFn).nthReturnedWith(<span class="hljs-number">1</span>, <span class="hljs-string">'first call'</span>);<br>    expect(myMockFn).nthReturnedWith(<span class="hljs-number">2</span>, <span class="hljs-string">'second call'</span>);<br>    expect(myMockFn).nthReturnedWith(<span class="hljs-number">3</span>, <span class="hljs-string">'default'</span>);<br>    expect(myMockFn).nthReturnedWith(<span class="hljs-number">4</span>, <span class="hljs-string">'default'</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>若要回傳 <code>this</code>，可用 sugary API <code>.mockReturnThis()</code> 來簡化方法。</p><p>下面是相同的兩種寫法：</p><ul><li>使用 <code>.mockReturnThis()</code></li><li>使用 <code>jest.fn()</code> 自己實作 mock 函數要回傳 <code>this</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/mockImplementation.test.js</span><br>describe.only(<span class="hljs-string">'mock 函數回傳 `this`'</span>, () =&gt; &#123;<br>  it(<span class="hljs-string">'使用 `mockReturnThis()`'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> myObj = &#123;<br>      myMethod: jest.fn().mockReturnThis()<br>    &#125;;<br><br>    myObj.myMethod();<br><br>    expect(myObj.myMethod).toBeCalledTimes(<span class="hljs-number">1</span>);<br>    expect(myObj.myMethod).toReturnWith(myObj);<br>  &#125;);<br><br>  it(<span class="hljs-string">'使用 `jest.fn()` 實作'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> myObj = &#123;<br>      myMethod: jest.fn(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>      &#125;)<br>    &#125;;<br><br>    myObj.myMethod();<br><br>    expect(myObj.myMethod).toBeCalledTimes(<span class="hljs-number">1</span>);<br>    expect(myObj.myMethod).toReturnWith(myObj);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="mock-名稱"><a class="header-anchor" href="#mock-名稱"></a>mock 名稱</h1><p>可為 mock 函數命名，可在測試錯誤的輸出中顯示名稱，而不是 <code>jest.fn()</code>。若想快速識別 mock 函數，並在測試輸出中 report 錯誤，可用此方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe(<span class="hljs-string">'mock 名稱'</span>, () =&gt; &#123;<br>  it.only(<span class="hljs-string">'設定 mock 名稱'</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> myMockFn = jest.fn()<br>      .mockImplementation(<span class="hljs-function"><span class="hljs-params">scalar</span> =&gt;</span> <span class="hljs-number">42</span> + scalar)<br>      .mockName(<span class="hljs-string">'add42'</span>);<br><br>    myMockFn(<span class="hljs-number">10</span>);<br>    myMockFn(<span class="hljs-number">10</span>);<br>    myMockFn(<span class="hljs-number">10</span>);<br><br>    expect(myMockFn).toBeCalledTimes(<span class="hljs-number">3</span>);<br>    expect(myMockFn).toReturnWith(<span class="hljs-number">52</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>若沒設定 mock 函數名稱，測試錯誤時會像這樣：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">FAIL week-05/__tests__/mockName.test.js<br><br>  ● mock 名稱 › 設定 mock 名稱<br><br>    expect(jest.fn()).toReturnWith(expected)<br>    ...<br></code></pre></td></tr></table></figure><p>若有設定名稱就會像這樣：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">FAIL week-05/__tests__/mockName.test.js<br><br>  ● mock 名稱 › 設定 mock 名稱<br><br>    expect(add42).toReturnWith(expected)<br>    ...<br></code></pre></td></tr></table></figure><h1 id="自訂-matcher"><a class="header-anchor" href="#自訂-matcher"></a>自訂 matcher</h1><p>下面是 mock 函數會用到的 matcher，這些都是語法糖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// mock 函數被呼叫的次數</span><br>expect(mockFunc).toBeCalledTimes(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// mock 函數至少被呼叫一次</span><br>expect(mockFunc).toBeCalled();<br>expect(mockFunc).toHaveBeenCalled();<br><br><span class="hljs-comment">// 至少一次呼叫 mock 函數所指定的 args</span><br>expect(mockFunc).toBeCalledWith(arg1, arg2);<br>expect(mockFunc).toHaveBeenCalledWith(arg1, arg2);<br><br><span class="hljs-comment">// 最後一次呼叫 mock 函數所指定的 args</span><br>expect(mockFunc).lastCalledWith(arg1, arg2);<br>expect(mockFunc).toHaveBeenLastCalledWith(arg1, arg2);<br><br><span class="hljs-comment">// 所有呼叫和 mock 的名稱都寫成 snapshot</span><br>expect(mockFunc).toMatchSnapshot();<br></code></pre></td></tr></table></figure><p>這些 matcher 是檢查 <code>.mock</code> property 的常見形式的 sugar。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// mock 函數被呼叫的次數</span><br>expect(mockFunc.mock.calls.length).toBe(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// mock 函數至少被呼叫一次</span><br>expect(mockFunc.mock.calls.length).toBeGreaterThan(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 至少一次呼叫 mock 函數所指定的 args</span><br>expect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);<br><br><span class="hljs-comment">// 最後一次呼叫 mock 函數所指定的 args</span><br>expect(mockFunc.mock.calls[mockFunc.mock.calls.length - <span class="hljs-number">1</span>]).toEqual([<br>  arg1,<br>  arg2,<br>]);<br><br><span class="hljs-comment">// 最後一次呼叫 mock 函數的第一個 arg 是 `42` (此 assert 沒有語法糖)</span><br>expect(mockFunc.mock.calls[mockFunc.mock.calls.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// snapshot 會檢查 mock 是否以相同的順序、相同的 arg 被呼叫相同的次數</span><br>expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);<br><br><span class="hljs-comment">// assert mock 函數的名稱</span><br>expect(mockFunc.getMockName()).toBe(<span class="hljs-string">'a mock name'</span>);<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/customMatcher.test.js</span><br>it(<span class="hljs-string">'custom matcher'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> mockFunc = jest.fn(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y)<br>    .mockName(<span class="hljs-string">'mockFunc'</span>);<br><br>  mockFunc(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>  mockFunc();<br>  mockFunc(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><br>  <span class="hljs-comment">// mock 函數被呼叫的次數</span><br>  expect(mockFunc).toBeCalledTimes(<span class="hljs-number">3</span>);<br>  expect(mockFunc.mock.calls.length).toBe(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-comment">// mock 函數至少被呼叫一次</span><br>  expect(mockFunc).toBeCalled();<br>  expect(mockFunc.mock.calls.length).toBeGreaterThan(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 至少一次呼叫 mock 函數所指定的 args</span><br>  expect(mockFunc).toBeCalledWith(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>  expect(mockFunc).toBeCalledWith(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>  expect(mockFunc.mock.calls).toContainEqual([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br>  expect(mockFunc.mock.calls).toContainEqual([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><br>  <span class="hljs-comment">// 最後一次呼叫 mock 函數所指定的 args</span><br>  expect(mockFunc).lastCalledWith(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>  expect(mockFunc.mock.calls[mockFunc.mock.calls.length - <span class="hljs-number">1</span>]).toEqual([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><br>  <span class="hljs-comment">// 最後一次呼叫 mock 函數的第一個 arg 是 `3` (此 assert 沒有語法糖)</span><br>  expect(mockFunc.mock.calls[mockFunc.mock.calls.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).toBe(<span class="hljs-number">3</span>);<br><br>  <span class="hljs-comment">// snapshot 會檢查 mock 是否以相同的順序、相同的 arg 被呼叫相同的次數</span><br>  expect(mockFunc.mock.calls).toEqual([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]);<br><br>  <span class="hljs-comment">// assert mock 函數的名稱</span><br>  expect(mockFunc.getMockName()).toBe(<span class="hljs-string">'mockFunc'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/mock-functions" target="_blank" rel="noopener">Mock Functions · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;Jest 提供的 mock 函數可讓你自行決定要 mock 到什麼程度，並且可讓你在呼叫該 mock 函數之後，捕捉呼叫的次數、傳入的參數、使用 &lt;code&gt;new&lt;/code&gt; 實例化的 instance，以及你指定要回傳的值，我們可透過這些資訊來測試 mock 函數是否如預期的呼叫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="mock" scheme="https://titangene.github.io/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>Jest：非同步測試</title>
    <link href="https://titangene.github.io/article/jest-async-test.html"/>
    <id>https://titangene.github.io/article/jest-async-test.html</id>
    <published>2020-06-28T15:56:32.000Z</published>
    <updated>2020-06-28T15:59:53.353Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>處理 JS 非同步的常見作法包括 callback、ES6 的 <code>Promise</code> 以及 ES7 的 <code>async</code> 和 <code>await</code>，而本篇會分別說明如何在 Jest 使用這些 JS 特性來測試非同步程式碼。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><h2 id="Callbacks"><a class="header-anchor" href="#Callbacks"></a>Callbacks</h2><p>假設你要測下面這個函數，我使用 <code>setTimeout</code> 來模擬發 API 需要花一段時間，若 API 發送成功就會呼叫你傳入的 callback 函數，在呼叫 callback 時會傳入 <code>'hi'</code>，代表從 API 拿到的資料：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/fetchData.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- fetchData: Start ---`</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    callback(<span class="hljs-string">'hi'</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- fetchData: End ---`</span>);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> fetchData;<br></code></pre></td></tr></table></figure><p>而我們要測試的就是呼叫 <code>fetchData()</code> 所傳入的 callback 有無正確的呼叫，並且傳入 callback 的資料是否為 <code>&quot;hi&quot;</code>。也許你會這樣寫測試：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/async.test.js</span><br><span class="hljs-keyword">import</span> fetchData <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/async'</span>;<br><br>test(<span class="hljs-string">'同步執行 callback 回傳 hi'</span>, () =&gt; &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`---callback: Start---`</span>);<br>    expect(data).toBe(<span class="hljs-string">'hi'</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`---callback: End---`</span>);<br>  &#125;<br><br>  fetchData(callback);<br>&#125;);<br></code></pre></td></tr></table></figure><p>執行測試後，測試通過了，但感覺怪怪的！為什麼測試內的 <code>callback()</code> 沒有執行到？</p><p><img src="../images/jest-async-test/2020-06-28-22-55-49.png" alt=""></p><p>因為 Jest 測試只要跑到最後一行的 <code>fetchData(..)</code> 就會結束，裡面執行的非同步處理 (即模擬發 API 的 <code>setTimeout</code> ) 根本還沒處理完，Jest 測試就會在 callback 呼叫之前就結束了。</p><p>Jest 提供一種建議：使用 <code>test()</code> 時不要用 empty argument，而是用名為 <code>done</code> 的 argument。Jest 就會等到 <code>done</code> callback 被呼叫時才會結束測試。這樣就能確保測試是在你決定的地方結束 ( <code>done</code>，雙關)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/async.test.js</span><br><span class="hljs-keyword">import</span> fetchData <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/async'</span>;<br><br>test(<span class="hljs-string">'非同步執行 callback 回傳 hi'</span>, done =&gt; &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`---callback: Start---`</span>);<br>    expect(data).toBe(<span class="hljs-string">'hi'</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`---callback: End---`</span>);<br>    done();<br>  &#125;<br><br>  fetchData(callback);<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="../images/jest-async-test/2020-06-28-23-07-10.png" alt=""></p><p>若 <code>test()</code> 使用了 <code>done</code> argument，但沒有呼叫 <code>done()</code>，測試就會失敗 (帶有 timeout error)：</p><p><img src="../images/jest-async-test/2020-06-28-23-09-02.png" alt=""></p><div class="info"><p>錯誤訊息是說這個測試沒有在 timeout 內 invoke 非同步的 callback。</p><p>至於 timeout 的時間預設為 5 秒，若要自訂 <code>test()</code> 的 timeout，可自行加上第三個 arg (單位為豪秒)。像下面是自訂 timeout 為 3 秒：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'test name'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// some test code...</span><br>&#125;, <span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><blockquote><p>詳情可參閱 <a href="https://titangene.github.io/article/jest-describe-test-case.html#test-name-fn-timeout">Jest：Describe &amp; Test case</a> 的「<code>test(name, fn, timeout)</code>」段落。</p></blockquote></div><p>如果 <code>expect</code> 陳述句失敗，就會拋出錯誤，並且不會呼叫 <code>done()</code>。若想在測試輸出結果看到失敗的原因，就要用 <code>try</code> 區塊把 <code>expect</code> 包起來，並在 <code>catch</code> 區塊中接收錯誤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/async.test.js</span><br><span class="hljs-keyword">import</span> fetchData <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/async'</span>;<br><br>test(<span class="hljs-string">'非同步執行 callback 回傳 hi'</span>, done =&gt; &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`---callback: Start---`</span>);<br>      expect(data).toBe(<span class="hljs-string">'hi~~~'</span>);<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`---callback: End---`</span>);<br>      done();<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      done(error);<br>    &#125;<br>  &#125;<br><br>  fetchData(callback);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Promise"><a class="header-anchor" href="#Promise"></a>Promise</h2><p>如果測試回傳一個 promise，Jest 會等待這個 promise 的 resolve。如果 promise 被 reject，測試會自動失敗。</p><p>一定要回傳 promise：如果省略了 <code>return</code> 陳述句，測試會在 <code>promiseFetchData</code> 回傳的 promise 被 resolve，並且 <code>then()</code> 有機會執行 callback 之前完成。</p><p>例如：下面範例的測試不會等到 promise 內的 <code>setTimeout()</code> 跑完就會立即完成測試：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/fetchData.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseFetchData</span>(<span class="hljs-params">option</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- Promise: Start ---`</span>);<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (option.flag === <span class="hljs-string">'success'</span>) resolve(<span class="hljs-string">'hi'</span>);<br>      <span class="hljs-keyword">if</span> (option.flag === <span class="hljs-string">'fail'</span>) reject(<span class="hljs-string">'error'</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- Promise: End ---`</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/async.test.js</span><br><span class="hljs-keyword">import</span> promiseFetchData <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/fetchData'</span>;<br><br>test(<span class="hljs-string">'回傳的 promise resolve 資料為 hi'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> promiseFetchData(&#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">'success'</span> &#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- then: Start ---`</span>);<br>    expect(data).toBe(<span class="hljs-string">'hi'</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- then: End ---`</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>所以如果省略了 <code>return</code> 陳述句，下面範例的 <code>'hi XD'</code> 雖然跟 <code>data</code> 真正拿到的值不同，但測試還是會通過：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/async.test.js</span><br><span class="hljs-keyword">import</span> promiseFetchData <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/fetchData'</span>;<br><br>test(<span class="hljs-string">'回傳的 promise resolve 資料為 hi'</span>, () =&gt; &#123;<br>  promiseFetchData(&#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">'success'</span> &#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- then: Start ---`</span>);<br>    expect(data).toBe(<span class="hljs-string">'hi'</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- then: End ---`</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>若想讓 promise 被 reject，可用 <code>.catch</code> 方法。記得要加上 <code>expect.assertions</code> 來驗證是否呼叫一定數量的 assertions。否則一個 fulfilled promise 不會讓錯誤失敗：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/async.test.js</span><br><span class="hljs-keyword">import</span> promiseFetchData <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/fetchData'</span>;<br><br>test(<span class="hljs-string">'promise reject 的錯誤訊息為 error'</span>, () =&gt; &#123;<br>  expect.assertions(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> promiseFetchData(&#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">'fail'</span> &#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- catch: Start ---`</span>);<br>    expect(e).toMatch(<span class="hljs-string">'error'</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- catch: End ---`</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="resolves-rejects"><a class="header-anchor" href="#resolves-rejects"></a><code>.resolves</code> / <code>.rejects</code></h2><p>也可在 <code>expect</code> 陳述句中使用 <code>.resolves</code> matcher，Jest 會等待 promise 的 resolve。如果 promise 被 reject，測試會自動失敗。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/async.test.js</span><br><span class="hljs-keyword">import</span> promiseFetchData <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/fetchData'</span>;<br><br>test(<span class="hljs-string">'使用 resolves matcher'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> expect(promiseFetchData(&#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">'success'</span> &#125;)).resolves.toBe(<span class="hljs-string">'hi'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>一定要回傳 assertion：如果省略了 <code>return</code> 陳述句，測試會在 <code>promiseFetchData</code> 回傳的 promise 被 resolve，並且 <code>then()</code> 有機會執行 callback 之前完成。</p><p>若想讓 promise 被 reject，可用 <code>.rejects</code> matcher。如果 promise 是 fulfilled，測試就會自動失敗：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/async.test.js</span><br><span class="hljs-keyword">import</span> promiseFetchData <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/fetchData'</span>;<br><br>test(<span class="hljs-string">'使用 rejects matcher'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> expect(promiseFetchData(&#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">'fail'</span> &#125;)).rejects.toMatch(<span class="hljs-string">'error'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Async-Await"><a class="header-anchor" href="#Async-Await"></a>Async/Await</h2><p>也可用 <code>async</code> 和 <code>await</code>。在傳給測試函數前加上 <code>async</code> 關鍵字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/async.test.js</span><br><span class="hljs-keyword">import</span> promiseFetchData <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/fetchData'</span>;<br><br>test(<span class="hljs-string">'使用 await resolves'</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> promiseFetchData(&#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">'success'</span> &#125;);<br>  expect(data).toBe(<span class="hljs-string">'hi'</span>);<br>&#125;);<br><br>test(<span class="hljs-string">'使用 await rejects'</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  expect.assertions(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> promiseFetchData(&#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">'fail'</span> &#125;);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    expect(e).toMatch(<span class="hljs-string">'error'</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>也可將 <code>async</code> 和 <code>await</code> 與 <code>.resolves</code> 和 <code>.rejects</code> matcher 結合使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/async.test.js</span><br><span class="hljs-keyword">import</span> promiseFetchData <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/fetchData'</span>;<br><br>test(<span class="hljs-string">'使用 await 和 resolves matcher'</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> expect(promiseFetchData(&#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">'success'</span> &#125;)).resolves.toBe(<span class="hljs-string">'hi'</span>);<br>&#125;);<br><br>test(<span class="hljs-string">'使用 await 和 rejects matcher'</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> expect(promiseFetchData(&#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">'fail'</span> &#125;)).rejects.toMatch(<span class="hljs-string">'error'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>資料來源：<a href="https://jestjs.io/docs/en/asynchronous" target="_blank" rel="noopener">Testing Asynchronous Code · Jest</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;處理 JS 非同步的常見作法包括 callback、ES6 的 &lt;code&gt;Promise&lt;/code&gt; 以及 ES7 的 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt;，而本篇會分別說明如何在 Jest 使用這些 JS 特性來測試非同步程式碼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="async" scheme="https://titangene.github.io/tags/async/"/>
    
      <category term="promise" scheme="https://titangene.github.io/tags/promise/"/>
    
      <category term="callback" scheme="https://titangene.github.io/tags/callback/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Setup &amp; Teardown</title>
    <link href="https://titangene.github.io/article/jest-setup-teardown.html"/>
    <id>https://titangene.github.io/article/jest-setup-teardown.html</id>
    <published>2020-06-21T15:56:15.000Z</published>
    <updated>2020-06-21T15:56:07.894Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>每個測試案例都必須是獨立的，不能互相影響，而解決方法就是讓每個測試在執行前進行重設，或在每個測試結束後清除痕跡。在 Jest，提供 setup 和 teardown 的函數，能讓你自訂在執行 <code>describe</code> 區塊或 <code>test</code> 區塊的前後分別要做什麼準備和收尾。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><h1 id="測試案例互相汙染"><a class="header-anchor" href="#測試案例互相汙染"></a>測試案例互相汙染</h1><p>一開始寫測試時，可能會發生測試案例互相汙染的問題。</p><p>例如：有一個城市資料庫，提供初始化、清除、新增以及檢查是否已存在資料庫內這些功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/cityDB.js</span><br><span class="hljs-keyword">let</span> cityDB = [];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initCityDB</span>(<span class="hljs-params"></span>) </span>&#123;<br>  cityDB = [<span class="hljs-string">'Taipei'</span>, <span class="hljs-string">'Tainan'</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearCityDB</span>(<span class="hljs-params"></span>) </span>&#123;<br>  cityDB = [];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCity</span>(<span class="hljs-params">city</span>) </span>&#123;<br>  cityDB.push(city);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCity</span>(<span class="hljs-params">city</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> cityDB.includes(city);<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;<br>  initCityDB,<br>  clearCityDB,<br>  addCity,<br>  isCity<br>&#125;<br></code></pre></td></tr></table></figure><p>如果測試寫起來像這樣會發現，第一個測試操作的步驟會影響到第二個測試 (所以第二個測試不用初始化 DB 和新增城市就已經擁有該城市，看起來很奇怪吧？)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/unusedBeforeEachAndAfterEach.test.js</span><br><span class="hljs-keyword">import</span> &#123;<br>  initCityDB,<br>  isCity,<br>  addCity<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../src/cityDB'</span>;<br><br>describe(<span class="hljs-string">'未使用 beforeEach 和 afterEach'</span>, () =&gt; &#123;<br>  describe(<span class="hljs-string">'測試案例會互相汙染'</span>, () =&gt; &#123;<br>    test(<span class="hljs-string">'新增 Kaohsiung'</span>, () =&gt; &#123;<br>      initCityDB();<br>      expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>      addCity(<span class="hljs-string">'Kaohsiung'</span>);<br>      expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeTruthy();<br>    &#125;);<br><br>    test(<span class="hljs-string">'第二個測試案例未重新設定，所以有 Kaohsiung'</span>, () =&gt; &#123;<br>      expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeTruthy();<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>所以你可能會手動處理初始化和清除的工作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/unusedBeforeEachAndAfterEach.test.js</span><br><span class="hljs-keyword">import</span> &#123;<br>  initCityDB,<br>  clearCityDB,<br>  isCity,<br>  addCity<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../src/cityDB'</span>;<br><br>describe(<span class="hljs-string">'未使用 beforeEach 和 afterEach'</span>, () =&gt; &#123;<br>  describe(<span class="hljs-string">'手動在每個測試案例重複設定'</span>, () =&gt; &#123;<br>    test(<span class="hljs-string">'新增 Kaohsiung'</span>, () =&gt; &#123;<br>      initCityDB();<br>      expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>      addCity(<span class="hljs-string">'Kaohsiung'</span>);<br>      expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeTruthy();<br>      clearCityDB();<br>    &#125;);<br>    <br>    test(<span class="hljs-string">'第二個測試案例有重新設定，所以預設沒有 Kaohsiung'</span>, () =&gt; &#123;<br>      initCityDB();<br>      expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>      clearCityDB();<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>但每次都要手動處理這些問題很麻煩，所以在寫測試時常需要：</p><ul><li>在測試執行前進行一些設定工作</li><li>在測試執行後進行一些收尾工作</li></ul><h1 id="多次測試的重複設定：beforeEach、afterEach"><a class="header-anchor" href="#多次測試的重複設定：beforeEach、afterEach"></a>多次測試的重複設定：<code>beforeEach</code>、<code>afterEach</code></h1><p>每個測試案例都要進行一些設定，可用 <code>beforeEach</code> 和 <code>afterEach</code>：</p><ul><li><code>beforeEach(fn, timeout)</code>：<ul><li>在執行此檔案中的每個測試之前執行 <code>fn</code> 函數</li><li>若 <code>fn</code> 函數回傳 promise 或 generator，Jest 會在執行測試之前等待該 promise resolve</li><li>若 <code>beforeEach</code> 放在 <code>describe</code> 區塊內，就只會在此區塊內的測試之前執行</li><li>例如：重置每個測試要使用的全域狀態</li></ul></li><li><code>afterEach(fn, timeout)</code>：<ul><li>在執行此檔案中的每個測試之後執行 <code>fn</code> 函數</li><li>若 <code>fn</code> 函數回傳 promise 或 generator，Jest 會等待該 promise resolve 後才會繼續</li><li>若 <code>afterEach</code> 放在 <code>describe</code> 區塊內，就只會在此區塊內的測試之後執行</li><li>例如：清除每個測試建立的某些臨時狀態</li></ul></li></ul><div class="info"><p><code>timeout</code> 是可選參數，可提供 timeout 來指定 <code>beforeEach</code> 或 <code>afterEach</code> 中止前要等待的時間，單位為豪秒，預設為 5 秒。</p></div><h2 id="同步的重複設定"><a class="header-anchor" href="#同步的重複設定"></a>同步的重複設定</h2><p>例如：要在每個測試案例執行之前呼叫 <code>initCityDB()</code>，並在每個測試案例執行之後呼叫 <code>clearCityDB()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/repeatSetupForManyTests/sync.test.js</span><br><span class="hljs-keyword">import</span> &#123;<br>  addCity,<br>  clearCityDB,<br>  initCityDB,<br>  isCity<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../src/cityDB'</span>;<br><br>describe(<span class="hljs-string">'使用 beforeEach 和 afterEach 對多個測試重複設定'</span>, () =&gt; &#123;<br>  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- beforeEach init DB Start ---`</span>);<br>    initCityDB();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- beforeEach init DB End ---`</span>);<br>  &#125;);<br><br>  afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- afterEach clear DB Start ---`</span>);<br>    clearCityDB();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- afterEach clear DB End ---`</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`=========================================`</span>);<br>  &#125;);<br><br>  test(<span class="hljs-string">'新增 Kaohsiung'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test1 Start ---`</span>);<br>    expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>    addCity(<span class="hljs-string">'Kaohsiung'</span>);<br>    expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeTruthy();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test1 End ---`</span>);<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'有 Tainan，但沒有 Kaohsiung'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test2 Start ---`</span>);<br>    expect(isCity(<span class="hljs-string">'Tainan'</span>)).toBeTruthy();<br>    expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test2 End ---`</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>執行測試；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/repeatSetupForManyTests/sync.test.js --watch</span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-setup-teardown/repeat-setup-for-many-tests_sync.png" alt=""></p><h2 id="非同步的重複設定"><a class="header-anchor" href="#非同步的重複設定"></a>非同步的重複設定</h2><p><code>beforeEach</code> 和 <code>afterEach</code> 可以若要<a href="https://jestjs.io/docs/en/asynchronous" target="_blank" rel="noopener">處理非同步</a>，有兩種處理方式：</p><ul><li>使用 <code>.done</code> 參數</li><li>回傳 promise</li></ul><h3 id="使用-done-參數"><a class="header-anchor" href="#使用-done-參數"></a>使用 <code>.done</code> 參數</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/repeatSetupForManyTests/doneParameter.test.js</span><br><span class="hljs-keyword">import</span> &#123;<br>  addCity,<br>  clearCityDBCallback,<br>  initCityDBCallback,<br>  isCity<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../src/cityDB'</span>;<br><br>describe(<span class="hljs-string">'beforeEach 和 afterEach 使用 done 參數'</span>, () =&gt; &#123;<br>  beforeEach(<span class="hljs-function"><span class="hljs-params">done</span> =&gt;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>) </span>&#123;<br>      done();<br>    &#125;<br>    <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- beforeEach callback init DB Start ---`</span>);<br>    initCityDBCallback(callback);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- beforeEach callback init DB End ---`</span>);<br>  &#125;);<br><br>  afterEach(<span class="hljs-function"><span class="hljs-params">done</span> =&gt;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>) </span>&#123;<br>      done();<br>    &#125;<br>    <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- afterEach callback clear DB Start ---`</span>);<br>    clearCityDBCallback(callback);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- afterEach callback clear DB End ---`</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`===============================================`</span>);<br>  &#125;);<br><br>  test(<span class="hljs-string">'新增 Kaohsiung'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test1 Start ---`</span>);<br>    expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>    addCity(<span class="hljs-string">'Kaohsiung'</span>);<br>    expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeTruthy();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test1 End ---`</span>);<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'有 Tainan，但沒有 Kaohsiung'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test2 Start ---`</span>);<br>    expect(isCity(<span class="hljs-string">'Tainan'</span>)).toBeTruthy();<br>    expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test2 End ---`</span>);<br>  &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><p>執行測試：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/repeatSetupForManyTests/doneParameter.test.js --watch</span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-setup-teardown/repeat-setup-for-many-tests_done-parameter_1.png" alt=""></p><p><img src="../images/jest-setup-teardown/repeat-setup-for-many-tests_done-parameter_2.png" alt=""></p><h3 id="回傳-promise"><a class="header-anchor" href="#回傳-promise"></a>回傳 promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/repeatSetupForManyTests/returnPromise.test.js</span><br><span class="hljs-keyword">import</span> &#123;<br>  addCity,<br>  initCityDBPromise,<br>  clearCityDBPromise,<br>  isCity<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../src/cityDB'</span>;<br><br>describe(<span class="hljs-string">'城市資料庫 (使用 beforeEach 和 afterEach 回傳 promise)'</span>, () =&gt; &#123;<br>  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- beforeEach promise init DB Start ---`</span>);<br>    <span class="hljs-keyword">return</span> initCityDBPromise();<br>  &#125;);<br>  <br>  afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- afterEach promise clear DB Start ---`</span>);<br>    <span class="hljs-keyword">return</span> clearCityDBPromise();<br>  &#125;);<br><br>  test(<span class="hljs-string">'新增 Kaohsiung'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test1 Start ---`</span>);<br>    expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>    addCity(<span class="hljs-string">'Kaohsiung'</span>);<br>    expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeTruthy();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test1 End ---`</span>);<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'有 Tainan，但沒有 Kaohsiung'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test2 Start ---`</span>);<br>    expect(isCity(<span class="hljs-string">'Tainan'</span>)).toBeTruthy();<br>    expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- test2 End ---`</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>執行測試：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/repeatSetupForManyTests/returnPromise.test.js --watch</span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-setup-teardown/repeat-setup-for-many-tests_return-promise.png" alt=""></p><h1 id="一次性設定：beforeAll、afterAll"><a class="header-anchor" href="#一次性設定：beforeAll、afterAll"></a>一次性設定：<code>beforeAll</code>、<code>afterAll</code></h1><p>有時需要在檔案的開頭執行一次設定。當設定是非同步時，可能很麻煩，所以不能直接在檔案開頭處理。Jest 提供 <code>beforeAll</code> 和 <code>afterAll</code> 來處理這種情況。</p><p>若要在所有測試執行之後處理一些事，可用 <code>beforeAll</code> 和 <code>afterAll</code>：</p><ul><li><code>beforeAll(fn, timeout)</code>：<ul><li>在執行此檔案中的所有測試之前執行 <code>fn</code> 函數</li><li>若 <code>fn</code> 函數回傳 promise 或 generator，Jest 會在執行測試之前等待該 promise resolve</li><li>若 <code>beforeAll</code> 放在 <code>describe</code> 區塊內，就只會在此區塊內的開頭執行</li><li>例如：設定多個測試都要共用的全域狀態</li></ul></li><li><code>afterAll(fn, timeout)</code>：<ul><li>在執行此檔案中的所有測試之後執行 <code>fn</code> 函數</li><li>若 <code>fn</code> 函數回傳 promise 或 generator，Jest 會等待該 promise resolve 後才會繼續</li><li>若 <code>afterAll</code> 放在 <code>describe</code> 區塊內，就只會在此區塊內的結尾執行</li><li>例如：清除多個測試都要共用的全域狀態</li></ul></li></ul><div class="info"><p><code>timeout</code> 是可選參數，可提供 timeout 來指定 <code>beforeAll</code> 或 <code>afterAll</code> 中止前要等待的時間，單位為豪秒，預設為 5 秒</p></div><p>例如：若 <code>initCityDBPromise</code> 和 <code>clearCityDBPromise</code> 都回傳 promise，並且城市資料庫可以在多個測試案例之間重用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/cityDB.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initCityDBPromise</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- Promise：init DB Start ---`</span>);<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      cityDB = [<span class="hljs-string">'Taipei'</span>, <span class="hljs-string">'Tainan'</span>];<br>      resolve();<br>    &#125;, <span class="hljs-number">3000</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- Promise：init DB End ---`</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearCityDBPromise</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- Promise：clear DB Start ---`</span>);<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      cityDB = [];<br>      resolve();<br>    &#125;, <span class="hljs-number">3000</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- Promise：clear DB End ---`</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/setupAndTeardown.test.js</span><br><span class="hljs-keyword">import</span> &#123;<br>  initCityDBPromise,<br>  clearCityDBPromise,<br>  isCity<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/cityDB'</span>;<br><br>beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'beforeAll'</span>);<br>  <span class="hljs-keyword">return</span> initCityDBPromise();<br>&#125;);<br><br>afterAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'afterAll'</span>);<br>  <span class="hljs-keyword">return</span> clearCityDBPromise();<br>&#125;);<br><br>test(<span class="hljs-string">'有 Tainan'</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test 1'</span>);<br>  expect(isCity(<span class="hljs-string">'Tainan'</span>)).toBeTruthy();<br>&#125;);<br><br>test(<span class="hljs-string">'沒有 Kaohsiung'</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test 2'</span>);<br>  expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>&#125;);<br></code></pre></td></tr></table></figure><p>執行測試：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/setupAndTeardown.test.js --watch</span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-setup-teardown/setup-and-teardown.png" alt=""></p><h1 id="Scoping"><a class="header-anchor" href="#Scoping"></a>Scoping</h1><p><code>before</code> 和 <code>after</code> 區塊適用於檔案中的每個測試，也可放在 <code>describe</code> 區塊來將測試案例分組。當 <code>before</code> 和 <code>after</code> 放在 <code>describe</code> 區塊中時，只適用在該 <code>describe</code> 區塊中的測試案例。</p><p>若以下這些放在 <code>describe</code> 區塊內；</p><ul><li><code>beforeAll</code>：只會在此區塊內的開頭執行</li><li><code>afterAll</code>：只會在此區塊內的結尾執行</li><li><code>beforeEach</code>：只會在此區塊內的測試之前執行</li><li><code>afterEach</code>：只會在此區塊內的測試之後執行</li></ul><p>例如：有城市資料庫和食物資料庫，可為不同測試做不同設定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/foodDB.js</span><br><span class="hljs-keyword">let</span> foodDB = [];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initFoodDBPromise</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- Promise: init DB Start ---`</span>);<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      foodDB = [<br>        &#123; <span class="hljs-attr">city</span>: <span class="hljs-string">'Taipei'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Apple'</span> &#125;,<br>        &#123; <span class="hljs-attr">city</span>: <span class="hljs-string">'Tainan'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Banana'</span> &#125;<br>      ];<br>      resolve();<br>    &#125;, <span class="hljs-number">3000</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- Promise: init DB End ---`</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearFoodDBPromise</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- Promise: clear DB Start ---`</span>);<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      foodDB = [];<br>      resolve();<br>    &#125;, <span class="hljs-number">3000</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`--- Promise: clear DB End ---`</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidCityFoodPair</span>(<span class="hljs-params">foodCity, foodName</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> foodDB.some(<span class="hljs-function"><span class="hljs-params">food</span> =&gt;</span> (food.city === foodCity) &amp;&amp; (food.name === foodName));<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;<br>  initFoodDBPromise,<br>  clearFoodDBPromise,<br>  isValidCityFoodPair<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/scoping/scope.test.js</span><br><span class="hljs-keyword">import</span> &#123;<br>  initCityDBPromise,<br>  clearCityDBPromise,<br>  isCity<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../src/cityDB'</span>;<br><br><span class="hljs-keyword">import</span> &#123;<br>  initFoodDBPromise,<br>  clearFoodDBPromise,<br>  isValidCityFoodPair<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../src/foodDB'</span>;<br><br><span class="hljs-comment">// 適用於此文件中的所有測試</span><br>beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global: beforeEach'</span>);<br>  <span class="hljs-keyword">return</span> initCityDBPromise();<br>&#125;);<br><br>afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global: afterEach'</span>);<br>  <span class="hljs-keyword">return</span> clearCityDBPromise();<br>&#125;);<br><br>test(<span class="hljs-string">'城市資料庫有 Tainan'</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global: test1'</span>);<br>  expect(isCity(<span class="hljs-string">'Tainan'</span>)).toBeTruthy();<br>&#125;);<br><br>test(<span class="hljs-string">'城市資料庫沒有 Kaohsiung'</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global: test2'</span>);<br>  expect(isCity(<span class="hljs-string">'Kaohsiung'</span>)).toBeFalsy();<br>&#125;);<br><br>describe(<span class="hljs-string">'城市與食物 match'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 僅適用於此 describe 區塊中的測試</span><br>  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scope: beforeEach'</span>);<br>    <span class="hljs-keyword">return</span> initFoodDBPromise();<br>  &#125;);<br>  <br>  afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scope: afterEach'</span>);<br>    <span class="hljs-keyword">return</span> clearFoodDBPromise();<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'Taipei &lt;3 Apple'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scope: test1'</span>);<br>    expect(isValidCityFoodPair(<span class="hljs-string">'Taipei'</span>, <span class="hljs-string">'Apple'</span>)).toBe(<span class="hljs-literal">true</span>);<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'Tainan &lt;3 Banana'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scope: test2'</span>);<br>    expect(isValidCityFoodPair(<span class="hljs-string">'Tainan'</span>, <span class="hljs-string">'Banana'</span>)).toBe(<span class="hljs-literal">true</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>執行測試：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/scoping/scope.test.js --watch</span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-setup-teardown/scoping%E2%80%94scope_1.png" alt=""></p><p><img src="../images/jest-setup-teardown/scoping%E2%80%94scope_2.png" alt=""></p><p><img src="../images/jest-setup-teardown/scoping%E2%80%94scope_3.png" alt=""></p><p>測試檔最上層的 <code>beforeEach</code> 會在 <code>describe</code> 區塊內的 <code>beforeEach</code> 之前執行。看以下範例可了解這些 hook 的執行順序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/scoping/executionOrder.test.js</span><br>beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global: beforeAll'</span>));<br>afterAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global: afterAll'</span>));<br><br>beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global: beforeEach'</span>));<br>afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global: afterEach'</span>));<br><br>test(<span class="hljs-string">''</span>, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global: test'</span>));<br><br>describe(<span class="hljs-string">'Scoped / Nested block'</span>, () =&gt; &#123;<br>  beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scope: beforeAll'</span>));<br>  afterAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scope: afterAll'</span>));<br><br>  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scope: beforeEach'</span>));<br>  afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scope: afterEach'</span>));<br><br>  test(<span class="hljs-string">''</span>, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scope: test'</span>));<br>&#125;);<br><br><span class="hljs-comment">// global: beforeAll</span><br><span class="hljs-comment">// global: beforeEach</span><br><span class="hljs-comment">// global: test</span><br><span class="hljs-comment">// global: afterEach</span><br><br><span class="hljs-comment">// scope: beforeAll</span><br><span class="hljs-comment">// global: beforeEach</span><br><span class="hljs-comment">// scope: beforeEach</span><br><span class="hljs-comment">// scope: test</span><br><span class="hljs-comment">// scope: afterEach</span><br><span class="hljs-comment">// global: afterEach</span><br><span class="hljs-comment">// scope: afterAll</span><br><br><span class="hljs-comment">// global: afterAll</span><br></code></pre></td></tr></table></figure><p>執行測試：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/scoping/executionOrder.test.js --watch</span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-setup-teardown/scoping_execution-order.png" alt=""></p><h1 id="describe-區塊和-test-區塊的執行順序"><a class="header-anchor" href="#describe-區塊和-test-區塊的執行順序"></a><code>describe</code> 區塊和 <code>test</code> 區塊的執行順序</h1><ul><li>Jest 在執行任何測試之前，會先執行測試檔案中的所有 <code>describe</code> handler<ul><li>這就是為何要在 <code>before*</code> 和 <code>after*</code> handler 中進行設定和拆除 (setup and teardown)，而不是在 <code>describe</code> 區塊中處理的原因</li></ul></li><li>當 <code>describe</code> 區塊完成時，預設情況下，Jest 會按照在收集階段中遇到的順序連續執行所有測試，等待每個測試完成並進行整理之後再繼續</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/orderOfExecutionOfDescribeAndTestBlocks.test.js</span><br>describe(<span class="hljs-string">'outer'</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'describe outer-a'</span>);<br><br>  describe(<span class="hljs-string">'describe inner 1'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'describe inner 1'</span>);<br>    test(<span class="hljs-string">'test 1'</span>, () =&gt; &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test for describe inner 1'</span>);<br>      expect(<span class="hljs-literal">true</span>).toEqual(<span class="hljs-literal">true</span>);<br>    &#125;);<br>  &#125;);<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'describe outer-b'</span>);<br><br>  test(<span class="hljs-string">'test 1'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test for describe outer'</span>);<br>    expect(<span class="hljs-literal">true</span>).toEqual(<span class="hljs-literal">true</span>);<br>  &#125;);<br><br>  describe(<span class="hljs-string">'describe inner 2'</span>, () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'describe inner 2'</span>);<br>    test(<span class="hljs-string">'test for describe inner 2'</span>, () =&gt; &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test for describe inner 2'</span>);<br>      expect(<span class="hljs-literal">false</span>).toEqual(<span class="hljs-literal">false</span>);<br>    &#125;);<br>  &#125;);<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'describe outer-c'</span>);<br>&#125;);<br><br><span class="hljs-comment">// describe outer-a</span><br><span class="hljs-comment">// describe inner 1</span><br><span class="hljs-comment">// describe outer-b</span><br><span class="hljs-comment">// describe inner 2</span><br><span class="hljs-comment">// describe outer-c</span><br><span class="hljs-comment">// test for describe inner 1</span><br><span class="hljs-comment">// test for describe outer</span><br><span class="hljs-comment">// test for describe inner 2</span><br></code></pre></td></tr></table></figure><p>執行測試：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/scoping/OrderOfExecutionOfDescribeAndTestBlocks.test.js --watch</span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-setup-teardown/order-of-execution-of-describe-and-test-blocks.png" alt=""></p><h1 id="建議"><a class="header-anchor" href="#建議"></a>建議</h1><p>如果測試失敗，要檢查的第一件事就是當只有它在執行時是否會失敗。若只要讓 Jest 執行一個測試，可將測試指令臨時改成 <a href="https://titangene.github.io/article/jest-describe-test-case.html#test-only-name-fn-timeout"><code>test.only</code></a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// __tests__/testOnly.test.js</span><br>test.only(<span class="hljs-string">'this will be the only test that runs'</span>, () =&gt; &#123;<br>  expect(<span class="hljs-literal">true</span>).toBe(<span class="hljs-literal">true</span>);<br>&#125;);<br><br>test(<span class="hljs-string">'this test will not run'</span>, () =&gt; &#123;<br>  expect(<span class="hljs-string">'A'</span>).toBe(<span class="hljs-string">'A'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>執行測試：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx jest ./__tests__/testOnly.test.js --watch</span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-setup-teardown/test-only.png" alt=""></p><p>如果你有一個測試在大型案例的一部份執行會發生錯誤，但單獨執行不會失敗，那可能是其他測試干擾了此測試。通常可用 <code>beforeEach</code> 來清除一些共享狀態來解決此問題。若不確定是否正在修改哪些共享狀態，也可嘗試用 <code>beforeEach</code> 來紀錄資料。</p><h1 id="參考資料"><a class="header-anchor" href="#參考資料"></a>參考資料</h1><ul><li><a href="https://jestjs.io/docs/en/setup-teardown" target="_blank" rel="noopener">Setup and Teardown · Jest</a></li><li><a href="https://medium.com/enjoy-life-enjoy-coding/unit-test-%E6%9B%BF%E6%B8%AC%E8%A9%A6%E8%A8%AD%E7%BD%AE%E5%88%86%E9%A1%9E-describe-%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F-scoping-2c5082266ca" target="_blank" rel="noopener">Jest | 測試設定分類 (describe) 及作用域 (scoping) by 神Q超人</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;每個測試案例都必須是獨立的，不能互相影響，而解決方法就是讓每個測試在執行前進行重設，或在每個測試結束後清除痕跡。在 Jest，提供 setup 和 teardown 的函數，能讓你自訂在執行 &lt;code&gt;describe&lt;/code&gt; 區塊或 &lt;code&gt;test&lt;/code&gt; 區塊的前後分別要做什麼準備和收尾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Describe &amp; Test case</title>
    <link href="https://titangene.github.io/article/jest-describe-test-case.html"/>
    <id>https://titangene.github.io/article/jest-describe-test-case.html</id>
    <published>2020-06-14T15:57:34.000Z</published>
    <updated>2020-06-28T14:07:35.609Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>上次介紹了 <a href="https://titangene.github.io/article/jest-matcher-assertion.html">Jest 提供的 matcher</a>，可讓你驗證程式碼是否符合預期，而這次來說明如何透過 <code>describe</code> 和 <code>test</code> 區塊來組織測試案例。當需求變多時，可針對需求來分類測試案例，將相關的測試放在同一個群組區塊內，此時就會用到 Jest 提供的 <code>describe</code> 和 <code>test</code> 區塊。</p><a id="more"></a><ul><li><code>test</code> 區塊：即測試案例 (test case)，使用 matcher 驗證程式執行結果是否符合預期</li><li><code>describe</code> 區塊：將多個相關的 <code>test</code> 區塊放在一起，便於組織測試案例</li></ul><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><p>下面範例都會用數學運算的範例來說明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> addition = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(x) === <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-keyword">typeof</span>(y) === <span class="hljs-string">'number'</span>)<br>   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomError(<span class="hljs-string">'請輸入數字'</span>);<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br><span class="hljs-keyword">const</span> subtraction = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(x) === <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-keyword">typeof</span>(y) === <span class="hljs-string">'number'</span>)<br>   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomError(<span class="hljs-string">'請輸入數字'</span>);<br>  <span class="hljs-keyword">return</span> x - y;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="describe-區塊"><a class="header-anchor" href="#describe-區塊"></a><code>describe</code> 區塊</h1><h2 id="describe-name-fn"><a class="header-anchor" href="#describe-name-fn"></a><code>describe(name, fn)</code></h2><p>argument：</p><ul><li><code>name</code>：描素此 <code>describe</code> 區塊的敘述</li><li><code>fn</code>：包含 <code>test</code> 區塊的函數</li></ul><p>用來將多個相關的 <code>test</code> 區塊放在同一個 <code>describe</code> 區塊內，以便於將測試組織成群組。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe(<span class="hljs-string">'數學運算'</span>, () =&gt; &#123;<br>  test(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>    expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'減法運算'</span>, () =&gt; &#123;<br>    expect(subtraction(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)).toBe(<span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>但寫測試不一定要用 <code>describe</code> 區塊，也可以不用將 <code>test</code> 區塊包在 <code>describe</code> 區塊內，而是直接寫在測試檔上，但建議你使用 <code>describe</code> 區塊。</p><p>也可以巢狀使用 <code>describe</code> 區塊：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe(<span class="hljs-string">'數學運算'</span>, () =&gt; &#123;<br>  describe(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>    describe(<span class="hljs-string">'傳入非數字值'</span>, () =&gt; &#123;<br>      test(<span class="hljs-string">'傳入布林值應拋出 CustomError'</span>, () =&gt; &#123;<br>        expect(addition(<span class="hljs-literal">true</span>, <span class="hljs-number">2</span>)).toThrow(CustomError);<br>      &#125;);<br><br>      test(<span class="hljs-string">'傳入字串值應拋出 CustomError'</span>, () =&gt; &#123;<br>        expect(addition(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>)).toThrow(CustomError);<br>      &#125;);<br>    &#125;);<br>    <br>    describe(<span class="hljs-string">'傳入數字值'</span>, () =&gt; &#123;<br>      test(<span class="hljs-string">'應回傳正確的運算結果'</span>, () =&gt; &#123;<br>        expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br><br>  describe(<span class="hljs-string">'減法運算'</span>, () =&gt; &#123;<br>    describe(<span class="hljs-string">'傳入非數字值'</span>, () =&gt; &#123;<br>      test(<span class="hljs-string">'傳入布林值應拋出 CustomError'</span>, () =&gt; &#123;<br>        expect(subtraction(<span class="hljs-literal">true</span>, <span class="hljs-number">2</span>)).toThrow(CustomError);<br>      &#125;);<br><br>      test(<span class="hljs-string">'傳入字串值應拋出 CustomError'</span>, () =&gt; &#123;<br>        expect(subtraction(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>)).toThrow(CustomError);<br>      &#125;);<br>    &#125;);<br>    <br>    describe(<span class="hljs-string">'傳入數字值'</span>, () =&gt; &#123;<br>      test(<span class="hljs-string">'應回傳正確的運算結果'</span>, () =&gt; &#123;<br>        expect(subtraction(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)).toBe(<span class="hljs-number">2</span>);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="describe-only-name-fn"><a class="header-anchor" href="#describe-only-name-fn"></a><code>describe.only(name, fn)</code></h2><p>alias：<code>fdescribe(name, fn)</code></p><p>讓測試只跑使用 <code>describe.only()</code> 的 <code>describe</code> 區塊。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe.only(<span class="hljs-string">'數學運算'</span>, () =&gt; &#123;<br>  test(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>    expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'減法運算'</span>, () =&gt; &#123;<br>    expect(subtraction(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)).toBe(<span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;);<br><br>describe(<span class="hljs-string">'其他'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 此區塊的測試會被略過</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="describe-skip-name-fn"><a class="header-anchor" href="#describe-skip-name-fn"></a><code>describe.skip(name, fn)</code></h2><p>alias：<code>xdescribe(name, fn)</code></p><p>不想執行指定的 <code>describe</code> 區塊可用 <code>describe.skip()</code>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">describe(<span class="hljs-string">'數學運算'</span>, () =&gt; &#123;<br>  test(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>    expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>  &#125;);<br>  <br>  test(<span class="hljs-string">'減法運算'</span>, () =&gt; &#123;<br>    expect(subtraction(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)).toBe(<span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;);<br><br>describe.skip(<span class="hljs-string">'其他'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 略過此區塊的測試</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="test-區塊"><a class="header-anchor" href="#test-區塊"></a><code>test</code> 區塊</h1><h2 id="test-name-fn-timeout"><a class="header-anchor" href="#test-name-fn-timeout"></a><code>test(name, fn, timeout)</code></h2><p>alias：<code>it(name, fn, timeout)</code></p><p>argument：</p><ul><li><code>name</code>：測試名稱</li><li><code>fn</code>：包含要測試的期望函數</li><li><code>timeout</code> (可選)：測試終止之前要等待的時間 (單位毫秒)，預設為 5 秒</li></ul><p>測試檔案內一定要有 <code>test</code> 區塊才能測試程式。</p><p>剛剛有提到，不一定要 <code>describe</code> 區塊，可直接在測試檔內放 <code>test</code> 區塊即可。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>  expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="test-only-name-fn-timeout"><a class="header-anchor" href="#test-only-name-fn-timeout"></a><code>test.only(name, fn, timeout)</code></h2><p>alias：<code>it.only(name, fn, timeout)</code> 和 <code>fit(name, fn, timeout)</code></p><p>在 debug 測試檔內的測試時，通常只需要執行一部分的測試，此時就可以將那些 <code>test</code> 區塊加上 <code>.only</code> 來指定要執行哪些測試，其餘的測試都會被略過。</p><blockquote><p>註：<code>timeout</code> argument 跟 <code>test()</code> 一樣，所以不再次重複說明。</p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test.only(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>  expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>&#125;);<br><br>test(<span class="hljs-string">'其他運算'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 略過此區塊的測試</span><br>&#125;);<br></code></pre></td></tr></table></figure><div class="info"><p><code>test.only</code> 只會在 debug 階段使用，不建議 commit 至 Git 版本控制中，記得要在 debug 後刪掉 <code>.only</code>。</p></div><h2 id="test-skip-name-fn"><a class="header-anchor" href="#test-skip-name-fn"></a><code>test.skip(name, fn)</code></h2><p>alias：<code>it.skip(name, fn)</code> 或 <code>xit(name, fn)</code> 或 <code>xtest(name, fn)</code></p><p>若要跳過一些 <code>test</code> 區塊的測試，可用 <code>test.skip()</code>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'加法運算'</span>, () =&gt; &#123;<br>  expect(addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">3</span>);<br>&#125;);<br><br>test.skip(<span class="hljs-string">'其他運算'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// 略過此區塊的測試</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>若不想執行某 <code>test</code> 區塊的測試，雖然可將該測試註解掉，但建議用 <code>test.skip</code>，因為只少會保留原本的縮排和顯示程式碼 highlight。</p><h2 id="test-todo-name"><a class="header-anchor" href="#test-todo-name"></a><code>test.todo(name)</code></h2><p>alias：<code>it.todo(name)</code></p><p>規劃要寫的測試 (寫在 <code>name</code> argument 上) 可用 <code>test.todo()</code>，這些測試會在摘要輸出中 highlight 顯示，以便提醒你還有多少測試還沒寫。</p><p>若提供 test callback 函數，<code>test.todo()</code> 會拋出錯誤。若你已實作了該測試，且該測試已出錯，而你不想執行此測試，請改用 <code>test.skip()</code>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br><br>test.todo(<span class="hljs-string">'add should be associative'</span>);<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/api" target="_blank" rel="noopener">Globals · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;上次介紹了 &lt;a href=&quot;https://titangene.github.io/article/jest-matcher-assertion.html&quot;&gt;Jest 提供的 matcher&lt;/a&gt;，可讓你驗證程式碼是否符合預期，而這次來說明如何透過 &lt;code&gt;describe&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; 區塊來組織測試案例。當需求變多時，可針對需求來分類測試案例，將相關的測試放在同一個群組區塊內，此時就會用到 Jest 提供的 &lt;code&gt;describe&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; 區塊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
  </entry>
  
  <entry>
    <title>Jest：Matcher &amp; Assertion</title>
    <link href="https://titangene.github.io/article/jest-matcher-assertion.html"/>
    <id>https://titangene.github.io/article/jest-matcher-assertion.html</id>
    <published>2020-06-07T03:56:22.000Z</published>
    <updated>2020-06-28T14:07:19.145Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>Assertion (斷言) 就要測試程式碼的執行結果是否符合預期，如果結果一致，代表測試通過，否則 assertion 就會拋出錯誤，代表測試失敗。而 Jest 提供多種 matcher，能讓你 assert 程式碼執行結果的正確性。</p><a id="more"></a><blockquote><p>之前介紹了如何建制 Jest 測試環境，還沒安裝環境的可參閱：</p><ul><li><a href="https://titangene.github.io/article/jest-build-test-env.html">Jest：建置測試環境 (包含 Babel) | Titangene Blog</a></li><li><a href="https://titangene.github.io/article/jest-typescript.html">Jest + TypeScript：建置測試環境 | Titangene Blog</a></li></ul></blockquote><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><p>下面介紹 Jest 提供的各種 matcher：</p><h1 id="通用-Matchers"><a class="header-anchor" href="#通用-Matchers"></a>通用 Matchers</h1><p><code>expect()</code> 回傳一個 “期望 (expectation)” 的物件</p><p>當 Jest 執行時，它會追蹤所有失敗的 matcher，以便列印錯誤訊息：</p><ul><li><code>.toBe()</code> 是 matcher，使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noopener"><code>Object.is()</code></a> 來測試 exact equality (精確相等)</li><li><code>.toEqual()</code>：檢查物件的值，遞迴的檢查物件或陣列的每個 field</li><li><code>.not</code>：matcher 的相反</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'two plus two is four'</span>, () =&gt; &#123;<br>  expect(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>).toBe(<span class="hljs-number">4</span>);<br>&#125;);<br><br>test(<span class="hljs-string">'object assignment'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">one</span>: <span class="hljs-number">1</span>&#125;;<br>  data[<span class="hljs-string">'two'</span>] = <span class="hljs-number">2</span>;<br>  expect(data).toEqual(&#123;<span class="hljs-attr">one</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">two</span>: <span class="hljs-number">2</span>&#125;);<br>&#125;);<br><br>test(<span class="hljs-string">'adding positive numbers is not zero'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>; a &lt; <span class="hljs-number">10</span>; a++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>; b &lt; <span class="hljs-number">10</span>; b++) &#123;<br>      expect(a + b).not.toBe(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Truthiness-真實性"><a class="header-anchor" href="#Truthiness-真實性"></a>Truthiness (真實性)</h1><p>在測試中，有時需要區分 <code>undefined</code>、<code>null</code> 和 <code>false</code>，但有時你又不需要區分。Jest 包含一些 helper，便於確認想要的內容：</p><ul><li><code>toBeNull</code> 只 match <code>null</code></li><li><code>toBeUndefined</code> 只 match <code>undefined</code></li><li><code>toBeDefined</code> 與 <code>toBeUndefined</code> 相反</li><li><code>toBeTruthy</code> match 任何 <code>if</code> 陳述句為 true</li><li><code>toBeFalsy</code> match 任何 <code>if</code> 陳述句為 false</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'null'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> n = <span class="hljs-literal">null</span>;<br>  expect(n).toBeNull();<br>  expect(n).not.toBeUndefined();<br>  expect(n).toBeDefined();<br>  expect(n).not.toBeTruthy();<br>  expect(n).toBeFalsy();<br>&#125;);<br><br>test(<span class="hljs-string">'zero'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> z = <span class="hljs-number">0</span>;<br>  expect(z).not.toBeNull();<br>  expect(z).toBeDefined();<br>  expect(z).not.toBeUndefined();<br>  expect(z).not.toBeTruthy();<br>  expect(z).toBeFalsy();<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Numbers"><a class="header-anchor" href="#Numbers"></a>Numbers</h1><p>大多數的比較數字都有 matcher equivalents (等價物)：</p><ul><li><code>toBeGreaterThan()</code>：比較 <code>received &gt; expected</code></li><li><code>toBeGreaterThanOrEqual()</code>：比較 <code>received &gt;= expected</code></li><li><code>toBeLessThan()</code>：比較 <code>received &lt; expected</code></li><li><code>toBeLessThanOrEqual()</code>：比較 <code>received &lt;= expected</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'two plus two'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> value = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>  expect(value).toBeGreaterThan(<span class="hljs-number">3</span>);<br>  expect(value).toBeGreaterThanOrEqual(<span class="hljs-number">3.5</span>);<br>  expect(value).toBeLessThan(<span class="hljs-number">5</span>);<br>  expect(value).toBeLessThanOrEqual(<span class="hljs-number">4.5</span>);<br><br>  <span class="hljs-comment">// toBe 和 toEqual 等價於數字</span><br>  expect(value).toBe(<span class="hljs-number">4</span>);<br>  expect(value).toEqual(<span class="hljs-number">4</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>對於浮點數相等，請使用 <code>toBeCloseTo()</code> 而不是 <code>toEqual()</code>，因為你不希望測試依賴於微小的捨入誤差 (rounding error)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'adding floating point numbers'</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> value = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;<br>  <span class="hljs-comment">// expect(value).toBe(0.3);        由於舍入錯誤無法運作</span><br>  expect(value).toBeCloseTo(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// 可運作</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Strings"><a class="header-anchor" href="#Strings"></a>Strings</h1><p>可用 <code>toMatch()</code> 根據 regex 檢查字串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test(<span class="hljs-string">'there is no I in team'</span>, () =&gt; &#123;<br>  expect(<span class="hljs-string">'team'</span>).not.toMatch(<span class="hljs-regexp">/I/</span>);<br>&#125;);<br><br>test(<span class="hljs-string">'but there is a "stop" in Christoph'</span>, () =&gt; &#123;<br>  expect(<span class="hljs-string">'Christoph'</span>).toMatch(<span class="hljs-regexp">/stop/</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Arrays-和-iterables"><a class="header-anchor" href="#Arrays-和-iterables"></a>Arrays 和 iterables</h1><p>可用 <code>toContain()</code> 來檢查陣列或可迭代物件是否包含特定項目：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> shoppingList = [<br>  <span class="hljs-string">'diapers'</span>,<br>  <span class="hljs-string">'kleenex'</span>,<br>  <span class="hljs-string">'trash bags'</span>,<br>  <span class="hljs-string">'paper towels'</span>,<br>  <span class="hljs-string">'beer'</span>,<br>];<br><br>test(<span class="hljs-string">'the shopping list has beer on it'</span>, () =&gt; &#123;<br>  expect(shoppingList).toContain(<span class="hljs-string">'beer'</span>);<br>  expect(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(shoppingList)).toContain(<span class="hljs-string">'beer'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="Exceptions"><a class="header-anchor" href="#Exceptions"></a>Exceptions</h1><p>若要測試特定函數在呼叫時是否拋出錯誤，請使用 <code>toThrow()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileAndroidCode</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'you are using the wrong JDK'</span>);<br>&#125;<br><br>test(<span class="hljs-string">'compiling android goes as expected'</span>, () =&gt; &#123;<br>  expect(compileAndroidCode).toThrow();<br>  expect(compileAndroidCode).toThrow(<span class="hljs-built_in">Error</span>);<br><br>  <span class="hljs-comment">// 還可以使用確切的錯誤訊息或 regexp</span><br>  expect(compileAndroidCode).toThrow(<span class="hljs-string">'you are using the wrong JDK'</span>);<br>  expect(compileAndroidCode).toThrow(<span class="hljs-regexp">/JDK/</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>更多 matcher 可參閱 Jest 社群維護的 <a href="https://github.com/jest-community/jest-extended" target="_blank" rel="noopener">jest-community/jest-extended</a>。</p></blockquote><p>資料來源：<a href="https://jestjs.io/docs/en/using-matchers" target="_blank" rel="noopener">Using Matchers · Jest</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;Assertion (斷言) 就要測試程式碼的執行結果是否符合預期，如果結果一致，代表測試通過，否則 assertion 就會拋出錯誤，代表測試失敗。而 Jest 提供多種 matcher，能讓你 assert 程式碼執行結果的正確性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
  </entry>
  
  <entry>
    <title>Jest + TypeScript：建置測試環境</title>
    <link href="https://titangene.github.io/article/jest-typescript.html"/>
    <id>https://titangene.github.io/article/jest-typescript.html</id>
    <published>2020-05-31T15:59:10.000Z</published>
    <updated>2020-06-28T14:07:10.125Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest-typescript.jpg" alt=""></p><p>TypeScript 是 JavaScript 的 typed superset，提供強大的型別檢查系統，讓你在編譯時期就能即時發現錯誤，而不是到了 runtime 才發生未知的 bug。上次介紹了 <a href="https://titangene.github.io/article/jest-build-test-env.html">Jest + Babel 的測試環境建置</a>，這次來介紹 Jest + TypeScript 的測試環境建置過程。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><p>下面來介紹如何建置 Jest + TypeScript 的測試開發環境。</p><h1 id="建立開發環境"><a class="header-anchor" href="#建立開發環境"></a>建立開發環境</h1><h2 id="建立-npm-專案"><a class="header-anchor" href="#建立-npm-專案"></a>建立 npm 專案</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm init -y</span><br></code></pre></td></tr></table></figure><h2 id="安裝-TypeScript"><a class="header-anchor" href="#安裝-TypeScript"></a>安裝 TypeScript</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add -D typescript</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -D typescript</span><br></code></pre></td></tr></table></figure><h2 id="安裝與-Node-js-和-TypeScript-相關的環境"><a class="header-anchor" href="#安裝與-Node-js-和-TypeScript-相關的環境"></a>安裝與 Node.js 和 TypeScript 相關的環境</h2><ul><li><a href="https://github.com/TypeStrong/ts-node" target="_blank" rel="noopener"><code>ts-node</code></a>：Node.js 的 TypeScript 執行環境和 REPL，且支援 source map<ul><li>不用手動執行 <code>tsc</code> 編譯 TypeScript 檔案，就能直接像是使用 <code>node</code> 指令那樣，直接透過 <code>ts-node</code> 指令來編譯並執行 TypeScript 檔案</li></ul></li><li><a href="https://github.com/remy/nodemon" target="_blank" rel="noopener"><code>nodemon</code></a>：提供 watch 模式的 <code>node</code><ul><li>當 <code>nodemon</code> 檢測到指定目錄中的檔案有變更時，就會重新啟動 Node 應用程式</li></ul></li><li><a href="https://www.npmjs.com/package/@types/node" target="_blank" rel="noopener"><code>@types/node</code></a>：Node.js 的型別定義檔</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add -D ts-node nodemon @types/node</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -D ts-node nodemon @types/node</span><br></code></pre></td></tr></table></figure><h2 id="安裝與-Jest-和-TS-相關的環境"><a class="header-anchor" href="#安裝與-Jest-和-TS-相關的環境"></a>安裝與 Jest 和 TS 相關的環境</h2><ul><li><a href="https://github.com/facebook/jest" target="_blank" rel="noopener"><code>jest</code></a>：JavaScript 測試框架</li><li><a href="https://github.com/kulshekhar/ts-jest" target="_blank" rel="noopener"><code>ts-jest</code></a>：用於 Jest preprocessor 的 TypeScript preprocessor<ul><li>支援 Jest 的 source map</li><li>可讓你使用 Jest 來測試用 TypeScript 寫的專案</li><li>支援 TS 的所有功能，包括型別檢查</li></ul></li><li><a href="https://www.npmjs.com/package/@types/jest" target="_blank" rel="noopener"><code>@types/jest</code></a>：Jest 的型別定義檔</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add -D jest ts-jest @types/jest</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -D jest ts-jest @types/jest</span><br></code></pre></td></tr></table></figure><h2 id="設定-package-json"><a class="header-anchor" href="#設定-package-json"></a>設定 <code>package.json</code></h2><p>在 <code>package.json</code> 加上下面內容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"scripts"</span>: &#123;<br>    <span class="hljs-attr">"start"</span>: <span class="hljs-string">"ts-node src/main.ts"</span>,<br>    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"nodemon --watch 'src/**/*.ts' --exec ts-node src/main.ts"</span>,<br>    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"tsc"</span>,<br>    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"jest --coverage"</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="設定-jest-config-js"><a class="header-anchor" href="#設定-jest-config-js"></a>設定 <code>jest.config.js</code></h2><p>Jest 的預設是可以不用配置任何檔案就能執行測試，但 Jest 的預設是使用 Babel 來處理 <code>.ts</code> (和 <code>.tsx</code> ) 檔案 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，而 Babel 不會對 <code>.ts</code> 檔案進行編譯處理，所以就不會進行型別檢查。而 <code>ts-jest</code> 就能幫你處理 TS 該做的這些事。</p><blockquote><p>在 <a href="https://kulshekhar.github.io/ts-jest/user/babel7-or-ts" target="_blank" rel="noopener">Babel7 or TypeScript | ts-jest</a> 這篇文章內有提到為何不要用 <code>@babel/preset-typescript</code>，而要用 <code>ts-jest</code> 的原因。</p><p>所以若要開發 TypeScript，不建議使用 Babel，建議用 <code>tsc</code> 來編譯 TypeScript。</p></blockquote><p>為了要使用 <code>ts-jest</code> 來 transpile TypeScript，請執行以下指令來建立 Jest 的配置檔案 <code>jest.config.js</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx ts-jest config:init</span><br></code></pre></td></tr></table></figure><p>此指令建立的 <code>jest.config.js</code> 檔案內容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  preset: <span class="hljs-string">'ts-jest'</span>,<br>  testEnvironment: <span class="hljs-string">'node'</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>但我自己自訂了一些配置：</p><ul><li><code>coverageDirectory</code>：Jest 輸出的 coverage 檔案要放在哪個目錄<ul><li>預設：<code>undefined</code></li></ul></li><li><code>preset</code>：設定 preset<ul><li>預設：<code>undefined</code></li><li>preset 應指向 root 目錄上具有 <code>jest-preset.json</code> 或 <code>jest-preset.js</code> 檔案的 npm 模組</li></ul></li><li><code>testEnvironment</code>：用於測試的測試環境<ul><li>預設：<code>&quot;jsdom&quot;</code> (類似瀏覽器的環境)</li><li>若要建置 node service，可用 <code>&quot;node&quot;</code> 來使用類似 node 的環境</li></ul></li><li><code>testRegex</code>：Jest 只執行 match 此 pattern 的測試檔案<ul><li>預設：<code>(/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$</code><ul><li>即在 <code>__tests__</code> 目錄內的 <code>.js</code>、<code>.jsx</code>、<code>.ts</code> 和 <code>.tsx</code> 檔，以及帶有 <code>.test</code> 或 <code>.spec</code> 後綴的任何檔案，例如：<code>sum.test.ts</code> 或 <code>sum.spec.ts</code></li></ul></li><li>Jest 會用 <code>testRegex</code> 配置的 pattern 來嘗試 match 測試檔案的絕對路徑</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  coverageDirectory: <span class="hljs-string">"coverage"</span>,<br>  preset: <span class="hljs-string">'ts-jest'</span>,<br>  testEnvironment: <span class="hljs-string">"node"</span>,<br>  testRegex: <span class="hljs-string">"(/__tests__/.*|(\\.|/)(test|spec))\\.tsx?$"</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>更多 Jest 配置詳情可參閱 <a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">Configuring Jest · Jest</a>。</p></blockquote><h1 id="設定-tsconfig-json"><a class="header-anchor" href="#設定-tsconfig-json"></a>設定 <code>tsconfig.json</code></h1><p>自己手動建立 <code>tsconfig.json</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"compilerOptions"</span>: &#123;<br>    <span class="hljs-attr">"target"</span>: <span class="hljs-string">"es6"</span>,<br>    <span class="hljs-attr">"module"</span>: <span class="hljs-string">"commonjs"</span>,<br>    <span class="hljs-attr">"outDir"</span>: <span class="hljs-string">"dist"</span>,<br>    <span class="hljs-attr">"strict"</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">"sourceMap"</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">"esModuleInterop"</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>當然你也可以用 <code>tsc --init</code> 指令來建立 <code>tsconfig.json</code>。</p><blockquote><p>更多 <code>tsconfig.json</code> 配置詳情可參閱 <a href="https://www.typescriptlang.org/tsconfig" target="_blank" rel="noopener">TypeScript: TSConfig Reference - Docs on every TSConfig option</a>。</p></blockquote><h1 id="寫範例程式碼"><a class="header-anchor" href="#寫範例程式碼"></a>寫範例程式碼</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/sum.ts</span><br><span class="hljs-keyword">type</span> sumType = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">const</span> sum: sumType = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> sum;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/main.ts</span><br><span class="hljs-keyword">import</span> sum <span class="hljs-keyword">from</span> <span class="hljs-string">'./sum'</span>;<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>執行 <code>main.js</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn start</span><br>yarn run v1.21.1<br><span class="hljs-meta">$</span><span class="bash"> ts-node src/main.ts</span><br>3<br>Done in 4.71s.<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm run start</span><br><br><span class="hljs-meta">&gt;</span><span class="bash"> jest-typescript-101@1.0.0 start /home/titan/project/jest/jest-typescript-101</span><br><span class="hljs-meta">&gt;</span><span class="bash"> ts-node src/main.ts</span><br><br>3<br></code></pre></td></tr></table></figure><h1 id="建立測試"><a class="header-anchor" href="#建立測試"></a>建立測試</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// src/__tests__/sum.test.ts</span><br><span class="hljs-keyword">import</span> sum <span class="hljs-keyword">from</span> <span class="hljs-string">'../sum'</span>;<br><br>test(<span class="hljs-string">'adds 1 + 2 to equal 3'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// Arrange</span><br>  <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>, y: <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> expected: <span class="hljs-built_in">number</span> = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-comment">// Act</span><br>  <span class="hljs-keyword">let</span> actual: <span class="hljs-built_in">number</span> = sum(x, y);<br><br>  <span class="hljs-comment">// Assert</span><br>  expect(actual).toBe(expected);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="執行測試"><a class="header-anchor" href="#執行測試"></a>執行測試</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm run <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>測試通過：</p><p><img src="../images/jest-typescript/2020-05-31-23-23-21.png" alt=""></p><p>資料來源：</p><ul><li><a href="https://kulshekhar.github.io/ts-jest/" target="_blank" rel="noopener">ts-jest</a></li><li><a href="https://github.com/TypeStrong/ts-node" target="_blank" rel="noopener">ts-node</a></li><li><a href="https://github.com/remy/nodemon" target="_blank" rel="noopener">nodemon</a></li><li><a href="https://jestjs.io/docs/en/getting-started" target="_blank" rel="noopener">Getting Started · Jest</a></li><li><a href="https://jestjs.io/docs/en/cli" target="_blank" rel="noopener">Jest CLI Options · Jest</a></li><li><a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">Configuring Jest · Jest</a></li><li><a href="https://www.typescriptlang.org/tsconfig" target="_blank" rel="noopener">TypeScript: TSConfig Reference - Docs on every TSConfig option</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://jestjs.io/blog/2019/01/25/jest-24-refreshing-polished-typescript-friendly#typescript-support" target="_blank" rel="noopener">Jest 24: 💅 Refreshing, Polished, TypeScript-friendly · Jest</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest-typescript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;TypeScript 是 JavaScript 的 typed superset，提供強大的型別檢查系統，讓你在編譯時期就能即時發現錯誤，而不是到了 runtime 才發生未知的 bug。上次介紹了 &lt;a href=&quot;https://titangene.github.io/article/jest-build-test-env.html&quot;&gt;Jest + Babel 的測試環境建置&lt;/a&gt;，這次來介紹 Jest + TypeScript 的測試環境建置過程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="Node.js" scheme="https://titangene.github.io/tags/node-js/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
      <category term="TypeScript" scheme="https://titangene.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Jest：建置測試環境 (包含 Babel)</title>
    <link href="https://titangene.github.io/article/jest-build-test-env.html"/>
    <id>https://titangene.github.io/article/jest-build-test-env.html</id>
    <published>2020-05-24T15:50:20.000Z</published>
    <updated>2020-06-28T14:07:43.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/jest.jpg" alt=""></p><p>最近在學習單元測試，而 Jest 是在前端蠻常見的測試框架，可透過建立測試來確保自己寫的程式碼是否符合需求，而且當改動程式碼時，才能確保是否因不小心而產生的 bug，測試能讓我更有信心的去重構程式碼。</p><a id="more"></a><blockquote><p>其他 Jest 相關文章可參閱 <a href="https://titangene.github.io/tags/jest/">Jest 系列文章</a>。</p></blockquote><p>那 Jest 可以用在哪些專案？你可為下面這些專案建立測試：</p><ul><li><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a></li><li><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node</a></li><li><a href="https://angular.io/" target="_blank" rel="noopener">Angular</a>、<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>、<a href="https://reactjs.org/" target="_blank" rel="noopener">React</a></li><li>…等</li></ul><p>下面來介紹如何建置 Jest 的測試開發環境。</p><h1 id="建立開發環境"><a class="header-anchor" href="#建立開發環境"></a>建立開發環境</h1><h2 id="建立-npm-專案"><a class="header-anchor" href="#建立-npm-專案"></a>建立 npm 專案</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm init -y</span><br></code></pre></td></tr></table></figure><h2 id="安裝-Jest"><a class="header-anchor" href="#安裝-Jest"></a>安裝 Jest</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add -D jest</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -D jest</span><br></code></pre></td></tr></table></figure><h2 id="設定-package-json"><a class="header-anchor" href="#設定-package-json"></a>設定 <code>package.json</code></h2><p>在 <code>package.json</code> 加上下面內容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"scripts"</span>: &#123;<br>    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"jest"</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="寫範例程式碼"><a class="header-anchor" href="#寫範例程式碼"></a>寫範例程式碼</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// sum.js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = sum;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./sum'</span>);<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>執行 <code>main.js</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node main.js</span><br>3<br></code></pre></td></tr></table></figure><h1 id="建立測試"><a class="header-anchor" href="#建立測試"></a>建立測試</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// sum.test.js</span><br><span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./sum'</span>);<br><br>test(<span class="hljs-string">'adds 1 + 2 to equal 3'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// Arrange</span><br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> expected = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-comment">// Act</span><br>  <span class="hljs-keyword">let</span> actual = sum(x, y);<br><br>  <span class="hljs-comment">// Assert</span><br>  expect(actual).toBe(expected);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="執行測試"><a class="header-anchor" href="#執行測試"></a>執行測試</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm run <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>測試通過：</p><p><img src="../images/jest-build-test-env/2020-05-24-22-26-37.png" alt=""></p><h1 id="從指令列執行測試"><a class="header-anchor" href="#從指令列執行測試"></a>從指令列執行測試</h1><p>例如：Jest 只執行 match <code>my-test</code> 的測試檔案，以及使用 <code>config.json</code> 作為配置檔案，並且在執行後顯示 native 的 OS 通知：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> jest my-test --notify --config=config.json</span><br></code></pre></td></tr></table></figure><p>Jest CLI option 說明：</p><ul><li><code>jest &lt;regexForTestFiles&gt;</code>：match 到名為 <code>&lt;regexForTestFiles&gt;</code> (像此範例的 <code>my-test</code> ) 的檔案執行 Jest<ul><li>若在執行 <code>jest</code> 時使用了 <code>&lt;regexForTestFiles&gt;</code> argument，該 argument 會被視為 regex pattern，Jest 只會執行與 pattern match 的測試檔案</li><li>有些 terminal 可能需要用引號把 argument 包起來，例如：<code>jest &quot;my.*(complex)?pattern&quot;</code></li><li>Windows 需使用 <code>/</code> 作為路徑分隔字元 (separator) 或將 <code>\</code> 轉義 (escape) 成 <code>\\</code></li></ul></li><li><code>--config=&lt;path&gt;</code>，<code>-c=&lt;path&gt;</code>：使用 <code>&lt;path&gt;</code> (像此範例的 <code>config.json</code> ) 作為配置檔案<ul><li>Jest 配置檔案的路徑來指定如何查找和執行測試</li><li>如果在配置中未設定 <code>rootDir</code>，則假定包含配置檔案的目錄為專案的 <code>rootDir</code></li><li>也可以是 JSON-encoded value 作為 Jest 的配置</li></ul></li><li><code>--notify</code>：執行完成後顯示原生的 OS 通知<ul><li>激活 (activates) 測試結果通知</li><li>當你不希望自己的意識能夠專注於 JavaScript 測試以外的任何事物時，可用此 option</li><li>Beware：Jest 使用 <a href="https://github.com/mikaelbr/node-notifier" target="_blank" rel="noopener">node-notifier</a> 來顯示桌面通知<ul><li>在 Windows 上，它在第一次使用時會建立一個新的 start menu entry，並且不會顯示通知。通知將在後續執行中正確顯示</li></ul></li></ul></li></ul><h1 id="Jest-Config"><a class="header-anchor" href="#Jest-Config"></a>Jest Config</h1><p>使用下面指令生成 Jest 的基礎配置檔案 <code>jest.config.js</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> jest --init</span><br></code></pre></td></tr></table></figure><p>因為我沒有在 global 安裝 <code>jest</code>，所以需要透過 <code>yarn</code> 來執行 Jest CLI (或是可透過 <code>npx</code> 來執行)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn <span class="hljs-built_in">test</span> --init</span><br>yarn run v1.21.1<br><span class="hljs-meta">$</span><span class="bash"> jest --init</span><br><br>The following questions will help Jest to create a suitable configuration for your project<br><br>✔ Choose the test environment that will be used for testing › node<br>✔ Do you want Jest to add coverage reports? … yes<br>✔ Automatically clear mock calls and instances between every test? … no<br><br>📝  Configuration file created at /home/titan/.local/share/Trash/files/jest.config.js<br>Done in 7.41s.<br></code></pre></td></tr></table></figure><p>第一個問題我選擇 <code>node</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">? Choose the test environment that will be used for testing › - Use arrow-keys. Return to submit.<br>❯   node<br>    jsdom (browser-like)<br></code></pre></td></tr></table></figure><p>第二個問題：是否要測試涵蓋報告 (coverage reports)？我選擇 <code>yes</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">? Do you want Jest to add coverage reports? › (y/N)<br></code></pre></td></tr></table></figure><p>第三個問題：是否要在每個測試之間自動清除 mock calls 和 instance？我選擇 <code>No</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">? Automatically clear mock calls and instances between every test? › (y/N)<br></code></pre></td></tr></table></figure><p>下面是剛剛執行 <code>jest init</code> 時，所生成的 <code>jest.config.js</code> 設定：</p><ul><li><code>coverageDirectory</code>：Jest 輸出的 coverage 檔案要放在哪個目錄<ul><li>預設：<code>undefined</code></li></ul></li><li><code>testEnvironment</code>：用於測試的測試環境<ul><li>預設：<code>&quot;jsdom&quot;</code> (類似瀏覽器的環境)</li><li>若要建置 node service，可用 <code>&quot;node&quot;</code> 來使用類似 node 的環境</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  coverageDirectory: <span class="hljs-string">"coverage"</span>,<br>  testEnvironment: <span class="hljs-string">"node"</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>更多 Jest 配置設定，詳情可參閱 <a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">Configuring Jest · Jest</a>。</p></blockquote><h1 id="使用-Babel"><a class="header-anchor" href="#使用-Babel"></a>使用 Babel</h1><p>在安裝 Babel 前，將程式碼改成 ES6 語法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// sum.js</span><br><span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> sum;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> sum <span class="hljs-keyword">from</span> <span class="hljs-string">'./sum'</span>;<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// sum.test.js</span><br><span class="hljs-keyword">import</span> sum <span class="hljs-keyword">from</span> <span class="hljs-string">'./sum'</span>;<br><br>test(<span class="hljs-string">'adds 1 + 2 to equal 3'</span>, () =&gt; &#123;<br>  <span class="hljs-comment">// Arrange</span><br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">let</span> expected = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-comment">// Act</span><br>  <span class="hljs-keyword">let</span> actual = sum(x, y);<br><br>  <span class="hljs-comment">// Assert</span><br>  expect(actual).toBe(expected);<br>&#125;);<br></code></pre></td></tr></table></figure><p>跑測試會出錯，因為 Jest 需要透過 Babel 才能執行 ES6 的語法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-build-test-env/2020-05-24-23-17-50.png" alt=""></p><p>所以來安裝 <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add -D babel-jest @babel/core @babel/preset-env</span><br></code></pre></td></tr></table></figure><p>在專案根目錄建立 <code>babel.config.js</code>，此檔案用於配置與你當前 Node 版本相容的 Babel：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// babel.config.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  presets: [<br>    [<br>      <span class="hljs-string">'@babel/preset-env'</span>,<br>      &#123;<br>        targets: &#123;<br>          node: <span class="hljs-string">'current'</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>再跑測試就會通過：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p><img src="../images/jest-build-test-env/2020-05-24-23-24-29.png" alt=""></p><blockquote><p>詳情可參閱 <a href="https://babeljs.io/docs/en/" target="_blank" rel="noopener">Babel 官方文件</a>。</p></blockquote><p>資料來源：</p><ul><li><a href="https://jestjs.io/docs/en/getting-started" target="_blank" rel="noopener">Getting Started · Jest</a></li><li><a href="https://jestjs.io/docs/en/cli" target="_blank" rel="noopener">Jest CLI Options · Jest</a></li><li><a href="https://jestjs.io/docs/en/configuration" target="_blank" rel="noopener">Configuring Jest · Jest</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/jest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;最近在學習單元測試，而 Jest 是在前端蠻常見的測試框架，可透過建立測試來確保自己寫的程式碼是否符合需求，而且當改動程式碼時，才能確保是否因不小心而產生的 bug，測試能讓我更有信心的去重構程式碼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Testing" scheme="https://titangene.github.io/categories/testing/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Jest" scheme="https://titangene.github.io/tags/jest/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Node.js" scheme="https://titangene.github.io/tags/node-js/"/>
    
      <category term="Babel" scheme="https://titangene.github.io/tags/babel/"/>
    
      <category term="Unit Testing" scheme="https://titangene.github.io/tags/unit-testing/"/>
    
  </entry>
  
  <entry>
    <title>Sass：@import rule</title>
    <link href="https://titangene.github.io/article/sass-import-rule.html"/>
    <id>https://titangene.github.io/article/sass-import-rule.html</id>
    <published>2020-05-17T15:54:46.000Z</published>
    <updated>2020-05-17T15:53:41.487Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/sass.jpg" alt=""></p><p>Sass 的 <code>@import</code> rule 可以引入 Sass 和 CSS stylesheet、提供對 mixin、function 和變數的存取，並且還能將多個 stylesheet 的 CSS 組合在一起。例如：<code>main.scss</code> 內使用 <code>@import</code> 引入 Sass 和 CSS 檔，在編譯 Sass 後，就只會產生一個 <code>main.css</code> 檔。</p><a id="more"></a><p>而 CSS 本身提供的 <code>@import</code> rule 會讓瀏覽器在呈現頁面時，有幾個 CSS 檔案是透過 <code>@import</code> 引入的，就要發出幾個 HTTP request，這與 Sass <code>@import</code> rule 的行為不同。</p><h2 id="同時引入多個檔案"><a class="header-anchor" href="#同時引入多個檔案"></a>同時引入多個檔案</h2><p>雖然 Sass 和 CSS 的引入語法相同，但 Sass 可以用逗號分隔，一次引入多個檔案，不需要每個檔案都各別用一行 <code>@import</code> 引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; _button.scss<br>.button &#123; color: #aaa; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; _nav.scss<br>.nav &#123; color: #bbb; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; main.scss<br>@import &#39;button&#39;, &#39;nav&#39;;<br><br>main &#123; color: #000; &#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>; &#125;<br><span class="hljs-selector-class">.nav</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#bbb</span>; &#125;<br><span class="hljs-selector-tag">main</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>; &#125;<br></code></pre></td></tr></table></figure><p>當 Sass 引入檔案時，會對該檔案進行估算，很像是將內容直接抄在你使用 <code>@import</code> 的位置上。</p><p>在 <code>@import</code> 之前定義的任何 mixin、function 或變數 (甚至來自其他 <code>@import</code> 的) 都可以在你引入的 stylesheet 中使用他們。</p><h2 id="不要重複引入"><a class="header-anchor" href="#不要重複引入"></a>不要重複引入</h2><p>所以若對同一個檔案引入多次，就會造成編譯出來的 CSS 檔案內，會有重複的 stylesheet。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; main.scss<br>@import &#39;button&#39;;<br>@import &#39;button&#39;;<br><br>main &#123; color: #000; &#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>; &#125;<br><span class="hljs-selector-class">.button</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>; &#125;<br><span class="hljs-selector-tag">main</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>; &#125;<br></code></pre></td></tr></table></figure><p>除非你重複引入的檔案內，只有像是 mixin、function 或變數等不會產生樣式規則的東西，就不會產生重複的內容。</p><h2 id="引入不用寫副檔名"><a class="header-anchor" href="#引入不用寫副檔名"></a>引入不用寫副檔名</h2><p>另外，使用 Sass 的 <code>@import</code> rule 時，不用寫檔案的副檔名，因為 Sass 會自動幫你引入。</p><p>例如：當你引入 <code>@import &quot;a&quot;</code> 時，Sass 會自動引入 <code>a.scss</code>、<code>a.sass</code> 或 <code>a.css</code>。但 CSS 本身提供的 <code>@import</code> rule 記得要寫檔案的副檔名才能正確的引入。</p><h2 id="引入路徑"><a class="header-anchor" href="#引入路徑"></a>引入路徑</h2><ul><li>在引入 partials (以 <code>_</code> 為開頭的檔案) 時，不用寫 <code>_</code> 就能引入，且該檔案不會被編譯</li><li>引入檔案時可省略 <code>./</code> 相對引入</li><li>在使用 Sass CLI 時，若有提供 <code>--load-path</code> 或 <code>-I</code> option，就可以簡化引入的路徑<ul><li>詳情可參閱我之前寫的 <a href="https://titangene.github.io/article/dart-sass.html#load-path%EF%BC%8C-I">Dart Sass 介紹 (使用與安裝)</a></li><li>但引入時，Sass 會先解析相對於當前檔案的路徑，若沒有找到時，才會引入相對於 <code>--load-path</code> 提供的路徑內的檔案</li></ul></li></ul><p>例如：在 <code>node_modules/bootstrap/scss</code> 目錄內正好有名為 <code>_button.scss</code> 的檔案，而我引入了 <code>@import 'buttons'</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; src&#x2F;_buttons.scss<br>.button &#123; color: blue; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; src&#x2F;main.scss<br>@import &#39;buttons&#39;;<br><br>main &#123; color: #000; &#125;<br></code></pre></td></tr></table></figure><p>編譯 Sass (注意，我使用了 <code>--load-path</code> option，指定了 Bootstrap 內的路徑)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --load-path=node_modules/bootstrap/scss src/main.scss</span><br></code></pre></td></tr></table></figure><p>但輸出的結果表名，我引入的 <code>@import 'buttons'</code> 指的是 <code>src/_buttons.scss</code> 這個檔案，而不是 <code>node_modules/bootstrap/scss</code> 目錄內的 <code>_button.scss</code> 這個檔案：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123; <span class="hljs-attribute">color</span>: blue; &#125;<br><span class="hljs-selector-tag">main</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>; &#125;<br></code></pre></td></tr></table></figure><p>因為在 <code>src</code> 目錄內，<code>_buttons.scss</code> 相對於 <code>main.scss</code>，所以不會引用到 Bootstrap 內的檔案。</p><h2 id="index-檔案"><a class="header-anchor" href="#index-檔案"></a>index 檔案</h2><p>若在資料夾 (例如：<code>base</code> 資料夾) 內建立 <code>_index.scss</code> 或 <code>_index.sass</code> 檔案，而 index 檔案內引入了該資料夾內的其他檔案 (例如：<code>_code.scss</code> 和 <code>_list.scss</code> ) 時，則可直接透過 <code>@import</code> 該資料夾來引入那些檔案。</p><p>目錄結構：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree</span><br>.<br>├── base<br>│   ├── _code.scss<br>│   ├── _index.scss<br>│   └── _list.scss<br>└── main.scss<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; base&#x2F;_code.scss<br>code &#123; padding: 4px; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; base&#x2F;_list.scss<br>ul &#123; padding: 0; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; base&#x2F;_index.scss<br>@import &#39;code&#39;, &#39;list&#39;;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; main.scss<br>@import &#39;base&#39;;<br><br>main &#123; color: #000; &#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">code</span> &#123; <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>; &#125;<br><span class="hljs-selector-tag">ul</span> &#123; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>; &#125;<br><span class="hljs-selector-tag">main</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>; &#125;<br></code></pre></td></tr></table></figure><h2 id="巢狀引入"><a class="header-anchor" href="#巢狀引入"></a>巢狀引入</h2><p>也可以巢狀引入，但要注意的是在巢狀引入 (nested import) 中定義的 mixin、function 或變數都還是全域定義的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; _button.scss<br>.button &#123; color: #aaa; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; main.scss<br>main &#123;<br>  @import &#39;a&#39;;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span> <span class="hljs-selector-class">.button</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>; &#125;<br></code></pre></td></tr></table></figure><p>若是巢狀引入的檔案內有使用 parent selectors (也就是 <code>&amp;</code> )，則會引用 stylesheet 巢狀在其中的選擇器 (估算的方式類似 mixin)，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; _theme.scss<br>ul li &#123;<br>  padding-left: 16px;<br><br>  [dir&#x3D;rtl] &amp; &#123;<br>    padding-left: 0;<br>    padding-right: 16px;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">&#x2F;&#x2F; style.scss<br>.theme-sample &#123;<br>  @import &#39;theme&#39;;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.theme-sample</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">16px</span>;<br>&#125;<br><span class="hljs-selector-attr">[dir=rtl]</span> <span class="hljs-selector-class">.theme-sample</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">16px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引入-CSS"><a class="header-anchor" href="#引入-CSS"></a>引入 CSS</h2><p>Sass 的 <code>@import</code> rule 除了可以引入 <code>.scss</code> 和 <code>.sass</code> 檔，也可以引入 <code>.css</code> 檔。</p><p>但要記得在引入 <code>.css</code> 檔時，不可以像 <code>@import 'file.css';</code> 這樣明確的寫你引入了 <code>.css</code> 檔，而是要忽略副檔名。因為當你明確的寫 <code>.css</code> 副檔名時，代表你想用 <a href="https://sass-lang.com/documentation/at-rules/import#plain-css-imports" target="_blank" rel="noopener">CSS 原本的 <code>@import</code> rule</a>。</p><p>以下這些引入方式都是 CSS 原本的 <code>@import</code> rule：</p><ul><li>以 <code>.css</code> 為結尾的 URL</li><li>以 <code>http://</code> 或 <code>https://</code> 為開頭的 URL</li><li>用 <code>url()</code> 來引入 URL</li><li>具有 media query 的引入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">@import &quot;theme.css&quot;;<br>@import &quot;http:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;Droid+Sans&quot;;<br>@import url(theme);<br>@import &quot;landscape&quot; screen and (orientation: landscape);<br></code></pre></td></tr></table></figure><h2 id="Interpolation"><a class="header-anchor" href="#Interpolation"></a>Interpolation</h2><p>雖然 Sass imports 不能使用 <a href="https://sass-lang.com/documentation/interpolation" target="_blank" rel="noopener">interpolation</a>，但 CSS 原本的 <code>@import</code> 是可以的。這樣就可以動態生成引入的 URL，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sass">@mixin google-font($family) &#123;<br>  @import url(&quot;http:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;#&#123;$family&#125;&quot;);<br>&#125;<br><br>@include google-font(&quot;Droid Sans&quot;);<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">"http://fonts.googleapis.com/css?family=Droid Sans"</span>);<br></code></pre></td></tr></table></figure><p>資料來源：<a href="https://sass-lang.com/documentation/at-rules/import" target="_blank" rel="noopener">Sass: @import</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/sass.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;Sass 的 &lt;code&gt;@import&lt;/code&gt; rule 可以引入 Sass 和 CSS stylesheet、提供對 mixin、function 和變數的存取，並且還能將多個 stylesheet 的 CSS 組合在一起。例如：&lt;code&gt;main.scss&lt;/code&gt; 內使用 &lt;code&gt;@import&lt;/code&gt; 引入 Sass 和 CSS 檔，在編譯 Sass 後，就只會產生一個 &lt;code&gt;main.css&lt;/code&gt; 檔。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web Dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Sass" scheme="https://titangene.github.io/tags/sass/"/>
    
      <category term="CSS" scheme="https://titangene.github.io/tags/css/"/>
    
      <category term="Dart Sass" scheme="https://titangene.github.io/tags/dart-sass/"/>
    
  </entry>
  
  <entry>
    <title>Sass：@use rule</title>
    <link href="https://titangene.github.io/article/sass-use-rule.html"/>
    <id>https://titangene.github.io/article/sass-use-rule.html</id>
    <published>2020-05-10T15:54:48.000Z</published>
    <updated>2020-05-10T23:03:19.504Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/sass.jpg" alt=""></p><p>若要模組化 Sass，最常用的就是 <code>@import</code> 規則。但在 <a href="https://titangene.github.io/article/dart-sass.html">Dart Sass</a> 推出了一個新功能：模組系統，可用 <code>@use</code> 規則，並透過 namespace 來引入其他 stylesheet 中的成員。</p><a id="more"></a><h1 id="Overview"><a class="header-anchor" href="#Overview"></a>Overview</h1><ul><li>載入其他 Sass stylesheet 中的 mixin、函數和變數，並將多個 stylesheet 中的 CSS 組合在一起</li><li>不管用 <code>@use</code> 載入幾次的任何樣式，都只會在編譯的 CSS 輸出中出現一次</li><li><code>@use</code> 必須放在所有規則之前 (除了 <code>@forward</code> 和變數宣告之外)</li><li>便於了解成員是從哪些檔案載入的</li><li>不用像使用 <code>@import</code> 時那樣，需把命名寫清楚，因為可透過 <code>@use</code> 提供的 namespace 來避免命名衝突</li></ul><div class="info"><p>只要使用 <code>@use</code> 引入的檔案，stylesheet 就會被全部引入，不管有無另外使用。</p></div><h1 id="語法"><a class="header-anchor" href="#語法"></a>語法</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span>;<br><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> as &lt;namespace&gt;;<br><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> as *;<br><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> with (<br>  &lt;variable&gt;: &lt;value&gt;,<br>  &lt;variable&gt;: &lt;value&gt;<br>);<br></code></pre></td></tr></table></figure><h1 id="載入成員"><a class="header-anchor" href="#載入成員"></a>載入成員</h1><ul><li>用 <code>@use</code> 載入的 stylesheet 稱為「modules (模組)」。</li><li>使用 <code>@use</code> 時，可透過 namespace 來存取另一個模組中的變數、函數和 mixin：<ul><li>變數：<code>&lt;namespace&gt;.&lt;variable&gt;</code></li><li>函數：<code>&lt;namespace&gt;.&lt;function&gt;()</code></li><li>mixin：<code>@include &lt;namespace&gt;.&lt;mixin&gt;()</code></li></ul></li><li>預設的 <code>&lt;namespace&gt;</code> 就是模組 URL 的檔名 (不包含 <code>_</code> 底線前綴和副檔名)</li><li>用 <code>@use</code> 載入的成員有存取範圍，只有載入它們的 stylesheet 才能存取<ul><li>若其他 stylesheet 想存取這些成員，就必須自己寫 <code>@use</code> 載入</li></ul></li></ul><p>例如：用 <code>@use</code> 引入的 <code>styles/base/_color.scss</code> 檔案會像下面這樣，而此模組的 namespace 就是 <code>color</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/base/_color.scss</span><br><span class="hljs-variable">$blue</span>: <span class="hljs-number">#2979ff</span>;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/_tool.scss</span><br><span class="hljs-keyword">@mixin</span> rounded &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>&#125;<br><br><span class="hljs-keyword">@function</span> px2em(<span class="hljs-variable">$pixel</span>, <span class="hljs-variable">$font-size-base</span>: <span class="hljs-number">16px</span>) &#123;<br>  <span class="hljs-keyword">@return</span> (<span class="hljs-variable">$pixel</span> / <span class="hljs-variable">$font-size-base</span>) * <span class="hljs-number">1em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/main.scss</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"base/color"</span>;<br><span class="hljs-keyword">@use</span> <span class="hljs-string">"tool"</span>;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: color.<span class="hljs-variable">$blue</span>;<br>  <span class="hljs-attribute">font-size</span>: tool.px2em(<span class="hljs-number">32px</span>);<br>  <span class="hljs-keyword">@include</span> tool.rounded;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#2979ff</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="設定-namespace"><a class="header-anchor" href="#設定-namespace"></a>設定 namespace</h1><p>語法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> as &lt;namespace&gt;;<br><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> as *;<br></code></pre></td></tr></table></figure><p>自訂 namespace (很像設定 alias) 的情境：</p><ul><li>載入相同檔名的多個模組 (例如：第三方 library 和我的檔名相同)</li><li>讓模組的名稱變短</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// src/_mycolor.scss</span><br><span class="hljs-variable">$blue</span>: <span class="hljs-number">#2979ff</span>;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// src/main.scss</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"src/mycolor"</span> as color;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">color</span>: color.<span class="hljs-variable">$blue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#2979ff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可用 <code>*</code> 來載入沒有 namespace 的模組，但建議使用在自己寫的 stylesheet 或 <a href="https://sass-lang.com/documentation/modules" target="_blank" rel="noopener">Sass 提供的內建模組</a>，以避免引入名稱衝突的成員：</p><p>例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">'sass:math'</span> as *;<br><br><span class="hljs-variable">$half</span>: percentage(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>);<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$half</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="私有成員"><a class="header-anchor" href="#私有成員"></a>私有成員</h1><p>若你不想讓你定義的所有成員都可在 stylesheet 之外使用，就可在成員名稱的前面加上 <code>-</code> 或 <code>_</code>，來讓它們變成私有成員。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/_corner.scss</span><br>$_radius: <span class="hljs-number">3px</span>;<br><br><span class="hljs-keyword">@mixin</span> rounded &#123;<br>  <span class="hljs-attribute">border-radius</span>: $_radius;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/main.scss</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"corner"</span>;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: corner.rounded;<br>  <span class="hljs-attribute">padding</span>: corner.$_radius;  <span class="hljs-comment">// Error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>編譯會報錯：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npx sass styles:dict/styles</span><br>Error: Private members can't be accessed from outside their modules.<br>  ╷<br>5 │   padding: corner.$_radius;<br>  │            ^^^^^^^^^^^^^^^<br>  ╵<br>  src/scss/main.scss 5:12  root stylesheet<br></code></pre></td></tr></table></figure><h1 id="配置模組"><a class="header-anchor" href="#配置模組"></a>配置模組</h1><p>stylesheet 可用 <a href="https://sass-lang.com/documentation/variables#default-values" target="_blank" rel="noopener"><code>!default</code> flag</a> 來定義變數，會被新的值給覆蓋。</p><p>若要載入帶有配置的模組，可用以下語法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">"&lt;url&gt;"</span> with (<br>  &lt;variable&gt;: &lt;value&gt;,<br>  &lt;variable&gt;: &lt;value&gt;<br>);<br></code></pre></td></tr></table></figure><p>配置的值會覆蓋變數的預設值。</p><p>例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/base/_color.scss</span><br><span class="hljs-variable">$blue</span>: <span class="hljs-number">#2979ff</span> !default;<br><span class="hljs-variable">$red</span>: <span class="hljs-number">#f44336</span> !default;<br><br><span class="hljs-variable">$primary</span>: <span class="hljs-variable">$blue</span>;<br><span class="hljs-variable">$secondary</span>: <span class="hljs-variable">$red</span>;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// styles/main.scss</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">"base/color"</span> with (<br>  <span class="hljs-variable">$blue</span>: <span class="hljs-number">#00f</span>,<br>  <span class="hljs-variable">$red</span>: <span class="hljs-number">#f00</span><br>);<br><br><span class="hljs-selector-class">.button-primary</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: color.<span class="hljs-variable">$primary</span>;<br>&#125;<br><br><span class="hljs-selector-class">.button-secondary</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: color.<span class="hljs-variable">$secondary</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>輸出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button-primary</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00f</span>;<br>&#125;<br><br><span class="hljs-selector-class">.button-secondary</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f00</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://sass-lang.com/documentation/at-rules/use#configuring-modules" target="_blank" rel="noopener">Sass: @use</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/sass.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;若要模組化 Sass，最常用的就是 &lt;code&gt;@import&lt;/code&gt; 規則。但在 &lt;a href=&quot;https://titangene.github.io/article/dart-sass.html&quot;&gt;Dart Sass&lt;/a&gt; 推出了一個新功能：模組系統，可用 &lt;code&gt;@use&lt;/code&gt; 規則，並透過 namespace 來引入其他 stylesheet 中的成員。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web Dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Sass" scheme="https://titangene.github.io/tags/sass/"/>
    
      <category term="CSS" scheme="https://titangene.github.io/tags/css/"/>
    
      <category term="Dart Sass" scheme="https://titangene.github.io/tags/dart-sass/"/>
    
  </entry>
  
  <entry>
    <title>Dart Sass 介紹 (使用與安裝)</title>
    <link href="https://titangene.github.io/article/dart-sass.html"/>
    <id>https://titangene.github.io/article/dart-sass.html</id>
    <published>2020-05-03T15:54:55.000Z</published>
    <updated>2020-05-10T23:03:26.624Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/sass.jpg" alt=""></p><p><a href="https://github.com/sass/dart-sass" target="_blank" rel="noopener">Dart Sass</a> 是 Sass 的主要實作，過去常見的是 Ruby Sass，而現今 <a href="https://sass-lang.com/ruby-sass" target="_blank" rel="noopener">Sass 官方推薦大家改用 Dart Sass</a>，尤其是用 JavaScript 或 Node.js 開發的相關專案。</p><a id="more"></a><p>Dart Sass 是 Sass 的 Dart 實作，效能比 Ruby Sass 還要快，且易於安裝，還可編譯成純 JavaScript，讓我們可以輕鬆的整合至現有的 Web 開發工作流程中。</p><h1 id="安裝"><a class="header-anchor" href="#安裝"></a>安裝</h1><p>有多種安裝和執行 Dart Sass 的方法：</p><h2 id="Standalone"><a class="header-anchor" href="#Standalone"></a>Standalone</h2><p>從 <a href="https://github.com/sass/dart-sass/releases/" target="_blank" rel="noopener">GitHub Release 頁面</a>下載適用於你 OS 的 standalone Dart Sass archive，其中包含 Dart VM 和 executable 的 snapshot。</p><p>使用方法很簡單，下載後並解壓縮，將解壓縮後的目錄新增至 <code>PATH</code> (<a href="https://katiek2.github.io/path-doc/" target="_blank" rel="noopener">這篇</a> 提供各 OS 如何設定 <code>PATH</code> 的步驟)，接著重新啟動 terminal，然後就能執行 <code>sass</code> executable 開始使用！</p><h2 id="npm"><a class="header-anchor" href="#npm"></a>npm</h2><p>可透過 npm 安裝 <a href="https://www.npmjs.com/package/sass" target="_blank" rel="noopener">Dart Sass</a>，該套件是已編譯為 JavaScript，且沒有任何 native code 或外部依賴。提供 command-line <code>sass</code> executable 和 Node.js API。</p><p>全域安裝：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -g sass</span><br></code></pre></td></tr></table></figure><p>local 安裝：新增至專案</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm init -y</span><br><span class="hljs-meta">$</span><span class="bash"> npm install --save-dev sass</span><br></code></pre></td></tr></table></figure><div class="info"><p>其餘的安裝方式可參考 <a href="https://github.com/sass/dart-sass#using-dart-sass" target="_blank" rel="noopener">Dart Sass GitHub Repo 的 README 說明</a>。</p></div><h1 id="為何用-Dart？"><a class="header-anchor" href="#為何用-Dart？"></a>為何用 Dart？</h1><p>在 <a href="https://github.com/sass/dart-sass#why-dart" target="_blank" rel="noopener">Dart Sass GitHub Repo</a> 的 README 有提到為何 Dart Sass 會取代 Ruby Sass，有以下幾個優點：</p><ul><li>效能快：比 Ruby 塊，且與 C++ 差不多</li><li>免安裝：<ul><li>Dart VM 沒有外部依賴，可將應用程式編譯成獨立的 snapshot 檔案，因此可將 Dart Sass 只需發佈三個檔案 (VM、snapshot 和 wrapper script)</li><li>可編譯成 JavaScript，所以可透過 npm 發佈</li></ul></li><li>容易寫：<ul><li>Dart 是比 C++ 更高級的語言，不需要太多的記憶體管理和建制系統的麻煩</li><li>Dart 是靜態型別 (statically typed)，與 Ruby 相比 可更容易的進行大型重構</li></ul></li><li>對貢獻者更友好：<ul><li>Dart 比 Ruby 更容易學習</li></ul></li></ul><h1 id="Command-Line"><a class="header-anchor" href="#Command-Line"></a>Command Line</h1><p>Dart Sass executable 有兩種使用模式：</p><ul><li>One-to-One Mode (一對一模式)</li><li>Many-to-many Mode (多對多模式)</li></ul><h2 id="One-to-One-Mode"><a class="header-anchor" href="#One-to-One-Mode"></a>One-to-One Mode</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass &lt;input.scss&gt; [output.css]</span><br></code></pre></td></tr></table></figure><ul><li>一個輸入檔 ( <code>input.scss</code> ) 編譯成一個輸出檔 ( <code>output.scss</code> )</li><li>若為提供輸出路徑，會將已編譯的 CSS 列印至 terminal 上</li><li>若輸入檔的副檔名是：<ul><li><code>.scss</code>：解析成 <a href="https://sass-lang.com/documentation/syntax#scss" target="_blank" rel="noopener">SCSS</a></li><li><code>.sass</code>：解析成 <a href="https://sass-lang.com/documentation/syntax#the-indented-syntax" target="_blank" rel="noopener">縮排語法 (indented syntax)</a></li><li><code>.css</code>：解析成 <a href="https://sass-lang.com/documentation/at-rules/import#importing-css" target="_blank" rel="noopener">純 CSS</a></li><li>若都不是以上三種，或來至標準輸入，預設會解析成 SCSS<ul><li>也可用 <code>--indented</code> flag 來控制輸出格式</li></ul></li></ul></li></ul><h2 id="Many-to-many-Mode"><a class="header-anchor" href="#Many-to-many-Mode"></a>Many-to-many Mode</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass [&lt;input.css&gt;:&lt;output.css&gt;] [&lt;input/&gt;:&lt;output/&gt;]...</span><br></code></pre></td></tr></table></figure><ul><li>一個或多個輸入檔編譯成一個或多個輸出檔</li><li>輸入和輸出用 <code>:</code> 字元來隔開</li><li>可將目錄中的所有 Sass 檔編譯為另一個目錄中具有相同名稱的 CSS 檔</li></ul><p>例如：</p><p>將 <code>style.scss</code> 編譯成 <code>style.css</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass style.scss:style.css</span><br></code></pre></td></tr></table></figure><p>將 <code>light.scss</code> 和 <code>dark.scss</code> 編譯成 <code>light.css</code> 和 <code>dark.css</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass light.scss:light.css dark.scss:dark.css</span><br></code></pre></td></tr></table></figure><p>將 <code>src/scss/</code> 目錄內的所有 Sass 檔編譯至 <code>public/css/</code> 目錄中，且會編譯成 CSS 檔：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass src/scss:public/css</span><br></code></pre></td></tr></table></figure><div class="info"><p>編譯整個目錄時，如果只想編譯出一個 CSS 檔案 (例如：<code>main.css</code> )，就要將主要檔案之外的其他檔案的名稱，改為以 <code>_</code> 為開頭的 (例如：<code>_color.scss</code>，這種檔案被稱為 <a href="https://sass-lang.com/documentation/at-rules/import#partials" target="_blank" rel="noopener">partial 檔案</a>)。</p></div><h2 id="CLI-option"><a class="header-anchor" href="#CLI-option"></a>CLI option</h2><h3 id="indented"><a class="header-anchor" href="#indented"></a><code>--indented</code></h3><p>指定輸入檔要解析成縮排語法 (indented syntax)</p><h3 id="load-path，-I"><a class="header-anchor" href="#load-path，-I"></a><code>--load-path</code>，<code>-I</code></h3><ul><li>新增額外的載入路徑來查找 stylesheet</li><li>此 option 可使用多次，代表提供多個載入路徑</li><li>最先載入的會優先於較晚載入的路徑</li></ul><p>例如：如果沒有使用 <code>--load-path</code> option，要 import Bootstrap 就必須使用很長的路徑：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">"../node_modules/bootstrap/scss/functions"</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">"../node_modules/bootstrap/scss/variables"</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">"../node_modules/bootstrap/scss/mixins"</span>;<br></code></pre></td></tr></table></figure><p>若使用 <code>--load-path</code> option，就能簡短 import Bootstrap 的路徑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --load-path=node_modules src/main.scss dist/main.css</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">"bootstrap/scss/functions"</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">"bootstrap/scss/variables"</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">"bootstrap/scss/mixins"</span>;<br></code></pre></td></tr></table></figure><h3 id="style，-s"><a class="header-anchor" href="#style，-s"></a><code>--style</code>，<code>-s</code></h3><p>指定 CSS 的輸出樣式。</p><p>Dart Sass 支援兩種輸出樣式：</p><ul><li><code>expanded</code>：預設，將每個選擇器和宣告寫在自己的那行上</li><li><code>compressed</code>：刪除盡可能多的多餘字元，並將整個 stylesheet 寫成一行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --style=expanded style.scss</span><br>h1 &#123;<br>  font-size: 40px;<br>&#125;<br><br><span class="hljs-meta">$</span><span class="bash"> sass --style=compressed style.scss</span><br>h1&#123;font-size:40px&#125;<br></code></pre></td></tr></table></figure><h3 id="error-css"><a class="header-anchor" href="#error-css"></a><code>--error-css</code></h3><ul><li>當編譯期間發生錯誤時，會告訴 Sass 是否 emit CSS 檔案</li><li>該 CSS 檔會在註解和 <code>body::before</code> 的 <code>content</code> property 中描述錯誤<ul><li>可在瀏覽器中察看錯誤訊息，而不會切回 terminal 察看</li></ul></li><li>預設若要編譯至少一個檔案 (不是標準輸出)，就會啟用 error CSS<ul><li>可在編譯成標準輸出時加上 <code>--error-css</code> 來啟用 error CSS</li><li>也可以加上 <code>--no-error-css</code> 來禁用 error CSS</li></ul></li><li>禁用 error CSS 後，<code>--update</code> flag 和 <code>--watch</code> flag 會在發生錯誤時刪除 CSS 檔案</li></ul><p>例如：以下 Sass 檔的內容是錯誤的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// main.scss</span><br><span class="hljs-variable">$width</span>: <span class="hljs-number">15px</span> + <span class="hljs-number">2em</span>;<br></code></pre></td></tr></table></figure><p>編譯此 Sass 檔會出現以下錯誤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --error-css main.scss main.css</span><br>Error: Incompatible units em and px.<br>  ╷<br>1 │ $width: 15px + 2em;<br>  │         ^^^^^^^^^^<br>  ╵<br>  test.scss 1:9  root stylesheet<br></code></pre></td></tr></table></figure><p>而輸出的 <code>main.css</code> 檔的內容如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* Error: Incompatible units em and px.</span><br><span class="hljs-comment"> *   ,</span><br><span class="hljs-comment"> * 1 | $width: 15px + 2em;</span><br><span class="hljs-comment"> *   |         ^^^^^^^^^^</span><br><span class="hljs-comment"> *   '</span><br><span class="hljs-comment"> *   test.scss 1:9  root stylesheet */</span><br><br><span class="hljs-selector-tag">body</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"Source Code Pro"</span>, <span class="hljs-string">"SF Mono"</span>, Monaco, Inconsolata, <span class="hljs-string">"Fira Mono"</span>,<br>      <span class="hljs-string">"Droid Sans Mono"</span>, monospace, monospace;<br>  <span class="hljs-attribute">white-space</span>: pre;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">1em</span>;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">"Error: Incompatible units em and px.\a   \2577 \a 1 \2502  $width: 15px + 2em;\a   \2502          ^^^^^^^^^^\a   \2575 \a   test.scss 1:9  root stylesheet"</span>;         <br>&#125;<br></code></pre></td></tr></table></figure><p>若用瀏覽器察看使用此 <code>main.css</code> 檔的頁面會像下圖這樣：</p><p><img src="../images/dart-sass/error-css.png" alt=""></p><h3 id="update"><a class="header-anchor" href="#update"></a><code>--update</code></h3><ul><li>當 stylesheets 的依賴更新時，Sass 就只會編譯 stylesheets</li><li>更新 stylesheets 時，會列印狀態訊息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --update themes:public/css</span><br>Compiled themes/light.scss to public/css/light.css.<br></code></pre></td></tr></table></figure><h3 id="watch"><a class="header-anchor" href="#watch"></a><code>--watch</code></h3><p>類似 <code>--update</code>，但是在完成第一次編譯後，Sass 保持 open 狀態，並在 stylesheets 或其依賴發生更改時繼續編譯 stylesheets。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --watch themes:public/css</span><br>Compiled themes/light.scss to public/css/light.css.<br><br><span class="hljs-meta">#</span><span class="bash"> Then when you edit themes/dark.scss...</span><br>Compiled themes/dark.scss to public/css/dark.css.<br></code></pre></td></tr></table></figure><h2 id="常用的-option"><a class="header-anchor" href="#常用的-option"></a>常用的 option</h2><p>開發用：</p><ul><li><code>--watch</code>：watch 模式</li><li><code>-I node_modules</code>：新增額外載入的 <code>node_modules</code> 目錄</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass --watch -I node_modules src/scss:dict/styles</span><br></code></pre></td></tr></table></figure><p>部署用 (build)：</p><ul><li><code>-s compressed</code>：CSS Minifier</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sass -s compressed src/scss:dict/styles</span><br></code></pre></td></tr></table></figure><div class="info"><p>更多 CLI option 可參閱 <a href="https://sass-lang.com/documentation/cli/dart-sass" target="_blank" rel="noopener">Sass 文件</a>。</p></div><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://github.com/sass/dart-sass#using-dart-sass" target="_blank" rel="noopener">sass/dart-sass: The reference implementation of Sass, written in Dart.</a></li><li><a href="https://sass-lang.com/ruby-sass" target="_blank" rel="noopener">Sass: Ruby Sass</a></li><li><a href="https://www.npmjs.com/package/sass" target="_blank" rel="noopener">sass - npm</a></li><li><a href="https://sass-lang.com/install" target="_blank" rel="noopener">Sass: Install Sass</a></li><li><a href="https://www.dart-china.org/t/topic/146" target="_blank" rel="noopener">CSS 預處理器 Sass 的預設實作將遷移到 Dart Sass - 分享 - Dart 中文社區</a></li><li><a href="https://sass-lang.com/documentation/cli/dart-sass" target="_blank" rel="noopener">Sass: Dart Sass Command-Line Interface</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/sass.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/sass/dart-sass&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dart Sass&lt;/a&gt; 是 Sass 的主要實作，過去常見的是 Ruby Sass，而現今 &lt;a href=&quot;https://sass-lang.com/ruby-sass&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sass 官方推薦大家改用 Dart Sass&lt;/a&gt;，尤其是用 JavaScript 或 Node.js 開發的相關專案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web Dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="Dart" scheme="https://titangene.github.io/tags/dart/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="Sass" scheme="https://titangene.github.io/tags/sass/"/>
    
      <category term="CSS" scheme="https://titangene.github.io/tags/css/"/>
    
      <category term="Dart Sass" scheme="https://titangene.github.io/tags/dart-sass/"/>
    
      <category term="CLI" scheme="https://titangene.github.io/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>npm / Yarn 套件管理器指令比對 cheatsheet</title>
    <link href="https://titangene.github.io/article/npm-and-yarn-cheatsheet.html"/>
    <id>https://titangene.github.io/article/npm-and-yarn-cheatsheet.html</id>
    <published>2020-04-26T11:36:11.000Z</published>
    <updated>2020-05-03T14:05:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/npm_yarn.jpg" alt=""></p><p>npm 或 Yarn 都是最常見的 Node.js 套件管理器。本篇紀錄兩個 CLI 對應的指令。</p><a id="more"></a><h2 id="建立新專案"><a class="header-anchor" href="#建立新專案"></a>建立新專案</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm init</span><br><span class="hljs-meta">$</span><span class="bash"> npm init -y</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn init</span><br><span class="hljs-meta">$</span><span class="bash"> yarn init -y</span><br></code></pre></td></tr></table></figure><h2 id="安裝專案-package-json-中的所有相依套件"><a class="header-anchor" href="#安裝專案-package-json-中的所有相依套件"></a>安裝專案 <code>package.json</code> 中的所有相依套件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn</span><br><span class="hljs-meta">$</span><span class="bash"> yarn install</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install</span><br><span class="hljs-meta">$</span><span class="bash"> npm i</span><br></code></pre></td></tr></table></figure><h2 id="安裝相依套件"><a class="header-anchor" href="#安裝相依套件"></a>安裝相依套件</h2><p>安裝相依套件，並將套件新增至不同類型的 <code>dependencies</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm i &lt;package&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt;@&lt;version&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt;@&lt;tag&gt;</span><br></code></pre></td></tr></table></figure><p>安裝套件並將此套件儲存至 <code>package.json</code> 中的 <code>dependencies</code> (目前 npm 的預設參數，不需加 <code>-S</code> 就有此功能，舊版 npm 需要加此 option 才會將安裝的套件存至 <code>package.json</code> )：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; --save</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; -S</span><br></code></pre></td></tr></table></figure><h3 id="新增至不同類型的-dependencies"><a class="header-anchor" href="#新增至不同類型的-dependencies"></a>新增至不同類型的 dependencies</h3><p>安裝相依套件，並將套件新增至不同類型的 <code>devDependencies</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; --save-dev</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; -D</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; --dev</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; -D</span><br></code></pre></td></tr></table></figure><p>安裝相依套件，並將套件新增至不同類型的 <code>optionalDependencies</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; --save-optional</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; -O</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; --optional</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; -O</span><br></code></pre></td></tr></table></figure><p>安裝相依套件，並將套件新增至不同類型的 <code>bundleDependencies</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; --save-bundle</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; -B</span><br></code></pre></td></tr></table></figure><p>安裝相依套件，並將套件新增至不同類型的 <code>peerDependencies</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; --peer</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; -P</span><br></code></pre></td></tr></table></figure><blockquote><p>不同類型的 dependencies 可參閱 <a href="https://classic.yarnpkg.com/zh-Hant/docs/dependency-types/" target="_blank" rel="noopener">Yarn 官方文件中的「依賴關係的種類」</a> 這篇。</p></blockquote><h3 id="安裝指定版本"><a class="header-anchor" href="#安裝指定版本"></a>安裝指定版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; --save-exact</span><br><span class="hljs-meta">$</span><span class="bash"> npm install &lt;package&gt; -E</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; --exact</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; -E</span><br></code></pre></td></tr></table></figure><h3 id="安裝次版號的最新版"><a class="header-anchor" href="#安裝次版號的最新版"></a>安裝次版號的最新版</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; --tilde</span><br><span class="hljs-meta">$</span><span class="bash"> yarn add &lt;package&gt; -T</span><br></code></pre></td></tr></table></figure><h3 id="在全域安裝套件"><a class="header-anchor" href="#在全域安裝套件"></a>在全域安裝套件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install -g &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn global add &lt;package&gt;</span><br></code></pre></td></tr></table></figure><h2 id="升級相依套件"><a class="header-anchor" href="#升級相依套件"></a>升級相依套件</h2><p>升級目前專案的相依套件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm update</span><br><span class="hljs-meta">$</span><span class="bash"> npm update &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn upgrade</span><br><span class="hljs-meta">$</span><span class="bash"> yarn upgrade &lt;package&gt;</span><br></code></pre></td></tr></table></figure><p>全域的相依套件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm update -g</span><br><span class="hljs-meta">$</span><span class="bash"> npm update -g &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn global upgrade</span><br><span class="hljs-meta">$</span><span class="bash"> yarn global upgrade &lt;package&gt;</span><br></code></pre></td></tr></table></figure><h3 id="升級至最新版"><a class="header-anchor" href="#升級至最新版"></a>升級至最新版</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn upgrade &lt;package&gt; --latest</span><br></code></pre></td></tr></table></figure><h2 id="升級相依套件可選擇是否升級"><a class="header-anchor" href="#升級相依套件可選擇是否升級"></a>升級相依套件可選擇是否升級</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn upgrade-interactive &lt;package&gt;</span><br></code></pre></td></tr></table></figure><h2 id="刪除套件"><a class="header-anchor" href="#刪除套件"></a>刪除套件</h2><p>刪除目前專案的相依套件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm uninstall &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn remove &lt;package&gt;</span><br></code></pre></td></tr></table></figure><p>刪除全域的相依套件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm uninstall -g &lt;package&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn global remove &lt;package&gt;</span><br></code></pre></td></tr></table></figure><h2 id="列出已安裝的套件"><a class="header-anchor" href="#列出已安裝的套件"></a>列出已安裝的套件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm ls</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yarn list</span><br></code></pre></td></tr></table></figure><p>資料來源</p><ul><li><a href="https://classic.yarnpkg.com/zh-Hant/docs/migrating-from-npm" target="_blank" rel="noopener">migrating from npm | Yarn</a></li><li><a href="https://classic.yarnpkg.com/zh-Hant/docs/cli/add" target="_blank" rel="noopener">yarn add | Yarn</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/npm_yarn.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;npm 或 Yarn 都是最常見的 Node.js 套件管理器。本篇紀錄兩個 CLI 對應的指令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web Dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="CLI" scheme="https://titangene.github.io/tags/cli/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Node.js" scheme="https://titangene.github.io/tags/node-js/"/>
    
      <category term="version manager" scheme="https://titangene.github.io/tags/version-manager/"/>
    
      <category term="npm" scheme="https://titangene.github.io/tags/npm/"/>
    
      <category term="Yarn" scheme="https://titangene.github.io/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>nvm：安裝、切換不同 Node.js 版本的管理器</title>
    <link href="https://titangene.github.io/article/nvm.html"/>
    <id>https://titangene.github.io/article/nvm.html</id>
    <published>2020-04-19T15:56:52.000Z</published>
    <updated>2020-05-03T14:05:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/node.jpg" alt=""></p><p>nvm 是 Node.js 的版本管理器 (version manager)，可在同一台主機上安裝多個版本的 Node.js 環境，因為不同專案可能會使用不同的 Node.js 版本，那就需要透過一個版本管理器來切換不同的 Node.js 版本。</p><a id="more"></a><h2 id="安裝-NVM"><a class="header-anchor" href="#安裝-NVM"></a>安裝 NVM</h2><p>可用 <code>cURL</code> 或 <code>wget</code> 指令使用安裝腳本安裝或更新 nvm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br></code></pre></td></tr></table></figure><p>此安裝腳本會將 nvm repo clone 到 <code>~/.nvm</code>，並且將 source line 新增至你的 profile 設定 ( <code>~/.bash_profile</code>、<code>~/.zshrc</code>、<code>~/.profile</code> 或 <code>~/.bashrc</code> )：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NVM_DIR=<span class="hljs-string">"<span class="hljs-variable">$HOME</span>/.nvm"</span><br>[ -s <span class="hljs-string">"<span class="hljs-variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="hljs-string">"<span class="hljs-variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="hljs-comment"># This loads nvm</span><br>[ -s <span class="hljs-string">"<span class="hljs-variable">$NVM_DIR</span>/bash_completion"</span> ] &amp;&amp; \. <span class="hljs-string">"<span class="hljs-variable">$NVM_DIR</span>/bash_completion"</span>  <span class="hljs-comment"># This loads nvm bash_completion</span><br></code></pre></td></tr></table></figure><p>如果在 Linux 執行安裝腳本後，執行下面指令會顯示以下訊息或沒有任何訊息時，建議重開一個新的終端機 (terminal) 再重新執行一次 <code>nvm</code> 指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">command</span> -v nvm</span><br>nvm: command not found<br></code></pre></td></tr></table></figure><p>如果還是無法使用 nvm，可執行下面指令立即應用 ZSH 的設定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">source</span> .zshrc</span><br></code></pre></td></tr></table></figure><div class="warning"><p>注意：</p><ul><li>使用 <code>nvm</code> 時，不需要 <code>sudo</code> 即可使用 <code>npm -g</code> 全域安裝模組，所以與其執行 <code>sudo npm i -g</code>，不如執行 <code>npm i -g</code></li><li>若你有 <code>~/.npmrc</code>，請確保裡面不包含任何 <code>prefix</code> 的設定 (因為與 <code>nvm</code> 不相容)</li><li>你可以 (但不應該) 保留以前在 “系統” 安裝的 Node.js，但 <code>nvm</code> 只對你的使用者帳戶 (用於安裝 <code>nvm</code> 的使用者帳戶) 可用。可能會導致版本不 match，因為其他使用者會使用 <code>/usr/local/lib/node_modules/*</code>，而使用者帳戶會使用 <code>~/.nvm/versions/node/vX.X.X/lib/node_modules/*</code></li></ul></div><h2 id="version：確認-NVM-是否安裝成功"><a class="header-anchor" href="#version：確認-NVM-是否安裝成功"></a><code>--version</code>：確認 NVM 是否安裝成功</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm --version</span><br>0.34.0<br></code></pre></td></tr></table></figure><h2 id="install：利用-NVM-安裝-Node-js"><a class="header-anchor" href="#install：利用-NVM-安裝-Node-js"></a><code>install</code>：利用 NVM 安裝 Node.js</h2><p>安裝 NVM 後，其實還沒安裝 Node 環境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node  </span><br>zsh: command not found: node<br></code></pre></td></tr></table></figure><p>如果執行下面指令，會提醒你需要執行 <code>install</code> 指令才能安裝 Node.js：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm use node</span><br>N/A: version "node -&gt; N/A" is not yet installed.<br><br>You need to run "nvm install node" to install it before using it.<br></code></pre></td></tr></table></figure><p>安裝最新版的 Node.js：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm install node</span><br>Downloading and installing node v12.8.1...<br>Downloading https://nodejs.org/dist/v12.8.1/node-v12.8.1-linux-x64.tar.xz...<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">################################################################################################### 100.0%</span></span><br>Computing checksum with sha256sum<br>Checksums matched!<br>Now using node v12.8.1 (npm v6.10.2)<br>Creating default alias: default -&gt; node (-&gt; v12.8.1)<br></code></pre></td></tr></table></figure><p>如果要指定安裝版本，可以直接指定版本號：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm install 8.9.1</span><br></code></pre></td></tr></table></figure><p>安裝的第一個版本的 Node.js 會成員 nvm 的預設版本，新的 shell 就會以預設版本的 Node.js 來使用 (例如：<code>nvm alias default</code>)。</p><p>查看目前安裝 Node.js 的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node -v</span><br>v12.8.1<br></code></pre></td></tr></table></figure><h2 id="ls-remote：察看可用的安裝版本"><a class="header-anchor" href="#ls-remote：察看可用的安裝版本"></a><code>ls-remote</code>：察看可用的安裝版本</h2><p>可以看目前有哪些可用版本可安裝，在版本號前面的 <code>-&gt;</code> 箭頭符號代表目前 nvm 正在使用的 Node.js 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm ls-remote</span><br>...<br>       v10.16.1   (LTS: Dubnium)<br>       v10.16.2   (LTS: Dubnium)<br>       v10.16.3   (Latest LTS: Dubnium)<br>...<br>        v12.7.0<br>        v12.8.0<br><span class="hljs-meta">-&gt;</span><span class="bash">      v12.8.1</span><br></code></pre></td></tr></table></figure><p>不過剛剛的 <code>ls-remote</code> 指令會把所有可用的版本都列出來，但通常會選擇安裝 LTS (Long-term support，長期支援) 版，所以只要加上 <code>-lts</code> 參數就可以指列出可用的 LTS 版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm ls-remote --lts</span><br>...<br>       v10.16.1   (LTS: Dubnium)<br>       v10.16.2   (LTS: Dubnium)<br>       v10.16.3   (Latest LTS: Dubnium)<br></code></pre></td></tr></table></figure><p>如果版本號的文字有特殊顏色 (不是白色字)，則代表該版本的 Node.js 有透過 nvm 安裝過，例如：我的電腦就安裝了 <code>v10.16.3</code> 和 <code>v12.8.1</code>：</p><p><img src="../images/nvm/nvm-ls-remote.png" alt=""></p><h2 id="ls：查看目前安裝了哪些版本"><a class="header-anchor" href="#ls：查看目前安裝了哪些版本"></a><code>ls</code>：查看目前安裝了哪些版本</h2><p><code>ls</code> 指令可以查看目前安裝了哪些版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm ls</span><br>       v10.16.3<br><span class="hljs-meta">-&gt;</span><span class="bash">      v12.8.1</span><br>default -&gt; node (-&gt; v12.8.1)<br>node -&gt; stable (-&gt; v12.8.1) (default)<br>stable -&gt; 12.8 (-&gt; v12.8.1) (default)<br>iojs -&gt; N/A (default)<br>unstable -&gt; N/A (default)<br>lts/* -&gt; lts/dubnium (-&gt; N/A)<br>lts/argon -&gt; v4.9.1 (-&gt; N/A)<br>lts/boron -&gt; v6.17.1 (-&gt; N/A)<br>lts/carbon -&gt; v8.16.1 (-&gt; N/A)<br>lts/dubnium -&gt; v10.16.3<br></code></pre></td></tr></table></figure><h2 id="use：切換-Node-js-版本"><a class="header-anchor" href="#use：切換-Node-js-版本"></a><code>use</code>：切換 Node.js 版本</h2><p>如果要使用 nvm 切換正在使用的 Node.js 版本，可用 <code>use</code> 指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm use v10.6.3</span><br>Now using node v10.16.3 (npm v6.9.0)<br></code></pre></td></tr></table></figure><p>如果切換的目標版本還沒安裝，nvm 會提醒你要安裝：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm use lts/carbon </span><br>N/A: version "lts/carbon -&gt; N/A" is not yet installed.<br><br>You need to run "nvm install lts/carbon" to install it before using it.<br></code></pre></td></tr></table></figure><p>透過 nvm 安裝 Node.js 時，nvm 會將不同的 Node.js 版本儲存在 <code>~/.nvm/versions/node/vX.X.X</code>，然後再修改 <code>$PATH</code>，將指定版本的 Node.js 路徑加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm current</span><br>v10.16.3<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span>             </span><br>/home/titan/.nvm/versions/node/v10.16.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br><br><span class="hljs-meta">$</span><span class="bash"> use v12.13.1</span><br><span class="hljs-meta">$</span><span class="bash"> nvm current</span><br>v12.13.1<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span>             </span><br>/home/titan/.nvm/versions/node/v12.13.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br></code></pre></td></tr></table></figure><p>在 nvm 的各個 Node.js 版本安裝的全域套件都會在各自版本的目錄內安裝，所以在切換至新安裝的 Node.js 版本後需要重新安裝，也因為如此，不同版本間的套件就不會有衝突問題。</p><h2 id="current：察看目前使用版本"><a class="header-anchor" href="#current：察看目前使用版本"></a><code>current</code>：察看目前使用版本</h2><p>如果忘記自己切換到哪個版本，可以用 <code>current</code> 指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm current</span><br>v10.6.3<br></code></pre></td></tr></table></figure><h2 id="run：直接執行-Node-js"><a class="header-anchor" href="#run：直接執行-Node-js"></a><code>run</code>：直接執行 Node.js</h2><p>如果要直接執行 Node.js，可以使用下面指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm run node</span><br>Running node v12.8.1 (npm v6.10.2)<br>Welcome to Node.js v12.8.1.<br>Type ".help" for more information.<br><span class="hljs-meta">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="exec：指定要執行的-Node-js-版本"><a class="header-anchor" href="#exec：指定要執行的-Node-js-版本"></a><code>exec</code>：指定要執行的 Node.js 版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm <span class="hljs-built_in">exec</span> 12.8.1 node</span><br>Running node v12.8.1 (npm v6.10.2)<br>Welcome to Node.js v12.8.1.<br>Type ".help" for more information.<br><span class="hljs-meta">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="which：察看-Node-js-的安裝路徑"><a class="header-anchor" href="#which：察看-Node-js-的安裝路徑"></a><code>which</code>：察看 Node.js 的安裝路徑</h2><p>執行下面指令可以查看特定版本的 Node.js 的安裝路徑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm <span class="hljs-built_in">which</span> 12.8.1</span><br>/home/titan/.nvm/versions/node/v12.8.1/bin/node<br></code></pre></td></tr></table></figure><h2 id="alias"><a class="header-anchor" href="#alias"></a>alias</h2><p>如下圖有些版本的文字是紅色或是顯示 <code>N/A</code>，就代表該版本未在電腦安裝：</p><p><img src="../images/nvm/nvm-ls.png" alt=""></p><p>預設 alias 可以取代版本號：</p><ul><li><code>node</code>：安裝最新版的 Node.js</li><li><code>iojs</code>：安裝最新版的 io.js</li><li><code>stable</code>：此 alias 已棄用，僅適用於 v0.12 以及更舊版，目前改為 <code>node</code> alias</li><li><code>unstable</code>：此 alias 為 v0.11，最後一個 “unstable” (不穩定) Node release，在 v1.0 之後的版本都是穩定版 (in SemVer, versions communicate breakage, not stability)</li></ul><p>可在下面這些指令使用以上預設別名：</p><ul><li><code>nvm install</code></li><li><code>nvm use</code></li><li><code>nvm run</code></li><li><code>nvm exec</code></li><li><code>nvm which</code></li><li>… 等</li></ul><h2 id="alias：察看別名、設定別名"><a class="header-anchor" href="#alias：察看別名、設定別名"></a><code>alias</code>：察看別名、設定別名</h2><h3 id="察看別名"><a class="header-anchor" href="#察看別名"></a>察看別名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm <span class="hljs-built_in">alias</span>                                                                    * ?</span><br>default -&gt; v10.16.3<br>node -&gt; stable (-&gt; v12.8.1) (default)<br>stable -&gt; 12.8 (-&gt; v12.8.1) (default)<br>iojs -&gt; N/A (default)<br>unstable -&gt; N/A (default)<br>lts/* -&gt; lts/erbium (-&gt; N/A)<br>lts/argon -&gt; v4.9.1 (-&gt; N/A)<br>lts/boron -&gt; v6.17.1 (-&gt; N/A)<br>lts/carbon -&gt; v8.16.2 (-&gt; N/A)<br>lts/dubnium -&gt; v10.17.0 (-&gt; N/A)<br>lts/erbium -&gt; v12.13.0 (-&gt; N/A)<br></code></pre></td></tr></table></figure><h3 id="設定別名"><a class="header-anchor" href="#設定別名"></a>設定別名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm <span class="hljs-built_in">alias</span> titan-test v10.15.3                                                  * ?</span><br>titan-test -&gt; v10.15.3<br></code></pre></td></tr></table></figure><p>接著用 <code>nvm alias</code> 指令就會看到剛剛新增的別名所對應的 Node.js 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nvm <span class="hljs-built_in">alias</span>                                                                    * ?</span><br>titan-test -&gt; v10.15.3<br>default -&gt; v10.16.3<br>node -&gt; stable (-&gt; v12.8.1) (default)<br>stable -&gt; 12.8 (-&gt; v12.8.1) (default)<br>iojs -&gt; N/A (default)<br>unstable -&gt; N/A (default)<br>lts/* -&gt; lts/erbium (-&gt; N/A)<br>lts/argon -&gt; v4.9.1 (-&gt; N/A)<br>lts/boron -&gt; v6.17.1 (-&gt; N/A)<br>lts/carbon -&gt; v8.16.2 (-&gt; N/A)<br>lts/dubnium -&gt; v10.17.0 (-&gt; N/A)<br>lts/erbium -&gt; v12.13.0 (-&gt; N/A)<br></code></pre></td></tr></table></figure><h2 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h2><ul><li><a href="https://github.com/nvm-sh/nvm#install--update-script" target="_blank" rel="noopener">nvm-sh/nvm: Node Version Manager</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/node.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;nvm 是 Node.js 的版本管理器 (version manager)，可在同一台主機上安裝多個版本的 Node.js 環境，因為不同專案可能會使用不同的 Node.js 版本，那就需要透過一個版本管理器來切換不同的 Node.js 版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web Dev" scheme="https://titangene.github.io/categories/web-dev/"/>
    
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
      <category term="CLI" scheme="https://titangene.github.io/tags/cli/"/>
    
      <category term="JavaScript" scheme="https://titangene.github.io/tags/javascript/"/>
    
      <category term="Node.js" scheme="https://titangene.github.io/tags/node-js/"/>
    
      <category term="version manager" scheme="https://titangene.github.io/tags/version-manager/"/>
    
  </entry>
  
  <entry>
    <title>淺入 Git：detached HEAD</title>
    <link href="https://titangene.github.io/article/git-detached-head.html"/>
    <id>https://titangene.github.io/article/git-detached-head.html</id>
    <published>2020-04-12T15:54:32.000Z</published>
    <updated>2020-04-12T15:55:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>在 Git 的世界中，想回到過去，也許你會用 <code>git checkout</code> 跳至某個過去的 commit，但 Git 會提醒你正在「detached HEAD」狀態。那 detached <code>HEAD</code> 是什麼？它能做什麼？要怎麼離開 detached <code>HEAD</code> 狀態？</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>在之前的 <a href="https://titangene.github.io/article/git-head-ref.html">深入 Git：<code>HEAD</code> refs</a> 有談到 <code>HEAD</code> 通常會指向當前分支，而當前分支通常會指向該分支頂端的 commit (也就是該分支最新的 commit)。不過再某些情況下，會發生 <code>HEAD</code> 不是指向分支，而是指向某個 commit，而這個狀態的 <code>HEAD</code> 就被稱為「detached HEAD」。</p><p>下面會用以下 Git 歷史紀錄作為範例來說明 detached <code>HEAD</code>。本專案內有四個檔案，分別是 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code>，我為每個檔案分別建立了一個 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls</span><br>a  b  c  d<br><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --graph --decorate</span><br>* 71e5770 (HEAD -&gt; master, origin/master) feat: d<br>* c3a31ea feat: c<br>* b757c26 feat: b<br>* 3b7be17 feat: a<br></code></pre></td></tr></table></figure><h2 id="路人甲發生的情境"><a class="header-anchor" href="#路人甲發生的情境"></a>路人甲發生的情境</h2><p>下面是路人甲發生的情境，讓我們來看這個情境發生了什麼？</p><p>現在 <code>HEAD</code> 指向 <code>master</code> 分支，而 <code>master</code> 分支指向名為 <code>e2f2a4</code> 的 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --graph --decorate</span><br>* 71e5770 (HEAD -&gt; master, origin/master) feat: d<br>* c3a31ea feat: c<br>* b757c26 feat: b<br>* 3b7be17 feat: a<br><br><span class="hljs-meta">$</span><span class="bash"> cat .git/HEAD</span><br>ref: refs/heads/master<br><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/heads/master</span><br>71e57702f208a7c463a2b5cd069ea47cdbed9eba<br></code></pre></td></tr></table></figure><p>路人甲可能想回到過去的 commit，於是使用了 <code>git checkout &lt;commit&gt;</code> 跳至指定的 commit，假設要 checkout 至名為 <code>b757c26</code> 的 commit 就會看到以下訊息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout b757c26</span><br>Note: checking out 'b757c26'.<br><br>You are in 'detached HEAD' state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make in this<br>state without impacting any branches by performing another checkout.<br><br>If you want to create a new branch to retain commits you create, you may<br>do so (now or later) by using -b with the checkout command again. Example:<br><br>  git checkout -b &lt;new-branch-name&gt;<br><br>HEAD is now at b757c26 feat: b<br></code></pre></td></tr></table></figure><div class="warning"><p>假設路人甲很少注意看 Git 提供的訊息，所以忽略了「detached HEAD」的提醒訊息。</p></div><p>路人甲只想確定自己是不是回到過去，於是執行 <code>git log</code> 來察看，的確看到 <code>HEAD</code> 指向 <code>b757c26</code> 這個 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --graph --decorate</span><br>* b757c26 (HEAD) feat: b<br>* 3b7be17 feat: a<br></code></pre></td></tr></table></figure><p>所以心滿意足的開始基於 <code>7e347a4</code> 這個 commit 開始建立兩個新的 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"test1"</span> &gt; test1</span><br><span class="hljs-meta">$</span><span class="bash"> git add test1</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">"feat: test1"</span></span><br>[detached HEAD 3936d06] feat: test1<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 test1<br><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"test2"</span> &gt; test2</span><br><span class="hljs-meta">$</span><span class="bash"> git add test2</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">"feat: test2"</span></span><br>[detached HEAD 845992a] feat: test2<br> 1 file changed, 1 insertion(+)<br> create mode 100644 test2<br></code></pre></td></tr></table></figure><p>所以現在 <code>git log</code> 變成這樣：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --graph --decorate</span><br>* 845992a (HEAD) feat: test2<br>* 9fd0924 feat: test1<br>* b757c26 feat: b<br>* 3b7be17 feat: a<br></code></pre></td></tr></table></figure><p>當路人甲建立完 commit 後，突然想回到之前的 <code>master</code> 分支，所以執行 <code>git checkout master</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br>Warning: you are leaving 2 commits behind, not connected to<br>any of your branches:<br><br>  845992a feat: test2<br>  9fd0924 feat: test1<br><br>If you want to keep them by creating a new branch, this may be a good time<br>to do so with:<br><br> git branch &lt;new-branch-name&gt; 845992a<br><br>Switched to branch 'master'<br>Your branch is up to date with 'origin/master'.<br></code></pre></td></tr></table></figure><p>回到 <code>master</code> 分支後，路人甲看 <code>git log</code> 變成下面這樣馬上傻眼，心想：「剛剛的那兩個 commit 呢？怎麼不見了！怎麼辦啊！還找的回來嗎？」：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --graph --decorate</span><br>* 71e5770 (HEAD -&gt; master, origin/master) feat: d<br>* c3a31ea feat: c<br>* b757c26 feat: b<br>* 3b7be17 feat: a<br></code></pre></td></tr></table></figure><p>好，看到這個故事，你應該會發現，其實 Git 一直不停的在輸出訊息提醒你：</p><ul><li>在 checkout 至某個 commit 時，會提醒你正在「detached HEAD」狀態</li><li>在「detached HEAD」狀態建立 commit 時，會像這樣提醒你：<code>[detached HEAD 845992a] feat: test2</code></li><li>在「detached HEAD」狀態建立 commit 後，checkout 回分支時，會像這樣提醒你：<code>Warning: you are leaving 2 commits behind</code></li></ul><p>所以看輸出訊息很重要！</p><div class="info"><p>我曾經就是那個不看輸出訊息的路人甲 XD</p></div><h2 id="此狀態有何用"><a class="header-anchor" href="#此狀態有何用"></a>此狀態有何用</h2><p>那「detached HEAD」狀態到底能做什麼？</p><p>如果在 detached <code>HEAD</code> 狀態時建立的 commit 是實驗性的，那的確可以直接 checkout 至任何分支，把那些 commit 都丟棄 (但 Git 不會馬上刪除，會自動等到 Git GC 來回收，所以還救的回來)，這代表你放棄了在 detached <code>HEAD</code> 狀態下所做的任何 commit，而且這些操作都不會影響任何分支。</p><p>那如果是像路人甲的情境那樣，你想保留那些 commit，那可以在該 commit 上建立 ref，讓該 ref 指向該 commit，ref 可以是分支或 tag。</p><p>建立 ref 有很多種方式，下面會介紹幾種處理的方式。</p><h2 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h2><ul><li><a href="https://git-scm.com/docs/git-checkout" target="_blank" rel="noopener">Git - git-checkout Documentation</a></li><li><a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches" target="_blank" rel="noopener">Git Branching - Remote Branches | Pro Git, 2/e</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;在 Git 的世界中，想回到過去，也許你會用 &lt;code&gt;git checkout&lt;/code&gt; 跳至某個過去的 commit，但 Git 會提醒你正在「detached HEAD」狀態。那 detached &lt;code&gt;HEAD&lt;/code&gt; 是什麼？它能做什麼？要怎麼離開 detached &lt;code&gt;HEAD&lt;/code&gt; 狀態？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>深入 Git：Git 物件儲存 - tag 物件</title>
    <link href="https://titangene.github.io/article/git-tag-object.html"/>
    <id>https://titangene.github.io/article/git-tag-object.html</id>
    <published>2020-04-05T15:40:46.000Z</published>
    <updated>2020-04-05T17:12:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>本篇將深入探討 Git tag 是什麼？如何建立 tag？Git 是如何儲存 tag？與 commit 和分支的差別在哪？</p><a id="more"></a><h1 id="Git-tag"><a class="header-anchor" href="#Git-tag"></a>Git tag</h1><p>Git tag 常用於標記某個版本號碼，例如：<code>v0.5</code>、<code>v1.0.1</code>、<code>9.1.0-rc.2</code>、<code>v2.6.0-beta.3</code>。</p><p>在 Git 中有兩種類型的 tag：lightweight tag (輕量標籤) 和 annotated tag (註解標籤)。</p><p>先介紹兩者的共通點：</p><ul><li>提供更 friendlier 的名稱的標記</li><li>都會指向某個 Git 物件 (通常為 commit 物件，但也可以是其他物件，也就是 tree 物件、blob 物件，甚至是其他 tag 物件)<ul><li>只是 lightweight tag 是直接指向某 Git 物件</li><li>而 annotated tag 則是透過 tag 物件，間接指向某 Git 物件</li></ul></li><li>不會改變 tag 所指向的物件 (除非用 <code>git tag -f</code> 替換現有 tag)</li></ul><p>接著會說明各自的特性、要如何建立 lightweight tag 和 annotated tag，以及在 Git 中是如何儲存這些 tag 的。</p><p>下面會用以下 Git 歷史紀錄的範例來說明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --decorate</span><br>32aa934 (HEAD -&gt; master) feat: c<br>9b6d639 feat: b<br>d835d6b feat: a<br></code></pre></td></tr></table></figure><h2 id="lightweight-tag-輕量標籤"><a class="header-anchor" href="#lightweight-tag-輕量標籤"></a>lightweight tag (輕量標籤)</h2><ul><li>很像不會移動的分支，tag 只會指向一個特定的 Git 物件</li><li>若只作為暫時的標籤，且不想保留額外資訊，可用 lightweight tag</li></ul><h3 id="建立-lightweight-tag"><a class="header-anchor" href="#建立-lightweight-tag"></a>建立 lightweight tag</h3><p>建立 lightweight tag 時，不要指定 <code>-a</code>、<code>-s</code> 或 <code>-m</code> option (建立 annotated tag 時才會用到，後面會說明)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag &lt;tagname&gt; [&lt;commit&gt; | &lt;object&gt;]</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag v1.0-lw</span><br></code></pre></td></tr></table></figure><p>也可以指定某個 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag v0.2-lw 9b6d639</span><br></code></pre></td></tr></table></figure><h3 id="察看-lightweight-tag"><a class="header-anchor" href="#察看-lightweight-tag"></a>察看 lightweight tag</h3><p>若要透過 <code>git show</code> 指令察看 lightweight tag，就不會看到該標籤的額外資訊，只會顯示標籤所在的 commit 資訊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git show v1.0-lw</span><br>commit 32aa934a24212ef22cc373e7838c30618952003d (HEAD -&gt; master, tag: v1.0-lw)<br>Author: titangene &lt;titangene.tw@gmail.com&gt;<br>Date:   Sun Apr 5 21:36:25 2020 +0800<br><br>    feat: c<br><br>diff --git a/c b/c<br>new file mode 100644<br>index 0000000..f2ad6c7<br>--- /dev/null<br>+++ b/c<br>@@ -0,0 +1 @@<br>+c<br></code></pre></td></tr></table></figure><h3 id="lightweight-tag-存在哪？"><a class="header-anchor" href="#lightweight-tag-存在哪？"></a>lightweight tag 存在哪？</h3><p>Git 將 lightweight tag 存在 <code>.git/refs/tag</code> 目錄內：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/refs/tags/</span><br>.git/refs/tags/<br>├── v0.2-lw<br>└── v1.0-lw<br><br>0 directories, 2 files<br></code></pre></td></tr></table></figure><p>tag ref 的內容就是該 tag 指向的 commit 物件 (也就是該 commit SHA-1 值)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/tags/v1.0-lw</span><br>32aa934a24212ef22cc373e7838c30618952003d<br></code></pre></td></tr></table></figure><p>使用 <code>git cat-file</code> 來確定此 SHA-1 值真的是 commit 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 32aa93</span><br>commit<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 32aa93</span><br>tree 04a59185a0c5f4047e4fd3fa87b0c84e671b00ee<br>parent 9b6d6398e5e020a76f9a0f8d620e676a1decc78a<br>author titangene &lt;titangene.tw@gmail.com&gt; 1586093785 +0800<br>committer titangene &lt;titangene.tw@gmail.com&gt; 1586093785 +0800<br><br>feat: c<br></code></pre></td></tr></table></figure><h3 id="使用底層指令建立-lightweight-tag"><a class="header-anchor" href="#使用底層指令建立-lightweight-tag"></a>使用底層指令建立 lightweight tag</h3><p>使用 <code>git update-ref</code> 底層指令建立 lightweight tag 的 ref：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git update-ref refs/tags/v0.1-lw d835d6bf85258f2fe93c582f60f3f148900e0d7f</span><br></code></pre></td></tr></table></figure><p>察看該 tag ref 的確是指向剛剛指定的 SHA-1 值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/tags/v0.1-lw </span><br>d835d6bf85258f2fe93c582f60f3f148900e0d7f<br></code></pre></td></tr></table></figure><h2 id="annotated-tag-註解標籤"><a class="header-anchor" href="#annotated-tag-註解標籤"></a>annotated tag (註解標籤)</h2><ul><li>會在 Git 的資料庫中儲存成完整的物件。它們將被計算校驗碼 (checksummed)</li><li>包含：<ul><li>建立標籤的人 (tagger) 的名字、電子郵件和建立日期</li><li>紀錄一個標籤訊息 (tagging message)</li><li>指標 (也就是 Git 物件)</li></ul></li><li>可以簽名 (signed) 及透過 GNU Privacy Guard (GPG) 驗證</li><li>若想紀錄與 tag 有關的資訊 (例如：建立 tag 的人、時間)，建議使用 annotated tag</li></ul><h3 id="建立-annotated-tag"><a class="header-anchor" href="#建立-annotated-tag"></a>建立 annotated tag</h3><p>建立 annotated tag 時，可同時指定以下 option：</p><ul><li><code>-a</code>，<code>--annotate</code>：製作一個 unsigned、annotated tag 物件 (未簽名且帶有註解的標籤物件)</li><li><code>-m &lt;msg&gt;</code>，<code>--message=&lt;msg&gt;</code>：<ul><li>指定標籤訊息，此訊息會和此標籤一起儲存</li><li>若你沒有為標籤指定訊息，Git 就會開啟編輯器讓你輸入 (很像 <code>git commit</code> 沒有加上 <code>-m</code> option 那樣)</li><li>若加上多組 <code>-m</code> option，會將這些值串聯成段落</li><li>如果使用 <code>-m</code> option 但沒有加上 <code>-a</code>、<code>-s</code> 或 <code>-u &lt;keyid&gt;</code>，則代表是 <code>-a</code> (也就是建立 annotated tag)</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a &lt;tagname&gt; -m &lt;msg&gt; [&lt;commit&gt; | &lt;object&gt;]</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a v1.0 -m <span class="hljs-string">"version 1.0"</span></span><br></code></pre></td></tr></table></figure><p>也可以指定某個 commit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a v0.1 -m <span class="hljs-string">"version 0.1"</span> d835d6b</span><br></code></pre></td></tr></table></figure><h3 id="察看-annotated-tag-資訊"><a class="header-anchor" href="#察看-annotated-tag-資訊"></a>察看 annotated tag 資訊</h3><p>使用 <code>git show</code> 指令可查看標籤資訊，以及此標籤所標記的 commit 資訊：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git show v0.1</span><br>tag v0.1<br>Tagger: titangene &lt;titangene.tw@gmail.com&gt;<br>Date:   Sun Apr 5 21:39:01 2020 +0800<br><br>version 0.1<br><br>commit d835d6bf85258f2fe93c582f60f3f148900e0d7f (tag: v0.1)<br>Author: titangene &lt;titangene.tw@gmail.com&gt;<br>Date:   Sun Apr 5 21:36:18 2020 +0800<br><br>    feat: a<br><br>diff --git a/a b/a<br>new file mode 100644<br>index 0000000..7898192<br>--- /dev/null<br>+++ b/a<br>@@ -0,0 +1 @@<br>+a<br></code></pre></td></tr></table></figure><p>以上面標籤資訊為例，包含：</p><ul><li>標籤名稱：<code>v0.1</code></li><li>建立標籤的人 (tagger) 的名字、電子郵件：<code>Tagger: titangene &lt;titangene.tw@gmail.com&gt;</code></li><li>標籤建立日期：<code>Date: Sun Apr 5 21:39:01 2020 +0800</code></li><li>標籤訊息：<code>version 0.1</code></li><li>指標：在 <code>git show</code> 沒有提供，下面會提到</li></ul><h3 id="annotated-tag-存在哪？"><a class="header-anchor" href="#annotated-tag-存在哪？"></a>annotated tag 存在哪？</h3><p>Git 也將 annotated tag 存在 <code>.git/refs/tag</code> 目錄內：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tree .git/refs/tags/</span><br>.git/refs/tags/<br>├── v0.1<br>├── v0.1-lw<br>├── v0.2-lw<br>├── v1.0<br>└── v1.0-lw<br><br>0 directories, 5 files<br></code></pre></td></tr></table></figure><p>tag ref 的內容就是該 tag 指向的 commit 物件 (也就是該 commit SHA-1 值)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/tags/v0.1</span><br>530097c078c2fa4c16a532443170a40179599a69<br></code></pre></td></tr></table></figure><p>使用 <code>git cat-file</code> 來確定此 SHA-1 值時，會發現跟剛剛介紹的 lightweight tag 不一樣，lightweight tag 會直接指向 commit 物件，而 annotated tag 則是指向 tag 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 530097</span><br>tag<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 530097</span><br>object d835d6bf85258f2fe93c582f60f3f148900e0d7f<br>type commit<br>tag v0.1<br>tagger titangene &lt;titangene.tw@gmail.com&gt; 1586093941 +0800<br><br>version 0.1<br></code></pre></td></tr></table></figure><p>而這個 tag 物件才是真正指向 commit 物件的 ref。</p><p>再次使用 <code>git cat-file</code> 指令，就能確定 tag 物件的確是指向 <code>d835d6</code> 這個 commit 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t d835d6</span><br>commit<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p d835d6</span><br>tree aaff74984cccd156a469afa7d9ab10e4777beb24<br>author titangene &lt;titangene.tw@gmail.com&gt; 1586093778 +0800<br>committer titangene &lt;titangene.tw@gmail.com&gt; 1586093778 +0800<br><br>feat: a<br></code></pre></td></tr></table></figure><h3 id="使用底層指令建立-annotated-tag"><a class="header-anchor" href="#使用底層指令建立-annotated-tag"></a>使用底層指令建立 annotated tag</h3><p>建立 annotated tag 主要有兩個步驟：</p><ol><li>建立 tag 物件</li><li>建立 tag ref，此 tag ref 會指向剛剛建立的 tag 物件</li></ol><p>我之前在 <a href="https://titangene.github.io/article/git--blob-object.html#hash-object-%E8%A8%88%E7%AE%97%E7%89%A9%E4%BB%B6%E5%90%8D%E7%A8%B1%E7%9A%84%E6%BC%94%E7%AE%97%E6%B3%95">深入 Git：Git 物件儲存 - blob 物件</a> 這篇有提到建立 Git 物件的底層指令 <code>git hash-object</code>，以及這個底層指令的原理。</p><p>但是在使用 <code>git hash-object</code> 之前，必須要先準備好這個指令上的 <code>--stdin</code> option 要從 stdin (standard input，標準輸入) 讀取的內容，內容格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">object &lt;object-sha1&gt;<br>type &lt;object-type&gt;<br>tag &lt;tag-name&gt;<br>tagger &lt;tagger-name&gt; &lt;&lt;tagger-email&gt;&gt; &lt;timestamp&gt;<br><br>&lt;tag-message&gt;<br></code></pre></td></tr></table></figure><p>內容範例如下 (我先隨意將以下內容儲存在一個檔案內，任意檔名都可以，因為重點是檔案的內容)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim my-tag.txt</span><br><span class="hljs-meta">$</span><span class="bash"> cat my-tag.txt</span><br>object 61780798228d17af2d34fce4cfbdf35556832472<br>type blob<br>tag file-b<br>tagger titangene &lt;titangene.tw@gmail.com&gt; 1586097930 +0800<br><br>file b<br></code></pre></td></tr></table></figure><p>因為這次要建立的是 tag 物件，所以需要在 <code>git hash-object</code> 指令上加上 <code>-t</code> option，並且指定 <code>tag</code>，代表要建立 tag 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">hash</span>-object -t tag -w --stdin &lt; my-tag.txt</span><br>8785f7a44e2af5628544ecb0aa9dccf2adfa37ff<br></code></pre></td></tr></table></figure><p>這邊輸出的 <code>8785f7</code> 就是剛剛建立的 tag 物件的 SHA-1 值，我們用 <code>git cat-file</code> 來驗證一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git cat-file -t 8785f7</span><br>tag<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p 8785f7</span><br>object 61780798228d17af2d34fce4cfbdf35556832472<br>type blob<br>tag file-b<br>tagger titangene &lt;titangene.tw@gmail.com&gt; 1586097930 +0800<br><br>file b<br></code></pre></td></tr></table></figure><p>接著處理第二步驟，使用 <code>git update-ref</code> 底層指令建立 annotated tag 的 ref：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git update-ref refs/tags/file-b 8785f7a44e2af5628544ecb0aa9dccf2adfa37ff</span><br></code></pre></td></tr></table></figure><p>察看該 tag ref 的確是指向剛剛指定的 SHA-1 值 (在這邊就是 tag 物件)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/tags/file-b  </span><br>8785f7a44e2af5628544ecb0aa9dccf2adfa37ff<br></code></pre></td></tr></table></figure><h2 id="在-git-log-察看-tag"><a class="header-anchor" href="#在-git-log-察看-tag"></a>在 <code>git log</code> 察看 tag</h2><p>使用 <code>git log</code> 察看剛剛建立的 tag 都貼上哪個 commit 上面 (也就是那些 tag 都指向哪個 commit)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --decorate</span><br>32aa934 (HEAD -&gt; master, tag: v1.0-lw, tag: v1.0) feat: c<br>9b6d639 (tag: v0.2-lw) feat: b<br>d835d6b (tag: v0.1-lw, tag: v0.1) feat: a<br></code></pre></td></tr></table></figure><p>另外提一下 (雖然上面有介紹到)，不管是 lightweight tag 還是 annotated tag，如果是指向 commit 物件之外的其他 Git 物件 (也就是 blob 物件或 tree 物件，甚至是其他 tag 物件)，都無法在 <code>git log</code> 的輸出察看，只能透過 <code>git show</code> 或是透過 <code>cat</code> 和 <code>git cat-file</code> 指令來察看該 tag 是指向哪個 Git 物件。</p><p>下面以 annotated tag 為例，透過這些指令來找到名為 <code>file-b</code> 的 tag 指向 SHA-1 值為 <code>8785f7</code> 的 tag 物件，而該 tag 物件是指向 SHA-1 值為 <code>617807</code> 的 blob 物件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag -a file-c -m <span class="hljs-string">"file c"</span> f2ad6c</span><br><br><span class="hljs-meta">$</span><span class="bash"> cat .git/refs/tags/file-c</span><br>febbaa9a5276f0321d72232c4bc3aa561bfc38c5<br><br><span class="hljs-meta">$</span><span class="bash"> git cat-file -t febbaa</span><br>tag<br><span class="hljs-meta">$</span><span class="bash"> git cat-file -p febbaa</span><br>object f2ad6c76f0115a6ba5b00456a849810e7ec0af20<br>type blob<br>tag file-c<br>tagger titangene &lt;titangene.tw@gmail.com&gt; 1586100520 +0800<br><br>file c<br></code></pre></td></tr></table></figure><h2 id="察看所有-tag"><a class="header-anchor" href="#察看所有-tag"></a>察看所有 tag</h2><p>執行 <code>git tag</code> 指令可以察看所有建立的 tag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>file-b<br>file-c<br>v0.1<br>v0.1-lw<br>v0.2-lw<br>v1.0<br>v1.0-lw<br></code></pre></td></tr></table></figure><h1 id="commit-vs-tag"><a class="header-anchor" href="#commit-vs-tag"></a>commit vs tag</h1><ul><li>commit 物件紀錄的指標只能是 tree 物件，不能是其他 Git 物件</li><li>tag 物件通常紀錄的指標是 commit 物件，當然也可以是其他 Git 物件，包括 tree 物件、blob 物件，甚至是其他 tag 物件</li></ul><h1 id="分支-vs-tag"><a class="header-anchor" href="#分支-vs-tag"></a>分支 vs tag</h1><p>那分支和 tag 都可以指向 commit 物件，那他們有何差別？</p><ul><li>分支：在提交新的 commit 時，會將分支指向該分支的末端，也就是新的 commit 物件</li><li>lightweight tag 和 annotated tag 這兩種 tag 都是永遠不會改變 tag 所指向的物件，只是提供更 friendlier 的名稱的標記而已<ul><li>lightweight tag：很像不會移動的分支，此 tag ref 只會指向一個特定的 Git 物件</li><li>annotated tag：此 tag ref 會指向 tag 物件，而 tag 物件會指向一個特定的 Git 物件</li></ul></li></ul><p>資料來源：</p><ul><li><a href="https://git-scm.com/book/zh-tw/v2/Git-Internals-Git-References" target="_blank" rel="noopener">Git Internals - Git References | Pro Git, 2/e</a></li><li><a href="https://git-scm.com/book/zh-tw/v2/Git-%E5%9F%BA%E7%A4%8E-%E6%A8%99%E7%B1%A4" target="_blank" rel="noopener">Git 基礎 - 標籤 | Pro Git, 2/e</a></li><li><a href="https://stackoverflow.com/questions/10986615/what-is-the-format-of-a-git-tag-object-and-how-to-calculate-its-sha" target="_blank" rel="noopener">hash - What is the format of a git tag object and how to calculate its SHA? - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇將深入探討 Git tag 是什麼？如何建立 tag？Git 是如何儲存 tag？與 commit 和分支的差別在哪？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
  <entry>
    <title>深入 Git：HEAD refs</title>
    <link href="https://titangene.github.io/article/git-head-ref.html"/>
    <id>https://titangene.github.io/article/git-head-ref.html</id>
    <published>2020-03-29T15:55:33.000Z</published>
    <updated>2020-03-29T15:57:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cover/git.jpg" alt=""></p><p>本篇將深入探討 Git <code>HEAD</code> 是什麼？儲存在 repo 的哪裡？以及跟 <code>git branch</code> 和 <code>git checkout</code> 之間的關係。</p><a id="more"></a><p>上次提到的 <a href="https://titangene.github.io/article/git-branch-ref.html">Git 分支 ref</a>，可用來紀錄不同的工作過程，例如最常見的 <code>master</code> 和 <code>develop</code> 分支，<code>master</code> 分支通常用來紀錄發佈的版本，而 <code>develop</code> 分支通常用來紀錄正在開發的版本。</p><p>那 Git 是如何知道你正在哪一個分支？其實是透過 <code>HEAD</code> 檔案來紀錄的。這個檔案通常會放在 <code>.git</code> 路徑底下。</p><p>通常 <code>HEAD</code> 檔案是對當前所在分支的 symbolic reference <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，也就是紀錄你正在哪一個分支的檔案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat .git/HEAD</span><br>ref: refs/heads/master<br></code></pre></td></tr></table></figure><p>如果執行 <code>git checkout</code> 來切換分支，Git 就會更新 <code>HEAD</code> 檔案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout</span><br>Switched to branch 'test'<br><span class="hljs-meta">$</span><span class="bash"> cat .git/HEAD</span><br>ref: refs/heads/test<br></code></pre></td></tr></table></figure><p>在執行 <code>git commit</code> 時，為何當前所在的分支會一直指向最新的 commit？這是因為 <code>HEAD</code> 會指向當前分支，而當前分支會指向該分支的末端，也就是說，當執行 <code>git commit</code> 時，Git 會建立新的 <a href="https://titangene.github.io/article/git-commit-object.html">commit 物件</a>，而分支會被更新成指向該分支的末端 (也就是新的 commit 物件)。</p><p>通常 <code>HEAD</code> 會指向當前分支，若 <code>HEAD</code> 檔案的內容為 Git 物件的 SHA-1 值時，則代表 <a href="https://git-scm.com/docs/git-checkout#_detached_head" target="_blank" rel="noopener">detached HEAD</a> 狀態。這種情況會在你使用 <code>git checkout</code> 切換至 tag、commit 或遠端分支時發生。在此狀態下，沒有分支會與 working tree 關聯。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout 665439e            </span><br>Note: checking out '665439e'.<br><br>You are in 'detached HEAD' state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make in this<br>state without impacting any branches by performing another checkout.<br><br>If you want to create a new branch to retain commits you create, you may<br>do so (now or later) by using -b with the checkout command again. Example:<br><br>  git checkout -b &lt;new-branch-name&gt;<br><br>HEAD is now at 665439e feat: a<br></code></pre></td></tr></table></figure><h2 id="手動編輯-HEAD-檔案模擬-checkout-分支"><a class="header-anchor" href="#手動編輯-HEAD-檔案模擬-checkout-分支"></a>手動編輯 <code>HEAD</code> 檔案模擬 checkout 分支</h2><p>我們來手動編輯此 <code>HEAD</code> 檔案，驗證改變 <code>HEAD</code> 檔案的內容就等同於在 <code>git checkout</code> 至某個分支。</p><p>假設目前正在 <code>test</code> 分支，然後將 <code>HEAD</code> 檔案的內容從 <code>ref: refs/heads/test</code> 變成 <code>ref: refs/heads/master</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch</span><br>* test<br>  master<br><br><span class="hljs-meta">$</span><span class="bash"> cat .git/HEAD</span><br>ref: refs/heads/test<br><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"ref: refs/heads/master"</span> &gt; .git/HEAD</span><br></code></pre></td></tr></table></figure><p>然後用 <code>git branch</code> 就能驗證現在已經「<code>checkout</code>」至 <code>master</code> 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch</span><br>  test<br>* master<br></code></pre></td></tr></table></figure><h2 id="使用-symbolic-ref-底層指令"><a class="header-anchor" href="#使用-symbolic-ref-底層指令"></a>使用 <code>symbolic-ref</code> 底層指令</h2><p>雖然剛剛有提到可以手動編輯 <code>HEAD</code> 檔案，但建議使用 Git 提供的底層指令 <a href="https://git-scm.com/docs/git-symbolic-ref" target="_blank" rel="noopener"><code>git symbolic-ref</code></a> 來編輯和讀取 <code>HEAD</code> 檔案：</p><p>讀取 <code>HEAD</code> 檔案 (察看當前所在分支)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git symbolic-ref HEAD</span><br>refs/heads/master<br></code></pre></td></tr></table></figure><p>加上 <code>--short</code> option 會只顯示分支名稱，不會顯示分支 ref 的路徑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git symbolic-ref HEAD --short</span><br>master<br></code></pre></td></tr></table></figure><p>設定 <code>HEAD</code> 檔案 (等同於 <code>git checkout &lt;branch&gt;</code> )：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git symbolic-ref HEAD refs/heads/<span class="hljs-built_in">test</span></span><br><span class="hljs-meta">$</span><span class="bash"> cat .git/HEAD</span><br>ref: refs/heads/test<br></code></pre></td></tr></table></figure><p>一定要用 <code>refs/</code> 為開頭的 ref 才能設定 <code>HEAD</code> 檔案，要不然會報錯：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git symbolic-ref HEAD <span class="hljs-built_in">test</span></span><br>fatal: Refusing to point HEAD outside of refs/<br></code></pre></td></tr></table></figure><p>資料來源：</p><ul><li><a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References" target="_blank" rel="noopener">Git Internals - Git References | Pro Git, 2/e</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://git-scm.com/docs/gitglossary#def_symref" target="_blank" rel="noopener">Git - gitglossary Documentation</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../images/cover/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇將深入探討 Git &lt;code&gt;HEAD&lt;/code&gt; 是什麼？儲存在 repo 的哪裡？以及跟 &lt;code&gt;git branch&lt;/code&gt; 和 &lt;code&gt;git checkout&lt;/code&gt; 之間的關係。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://titangene.github.io/categories/git/"/>
    
    
      <category term="深入 Git" scheme="https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"/>
    
      <category term="w3HexSchool" scheme="https://titangene.github.io/tags/w3hexschool/"/>
    
  </entry>
  
</feed>
