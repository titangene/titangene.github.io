{"meta":{"title":"Titangene Blog","subtitle":null,"description":"利用 blog 紀錄學習歷程","author":"Titangene","url":"https://titangene.github.io","root":"/"},"pages":[{"title":"Categories","date":"2018-10-22T14:40:00.000Z","updated":"2018-10-22T18:20:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://titangene.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2018-10-22T14:40:00.000Z","updated":"2018-10-22T18:21:46.000Z","comments":false,"path":"error/index.html","permalink":"https://titangene.github.io/error/index.html","excerpt":"","text":"This page does not exist, click here to go back to home page.頁面不存在，點此回到首頁。"},{"title":"Tags","date":"2018-10-22T14:40:00.000Z","updated":"2018-10-22T18:22:54.000Z","comments":false,"path":"tags/index.html","permalink":"https://titangene.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"推薦 Chrome Extension：新分頁篇","slug":"recommend-chrome-extension-2","date":"2020-08-16T15:38:24.000Z","updated":"2020-08-16T15:37:54.937Z","comments":true,"path":"article/recommend-chrome-extension-2.html","link":"","permalink":"https://titangene.github.io/article/recommend-chrome-extension-2.html","excerpt":"本篇推薦一些我常用的 Chrome Extension，包含隨機風景照的新分頁、隨機小知識的新分頁，以及能列出訂閱技術文章的新分頁。","text":"本篇推薦一些我常用的 Chrome Extension，包含隨機風景照的新分頁、隨機小知識的新分頁，以及能列出訂閱技術文章的新分頁。其他推薦 Chrome Extension 相關文章可參閱 推薦 Chrome Extension 系列文章。新分頁「起始分頁」就是當你打新分頁時，顯示的那個分頁。預設的新分頁很簡潔簡陋，有 Google 搜尋、常用頁面。沒了…當然你可以點擊右下角的「自訂」來設定背景、快速鍵 (設定捷徑、常看的網站)、顏色和主題：每次只能看純顏色的背景，或是一樣的背景圖，看膩了還要自己換！有沒有會幫你自動換漂亮風景照的工具？那我最推的就是「Unsplash Instant」。Unsplash Instant下載連結：Unsplash Instant功能：隨機照片：每次開新分頁都會看到不同的照片下載照片：若看到喜歡的照片，可下載至電腦，甚至設為桌布Unsplash 是蠻有名的高解析度免費圖庫平台，每張照片採用的授權很自由，任何人都可將照片自由使用至任何目的 (免費下載和使用、用於商業和非商業目的、不需許可)。而這個 extension 就是由 Unsplash 官方推出的！只要安裝此 extension，你開的新分頁就會是隨機漂亮的照片了！如果你不小心將快速開啟的新分頁關閉了，不用擔心，此 extension 有提供歷史紀錄，可以讓你看前兩張照片：若要下載照片，只要點擊右上角的「Download」即可。若要查看原照片連結，只要點擊左上角的 icon 即可跳至該連結。剛剛介紹了美化的新分頁，那接著來介紹能讓你提昇開發技能的 extension。30 Seconds of Knowledge下載連結：30 Seconds of Knowledge功能：提供多種程式語言的知識：包含 C++、CSS、JavaScript、PHP、Python、Ruby、React、Ramda、面試題等隨機小知識：每次開新分頁都會看到不同的知識，就如其名，只需要 30 秒就能閱讀完並理解儲存 snippet：若看到不錯的小知識，可儲存下來之後閱讀儲存下來的 snippet 會放在右下角的選單 icon，裡面的第一個 icon：像下圖就是我儲存的 snippet：此 extension 也提供一些設定，包括：選擇要看的程式語言主題主題：暗/亮字體大小若覺得小知識不能滿足你，你想訂閱更多文章和新的技術資訊，那「daily.dev」一定很適合你！daily.dev - News for Busy Developers下載連結：daily.dev - News for Busy Developers功能：隨時接收最新的文章和技術資訊：新文章都會列在新分頁上可選擇要訂閱的網站或 tag開源：若有 bug，歡迎大家貢獻左邊的選單可讓你選擇要訂閱的來源，可以是網站或 tag：若有喜歡或是想稍後閱讀的文章，可加入書籤保存：像下圖就是我保存的文章：有一些是付費功能，例如：自己新增來源，可以是 blog 或 RSS 網址。歡迎大家把我的「Titangene Blog」的 RSS 網址訂閱起來 XD：https://titangene.github.io/atom.xml","categories":[{"name":"Tools","slug":"tools","permalink":"https://titangene.github.io/categories/tools/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Chrome","slug":"chrome","permalink":"https://titangene.github.io/tags/chrome/"},{"name":"Chrome Extension","slug":"chrome-extension","permalink":"https://titangene.github.io/tags/chrome-extension/"}],"author":"Titangene"},{"title":"推薦 Chrome Extension：Markdown & 頁面主題篇","slug":"recommend-chrome-extension-1","date":"2020-08-09T15:56:36.000Z","updated":"2020-08-16T15:25:59.966Z","comments":true,"path":"article/recommend-chrome-extension-1.html","link":"","permalink":"https://titangene.github.io/article/recommend-chrome-extension-1.html","excerpt":"本篇推薦一些我常用的 Chrome Extension，包含複製分頁的 Markdown 格式的連結、將頁面變為暗主題。","text":"本篇推薦一些我常用的 Chrome Extension，包含複製分頁的 Markdown 格式的連結、將頁面變為暗主題。其他推薦 Chrome Extension 相關文章可參閱 推薦 Chrome Extension 系列文章。MarkdownCopy as Markdown下載連結：Copy as Markdown功能：複製當前分頁的 Markdown 格式的連結複製該視窗的所有分頁的 Markdown 格式的連結點擊 Extension 的圖案，可看到多種選項功能。其中的「Current tab link」選項會將該分頁連結的 Markdown 格式複製至剪貼簿。假設要複製此 blog 文章的連結，剪貼簿內儲存的連結格式如下：1[重新認識 CSS - 總結 &amp; 系列目錄 | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-series-catalog.html)此 Extension 會將頁面標題 (即 &lt;title&gt; 標籤的內容) 和連結變為 Markdown 格式。還有更厲害的！點擊「All tab link (n)」選項會複製該視窗的所有分頁連結，並以 Markdown 的無序清單的形式 (即 * ) 複製至剪貼簿。以上圖為例，此視窗開了 3 個分頁，所以我點擊「All tab link (n)」選項會複製以下內容：123* [重新認識 CSS - 總結 &amp; 系列目錄 | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-series-catalog.html)* [Git - 刪除遠端分支 (以 GitHub、GitLab 為例) | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git-delete-remote-branch.html)* [深入 Git：Git 物件儲存 - blob 物件 | Titangene Blog](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git--blob-object.html)如果只想要複製標題或連結而已，可以點擊「All tab title」或「All tab URL」選項。格式如下：123* 重新認識 CSS - 總結 &amp; 系列目錄 | Titangene Blog* Git - 刪除遠端分支 (以 GitHub、GitLab 為例) | Titangene Blog* 深入 Git：Git 物件儲存 - blob 物件 | Titangene Blog123* https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-series-catalog.html* https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git-delete-remote-branch.html* https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;git--blob-object.html寫 Markdown 筆記時，若想一次複製多個分頁的連結，並且是 Markdown 格式，用了這個「Copy as Markdown」Extension 就不用自己手動打了！拷貝為 Markdown下載連結：拷貝為 Markdown功能：將選取的內容轉為 Markdown 格式假設我要複製以下選取的內容，並且可以取得 Markdown 格式，只要選取該內容後，並點擊 Extension 的圖案，就會將內容複製至剪貼簿：複製的內容如下。可以看到連標題 (即 ## )、無序列表 (即 * )、引用 (即 &gt; ) 都能自動轉成 Markdown 格式：12345678910111213## Assigning property values, Cascading, and Inheritance瞭解在 CSS 中，繼承和權重這些重要的觀念之後，接著就可以更深入的瞭解 CSS 是如何處理屬性值的。系列如下：* [重新認識 CSS - Inheritance (繼承)](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-inheritance.html)* [重新認識 CSS - Cascading &amp; Specificity](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-cascading-and-specificity.html)* [重新認識 CSS - CSS 如何處理屬性值](https:&#x2F;&#x2F;titangene.github.io&#x2F;article&#x2F;css-value-processing.html)&gt; 對應 spec 的以下幾篇：&gt;&gt; * [CSS 2.2 - 6. Assigning property values, Cascading, and Inheritance](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;CSS22&#x2F;cascade.html)&gt; * [CSS Cascading and Inheritance Level 3](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css-cascade-3&#x2F;)&gt; * [CSS Cascading and Inheritance Level 4](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css-cascade-4&#x2F;)頁面主題Dark Reader下載連結：Dark Reader功能：將頁面變成暗主題、護眼模式點擊 Extension 的圖案會開啟設定視窗，點擊左上角的按鈕就可以啟用暗主題。它會自動偵測需要改變的顏色，大致上的目標是黑底白字。像下圖就是 Google 搜尋頁面的暗主題模式，你也可以自訂亮度、對比度等設定。你可對每個網站設定不同的設定，例如：A 網站要開啟暗主題，但 B 網站關閉暗主題。Stylus下載連結：Stylus功能：在各自頁面自訂 CSS 樣式，即客製化主題之前在「套用自訂 HackMD 暗主題」就有提供這個 Extension，當時我為 HackMD 客製化了暗主題。當然你也可以在你希望的網頁上自訂 CSS，例如：頁面的字太小，所以自己設定 font-size 放大文章連結沒有底線，看不出與無連結文字的差別，所以自己為設定了 a { text-decoration: underline; }…等那如何各別網站設定自訂的 CSS 呢？只要點擊 Extension 的圖案，並點擊「編寫樣式給：」下面的網址連結，就會為該網站開啟自訂 CSS 的編輯器：接著就可以開始寫自訂 CSS 了。像下圖是我自訂本 blog 的背景顏色改為灰黑色，只要儲存就能成功套用：如果想將自己自訂的 CSS 分享給別人，可將設定上傳至 Userstyles.org 這個網站讓別人下載套用。Medium Code Highlighter下載連結：Medium Code Highlighter功能：highlight Medium 文章內的程式碼找資料時，常會看到 Medium 的文章，但他的程式碼區塊沒有提供 code highlight 功能。使用此 Extension 就能 highlight Medium 文章內的程式碼：而且還能自己選主題：","categories":[{"name":"Tools","slug":"tools","permalink":"https://titangene.github.io/categories/tools/"}],"tags":[{"name":"Markdown","slug":"markdown","permalink":"https://titangene.github.io/tags/markdown/"},{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Chrome","slug":"chrome","permalink":"https://titangene.github.io/tags/chrome/"},{"name":"Chrome Extension","slug":"chrome-extension","permalink":"https://titangene.github.io/tags/chrome-extension/"},{"name":"Theme","slug":"theme","permalink":"https://titangene.github.io/tags/theme/"}],"author":"Titangene"},{"title":"Jest：DOM 測試 (jQuery)","slug":"jest-jquery-dom-testing","date":"2020-08-02T15:55:10.000Z","updated":"2020-08-02T15:54:34.300Z","comments":true,"path":"article/jest-jquery-dom-testing.html","link":"","permalink":"https://titangene.github.io/article/jest-jquery-dom-testing.html","excerpt":"若用 Jest 來測試直接操作 DOM 的程式碼，最大好處是不用安裝額外的套件就可以測試，因為 Jest 附帶了 jsdom，它是用來模擬 DOM 環境，讓你很像在瀏覽器上呼叫 DOM API，進而觀察 DOM 的操作是否符合預期，也就代表測畫面不用真的開啟瀏覽器，不用等待畫面渲染就可以進行測試。","text":"若用 Jest 來測試直接操作 DOM 的程式碼，最大好處是不用安裝額外的套件就可以測試，因為 Jest 附帶了 jsdom，它是用來模擬 DOM 環境，讓你很像在瀏覽器上呼叫 DOM API，進而觀察 DOM 的操作是否符合預期，也就代表測畫面不用真的開啟瀏覽器，不用等待畫面渲染就可以進行測試。其他 Jest 相關文章可參閱 Jest 系列文章。寫範例程式碼本篇會用下面程式碼作為範例：fetchCurrentUser.js：發送 request，並將收到的資料進行解析處理displayUser.js：在按鈕上註冊 click 事件，點擊按鈕後會發 API，並將資料顯示在畫面上12345678910111213141516171819// src/fetchCurrentUser.jsconst $ = require('jquery');function parseJSON(user) &#123; return &#123; fullName: user.firstName + ' ' + user.lastName, loggedIn: true, &#125;;&#125;function fetchCurrentUser(callback) &#123; return $.ajax(&#123; success: user =&gt; callback(parseJSON(user)), type: 'GET', url: 'http://example.com/currentUser', &#125;);&#125;module.exports = fetchCurrentUser;12345678910// src/displayUser.jsconst $ = require('jquery');const fetchCurrentUser = require('./fetchCurrentUser.js');$('#button').click(() =&gt; &#123; fetchCurrentUser(user =&gt; &#123; const loggedText = 'Logged ' + (user.loggedIn ? 'In' : 'Out'); $('#username').text(user.fullName + ' - ' + loggedText); &#125;);&#125;);建立測試被測試的函數在 #button DOM 元素上新增一個事件監聽器，所以需要設定 DOM 來進行測試。Jest 附帶了 jsdom，它模擬一個 DOM 環境，很像瀏覽器，代表呼叫的每個 DOM API 都可像在瀏覽器中觀察的方式一樣。mock fetchCurrentUser.js 可讓測試不用真的發出請求，可 reslove 成 local mock data，快速進行測試。12345678910111213141516171819202122232425262728293031323334353637// __tests__/displayUser.test.jsjest.mock('../src/fetchCurrentUser');it('點擊按鈕後顯示使用者已登入', () =&gt; &#123; // 設定 document body document.body.innerHTML = ` &lt;span id=\"username\"&gt;&lt;/span&gt; &lt;button id=\"button\"&gt;&lt;/button&gt;`; // 此 module 有 side-effect require('../src/displayUser'); const $ = require('jquery'); const fetchCurrentUser = require('../src/fetchCurrentUser'); // 告訴 fetchCurrentUser mock 函數自動使用一些資料來 invoke callback fetchCurrentUser.mockImplementation(callback =&gt; &#123; callback(&#123; fullName: 'Titan', loggedIn: true, &#125;); &#125;); // 點擊前的 DOM console.log(document.body.innerHTML); // 使用 jQuery 模擬點擊按鈕 $('#button').click(); // 點擊後的 DOM console.log(document.body.innerHTML); // Assert fetchCurrentUser 函數已被呼叫， // 且 span#username 的 inner text 已按預期更新了 expect(fetchCurrentUser).toBeCalled(); expect($('#username').text()).toEqual('Titan - Logged In');&#125;);下面測試為何要用 $.ajax.mock.calls[0][0].success() 的方式測，而不是直接 mock src/fetchCurrentUser.js 檔案內的 parseJSON？因為 src/fetchCurrentUser.js 檔案內的 parseJSON 沒有 export，所以不能 mock，而且 mock 就失去測試的意義了，該測試就是為了確定 $.ajax 發出請求拿到的使用者資料透過 parseJSON 處理後是否會得到正確的資料 (API 會回傳使用者的 firstName 和 lastName，而 parseJSON 是負責把名字組合成 fullName 和是否登入的狀態 loggedIn )。註：Jest 官方文件提供的 examples/jquery 範例內原本沒有以下內容，因視需求而修改的：為了讓將 mock 過的 $.ajax() 在每個測試執行前都被清乾淨 (不保留前一個測試使用個的痕跡)，所以需要在 beforeEach() 內加上 $.ajax.mockClear()原本範例內的每個測試都 require 了 jquery 和 fetchCurrentUser.js，為了簡化測試檔，把這些 require 統一放在測試檔的最上面可用與 expect(callback.mock.calls[0][0]).toEqual() 行為一致的 expect(callback).toBeCalledWith() 但更簡潔的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// __tests__/fetchCurrentUser.test.jsimport $ from 'jquery';const fetchCurrentUser = require('../src/fetchCurrentUser');jest.mock('jquery');beforeEach(() =&gt; &#123; jest.resetModules(); $.ajax.mockClear();&#125;);it('用正確的參數呼叫 $.ajax', () =&gt; &#123; // 呼叫要測試的函數 const dummyCallback = () =&gt; &#123;&#125;; fetchCurrentUser(dummyCallback); // 確保在前兩行有正確的呼叫 $.ajax // 不在意 $.ajax 的請求結果，只驗證呼叫 $.ajax 時傳的參數是否正確 expect($.ajax).toBeCalledWith(&#123; success: expect.any(Function), type: 'GET', url: 'http://example.com/currentUser', &#125;);&#125;);it('$.ajax 請求完成後呼叫 callback', () =&gt; &#123; // 為 callback 建立一個 mock function const callback = jest.fn(); fetchCurrentUser(callback); // 模擬 `$.ajax` 執行自己的 callback // 第一次呼叫的第一個參數 $.ajax.mock.calls[0][0].success(&#123; firstName: 'Bobby', lastName: 'Marley', &#125;); // assert 模擬 `$.ajax` 呼叫的 callback 傳入的 arg // 第一次呼叫的第一個參數 expect(callback.mock.calls[0][0]).toEqual(&#123; fullName: 'Bobby Marley', loggedIn: true, &#125;); expect(callback).toBeCalledWith(&#123; fullName: 'Bobby Marley', loggedIn: true, &#125;);&#125;);在 fetchCurrentUser.test.js 測試檔內我自己加了一個測試，用來測使用者點擊按鈕後是否正確的呼叫 fetchCurrentUser()，並且裡面呼叫的 $.ajax() 是否有正確的呼叫 success 內的 callback (即 success: user =&gt; callback(parseJSON(user)) )。但為了不讓 $.ajax() 發出真的請求，所以用 $.ajax = jest.fn() mock，接著再透過 $.ajax.mock.calls[0][0].success({...}) 的方式呼叫 success 內的 callback。不過，這個測試比較複雜，因為測試檔的最上面使用了 jest.mock('jquery')，讓整個測試檔都 mock 了 jQuery，但在 require('../src/displayUser') 要綁定按鈕點擊事件時需要用真的 jQuery，所以才需要用 jest.unmock('jquery') unmock jQuery。除了綁定按鈕點擊事件要用真的 jQuery，觸發點擊事件後顯示使用者已登入的 $('#username').text() 也要用真的 jQuery (因本測試會用 span#username 的 innerText 來驗證測試)。12345678910111213141516171819202122232425262728293031323334353637383940414243// __tests__/fetchCurrentUser.test.jsimport $ from 'jquery';const fetchCurrentUser = require('../src/fetchCurrentUser');jest.mock('jquery');beforeEach(() =&gt; &#123; jest.resetModules(); $.ajax.mockClear();&#125;);it('點擊按鈕發出 $.ajax 請求，請求完成後顯示使用者已登入', () =&gt; &#123; // 設定 document body document.body.innerHTML = ` &lt;span id=\"username\"&gt;&lt;/span&gt; &lt;button id=\"button\"&gt;&lt;/button&gt;`; // 使用 `jest.unmock(...)` 後，require 的模組都會是真的，不是 mock 的 // 因測試檔的最上面 mock 了 jQuery，而 `displayUser.js` 內 // 需要跑真的 jQuery，所以需要 unmock jQuery， jest.unmock('jquery'); // 此 module 有 side-effect require('../src/displayUser'); // 觸發點擊事件內要執行真的 `$(...).text()`，所以需要真的 jQuery const $ = require('jquery'); // 但只有 `$.ajax` 需要 mock $.ajax = jest.fn(); // 模擬點擊按鈕 document.querySelector('button').click(); // 模擬 `$.ajax` 執行自己的 callback // 第一次呼叫的第一個參數 $.ajax.mock.calls[0][0].success(&#123; firstName: 'Bobby', lastName: 'Marley', &#125;); // Assert span#username 的 inner text 已按預期更新了 (畫面顯示使用者已登入) expect($('#username').text()).toEqual('Bobby Marley - Logged In');&#125;);資料來源：DOM Manipulation · Jest","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"},{"name":"mock","slug":"mock","permalink":"https://titangene.github.io/tags/mock/"},{"name":"DOM","slug":"dom","permalink":"https://titangene.github.io/tags/dom/"},{"name":"jQuery","slug":"jquery","permalink":"https://titangene.github.io/tags/jquery/"}],"author":"Titangene"},{"title":"Jest：Manual Mocks","slug":"jest-manual-mocks","date":"2020-07-26T15:59:04.000Z","updated":"2020-07-26T16:00:27.192Z","comments":true,"path":"article/jest-manual-mocks.html","link":"","permalink":"https://titangene.github.io/article/jest-manual-mocks.html","excerpt":"manual mock 是用於透過 mock 資料來對功能進行 stub out。例如：若你不想存取網站或 DB 之類的遠端資源，可能需要使用 fake data 來 manual mock 這些功能，以確保可以快速測試且不會出錯。","text":"manual mock 是用於透過 mock 資料來對功能進行 stub out。例如：若你不想存取網站或 DB 之類的遠端資源，可能需要使用 fake data 來 manual mock 這些功能，以確保可以快速測試且不會出錯。其他 Jest 相關文章可參閱 Jest 系列文章。Mocking user modulesmanual mock 是透過將模組寫在相鄰該模組的 __mocks__/ 子目錄內來定義的。例如：要在 models 目錄 mock 一個名為 user 的模組，請建立名為 user.js 的檔案，並將該檔案放在 models/__mocks__ 目錄中。123456.├── models│ ├── __mocks__│ │ └── user.js│ └── user.js└── main.js__mocks__ 資料夾會區分大小寫 (case-sensitive)，所以在某些 OS 上命名成 __MOCKS__ 會失效。範例完整目錄如下：12345678910111213.├── src│ ├── controllers│ │ ├── __mocks__│ │ │ └── user.js│ │ └── user.js│ ├── models│ │ ├── index.js│ │ └── user.js│ ├── setup.js│ └── main.js└── __tests__ └── userMocked.test.js在 src/controllers/user.js 內提供取得第一個使用者資訊的 getFirstUser() (從 DB 拿出來的資料)：1234567891011121314// src/controllers/user.jsconst User = require('../models').User;module.exports = &#123; async getFirstUser() &#123; try &#123; const userId = 1; const user = await models.user.findByPk(userId); return user; &#125; catch (error) &#123; console.log(error.message); &#125; &#125;&#125;;接著在 src/controllers 目錄內新增 __mocks__ 子目錄，並在裡面建立名為 user.js 的檔案，內容如下，manual mock 的內容就是回傳固定的 fake data，讓每次執行測試不用真的去讀取資料庫的資料：123456789// src/controllers/__mocks__/user.jsconst User = jest.createMockFromModule('../user');User.getFirstUser = async () =&gt; (&#123; name: 'Mock name', age: 87&#125;);module.exports = User;測試要引入 manual mock 的模組時，記得要呼叫 jest.mock('./moduleName')，其餘測試寫法就跟平時一樣：123456789101112// __tests__/userMocked.test.jsimport User from '../src/controllers/user';jest.mock('../src/controllers/user');it('if user model is mocked', async () =&gt; &#123; const expected = &#123;name: 'Mock name', age: 87&#125;; const user = await User.getFirstUser(); expect(user).toMatchObject(expected);&#125;);Mocking Node modules若要 mock 的模組是 Node 模組 (例如：lodash )，則 mock 應放在與 node_modules 相鄰的 __mocks__ 目錄中 (除非你將 roots 配置為指向專案 root 目錄以外的資料夾)，並且會被自動 mock。無需明確呼叫 jest.mock('./moduleName')：1234567.├── __mocks__│ └── lodash.js├── node_modules│ └── lodash│ └── lodash.js└── main.js可以透過在目錄結構中建立一個與 scoped module 名稱 match 的檔案來 mock scoped module。例如：若要 mock 名為 @scope/project-name 的 scoped module，請建立名為 __mocks__/@scope/project-name.js 的檔案：12345678.├── __mocks__│ └── @scope│ └── project-name.js├── node_modules│ └── @scope│ └── project-name└── main.js警告：若要 mock Node 的核心模組 (例如：fs 或 path )，必須要明確呼叫 (例如：jest.mock('path') )，因為預設不會 mock 核心 Node 模組。例如12345678910.├── config├── __mocks__│ └── fs.js├── models│ ├── __mocks__│ │ └── user.js│ └── user.js├── node_modules└── views當給定模組有 manual mock 時，Jest 的模組系統會在明確呼叫 jest.mock('moduleName') 時使用該模組。但是，當配置的 automock 設為 true 時，即使未呼叫 jest.mock('moduleName')，也會用 manual mock implementation 來取代自動建立的 mock。若要取消 mock，需要在應該使用實際模組 implementation 的測試中顯式明確呼叫 jest.unmock('moduleName')。為了正確的 mock，Jest 需要 jest.mock('moduleName') 與 require / import 陳述句在同一個 scope 內。例如：有一個模組可提供給定目錄中所有檔案的摘要。這裡使用核心 (內建) fs 模組：12345678910111213// fileSummarizer.js'use strict';const fs = require('fs');function summarizeFilesInDirectorySync(directory) &#123; return fs.readdirSync(directory).map(fileName =&gt; (&#123; directory, fileName, &#125;));&#125;exports.summarizeFilesInDirectorySync = summarizeFilesInDirectorySync;由於我們希望測試避免實際對硬碟進行存取 (因為會很慢且脆弱)，所以會透過擴充自動 mock 來為 fs 模組建立 manual mock。我們的 manual mock 會實作可用於測試的 fs API 的自訂版：1234567891011121314151617181920212223242526272829303132// __mocks__/fs.js'use strict';const path = require('path');const fs = jest.createMockFromModule('fs');// 這是自訂函數，測試可在 setup 過程中使用此函數// 來指定使用任何 `fs` API 時 mock filesystem 上的檔案應該為何let mockFiles = Object.create(null);function __setMockFiles(newMockFiles) &#123; mockFiles = Object.create(null); for (const file in newMockFiles) &#123; const dir = path.dirname(file); if (!mockFiles[dir]) &#123; mockFiles[dir] = []; &#125; mockFiles[dir].push(path.basename(file)); &#125;&#125;// 自訂版的 `readdirSync` 透過// 從`__setMockFiles` 設定的指定 mocked 檔案列表中讀取function readdirSync(directoryPath) &#123; return mockFiles[directoryPath] || [];&#125;fs.__setMockFiles = __setMockFiles;fs.readdirSync = readdirSync;module.exports = fs;現在我們來寫測試。請注意，由於它是核心 Node 模組，所以需要明確告知我們要 mock fs 模組 (也就是需明確呼叫 jest.mock('fs') )：12345678910111213141516171819202122232425// __tests__/FileSummarizer-test.js'use strict';jest.mock('fs');describe('listFilesInDirectorySync', () =&gt; &#123; const MOCK_FILE_INFO = &#123; '/path/to/file1.js': 'console.log(\"file1 contents\");', '/path/to/file2.txt': 'file2 contents', &#125;; beforeEach(() =&gt; &#123; // 在每次測試之前 setup 一些 mocked out 檔案資訊 require('fs').__setMockFiles(MOCK_FILE_INFO); &#125;); test('includes all files in the directory in the summary', () =&gt; &#123; const FileSummarizer = require('../FileSummarizer'); const fileSummary = FileSummarizer.summarizeFilesInDirectorySync( '/path/to', ); expect(fileSummary.length).toBe(2); &#125;);&#125;);此範例的 mock 是用 jest.createMockFromModule 來生成自動 mock，並覆蓋預設的行為 (也就是大部份都是真的，但少部份是假的)。推薦此方法，但不強迫。若不想使用自動 mock，則可從 mock 檔案中 export 自己的函數。完全 manual mock 的一個缺點是它們是手動的，代表必須在模組 mocking changes 時隨時手動更新它們。所以最好在滿足你的需求時使用或擴充自動 mock。為了確保 manual mock 和實際實作保持同步，在 export manual mock 模組之前，請在 manual mock 中使用 jest.requireActual(moduleName) 使用真實的模組，並用 mock 函數對其進行變更，這可能會很有用。範例程式碼：examples/manual-mocks。與 ES 模組引入一起使用若你正在使用 ES 模組 imports，通常會傾向將 import 陳述句放在測試檔案的最上面。但通常你需要指示 Jest 在模組使用 mock 之前使用它。所以 Jest 會自動將 jest.mock 呼叫 hoist 至模組的最上面 (在 import 之前)。詳情可參閱 kentcdodds/how-jest-mocking-works。JSDOM 中未實作的 mock 方法若某些程式碼使用的方法尚未實作 JSDOM (Jest 使用的 DOM implementation)，則不易於測試。例如：Window.matchMedia() 的情況。Jest 會回傳 TypeError: window.matchMedia is not a function，不能正確執行測試。在這種情況下，在測試檔案中 mock matchMedia 應該可以解決此問題：1234567891011121314// __tests__/matchMedia.mock.jsObject.defineProperty(window, 'matchMedia', &#123; writable: true, value: jest.fn().mockImplementation(query =&gt; (&#123; matches: false, media: query, onchange: null, addListener: jest.fn(), // deprecated removeListener: jest.fn(), // deprecated addEventListener: jest.fn(), removeEventListener: jest.fn(), dispatchEvent: jest.fn(), &#125;)),&#125;);matchMedia.mock.js 這個檔案放哪都可以，但記得配置要設成 testEnvironment: &quot;jsdom&quot;。若在測試中 invoked 的函數 (或方法) 中使用 window.matchMedia()，則此方法可以運作若在測試檔案中直接執行 window.matchMedia()，Jest 會出現相同的錯誤所以解決方案是將 manual mock 放在獨立的檔案中，並在測試之前將其包含在測試檔案中：1234// src/useMatchMedia.jsexport default function useMatchMedia() &#123; return window.matchMedia('xx').matches;&#125;12345678// __tests__/userMocked.test.jsimport \"./matchMedia.mock\"; // 必須在測試檔案之前 importimport useMatchMedia from \"../src/useMatchMedia\";it('use matchMedia()', () =&gt; &#123; // 在這裡測試 method... expect(useMatchMedia()).toBeFalsy();&#125;);資料來源：Manual Mocks · Jest","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"},{"name":"mock","slug":"mock","permalink":"https://titangene.github.io/tags/mock/"}],"author":"Titangene"},{"title":"Jest：Timer Mocks","slug":"jest-timer-mocks","date":"2020-07-19T14:05:04.000Z","updated":"2020-07-19T14:04:15.794Z","comments":true,"path":"article/jest-timer-mocks.html","link":"","permalink":"https://titangene.github.io/article/jest-timer-mocks.html","excerpt":"常用的 native timer 包括 setTimeout、setInterval、clearTimeout、clearInterval 等，用到這些 timer 的函數可以說是依賴於真實流逝的時間。如果 timer 要跑幾秒後才會觸發，或是要確認某函數是否在固定週期內被呼叫幾次，你不可能真的去等待 timer 跑完才能驗證結果吧，那根本是浪費時間。所以應該要使用 mock 函數來 mock 掉那些 timer 函數，透過 Jest 提供的功能來控制時間，其中就有時間快轉的功能，減少測試要等待的時間。","text":"常用的 native timer 包括 setTimeout、setInterval、clearTimeout、clearInterval 等，用到這些 timer 的函數可以說是依賴於真實流逝的時間。如果 timer 要跑幾秒後才會觸發，或是要確認某函數是否在固定週期內被呼叫幾次，你不可能真的去等待 timer 跑完才能驗證結果吧，那根本是浪費時間。所以應該要使用 mock 函數來 mock 掉那些 timer 函數，透過 Jest 提供的功能來控制時間，其中就有時間快轉的功能，減少測試要等待的時間。其他 Jest 相關文章可參閱 Jest 系列文章。啟動 fake timer要在 Jest 使用 mock 過的 timer，可透過呼叫 jest.useFakeTimers() 來啟動 fake timer，之後就可以用 fake timer 來控制時間。假設有一個 timerGame() 函數，呼叫該函數時，會先列印 'Ready....go!'，接著至少過了 1 秒後才會列印 &quot;Time's up -- stop!&quot;，並且呼叫傳入的 callback：12345678// src/timerGame.jsexport function timerGame(callback) &#123; console.log('Ready....go!'); setTimeout(() =&gt; &#123; console.log(\"Time's up -- stop!\"); callback &amp;&amp; callback(); &#125;, 1000);&#125;如果測試這樣寫：12345678910111213// __tests__/timerGame.test.jsimport &#123; timerGame &#125; from '../src/timerGame';jest.useFakeTimers();describe('執行一次 timer', () =&gt; &#123; it('等待 1 秒後結束遊戲', () =&gt; &#123; timerGame(); expect(setTimeout).toBeCalledTimes(1); expect(setTimeout).lastCalledWith(expect.any(Function), 1000); &#125;);&#125;);測試只有測到 timerGame() 的以下內容：setTimeout 被呼叫幾次 (即 toBeCalledTimes(number) )最後一次呼叫 setTimeout 的 argument 為何 (即 lastCalledWith(arg1, arg2, ...) )：第一個 argument 可以是任何函數第二個 argument 一定是 1000 豪秒所以 timerGame() 內的 console.log(&quot;Time's up -- stop!&quot;) 那行都還沒執行就測試通過了 (所以才只輸出 'Ready....go!' 這行)。若在一個檔案或 describe 區塊中執行多個測試，就可在每個測試之前手動呼叫 jest.useFakeTimers()，或是使用 beforeEach 之類的 setup 函數。否則會讓內部使用的 timer 未被 reset。如果沒有 reset timer，可能會像這個測試一樣很奇怪：第一個 it 區塊的測試很正常，只呼叫一次 timerGame()，所以 setTimeout 只被呼叫過一次但第二個 it 區塊的測試被第一個 it 區塊使用的 setTimeout 所污染，明明 timerGame() 只呼叫過一次，竟然 assert setTimeout 不是被呼叫過一次 ，而是兩次123456789101112131415161718192021222324// __tests__/resetTimer.test.jsimport &#123; timerGame &#125; from '../src/timerGame';describe('每個測試都只呼叫一次 `timerGame()`', () =&gt; &#123; describe('未在每個測試執行前 reset timer', () =&gt; &#123; // 不建議直接在 `describe` 區塊內呼叫 `jest.useFakeTimers()` // 應在 Setup and Teardown 時 reset timer jest.useFakeTimers(); it('setTimeout 的呼叫次數應為 1 次', () =&gt; &#123; timerGame(); expect(setTimeout).toBeCalledTimes(1); expect(setTimeout).lastCalledWith(expect.any(Function), 1000); &#125;); it('setTimeout 的呼叫次數應為 2 次，setTimeout 的呼叫次數會因前面的測試未 reset timer 而影響', () =&gt; &#123; timerGame(); expect(setTimeout).not.toBeCalledTimes(1); expect(setTimeout).toBeCalledTimes(2); &#125;); &#125;);&#125;);所以應在 setup (即 beforeEach() ) 和 teardown (即 afterEach() ) 時 reset timer：12345678910111213141516171819202122232425262728293031// __tests__/resetTimer.test.jsimport &#123; timerGame &#125; from '../src/timerGame';// 不建議在測試檔案的全域使用 `jest.useFakeTimers()`// 應在 Setup and Teardown 時 reset timer// jest.useFakeTimers();describe('每個測試都只呼叫一次 `timerGame()`', () =&gt; &#123; describe('有在每個測試執行前 reset timer', () =&gt; &#123; beforeEach(() =&gt; &#123; jest.useFakeTimers(); &#125;); it('setTimeout 的呼叫次數應為 1 次', () =&gt; &#123; timerGame(); expect(setTimeout).toBeCalledTimes(1); expect(setTimeout).lastCalledWith(expect.any(Function), 1000); &#125;); it('setTimeout 的呼叫次數應為 1 次，setTimeout 的呼叫次數不會受前面的測試影響', () =&gt; &#123; timerGame(); expect(setTimeout).toBeCalledTimes(1); &#125;); afterEach(() =&gt; &#123; jest.clearAllTimers(); &#125;); &#125;);&#125;);使用 jest.useFakeTimers() 的建議不應在以下位置使用 jest.useFakeTimers()：測試檔案的全域呼叫直接在 describe 區塊內呼叫建議在 setup 和 teardown 時 reset timer。當然可以放在 it 或 test 區塊內，或是在 setup 和 teardown 呼叫，但需重複寫很多次，很麻煩。下面是 jest.useFakeTimers(implementation?: 'modern' | 'legacy') 的介紹：指定 Jest 使用 fake 的標準 timer 函數，包括：setTimeoutsetIntervalclearTimeoutclearIntervalnextTicksetImmediateclearImmediate若使用 'modern' 作為 argument，則會使用 @sinonjs/fake-timers 來作為 implementation，而不是 Jest 自己的 fake timer也可 mock 其他 timer，例如：Date'modern' 是 Jest 27 的預設行為 (目前我使用的環境是 Jest 25，所以是用 legacy )回傳用於 chaining 的 jest 物件上面提到的 'modern' 和 legacy 是 jest.config.js 內的 timers config：預設為 &quot;real&quot;設為 &quot;legacy&quot; 或 &quot;fake&quot; 時，允許對函數使用 fake timer。當程式碼設定了不想在測試中等待的 long timeout，fake timer 就很好用設為 &quot;modern&quot; 時，會將 @sinonjs/fake-timers 作為實作，而不是 Jest 自己的舊實作。Jest 27 會預設此設定在 Jest 15 開始才將 timers config 預設成 &quot;real&quot;。可透過在配置中指定 timers: &quot;fake&quot; 或呼叫 jest.useRealTimers() 和 jest.useFakeTimers() 全域開關來覆蓋此設定。執行所有 timer若要測試 assert 在 1 秒後呼叫 callback，可在測試中使用 Jest 的 timer 控制 API jest.runAllTimers() 來快轉時間：1234567891011121314151617181920// __tests__/timerGame.test.jsdescribe('執行所有 timer', () =&gt; &#123; it('1 秒後呼叫 callback', () =&gt; &#123; jest.useFakeTimers(); const callback = jest.fn(); timerGame(callback); // 此時 callback 應該還沒被呼叫 expect(callback).not.toBeCalled(); // 快轉直到執行完所有 timer jest.runAllTimers(); // 現在 callback 已被呼叫 expect(callback).toBeCalled(); expect(callback).toBeCalledTimes(1); &#125;);&#125;);jest.runAllTimers()：用盡 macro-task queue (即由 setTimeout()、setInterval() 和 setImmediate() 排隊 (queued) 的所有 task) 和 micro-task queue (通常會透過 process.nextTick interfaced 至 node)呼叫此 API 時，會執行所有 pending macro-tasks 和 micro-tasks。若這些 task 本身安排了 (schedule) 新 task，這些 task 就會不斷的耗盡 (exhausted)，直到 queue 中沒有其他 task 為止通常在測試期間同步執行 setTimeout 很有用，以便同步 assert 某些行為，但這些行為只會在 setTimeout() 或 setInterval() 的 callback 執行後才發生執行 pending timer假設有遞迴的 timer，會在自己的 callback 中設定一個新的 timer。若執行所有 timer 就會變成無限迴圈，所以不能用像是 jest.runAllTimers()，但可用 jest.runOnlyPendingTimers()：1234567891011121314// src/infiniteTimerGame.jsexport function infiniteTimerGame(callback) &#123; console.log('Ready....go!'); setTimeout(() =&gt; &#123; console.log(\"Time's up! 5 seconds before the next game starts...\"); callback &amp;&amp; callback(); // 在 5 秒內安排下一場比賽 setTimeout(() =&gt; &#123; infiniteTimerGame(callback); &#125;, 5000); &#125;, 1000);&#125;1234567891011121314151617181920212223242526// __tests__/infiniteTimerGame.test.jsimport &#123; infiniteTimerGame &#125; from '../src/infiniteTimerGame';describe('infiniteTimerGame', () =&gt; &#123; test('在 1 秒後安排 5 秒 timer', () =&gt; &#123; jest.useFakeTimers(); const callback = jest.fn(); infiniteTimerGame(callback); // 此時應該只有呼叫一次 `setTimeout` 才能在 1 秒內安排遊戲結束 expect(setTimeout).toBeCalledTimes(1); expect(setTimeout).lastCalledWith(expect.any(Function), 1000); // 快轉並只耗盡當前 pending timer // (但此過程中不會建立任何新的 timer) jest.runOnlyPendingTimers(); // 此時，1 秒的 timer 應該觸發了 callback expect(callback).toBeCalled(); // 並且應該已建立一個新的 timer，可在 5 秒內開始遊戲 expect(setTimeout).toBeCalledTimes(2); expect(setTimeout).lastCalledWith(expect.any(Function), 5000); &#125;);&#125;);依時間 advance (提前) timerjest.advanceTimersByTime(msToRun)：Jest 22.0.0 將 runTimersToTime() (但還可以當作 alias 使用) 重新命名成 advanceTimersByTime()只會執行 macro task queue (即由 setTimeout() 或 setInterval() 和 setImmediate() 排隊 (queued) 的所有 task)呼叫時，所有 timer 都會被提前 msToRun 豪秒透過 setTimeout() 或 setInterval() 排隊 (queued)，並在此時間範圍 (time frame) 內執行的所有 pending “macro-tasks” 都會被執行如果這些是 macro-tasks 計劃 (schedule) 在同一時間範圍內執行的新 macro-tasks，就會一直執行這些 macro-tasks，直到 queue 中沒有其他應該在 msToRun 毫秒內執行的 macro-tasks 為止1234567891011121314151617// __tests__/advanceTimersByTime.test.jsdescribe('Advance Timers by Time', () =&gt; &#123; it('1 秒後透過 `advanceTimersByTime` 呼叫 callback', () =&gt; &#123; const callback = jest.fn(); timerGame(callback); // 此時 callback 應該還沒被呼叫 expect(callback).not.toBeCalled(); // 快轉直到執行完所有 timer jest.advanceTimersByTime(1000); // 現在 callback 已被呼叫 expect(callback).toBeCalled(); expect(callback).toHaveBeenCalledTimes(1); &#125;);&#125;);可用 jest.clearAllTimers() 從 timer 系統中刪除所有 pending timer，也就是若 scheduled (安排了) 任何 timer (但尚未執行)，可被清除並永遠沒有機會執行它們。其他jest.useRealTimers()指定 Jest 使用標準 timer 函數的實際版本回傳用於 chaining 的 jest 物件jest.runAllTicks()：耗盡 micro-task queue (通常會透過 process.nextTick interfaced 至 node)呼叫此 API 時，會執行透過 process.nextTick 排隊 (queued) 的所有 pending micro-tasks若這些 micro-tasks 安排了 (schedule) 新 task，這些 task 就會不斷的耗盡 (exhausted)，直到 queue 中沒有其他 micro-tasks 為止jest.runAllImmediates()：耗盡由 setImmediate() 排隊 (queued) 的所有 tasks注意：使用 modern fake timers implementation 時，此函數不可用jest.runOnlyPendingTimers()：只執行當前 pending macro-tasks (即只執行 setTimeout() 或 setInterval() 至目前為止已 queued (排隊) 的 task)若任何當前 pending macro-tasks 安排了 (schedule) 新 task，這些新 task 就不會透過 jest.runOnlyPendingTimers() 呼叫執行jest.advanceTimersToNextTimer(steps?)：將所有 timer 提前所需的毫秒數，以便只執行下一個 timeouts/intervals可提供 steps arg，執行下一次 timeouts/intervals 的 steps 數jest.getTimerCount()：回傳仍在執行的 fake timer 數量jest.setSystemTime()：設定 fake timer 使用的當前系統時間模擬使用者在 program 執行時變更系統時鐘會影響當前時間，但不會導致像是 timers to fire (定時觸發)會完全照原樣觸發 (fire)，而無需呼叫 jest.setSystemTime()注意：此函數只在使用 modern fake timers implementation 時可用jest.getRealSystemTime()：在 mock 時間時，也會 mock Date.now()若想存取實際的當前時間，可 invoke 此函數注意：此函數只在使用 modern fake timers implementation 時可用jest.setTimeout(timeout)：設定測試和 hook 之前/之後的預設 timeout interval (單位為豪秒)會影響從中呼叫此函數的測試檔案若未呼叫此方法，預設 timeout interval 為 5 秒注意：若要為所有測試檔案設定 timeout，可在 setupFilesAfterEnv 中設定jest.retryTimes(numTestRetries)：n 次執行失敗的測試，直到它們通過或直到最大重試次數用完為止只適用於 jest-circus回傳用於 chaining 的 jest 物件1234jest.retryTimes(3);test('will fail', () =&gt; &#123; expect(true).toBe(false);&#125;);資料來源：Timer Mocks · JestJest 15.0: New Defaults for Jest · Jest","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"},{"name":"mock","slug":"mock","permalink":"https://titangene.github.io/tags/mock/"},{"name":"timer","slug":"timer","permalink":"https://titangene.github.io/tags/timer/"}],"author":"Titangene"},{"title":"Jest：Snapshot 測試","slug":"jest-snapshot-testing","date":"2020-07-12T15:58:31.000Z","updated":"2020-07-12T16:14:01.980Z","comments":true,"path":"article/jest-snapshot-testing.html","link":"","permalink":"https://titangene.github.io/article/jest-snapshot-testing.html","excerpt":"若想確保 UI 不會因意外修改而產生 bug，snapshot 測試就是一個很好用的工具。","text":"若想確保 UI 不會因意外修改而產生 bug，snapshot 測試就是一個很好用的工具。其他 Jest 相關文章可參閱 Jest 系列文章。使用 Jest 進行 snapshot 測試如果想測試一個 UI 元件，要測的是產生的元素 (可序列化的值，即 HTML 原始碼)，而不是需要花時間渲染出來的畫面 (圖形 UI)。下面以連結元件為例，呼叫 rendererLinkElement()，並傳入 URL 和連結名稱就可以取得 renderer 回傳的 HTML：123456// src/linkElement.jsfunction rendererLinkElement(url, linkName) &#123; return `&lt;a href=\"$&#123;url&#125;\"&gt;$&#123;linkName&#125;&lt;/a&gt;`;&#125;export default rendererLinkElement;這邊使用 Jest 提供的 toMatchSnapshot() 進行測試：1234567891011// __tests__/externalSnapshots.test.jsdescribe('external snapshots', () =&gt; &#123; it('render the link element of the Titangene Blog home page', () =&gt; &#123; const url = 'https://titangene.github.io/'; const linkName = 'Titangene Blog'; const actual = rendererLinkElement(url, linkName); expect(actual).toMatchSnapshot(); &#125;);&#125;);執行測試：1234567891011121314$ npx jest ./__tests__/externalSnapshots.test.js PASS __tests__/externalSnapshots.test.js external snapshots ✓ render the link element of the Titangene Blog home page (3ms) › 1 snapshot written.Snapshot Summary › 1 snapshot written from 1 test suite.Test Suites: 1 passed, 1 totalTests: 1 passed, 1 totalSnapshots: 1 written, 1 totalTime: 0.657s, estimated 1sRan all test suites matching /.\\/__tests__\\/externalSnapshots.test.js/i.第一次執行此測試時，Jest 會在 __tests__ 目錄內建立 __snapshots__ 目錄，裡面建立一個 snapshot 檔案，檔名會是測試檔的名稱再加上 .snap (例如：externalSnapshots.test.js.snap )，內容如下：123// Jest Snapshot v1, https://goo.gl/fbAQLPexports[`renders correctly 1`] = `\"&lt;a href=\\\\\"https://titangene.github.io/\\\\\"&gt;Titangene Blog&lt;/a&gt;\"`;之後再次執行測試就會將 render 的輸出與之前的 snapshot 進行比較：若 match，測試就會通過若不 match，測試就會失敗可能是程式有 bug，或是實作發生變化，需要更新 snapshot123456789$ npx jest ./__tests__/linkElement.test.js PASS __tests__/linkElement.test.js ✓ renders correctly (4ms)Test Suites: 1 passed, 1 totalTests: 1 passed, 1 totalSnapshots: 1 passed, 1 totalTime: 0.777s, estimated 2sRan all test suites matching /.\\/__tests__\\/linkElement.test.js/i.snapshot 應與修改的程式碼一起 commit，並在 code review 中進行 review。註：Jest 內建提供 pretty-format 套件，可讓任何 JavaScript 值變成 human-readable 的字串 (序列化 JavaScript 內建型別值)，而 snapshot 就使用了此套件，所以 snapshot 才能在 code review 過程具有可讀性。更新 snapshot剛剛提到，若程式的實作發生變化，snapshot 與程式執行結果可能會不 match，測試就會失敗。假設不是因為 bug，是你現在修改的執行結果的確是你要的，但 snapshot 還是之前的預期結果，而你想將 snapshot 換成新的預期結果，這就需要更新 snapshot。下面就舉個情境，假設我想將測試修改成這樣：12345678910it('renders correctly', () =&gt; &#123;- const url = 'https://titangene.github.io/';- const linkName = 'Titangene Blog';+ const url = 'https://www.google.com/';+ const linkName = 'Google'; const actual = rendererLinkElement(url, linkName); expect(actual).toMatchSnapshot();&#125;);再次執行測試就會失敗，因為之前 snapshot 儲存的跟現在修改的不 match：使用 --updateSnapshot (或 -u ) option 就能為失敗的測試重新建立新的 snapshot (通過的測試不會重新建立)：1$ jest --updateSnapshot12345678910111213$ npx jest ./__tests__/linkElement.test.js -u PASS __tests__/linkElement.test.js ✓ renders correctly (4ms) › 1 snapshot updated.Snapshot Summary › 1 snapshot updated from 1 test suite.Test Suites: 1 passed, 1 totalTests: 1 passed, 1 totalSnapshots: 1 updated, 1 totalTime: 0.794s, estimated 1sRan all test suites matching /.\\/__tests__\\/linkElement.test.js/i.若要指定哪個測試需要重新產生 snapshot，可加上 --testNamePattern=&lt;regex&gt; option：1$ jest -u --testNamePattern=&lt;regex&gt;互動式 snapshot 模式在 watch 模式下，按 i 鍵進入互動式 snapshot 模式 (只有在有 failed snapshot 時，才會看到 i 這個選項)：此互動式 snapshot 模式是用 failed snapshot 和 failed output，此模式會各別看每個 snapshot，有以下功能：u (update)：更新失敗的 snapshots (skip)：跳過當前測試 (跳至下一個測試)q (quit)：離開互動式 snapshot 模式Enter：觸發測試執行 (重跑單前測試)只要還有一個 failed snapshot 未更新，就能按 r 鍵重新回到互動式 snapshot 模式：更新所有 failed snapshot 後，就可按 Enter 回到 watch 模式：可是奇怪的是，原本我執行 Jest 時有指定某個目錄內的測試，當我從互動式 snapshot 模式回到 watch 模式時，竟然之前的指令就失效，所以還會多測其他目錄內的測試 (目前猜測是未被 Git 追蹤的測試檔都會被執行)。Inline Snapshotsinline snapshot 和 external snapshot ( .snap 檔案) 的行為相同，但 inline snapshot 會把 snapshot value 自動寫回原始碼中。不用切換至外部檔案來確保寫入正確的值。inline snapshot 是由 Prettier 提供支援，所以必須安裝 Prettier 才能用 inline snapshot。寫測試檔時，請遵守你的 Prettier 配置。若你在 Jest 找不到的地方安裝 Prettier，則可用 prettierPath 配置屬性來告訴 Jest。如果未安裝 Prettier 就使用 toMatchInlineSnapshot()，會輸出以下錯誤訊息：123456FAIL __tests__/inlineSnapshots.test.js ● Test suite failed to run Cannot find module 'prettier' from 'setup_jest_globals.js' at Resolver.resolveModule (node_modules/jest-resolve/build/index.js:296:11)安裝 Prettier：1$ yarn add prettier --dev --exact一開始寫測試時，不帶 argument 呼叫 toMatchInlineSnapshot()：12345678910111213// __tests__/inlineSnapshots.test.jsimport rendererLinkElement from \"../src/linkElement\";describe(\"inline snapshots\", () =&gt; &#123; it(\"render the link element of the Titangene Blog home page\", () =&gt; &#123; const url = \"https://titangene.github.io/\"; const linkName = \"Titangene Blog\"; const actual = rendererLinkElement(url, linkName); expect(actual).toMatchInlineSnapshot(); &#125;);&#125;);執行測試時，Jest 會對 tree 進行評估，且 snapshot 會寫入 toMatchInlineSnapshot() 的 argument：1234567891011121314$ npx jest .__tests__/inlineSnapshots.test.js PASS __tests__/inlineSnapshots.test.js inline snapshots ✓ render the link element of the Titangene Blog home page (12ms) › 1 snapshot written.Snapshot Summary › 1 snapshot written from 1 test suite.Test Suites: 1 passed, 1 totalTests: 1 passed, 1 totalSnapshots: 1 written, 1 totalTime: 0.909s, estimated 1sRan all test suites matching /.\\/__tests__\\/inlineSnapshots.test.js/i.123456789101112describe(\"inline snapshots\", () =&gt; &#123; it(\"render the link element of the Titangene Blog home page\", () =&gt; &#123; const url = \"https://titangene.github.io/\"; const linkName = \"Titangene Blog\"; const actual = rendererLinkElement(url, linkName); expect(actual).toMatchInlineSnapshot( `\"&lt;a href=\\\\\"https://titangene.github.io/\\\\\"&gt;Titangene Blog&lt;/a&gt;\"` ); &#125;);&#125;);也可在指令使用 --updateSnapshot (或 -u ) option 或在 --watch 模式下按 u 鍵來更新 snapshot。Property Matchers有時 snapshot 的物件中會有生成一些 field (例如：ID 和 Date)，若對這些物件進行 snapshot，就會在執行時常常發生 snapshot 失敗。1234567891011121314// __tests__/propertyMatchers.test.jsdescribe('Property Matchers', () =&gt; &#123; it('will fail every time', () =&gt; &#123; const user = &#123; name: 'Titan', createdAt: new Date(), id: Math.floor(Math.random() * 20) &#125;; console.log(user); expect(user).toMatchSnapshot(); &#125;);&#125;);像上面的測試執行第二次時，snapshot 就會失敗：所以 Jest 允許你對任何 property 提供 asymmetric matcher。Jest 會在寫入 snapshot 或測試 snapshot 之前，檢查 matcher，然後將 snapshot 儲存至 snapshot 檔案中，而不是 received value：1234567891011121314151617// __tests__/propertyMatchers.test.jsdescribe('Property Matchers', () =&gt; &#123; it('will check the matchers and pass', () =&gt; &#123; const user = &#123; name: 'Titan', createdAt: new Date(), id: Math.floor(Math.random() * 20) &#125;; console.log(user); expect(user).toMatchSnapshot(&#123; createdAt: expect.any(Date), id: expect.any(Number), &#125;); &#125;);&#125;);asymmetric matcher：在 Jasmine 也稱為 argument matcher，可用於建立自己的自訂 matcher 來封裝測試邏輯。下面是 snapshot 儲存的內容：12345678// __tests__/__snapshots__/propertyMatchers.test.js.snapexports[`Property Matchers will check the matchers and pass 1`] = `Object &#123; \"createdAt\": Any&lt;Date&gt;, \"id\": Any&lt;Number&gt;, \"name\": \"Titan\",&#125;`;任何非 matcher 的 givin value，會被被明確地檢查並儲存至 snapshot，例如下面測試中的 name property：123456789101112131415161718// __tests__/propertyMatchers.test.jsdescribe('Property Matchers', () =&gt; &#123; it('will check the values and pass', () =&gt; &#123; const user = &#123; name: 'Titan', createdAt: new Date(), id: Math.floor(Math.random() * 20) &#125;; console.log(user); expect(user).toMatchSnapshot(&#123; name: 'Titan', createdAt: expect.any(Date), id: expect.any(Number), &#125;); &#125;);&#125;);下面是 snapshot 儲存的內容：12345678// __tests__/__snapshots__/propertyMatchers.test.js.snapexports[`Property Matchers will check the values and pass 1`] = `Object &#123; \"createdAt\": Any&lt;Date&gt;, \"id\": Any&lt;Number&gt;, \"name\": \"Titan\",&#125;`;資料來源：Snapshot Testing · JestJest 14.0: React Tree Snapshot Testing · JestTesting with Jest Snapshots: First Impressions | benmccormick.orgUse Jest’s Snapshot Testing Feature from @kentcdodds on @eggheadio","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"},{"name":"snapshot","slug":"snapshot","permalink":"https://titangene.github.io/tags/snapshot/"}],"author":"Titangene"},{"title":"Jest：Mock 函數","slug":"jest-mock-function","date":"2020-07-05T15:59:41.000Z","updated":"2020-07-05T15:59:08.196Z","comments":true,"path":"article/jest-mock-function.html","link":"","permalink":"https://titangene.github.io/article/jest-mock-function.html","excerpt":"Jest 提供的 mock 函數可讓你自行決定要 mock 到什麼程度，並且可讓你在呼叫該 mock 函數之後，捕捉呼叫的次數、傳入的參數、使用 new 實例化的 instance，以及你指定要回傳的值，我們可透過這些資訊來測試 mock 函數是否如預期的呼叫。","text":"Jest 提供的 mock 函數可讓你自行決定要 mock 到什麼程度，並且可讓你在呼叫該 mock 函數之後，捕捉呼叫的次數、傳入的參數、使用 new 實例化的 instance，以及你指定要回傳的值，我們可透過這些資訊來測試 mock 函數是否如預期的呼叫。其他 Jest 相關文章可參閱 Jest 系列文章。有兩種方法來 mock 函數：在測試程式碼中使用 mock 函數使用手動 mock 來覆蓋依賴模組使用 mock 函數jest.fn(implementation)：新回傳一個未使用的 mock 函數 ( implementation 為可選的 mock 實作)若要測試下面 forEach()，可用 mock 函數，並檢查 mock 的狀態，以確保按預期 invoke callback：123456// src/forEach.jsfunction forEach(items, callback) &#123; for (const item of items) &#123; callback(item); &#125;&#125;1234567891011121314151617// __tests__/forEach.test.jsimport forEach from '../src/forEach';test('forEach', () =&gt; &#123; const mockCallback = jest.fn(x =&gt; 42 + x); forEach([0, 1], mockCallback); console.log(mockCallback.mock.calls); // [[0], [1]] expect(mockCallback.mock.calls.length).toBe(2); expect(mockCallback.mock.calls[0][0]).toBe(0); expect(mockCallback.mock.calls[1][0]).toBe(1); expect(mockCallback.mock.results[0].value).toBe(42); expect(mockCallback.mock.results[1].value).toBe(43);&#125;);.mock property所有 mock 函數都有 .mock property，用來儲存如何呼叫函數和回傳函數的資料，此 property 也會追蹤每個呼叫的 this 值：mockFn.mock.calls：回傳一個陣列包含對此 mock 函數所有呼叫的呼叫 argument，此陣列中的每個項目都是在呼叫過程中傳遞的 argument 陣列例如：有一個 mock 函數被呼叫兩次，第一次被呼叫的 argument 為 f('arg1', 'arg2')，第二次為 f('arg3', 'arg4')，那此 f.mock.calls 會回傳 [['arg1', 'arg2'], ['arg3', 'arg4']]mockFn.mock.results：回傳一個陣列包含對此 mock 函數所有呼叫的結果，此陣列中的每個項目都是一個包含 type 和 value property 的物件type 為以下任一種：return：透過正常回傳已完成的呼叫throw：透過拋出一個值來完成呼叫incomplete：呼叫尚未完成。若從 mock 函數本身內部或從 mock 呼叫的函數內部測試結果，則會發生這種狀況value：包含拋出的值或回傳值當 type === 'incomplete' 時，值為定義mockFn.mock.instances：回傳一個陣列包含使用 new 從此 mock 函數實例化的所有物件 instance123456789101112131415161718192021222324252627282930313233343536373839404142434445// __tests__/mockProperty.test.jsit('mock property', () =&gt; &#123; const fooMockFunction = jest .fn(function (x, y) &#123; let tmp = this.x || 0; return tmp + x + y; &#125;); const a = new fooMockFunction('first arg', 'second arg'); console.log(a); // mockConstructor &#123;&#125; console.log(a.x); // undefined const b = &#123;x: 10&#125;; const bound = fooMockFunction.bind(b, 3, 4); console.log(bound()); // 17 console.log(fooMockFunction.mock); // &#123; // calls: [ [ 1, 2 ], [ 3, 4 ] ], // instances: [ mockConstructor &#123;&#125;, &#123; x: 10 &#125; ], // invocationCallOrder: [ 1, 2 ], // results: [ // &#123; type: 'return', value: 3; &#125;, // &#123; type: 'return', value: 17 &#125; // ] // &#125; console.log(fooMockFunction.mock.instances[0]); // mockConstructor &#123;&#125; console.log(fooMockFunction.mock.instances[1]); // &#123; x: 10 &#125; // 呼叫幾次 expect(fooMockFunction.mock.calls.length).toBe(2); // 第幾次呼叫的第幾個 arg expect(fooMockFunction.mock.calls[0][0]).toBe('first arg'); expect(fooMockFunction.mock.calls[0][1]).toBe('second arg'); expect(fooMockFunction.mock.calls[1][0]).toBe(3); expect(fooMockFunction.mock.calls[1][1]).toBe(4); // 第幾次呼叫的回傳值 expect(fooMockFunction.mock.results[1].value).toBe(17); // 此 mock 函數被實例化的次數 expect(fooMockFunction.mock.instances.length).toBe(2);&#125;);mock 回傳值使用 mock 函數在測試期間將測試值注入至程式碼中：123456789101112131415// __tests__/mockReturnValues.test.jstest('mock return values', () =&gt; &#123; const myMock = jest.fn(); console.log(myMock()); // undefined myMock .mockReturnValueOnce(10) .mockReturnValueOnce('x') .mockReturnValue(true); expect(myMock()).toBe(10); expect(myMock()).toBe('x'); expect(myMock()).toBe(true); expect(myMock()).toBe(true);&#125;);這種寫法可避免需要複雜的 stub 來重新建立實際元件的行為，利於在使用前將值直接注入到測試中。Test stub：回傳固定值的實作資料來源：搞笑談軟工: Test Double（2）：五種替身簡介123456789101112131415161718192021222324252627test('mock return values', () =&gt; &#123; const myMock = jest.fn(); console.log(myMock()); // undefined myMock .mockReturnValueOnce(10) .mockReturnValueOnce('x') .mockReturnValue(true); expect(myMock()).toBe(10); expect(myMock()).toBe('x'); expect(myMock()).toBe(true); expect(myMock()).toBe(true);&#125;);test('filter mock function return values', () =&gt; &#123; const filterTestFn = jest.fn(); filterTestFn .mockReturnValueOnce(true) .mockReturnValueOnce(false); const result = [11, 12].filter(num =&gt; filterTestFn(num)); expect(result).toMatchObject([11]); expect(filterTestFn.mock.calls[0]).toMatchObject([11]); expect(filterTestFn.mock.calls[1]).toMatchObject([12]);&#125;);儘量避免在沒有直接測試的函數內部實作邏輯。mocking 模組假設有一個從 API fetch 使用者的 class，該 class 使用 axios 呼叫 API，然後回傳包含所有使用者的 data 屬性：1234567891011// src/users.jsimport axios from 'axios';class Users &#123; static all() &#123; return axios.get('https://jsonplaceholder.typicode.com/users') .then(response =&gt; response.data); &#125;&#125;export default Users;若要在不實際打 API 的情況下測試該方法，可用 jest.mock() 自動 mock axios 模組。接著使用 mockResolvedValue() 來 mock axios.get。只要測試呼叫了 axios.get()，就會回傳 fake response，以便於我們來 assert 資料：1234567891011121314151617// __tests__/mockingModule.test.jsimport axios from 'axios';import Users from '../src/users';jest.mock('axios');test('should fetch users', () =&gt; &#123; const expected = [&#123;name: 'Titan'&#125;]; const response = &#123;data: expected&#125;; axios.get.mockResolvedValue(response); // 上一行等同於： // axios.get.mockImplementation(() =&gt; Promise.resolve(resp)) return Users.all() .then(data =&gt; expect(data).toEqual(expected));&#125;);Mock Implementations指定回傳值，以及完全替換 mock 函數的實作，可透過 jest.fn 或 mock 函數上的 mockImplementationOnce() 來完成：12345678910// __tests__/mockImplementation.test.jsdescribe('使用 `jest.fn()` 建立 mock 函數', () =&gt; &#123; it('mock 函數', () =&gt; &#123; const myMockFn = jest.fn(callback =&gt; callback(null, true)); myMockFn((err, val) =&gt; console.log(val)); expect(myMockFn).toBeCalledTimes(1); expect(myMockFn).lastCalledWith(expect.any(Function)); &#125;);&#125;);可用 mockImplementationOnce() 來定義 mock 函數的預設實作：1234567891011121314// __tests__/mockImplementation.test.jsimport foo from '../src/foo';jest.mock('../src/foo');describe('mock module', () =&gt; &#123; it('mock foo module', () =&gt; &#123; foo.mockImplementation(() =&gt; 42); foo(); expect(foo).toBeCalledTimes(1); expect(foo).toReturnWith(42); &#125;);&#125;);若要讓 mock 函數多次呼叫會產生不同的結果，也可用 mockImplementationOnce() 來定義。12345678910111213141516171819// __tests__/mockImplementation.test.jsdescribe('mock 函數呼叫多次時，會產生不同的結果', () =&gt; &#123; it('第一次呼叫回傳 `true`，第二次回傳 `false`，之後都不回傳', () =&gt; &#123; const myMockFn = jest.fn() .mockImplementationOnce(callback =&gt; callback(true)) .mockImplementationOnce(callback =&gt; callback(false)); myMockFn(value =&gt; value); myMockFn(value =&gt; value); myMockFn(value =&gt; value); myMockFn(value =&gt; value); expect(myMockFn).toBeCalledTimes(4); expect(myMockFn).nthReturnedWith(1, true); expect(myMockFn).nthReturnedWith(2, false); expect(myMockFn).nthReturnedWith(3); expect(myMockFn).nthReturnedWith(4); &#125;);&#125;);當 mock 函數執行完 mockImplementationOnce() 定義的實作時，會執行 jest.fn (若已定義) 的預設實作集合：12345678910111213141516171819// __tests__/mockImplementation.test.jsdescribe('mock 函數呼叫多次時，會產生不同的結果', () =&gt; &#123; it('第一次呼叫回傳 `first call`，第二次回傳 `second call`，之後都回傳 `default`', () =&gt; &#123; const myMockFn = jest.fn(() =&gt; 'default') .mockImplementationOnce(() =&gt; 'first call') .mockImplementationOnce(() =&gt; 'second call'); myMockFn(); myMockFn(); myMockFn(); myMockFn(); expect(myMockFn).toBeCalledTimes(4); expect(myMockFn).nthReturnedWith(1, 'first call'); expect(myMockFn).nthReturnedWith(2, 'second call'); expect(myMockFn).nthReturnedWith(3, 'default'); expect(myMockFn).nthReturnedWith(4, 'default'); &#125;);&#125;);若要回傳 this，可用 sugary API .mockReturnThis() 來簡化方法。下面是相同的兩種寫法：使用 .mockReturnThis()使用 jest.fn() 自己實作 mock 函數要回傳 this1234567891011121314151617181920212223242526// __tests__/mockImplementation.test.jsdescribe.only('mock 函數回傳 `this`', () =&gt; &#123; it('使用 `mockReturnThis()`', () =&gt; &#123; const myObj = &#123; myMethod: jest.fn().mockReturnThis() &#125;; myObj.myMethod(); expect(myObj.myMethod).toBeCalledTimes(1); expect(myObj.myMethod).toReturnWith(myObj); &#125;); it('使用 `jest.fn()` 實作', () =&gt; &#123; const myObj = &#123; myMethod: jest.fn(function() &#123; return this; &#125;) &#125;; myObj.myMethod(); expect(myObj.myMethod).toBeCalledTimes(1); expect(myObj.myMethod).toReturnWith(myObj); &#125;);&#125;);mock 名稱可為 mock 函數命名，可在測試錯誤的輸出中顯示名稱，而不是 jest.fn()。若想快速識別 mock 函數，並在測試輸出中 report 錯誤，可用此方式：1234567891011121314describe('mock 名稱', () =&gt; &#123; it.only('設定 mock 名稱', () =&gt; &#123; const myMockFn = jest.fn() .mockImplementation(scalar =&gt; 42 + scalar) .mockName('add42'); myMockFn(10); myMockFn(10); myMockFn(10); expect(myMockFn).toBeCalledTimes(3); expect(myMockFn).toReturnWith(52); &#125;);&#125;);若沒設定 mock 函數名稱，測試錯誤時會像這樣：123456FAIL week-05/__tests__/mockName.test.js ● mock 名稱 › 設定 mock 名稱 expect(jest.fn()).toReturnWith(expected) ...若有設定名稱就會像這樣：123456FAIL week-05/__tests__/mockName.test.js ● mock 名稱 › 設定 mock 名稱 expect(add42).toReturnWith(expected) ...自訂 matcher下面是 mock 函數會用到的 matcher，這些都是語法糖：1234567891011121314151617// mock 函數被呼叫的次數expect(mockFunc).toBeCalledTimes(4);// mock 函數至少被呼叫一次expect(mockFunc).toBeCalled();expect(mockFunc).toHaveBeenCalled();// 至少一次呼叫 mock 函數所指定的 argsexpect(mockFunc).toBeCalledWith(arg1, arg2);expect(mockFunc).toHaveBeenCalledWith(arg1, arg2);// 最後一次呼叫 mock 函數所指定的 argsexpect(mockFunc).lastCalledWith(arg1, arg2);expect(mockFunc).toHaveBeenLastCalledWith(arg1, arg2);// 所有呼叫和 mock 的名稱都寫成 snapshotexpect(mockFunc).toMatchSnapshot();這些 matcher 是檢查 .mock property 的常見形式的 sugar。1234567891011121314151617181920212223// mock 函數被呼叫的次數expect(mockFunc.mock.calls.length).toBe(4);// mock 函數至少被呼叫一次expect(mockFunc.mock.calls.length).toBeGreaterThan(0);// 至少一次呼叫 mock 函數所指定的 argsexpect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);// 最後一次呼叫 mock 函數所指定的 argsexpect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([ arg1, arg2,]);// 最後一次呼叫 mock 函數的第一個 arg 是 `42` (此 assert 沒有語法糖)expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);// snapshot 會檢查 mock 是否以相同的順序、相同的 arg 被呼叫相同的次數expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);// assert mock 函數的名稱expect(mockFunc.getMockName()).toBe('a mock name');例如：123456789101112131415161718192021222324252627282930313233343536// __tests__/customMatcher.test.jsit('custom matcher', () =&gt; &#123; const mockFunc = jest.fn((x, y) =&gt; x + y) .mockName('mockFunc'); mockFunc(1, 2); mockFunc(); mockFunc(3, 4); // mock 函數被呼叫的次數 expect(mockFunc).toBeCalledTimes(3); expect(mockFunc.mock.calls.length).toBe(3); // mock 函數至少被呼叫一次 expect(mockFunc).toBeCalled(); expect(mockFunc.mock.calls.length).toBeGreaterThan(0); // 至少一次呼叫 mock 函數所指定的 args expect(mockFunc).toBeCalledWith(1, 2); expect(mockFunc).toBeCalledWith(3, 4); expect(mockFunc.mock.calls).toContainEqual([1, 2]); expect(mockFunc.mock.calls).toContainEqual([3, 4]); // 最後一次呼叫 mock 函數所指定的 args expect(mockFunc).lastCalledWith(3, 4); expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([3, 4]); // 最後一次呼叫 mock 函數的第一個 arg 是 `3` (此 assert 沒有語法糖) expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(3); // snapshot 會檢查 mock 是否以相同的順序、相同的 arg 被呼叫相同的次數 expect(mockFunc.mock.calls).toEqual([[1, 2], [], [3, 4]]); // assert mock 函數的名稱 expect(mockFunc.getMockName()).toBe('mockFunc');&#125;);資料來源：Mock Functions · Jest","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"},{"name":"mock","slug":"mock","permalink":"https://titangene.github.io/tags/mock/"}],"author":"Titangene"},{"title":"Jest：非同步測試","slug":"jest-async-test","date":"2020-06-28T15:56:32.000Z","updated":"2020-06-28T15:59:53.353Z","comments":true,"path":"article/jest-async-test.html","link":"","permalink":"https://titangene.github.io/article/jest-async-test.html","excerpt":"處理 JS 非同步的常見作法包括 callback、ES6 的 Promise 以及 ES7 的 async 和 await，而本篇會分別說明如何在 Jest 使用這些 JS 特性來測試非同步程式碼。","text":"處理 JS 非同步的常見作法包括 callback、ES6 的 Promise 以及 ES7 的 async 和 await，而本篇會分別說明如何在 Jest 使用這些 JS 特性來測試非同步程式碼。其他 Jest 相關文章可參閱 Jest 系列文章。Callbacks假設你要測下面這個函數，我使用 setTimeout 來模擬發 API 需要花一段時間，若 API 發送成功就會呼叫你傳入的 callback 函數，在呼叫 callback 時會傳入 'hi'，代表從 API 拿到的資料：12345678910// src/fetchData.jsfunction fetchData(callback) &#123; console.log(`--- fetchData: Start ---`); setTimeout(() =&gt; &#123; callback('hi'); &#125;, 1000); console.log(`--- fetchData: End ---`);&#125;export default fetchData;而我們要測試的就是呼叫 fetchData() 所傳入的 callback 有無正確的呼叫，並且傳入 callback 的資料是否為 &quot;hi&quot;。也許你會這樣寫測試：123456789101112// __tests__/async.test.jsimport fetchData from '../src/async';test('同步執行 callback 回傳 hi', () =&gt; &#123; function callback(data) &#123; console.log(`---callback: Start---`); expect(data).toBe('hi'); console.log(`---callback: End---`); &#125; fetchData(callback);&#125;);執行測試後，測試通過了，但感覺怪怪的！為什麼測試內的 callback() 沒有執行到？因為 Jest 測試只要跑到最後一行的 fetchData(..) 就會結束，裡面執行的非同步處理 (即模擬發 API 的 setTimeout ) 根本還沒處理完，Jest 測試就會在 callback 呼叫之前就結束了。Jest 提供一種建議：使用 test() 時不要用 empty argument，而是用名為 done 的 argument。Jest 就會等到 done callback 被呼叫時才會結束測試。這樣就能確保測試是在你決定的地方結束 ( done，雙關)：12345678910111213// __tests__/async.test.jsimport fetchData from '../src/async';test('非同步執行 callback 回傳 hi', done =&gt; &#123; function callback(data) &#123; console.log(`---callback: Start---`); expect(data).toBe('hi'); console.log(`---callback: End---`); done(); &#125; fetchData(callback);&#125;);若 test() 使用了 done argument，但沒有呼叫 done()，測試就會失敗 (帶有 timeout error)：錯誤訊息是說這個測試沒有在 timeout 內 invoke 非同步的 callback。至於 timeout 的時間預設為 5 秒，若要自訂 test() 的 timeout，可自行加上第三個 arg (單位為豪秒)。像下面是自訂 timeout 為 3 秒：123test('test name', () =&gt; &#123; // some test code...&#125;, 3000);詳情可參閱 Jest：Describe &amp; Test case 的「test(name, fn, timeout)」段落。如果 expect 陳述句失敗，就會拋出錯誤，並且不會呼叫 done()。若想在測試輸出結果看到失敗的原因，就要用 try 區塊把 expect 包起來，並在 catch 區塊中接收錯誤。1234567891011121314151617// __tests__/async.test.jsimport fetchData from '../src/async';test('非同步執行 callback 回傳 hi', done =&gt; &#123; function callback(data) &#123; try &#123; console.log(`---callback: Start---`); expect(data).toBe('hi~~~'); console.log(`---callback: End---`); done(); &#125; catch (error) &#123; done(error); &#125; &#125; fetchData(callback);&#125;);Promise如果測試回傳一個 promise，Jest 會等待這個 promise 的 resolve。如果 promise 被 reject，測試會自動失敗。一定要回傳 promise：如果省略了 return 陳述句，測試會在 promiseFetchData 回傳的 promise 被 resolve，並且 then() 有機會執行 callback 之前完成。例如：下面範例的測試不會等到 promise 內的 setTimeout() 跑完就會立即完成測試：1234567891011// src/fetchData.jsfunction promiseFetchData(option) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(`--- Promise: Start ---`); setTimeout(() =&gt; &#123; if (option.flag === 'success') resolve('hi'); if (option.flag === 'fail') reject('error'); &#125;, 3000); console.log(`--- Promise: End ---`); &#125;);&#125;12345678910// __tests__/async.test.jsimport promiseFetchData from '../src/fetchData';test('回傳的 promise resolve 資料為 hi', () =&gt; &#123; return promiseFetchData(&#123; flag: 'success' &#125;).then(data =&gt; &#123; console.log(`--- then: Start ---`); expect(data).toBe('hi'); console.log(`--- then: End ---`); &#125;);&#125;);所以如果省略了 return 陳述句，下面範例的 'hi XD' 雖然跟 data 真正拿到的值不同，但測試還是會通過：12345678910// __tests__/async.test.jsimport promiseFetchData from '../src/fetchData';test('回傳的 promise resolve 資料為 hi', () =&gt; &#123; promiseFetchData(&#123; flag: 'success' &#125;).then(data =&gt; &#123; console.log(`--- then: Start ---`); expect(data).toBe('hi'); console.log(`--- then: End ---`); &#125;);&#125;);若想讓 promise 被 reject，可用 .catch 方法。記得要加上 expect.assertions 來驗證是否呼叫一定數量的 assertions。否則一個 fulfilled promise 不會讓錯誤失敗：1234567891011// __tests__/async.test.jsimport promiseFetchData from '../src/fetchData';test('promise reject 的錯誤訊息為 error', () =&gt; &#123; expect.assertions(1); return promiseFetchData(&#123; flag: 'fail' &#125;).catch(e =&gt; &#123; console.log(`--- catch: Start ---`); expect(e).toMatch('error'); console.log(`--- catch: End ---`); &#125;);&#125;);.resolves / .rejects也可在 expect 陳述句中使用 .resolves matcher，Jest 會等待 promise 的 resolve。如果 promise 被 reject，測試會自動失敗。123456// __tests__/async.test.jsimport promiseFetchData from '../src/fetchData';test('使用 resolves matcher', () =&gt; &#123; return expect(promiseFetchData(&#123; flag: 'success' &#125;)).resolves.toBe('hi');&#125;);一定要回傳 assertion：如果省略了 return 陳述句，測試會在 promiseFetchData 回傳的 promise 被 resolve，並且 then() 有機會執行 callback 之前完成。若想讓 promise 被 reject，可用 .rejects matcher。如果 promise 是 fulfilled，測試就會自動失敗：123456// __tests__/async.test.jsimport promiseFetchData from '../src/fetchData';test('使用 rejects matcher', () =&gt; &#123; return expect(promiseFetchData(&#123; flag: 'fail' &#125;)).rejects.toMatch('error');&#125;);Async/Await也可用 async 和 await。在傳給測試函數前加上 async 關鍵字：12345678910111213141516// __tests__/async.test.jsimport promiseFetchData from '../src/fetchData';test('使用 await resolves', async () =&gt; &#123; const data = await promiseFetchData(&#123; flag: 'success' &#125;); expect(data).toBe('hi');&#125;);test('使用 await rejects', async () =&gt; &#123; expect.assertions(1); try &#123; await promiseFetchData(&#123; flag: 'fail' &#125;); &#125; catch (e) &#123; expect(e).toMatch('error'); &#125;&#125;);也可將 async 和 await 與 .resolves 和 .rejects matcher 結合使用：12345678910// __tests__/async.test.jsimport promiseFetchData from '../src/fetchData';test('使用 await 和 resolves matcher', async () =&gt; &#123; await expect(promiseFetchData(&#123; flag: 'success' &#125;)).resolves.toBe('hi');&#125;);test('使用 await 和 rejects matcher', async () =&gt; &#123; await expect(promiseFetchData(&#123; flag: 'fail' &#125;)).rejects.toMatch('error');&#125;);資料來源：Testing Asynchronous Code · Jest","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"},{"name":"async","slug":"async","permalink":"https://titangene.github.io/tags/async/"},{"name":"promise","slug":"promise","permalink":"https://titangene.github.io/tags/promise/"},{"name":"callback","slug":"callback","permalink":"https://titangene.github.io/tags/callback/"}],"author":"Titangene"},{"title":"Jest：Setup & Teardown","slug":"jest-setup-teardown","date":"2020-06-21T15:56:15.000Z","updated":"2020-06-21T15:56:07.894Z","comments":true,"path":"article/jest-setup-teardown.html","link":"","permalink":"https://titangene.github.io/article/jest-setup-teardown.html","excerpt":"每個測試案例都必須是獨立的，不能互相影響，而解決方法就是讓每個測試在執行前進行重設，或在每個測試結束後清除痕跡。在 Jest，提供 setup 和 teardown 的函數，能讓你自訂在執行 describe 區塊或 test 區塊的前後分別要做什麼準備和收尾。","text":"每個測試案例都必須是獨立的，不能互相影響，而解決方法就是讓每個測試在執行前進行重設，或在每個測試結束後清除痕跡。在 Jest，提供 setup 和 teardown 的函數，能讓你自訂在執行 describe 區塊或 test 區塊的前後分別要做什麼準備和收尾。其他 Jest 相關文章可參閱 Jest 系列文章。測試案例互相汙染一開始寫測試時，可能會發生測試案例互相汙染的問題。例如：有一個城市資料庫，提供初始化、清除、新增以及檢查是否已存在資料庫內這些功能：12345678910111213141516171819202122232425// src/cityDB.jslet cityDB = [];function initCityDB() &#123; cityDB = ['Taipei', 'Tainan'];&#125;function clearCityDB() &#123; cityDB = [];&#125;function addCity(city) &#123; cityDB.push(city);&#125;function isCity(city) &#123; return cityDB.includes(city);&#125;export &#123; initCityDB, clearCityDB, addCity, isCity&#125;如果測試寫起來像這樣會發現，第一個測試操作的步驟會影響到第二個測試 (所以第二個測試不用初始化 DB 和新增城市就已經擁有該城市，看起來很奇怪吧？)：123456789101112131415161718192021// __tests__/unusedBeforeEachAndAfterEach.test.jsimport &#123; initCityDB, isCity, addCity&#125; from '../../src/cityDB';describe('未使用 beforeEach 和 afterEach', () =&gt; &#123; describe('測試案例會互相汙染', () =&gt; &#123; test('新增 Kaohsiung', () =&gt; &#123; initCityDB(); expect(isCity('Kaohsiung')).toBeFalsy(); addCity('Kaohsiung'); expect(isCity('Kaohsiung')).toBeTruthy(); &#125;); test('第二個測試案例未重新設定，所以有 Kaohsiung', () =&gt; &#123; expect(isCity('Kaohsiung')).toBeTruthy(); &#125;); &#125;);&#125;);所以你可能會手動處理初始化和清除的工作：12345678910111213141516171819202122232425// __tests__/unusedBeforeEachAndAfterEach.test.jsimport &#123; initCityDB, clearCityDB, isCity, addCity&#125; from '../../src/cityDB';describe('未使用 beforeEach 和 afterEach', () =&gt; &#123; describe('手動在每個測試案例重複設定', () =&gt; &#123; test('新增 Kaohsiung', () =&gt; &#123; initCityDB(); expect(isCity('Kaohsiung')).toBeFalsy(); addCity('Kaohsiung'); expect(isCity('Kaohsiung')).toBeTruthy(); clearCityDB(); &#125;); test('第二個測試案例有重新設定，所以預設沒有 Kaohsiung', () =&gt; &#123; initCityDB(); expect(isCity('Kaohsiung')).toBeFalsy(); clearCityDB(); &#125;); &#125;);&#125;);但每次都要手動處理這些問題很麻煩，所以在寫測試時常需要：在測試執行前進行一些設定工作在測試執行後進行一些收尾工作多次測試的重複設定：beforeEach、afterEach每個測試案例都要進行一些設定，可用 beforeEach 和 afterEach：beforeEach(fn, timeout)：在執行此檔案中的每個測試之前執行 fn 函數若 fn 函數回傳 promise 或 generator，Jest 會在執行測試之前等待該 promise resolve若 beforeEach 放在 describe 區塊內，就只會在此區塊內的測試之前執行例如：重置每個測試要使用的全域狀態afterEach(fn, timeout)：在執行此檔案中的每個測試之後執行 fn 函數若 fn 函數回傳 promise 或 generator，Jest 會等待該 promise resolve 後才會繼續若 afterEach 放在 describe 區塊內，就只會在此區塊內的測試之後執行例如：清除每個測試建立的某些臨時狀態timeout 是可選參數，可提供 timeout 來指定 beforeEach 或 afterEach 中止前要等待的時間，單位為豪秒，預設為 5 秒。同步的重複設定例如：要在每個測試案例執行之前呼叫 initCityDB()，並在每個測試案例執行之後呼叫 clearCityDB()：12345678910111213141516171819202122232425262728293031323334353637// __tests__/repeatSetupForManyTests/sync.test.jsimport &#123; addCity, clearCityDB, initCityDB, isCity&#125; from '../../src/cityDB';describe('使用 beforeEach 和 afterEach 對多個測試重複設定', () =&gt; &#123; beforeEach(() =&gt; &#123; console.log(`--- beforeEach init DB Start ---`); initCityDB(); console.log(`--- beforeEach init DB End ---`); &#125;); afterEach(() =&gt; &#123; console.log(`--- afterEach clear DB Start ---`); clearCityDB(); console.log(`--- afterEach clear DB End ---`); console.log(`=========================================`); &#125;); test('新增 Kaohsiung', () =&gt; &#123; console.log(`--- test1 Start ---`); expect(isCity('Kaohsiung')).toBeFalsy(); addCity('Kaohsiung'); expect(isCity('Kaohsiung')).toBeTruthy(); console.log(`--- test1 End ---`); &#125;); test('有 Tainan，但沒有 Kaohsiung', () =&gt; &#123; console.log(`--- test2 Start ---`); expect(isCity('Tainan')).toBeTruthy(); expect(isCity('Kaohsiung')).toBeFalsy(); console.log(`--- test2 End ---`); &#125;);&#125;);執行測試；1$ npx jest ./__tests__/repeatSetupForManyTests/sync.test.js --watch非同步的重複設定beforeEach 和 afterEach 可以若要處理非同步，有兩種處理方式：使用 .done 參數回傳 promise使用 .done 參數123456789101112131415161718192021222324252627282930313233343536373839404142434445// __tests__/repeatSetupForManyTests/doneParameter.test.jsimport &#123; addCity, clearCityDBCallback, initCityDBCallback, isCity&#125; from '../../src/cityDB';describe('beforeEach 和 afterEach 使用 done 參數', () =&gt; &#123; beforeEach(done =&gt; &#123; function callback() &#123; done(); &#125; console.log(`--- beforeEach callback init DB Start ---`); initCityDBCallback(callback); console.log(`--- beforeEach callback init DB End ---`); &#125;); afterEach(done =&gt; &#123; function callback() &#123; done(); &#125; console.log(`--- afterEach callback clear DB Start ---`); clearCityDBCallback(callback); console.log(`--- afterEach callback clear DB End ---`); console.log(`===============================================`); &#125;); test('新增 Kaohsiung', () =&gt; &#123; console.log(`--- test1 Start ---`); expect(isCity('Kaohsiung')).toBeFalsy(); addCity('Kaohsiung'); expect(isCity('Kaohsiung')).toBeTruthy(); console.log(`--- test1 End ---`); &#125;); test('有 Tainan，但沒有 Kaohsiung', () =&gt; &#123; console.log(`--- test2 Start ---`); expect(isCity('Tainan')).toBeTruthy(); expect(isCity('Kaohsiung')).toBeFalsy(); console.log(`--- test2 End ---`); &#125;);&#125;)執行測試：1$ npx jest ./__tests__/repeatSetupForManyTests/doneParameter.test.js --watch回傳 promise12345678910111213141516171819202122232425262728293031323334// __tests__/repeatSetupForManyTests/returnPromise.test.jsimport &#123; addCity, initCityDBPromise, clearCityDBPromise, isCity&#125; from '../../src/cityDB';describe('城市資料庫 (使用 beforeEach 和 afterEach 回傳 promise)', () =&gt; &#123; beforeEach(() =&gt; &#123; console.log(`--- beforeEach promise init DB Start ---`); return initCityDBPromise(); &#125;); afterEach(() =&gt; &#123; console.log(`--- afterEach promise clear DB Start ---`); return clearCityDBPromise(); &#125;); test('新增 Kaohsiung', () =&gt; &#123; console.log(`--- test1 Start ---`); expect(isCity('Kaohsiung')).toBeFalsy(); addCity('Kaohsiung'); expect(isCity('Kaohsiung')).toBeTruthy(); console.log(`--- test1 End ---`); &#125;); test('有 Tainan，但沒有 Kaohsiung', () =&gt; &#123; console.log(`--- test2 Start ---`); expect(isCity('Tainan')).toBeTruthy(); expect(isCity('Kaohsiung')).toBeFalsy(); console.log(`--- test2 End ---`); &#125;);&#125;);執行測試：1$ npx jest ./__tests__/repeatSetupForManyTests/returnPromise.test.js --watch一次性設定：beforeAll、afterAll有時需要在檔案的開頭執行一次設定。當設定是非同步時，可能很麻煩，所以不能直接在檔案開頭處理。Jest 提供 beforeAll 和 afterAll 來處理這種情況。若要在所有測試執行之後處理一些事，可用 beforeAll 和 afterAll：beforeAll(fn, timeout)：在執行此檔案中的所有測試之前執行 fn 函數若 fn 函數回傳 promise 或 generator，Jest 會在執行測試之前等待該 promise resolve若 beforeAll 放在 describe 區塊內，就只會在此區塊內的開頭執行例如：設定多個測試都要共用的全域狀態afterAll(fn, timeout)：在執行此檔案中的所有測試之後執行 fn 函數若 fn 函數回傳 promise 或 generator，Jest 會等待該 promise resolve 後才會繼續若 afterAll 放在 describe 區塊內，就只會在此區塊內的結尾執行例如：清除多個測試都要共用的全域狀態timeout 是可選參數，可提供 timeout 來指定 beforeAll 或 afterAll 中止前要等待的時間，單位為豪秒，預設為 5 秒例如：若 initCityDBPromise 和 clearCityDBPromise 都回傳 promise，並且城市資料庫可以在多個測試案例之間重用：12345678910111213141516171819202122// src/cityDB.jsfunction initCityDBPromise() &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(`--- Promise：init DB Start ---`); setTimeout(() =&gt; &#123; cityDB = ['Taipei', 'Tainan']; resolve(); &#125;, 3000); console.log(`--- Promise：init DB End ---`); &#125;);&#125;function clearCityDBPromise() &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(`--- Promise：clear DB Start ---`); setTimeout(() =&gt; &#123; cityDB = []; resolve(); &#125;, 3000); console.log(`--- Promise：clear DB End ---`); &#125;);&#125;1234567891011121314151617181920212223242526// __tests__/setupAndTeardown.test.jsimport &#123; initCityDBPromise, clearCityDBPromise, isCity&#125; from '../src/cityDB';beforeAll(() =&gt; &#123; console.log('beforeAll'); return initCityDBPromise();&#125;);afterAll(() =&gt; &#123; console.log('afterAll'); return clearCityDBPromise();&#125;);test('有 Tainan', () =&gt; &#123; console.log('test 1'); expect(isCity('Tainan')).toBeTruthy();&#125;);test('沒有 Kaohsiung', () =&gt; &#123; console.log('test 2'); expect(isCity('Kaohsiung')).toBeFalsy();&#125;);執行測試：1$ npx jest ./__tests__/setupAndTeardown.test.js --watchScopingbefore 和 after 區塊適用於檔案中的每個測試，也可放在 describe 區塊來將測試案例分組。當 before 和 after 放在 describe 區塊中時，只適用在該 describe 區塊中的測試案例。若以下這些放在 describe 區塊內；beforeAll：只會在此區塊內的開頭執行afterAll：只會在此區塊內的結尾執行beforeEach：只會在此區塊內的測試之前執行afterEach：只會在此區塊內的測試之後執行例如：有城市資料庫和食物資料庫，可為不同測試做不同設定：12345678910111213141516171819202122232425262728293031323334353637// src/foodDB.jslet foodDB = [];function initFoodDBPromise() &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(`--- Promise: init DB Start ---`); setTimeout(() =&gt; &#123; foodDB = [ &#123; city: 'Taipei', name: 'Apple' &#125;, &#123; city: 'Tainan', name: 'Banana' &#125; ]; resolve(); &#125;, 3000); console.log(`--- Promise: init DB End ---`); &#125;);&#125;function clearFoodDBPromise() &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(`--- Promise: clear DB Start ---`); setTimeout(() =&gt; &#123; foodDB = []; resolve(); &#125;, 3000); console.log(`--- Promise: clear DB End ---`); &#125;);&#125;function isValidCityFoodPair(foodCity, foodName) &#123; return foodDB.some(food =&gt; (food.city === foodCity) &amp;&amp; (food.name === foodName));&#125;export &#123; initFoodDBPromise, clearFoodDBPromise, isValidCityFoodPair&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// __tests__/scoping/scope.test.jsimport &#123; initCityDBPromise, clearCityDBPromise, isCity&#125; from '../../src/cityDB';import &#123; initFoodDBPromise, clearFoodDBPromise, isValidCityFoodPair&#125; from '../../src/foodDB';// 適用於此文件中的所有測試beforeEach(() =&gt; &#123; console.log('global: beforeEach'); return initCityDBPromise();&#125;);afterEach(() =&gt; &#123; console.log('global: afterEach'); return clearCityDBPromise();&#125;);test('城市資料庫有 Tainan', () =&gt; &#123; console.log('global: test1'); expect(isCity('Tainan')).toBeTruthy();&#125;);test('城市資料庫沒有 Kaohsiung', () =&gt; &#123; console.log('global: test2'); expect(isCity('Kaohsiung')).toBeFalsy();&#125;);describe('城市與食物 match', () =&gt; &#123; // 僅適用於此 describe 區塊中的測試 beforeEach(() =&gt; &#123; console.log('scope: beforeEach'); return initFoodDBPromise(); &#125;); afterEach(() =&gt; &#123; console.log('scope: afterEach'); return clearFoodDBPromise(); &#125;); test('Taipei &lt;3 Apple', () =&gt; &#123; console.log('scope: test1'); expect(isValidCityFoodPair('Taipei', 'Apple')).toBe(true); &#125;); test('Tainan &lt;3 Banana', () =&gt; &#123; console.log('scope: test2'); expect(isValidCityFoodPair('Tainan', 'Banana')).toBe(true); &#125;);&#125;);執行測試：1$ npx jest ./__tests__/scoping/scope.test.js --watch測試檔最上層的 beforeEach 會在 describe 區塊內的 beforeEach 之前執行。看以下範例可了解這些 hook 的執行順序：123456789101112131415161718192021222324252627282930313233// __tests__/scoping/executionOrder.test.jsbeforeAll(() =&gt; console.log('global: beforeAll'));afterAll(() =&gt; console.log('global: afterAll'));beforeEach(() =&gt; console.log('global: beforeEach'));afterEach(() =&gt; console.log('global: afterEach'));test('', () =&gt; console.log('global: test'));describe('Scoped / Nested block', () =&gt; &#123; beforeAll(() =&gt; console.log('scope: beforeAll')); afterAll(() =&gt; console.log('scope: afterAll')); beforeEach(() =&gt; console.log('scope: beforeEach')); afterEach(() =&gt; console.log('scope: afterEach')); test('', () =&gt; console.log('scope: test'));&#125;);// global: beforeAll// global: beforeEach// global: test// global: afterEach// scope: beforeAll// global: beforeEach// scope: beforeEach// scope: test// scope: afterEach// global: afterEach// scope: afterAll// global: afterAll執行測試：1$ npx jest ./__tests__/scoping/executionOrder.test.js --watchdescribe 區塊和 test 區塊的執行順序Jest 在執行任何測試之前，會先執行測試檔案中的所有 describe handler這就是為何要在 before* 和 after* handler 中進行設定和拆除 (setup and teardown)，而不是在 describe 區塊中處理的原因當 describe 區塊完成時，預設情況下，Jest 會按照在收集階段中遇到的順序連續執行所有測試，等待每個測試完成並進行整理之後再繼續1234567891011121314151617181920212223242526272829303132333435363738// __tests__/orderOfExecutionOfDescribeAndTestBlocks.test.jsdescribe('outer', () =&gt; &#123; console.log('describe outer-a'); describe('describe inner 1', () =&gt; &#123; console.log('describe inner 1'); test('test 1', () =&gt; &#123; console.log('test for describe inner 1'); expect(true).toEqual(true); &#125;); &#125;); console.log('describe outer-b'); test('test 1', () =&gt; &#123; console.log('test for describe outer'); expect(true).toEqual(true); &#125;); describe('describe inner 2', () =&gt; &#123; console.log('describe inner 2'); test('test for describe inner 2', () =&gt; &#123; console.log('test for describe inner 2'); expect(false).toEqual(false); &#125;); &#125;); console.log('describe outer-c');&#125;);// describe outer-a// describe inner 1// describe outer-b// describe inner 2// describe outer-c// test for describe inner 1// test for describe outer// test for describe inner 2執行測試：1$ npx jest ./__tests__/scoping/OrderOfExecutionOfDescribeAndTestBlocks.test.js --watch建議如果測試失敗，要檢查的第一件事就是當只有它在執行時是否會失敗。若只要讓 Jest 執行一個測試，可將測試指令臨時改成 test.only：12345678// __tests__/testOnly.test.jstest.only('this will be the only test that runs', () =&gt; &#123; expect(true).toBe(true);&#125;);test('this test will not run', () =&gt; &#123; expect('A').toBe('A');&#125;);執行測試：1$ npx jest ./__tests__/testOnly.test.js --watch如果你有一個測試在大型案例的一部份執行會發生錯誤，但單獨執行不會失敗，那可能是其他測試干擾了此測試。通常可用 beforeEach 來清除一些共享狀態來解決此問題。若不確定是否正在修改哪些共享狀態，也可嘗試用 beforeEach 來紀錄資料。參考資料Setup and Teardown · JestJest | 測試設定分類 (describe) 及作用域 (scoping) by 神Q超人","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"}],"author":"Titangene"},{"title":"Jest：Describe & Test case","slug":"jest-describe-test-case","date":"2020-06-14T15:57:34.000Z","updated":"2020-06-28T14:07:35.609Z","comments":true,"path":"article/jest-describe-test-case.html","link":"","permalink":"https://titangene.github.io/article/jest-describe-test-case.html","excerpt":"上次介紹了 Jest 提供的 matcher，可讓你驗證程式碼是否符合預期，而這次來說明如何透過 describe 和 test 區塊來組織測試案例。當需求變多時，可針對需求來分類測試案例，將相關的測試放在同一個群組區塊內，此時就會用到 Jest 提供的 describe 和 test 區塊。","text":"上次介紹了 Jest 提供的 matcher，可讓你驗證程式碼是否符合預期，而這次來說明如何透過 describe 和 test 區塊來組織測試案例。當需求變多時，可針對需求來分類測試案例，將相關的測試放在同一個群組區塊內，此時就會用到 Jest 提供的 describe 和 test 區塊。test 區塊：即測試案例 (test case)，使用 matcher 驗證程式執行結果是否符合預期describe 區塊：將多個相關的 test 區塊放在一起，便於組織測試案例其他 Jest 相關文章可參閱 Jest 系列文章。下面範例都會用數學運算的範例來說明：12345678910const addition = (x, y) =&gt; &#123; if (typeof(x) === 'number' &amp;&amp; typeof(y) === 'number') throw new CustomError('請輸入數字'); return x + y;&#125;;const subtraction = (x, y) =&gt; &#123; if (typeof(x) === 'number' &amp;&amp; typeof(y) === 'number') throw new CustomError('請輸入數字'); return x - y;&#125;;describe 區塊describe(name, fn)argument：name：描素此 describe 區塊的敘述fn：包含 test 區塊的函數用來將多個相關的 test 區塊放在同一個 describe 區塊內，以便於將測試組織成群組。例如：123456789describe('數學運算', () =&gt; &#123; test('加法運算', () =&gt; &#123; expect(addition(1, 2)).toBe(3); &#125;); test('減法運算', () =&gt; &#123; expect(subtraction(3, 1)).toBe(2); &#125;);&#125;);但寫測試不一定要用 describe 區塊，也可以不用將 test 區塊包在 describe 區塊內，而是直接寫在測試檔上，但建議你使用 describe 區塊。也可以巢狀使用 describe 區塊：12345678910111213141516171819202122232425262728293031323334353637describe('數學運算', () =&gt; &#123; describe('加法運算', () =&gt; &#123; describe('傳入非數字值', () =&gt; &#123; test('傳入布林值應拋出 CustomError', () =&gt; &#123; expect(addition(true, 2)).toThrow(CustomError); &#125;); test('傳入字串值應拋出 CustomError', () =&gt; &#123; expect(addition('a', 1)).toThrow(CustomError); &#125;); &#125;); describe('傳入數字值', () =&gt; &#123; test('應回傳正確的運算結果', () =&gt; &#123; expect(addition(1, 2)).toBe(3); &#125;); &#125;); &#125;); describe('減法運算', () =&gt; &#123; describe('傳入非數字值', () =&gt; &#123; test('傳入布林值應拋出 CustomError', () =&gt; &#123; expect(subtraction(true, 2)).toThrow(CustomError); &#125;); test('傳入字串值應拋出 CustomError', () =&gt; &#123; expect(subtraction('a', 1)).toThrow(CustomError); &#125;); &#125;); describe('傳入數字值', () =&gt; &#123; test('應回傳正確的運算結果', () =&gt; &#123; expect(subtraction(3, 1)).toBe(2); &#125;); &#125;); &#125;);&#125;);describe.only(name, fn)alias：fdescribe(name, fn)讓測試只跑使用 describe.only() 的 describe 區塊。例如：12345678910111213describe.only('數學運算', () =&gt; &#123; test('加法運算', () =&gt; &#123; expect(addition(1, 2)).toBe(3); &#125;); test('減法運算', () =&gt; &#123; expect(subtraction(3, 1)).toBe(2); &#125;);&#125;);describe('其他', () =&gt; &#123; // 此區塊的測試會被略過&#125;);describe.skip(name, fn)alias：xdescribe(name, fn)不想執行指定的 describe 區塊可用 describe.skip()。例如：12345678910111213describe('數學運算', () =&gt; &#123; test('加法運算', () =&gt; &#123; expect(addition(1, 2)).toBe(3); &#125;); test('減法運算', () =&gt; &#123; expect(subtraction(3, 1)).toBe(2); &#125;);&#125;);describe.skip('其他', () =&gt; &#123; // 略過此區塊的測試&#125;);test 區塊test(name, fn, timeout)alias：it(name, fn, timeout)argument：name：測試名稱fn：包含要測試的期望函數timeout (可選)：測試終止之前要等待的時間 (單位毫秒)，預設為 5 秒測試檔案內一定要有 test 區塊才能測試程式。剛剛有提到，不一定要 describe 區塊，可直接在測試檔內放 test 區塊即可。例如：123test('加法運算', () =&gt; &#123; expect(addition(1, 2)).toBe(3);&#125;);test.only(name, fn, timeout)alias：it.only(name, fn, timeout) 和 fit(name, fn, timeout)在 debug 測試檔內的測試時，通常只需要執行一部分的測試，此時就可以將那些 test 區塊加上 .only 來指定要執行哪些測試，其餘的測試都會被略過。註：timeout argument 跟 test() 一樣，所以不再次重複說明。例如：1234567test.only('加法運算', () =&gt; &#123; expect(addition(1, 2)).toBe(3);&#125;);test('其他運算', () =&gt; &#123; // 略過此區塊的測試&#125;);test.only 只會在 debug 階段使用，不建議 commit 至 Git 版本控制中，記得要在 debug 後刪掉 .only。test.skip(name, fn)alias：it.skip(name, fn) 或 xit(name, fn) 或 xtest(name, fn)若要跳過一些 test 區塊的測試，可用 test.skip()。例如：1234567test('加法運算', () =&gt; &#123; expect(addition(1, 2)).toBe(3);&#125;);test.skip('其他運算', () =&gt; &#123; // 略過此區塊的測試&#125;);若不想執行某 test 區塊的測試，雖然可將該測試註解掉，但建議用 test.skip，因為只少會保留原本的縮排和顯示程式碼 highlight。test.todo(name)alias：it.todo(name)規劃要寫的測試 (寫在 name argument 上) 可用 test.todo()，這些測試會在摘要輸出中 highlight 顯示，以便提醒你還有多少測試還沒寫。若提供 test callback 函數，test.todo() 會拋出錯誤。若你已實作了該測試，且該測試已出錯，而你不想執行此測試，請改用 test.skip()。例如：123const add = (a, b) =&gt; a + b;test.todo('add should be associative');資料來源：Globals · Jest","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"}],"author":"Titangene"},{"title":"Jest：Matcher & Assertion","slug":"jest-matcher-assertion","date":"2020-06-07T03:56:22.000Z","updated":"2020-06-28T14:07:19.145Z","comments":true,"path":"article/jest-matcher-assertion.html","link":"","permalink":"https://titangene.github.io/article/jest-matcher-assertion.html","excerpt":"Assertion (斷言) 就要測試程式碼的執行結果是否符合預期，如果結果一致，代表測試通過，否則 assertion 就會拋出錯誤，代表測試失敗。而 Jest 提供多種 matcher，能讓你 assert 程式碼執行結果的正確性。","text":"Assertion (斷言) 就要測試程式碼的執行結果是否符合預期，如果結果一致，代表測試通過，否則 assertion 就會拋出錯誤，代表測試失敗。而 Jest 提供多種 matcher，能讓你 assert 程式碼執行結果的正確性。之前介紹了如何建制 Jest 測試環境，還沒安裝環境的可參閱：Jest：建置測試環境 (包含 Babel) | Titangene BlogJest + TypeScript：建置測試環境 | Titangene Blog其他 Jest 相關文章可參閱 Jest 系列文章。下面介紹 Jest 提供的各種 matcher：通用 Matchersexpect() 回傳一個 “期望 (expectation)” 的物件當 Jest 執行時，它會追蹤所有失敗的 matcher，以便列印錯誤訊息：.toBe() 是 matcher，使用 Object.is() 來測試 exact equality (精確相等).toEqual()：檢查物件的值，遞迴的檢查物件或陣列的每個 field.not：matcher 的相反1234567891011121314151617test('two plus two is four', () =&gt; &#123; expect(2 + 2).toBe(4);&#125;);test('object assignment', () =&gt; &#123; const data = &#123;one: 1&#125;; data['two'] = 2; expect(data).toEqual(&#123;one: 1, two: 2&#125;);&#125;);test('adding positive numbers is not zero', () =&gt; &#123; for (let a = 1; a &lt; 10; a++) &#123; for (let b = 1; b &lt; 10; b++) &#123; expect(a + b).not.toBe(0); &#125; &#125;&#125;);Truthiness (真實性)在測試中，有時需要區分 undefined、null 和 false，但有時你又不需要區分。Jest 包含一些 helper，便於確認想要的內容：toBeNull 只 match nulltoBeUndefined 只 match undefinedtoBeDefined 與 toBeUndefined 相反toBeTruthy match 任何 if 陳述句為 truetoBeFalsy match 任何 if 陳述句為 false1234567891011121314151617test('null', () =&gt; &#123; const n = null; expect(n).toBeNull(); expect(n).not.toBeUndefined(); expect(n).toBeDefined(); expect(n).not.toBeTruthy(); expect(n).toBeFalsy();&#125;);test('zero', () =&gt; &#123; const z = 0; expect(z).not.toBeNull(); expect(z).toBeDefined(); expect(z).not.toBeUndefined(); expect(z).not.toBeTruthy(); expect(z).toBeFalsy();&#125;);Numbers大多數的比較數字都有 matcher equivalents (等價物)：toBeGreaterThan()：比較 received &gt; expectedtoBeGreaterThanOrEqual()：比較 received &gt;= expectedtoBeLessThan()：比較 received &lt; expectedtoBeLessThanOrEqual()：比較 received &lt;= expected1234567891011test('two plus two', () =&gt; &#123; const value = 2 + 2; expect(value).toBeGreaterThan(3); expect(value).toBeGreaterThanOrEqual(3.5); expect(value).toBeLessThan(5); expect(value).toBeLessThanOrEqual(4.5); // toBe 和 toEqual 等價於數字 expect(value).toBe(4); expect(value).toEqual(4);&#125;);對於浮點數相等，請使用 toBeCloseTo() 而不是 toEqual()，因為你不希望測試依賴於微小的捨入誤差 (rounding error)：12345test('adding floating point numbers', () =&gt; &#123; const value = 0.1 + 0.2; // expect(value).toBe(0.3); 由於舍入錯誤無法運作 expect(value).toBeCloseTo(0.3); // 可運作&#125;);Strings可用 toMatch() 根據 regex 檢查字串：1234567test('there is no I in team', () =&gt; &#123; expect('team').not.toMatch(/I/);&#125;);test('but there is a \"stop\" in Christoph', () =&gt; &#123; expect('Christoph').toMatch(/stop/);&#125;);Arrays 和 iterables可用 toContain() 來檢查陣列或可迭代物件是否包含特定項目：123456789101112const shoppingList = [ 'diapers', 'kleenex', 'trash bags', 'paper towels', 'beer',];test('the shopping list has beer on it', () =&gt; &#123; expect(shoppingList).toContain('beer'); expect(new Set(shoppingList)).toContain('beer');&#125;);Exceptions若要測試特定函數在呼叫時是否拋出錯誤，請使用 toThrow()：123456789101112function compileAndroidCode() &#123; throw new Error('you are using the wrong JDK');&#125;test('compiling android goes as expected', () =&gt; &#123; expect(compileAndroidCode).toThrow(); expect(compileAndroidCode).toThrow(Error); // 還可以使用確切的錯誤訊息或 regexp expect(compileAndroidCode).toThrow('you are using the wrong JDK'); expect(compileAndroidCode).toThrow(/JDK/);&#125;);更多 matcher 可參閱 Jest 社群維護的 jest-community/jest-extended。資料來源：Using Matchers · Jest","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"}],"author":"Titangene"},{"title":"Jest + TypeScript：建置測試環境","slug":"jest-typescript","date":"2020-05-31T15:59:10.000Z","updated":"2020-06-28T14:07:10.125Z","comments":true,"path":"article/jest-typescript.html","link":"","permalink":"https://titangene.github.io/article/jest-typescript.html","excerpt":"TypeScript 是 JavaScript 的 typed superset，提供強大的型別檢查系統，讓你在編譯時期就能即時發現錯誤，而不是到了 runtime 才發生未知的 bug。上次介紹了 Jest + Babel 的測試環境建置，這次來介紹 Jest + TypeScript 的測試環境建置過程。","text":"TypeScript 是 JavaScript 的 typed superset，提供強大的型別檢查系統，讓你在編譯時期就能即時發現錯誤，而不是到了 runtime 才發生未知的 bug。上次介紹了 Jest + Babel 的測試環境建置，這次來介紹 Jest + TypeScript 的測試環境建置過程。其他 Jest 相關文章可參閱 Jest 系列文章。下面來介紹如何建置 Jest + TypeScript 的測試開發環境。建立開發環境建立 npm 專案1$ npm init -y安裝 TypeScript1$ yarn add -D typescript或1$ npm install -D typescript安裝與 Node.js 和 TypeScript 相關的環境ts-node：Node.js 的 TypeScript 執行環境和 REPL，且支援 source map不用手動執行 tsc 編譯 TypeScript 檔案，就能直接像是使用 node 指令那樣，直接透過 ts-node 指令來編譯並執行 TypeScript 檔案nodemon：提供 watch 模式的 node當 nodemon 檢測到指定目錄中的檔案有變更時，就會重新啟動 Node 應用程式@types/node：Node.js 的型別定義檔1$ yarn add -D ts-node nodemon @types/node或1$ npm install -D ts-node nodemon @types/node安裝與 Jest 和 TS 相關的環境jest：JavaScript 測試框架ts-jest：用於 Jest preprocessor 的 TypeScript preprocessor支援 Jest 的 source map可讓你使用 Jest 來測試用 TypeScript 寫的專案支援 TS 的所有功能，包括型別檢查@types/jest：Jest 的型別定義檔1$ yarn add -D jest ts-jest @types/jest或1$ npm install -D jest ts-jest @types/jest設定 package.json在 package.json 加上下面內容：12345678&#123; \"scripts\": &#123; \"start\": \"ts-node src/main.ts\", \"dev\": \"nodemon --watch 'src/**/*.ts' --exec ts-node src/main.ts\", \"build\": \"tsc\", \"test\": \"jest --coverage\" &#125;&#125;設定 jest.config.jsJest 的預設是可以不用配置任何檔案就能執行測試，但 Jest 的預設是使用 Babel 來處理 .ts (和 .tsx ) 檔案 [1]，而 Babel 不會對 .ts 檔案進行編譯處理，所以就不會進行型別檢查。而 ts-jest 就能幫你處理 TS 該做的這些事。在 Babel7 or TypeScript | ts-jest 這篇文章內有提到為何不要用 @babel/preset-typescript，而要用 ts-jest 的原因。所以若要開發 TypeScript，不建議使用 Babel，建議用 tsc 來編譯 TypeScript。為了要使用 ts-jest 來 transpile TypeScript，請執行以下指令來建立 Jest 的配置檔案 jest.config.js：1$ npx ts-jest config:init此指令建立的 jest.config.js 檔案內容如下：1234module.exports = &#123; preset: 'ts-jest', testEnvironment: 'node',&#125;;但我自己自訂了一些配置：coverageDirectory：Jest 輸出的 coverage 檔案要放在哪個目錄預設：undefinedpreset：設定 preset預設：undefinedpreset 應指向 root 目錄上具有 jest-preset.json 或 jest-preset.js 檔案的 npm 模組testEnvironment：用於測試的測試環境預設：&quot;jsdom&quot; (類似瀏覽器的環境)若要建置 node service，可用 &quot;node&quot; 來使用類似 node 的環境testRegex：Jest 只執行 match 此 pattern 的測試檔案預設：(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.[jt]sx?$即在 __tests__ 目錄內的 .js、.jsx、.ts 和 .tsx 檔，以及帶有 .test 或 .spec 後綴的任何檔案，例如：sum.test.ts 或 sum.spec.tsJest 會用 testRegex 配置的 pattern 來嘗試 match 測試檔案的絕對路徑123456module.exports = &#123; coverageDirectory: \"coverage\", preset: 'ts-jest', testEnvironment: \"node\", testRegex: \"(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.tsx?$\"&#125;;更多 Jest 配置詳情可參閱 Configuring Jest · Jest。設定 tsconfig.json自己手動建立 tsconfig.json：12345678910&#123; \"compilerOptions\": &#123; \"target\": \"es6\", \"module\": \"commonjs\", \"outDir\": \"dist\", \"strict\": true, \"sourceMap\": true, \"esModuleInterop\": true &#125;&#125;當然你也可以用 tsc --init 指令來建立 tsconfig.json。更多 tsconfig.json 配置詳情可參閱 TypeScript: TSConfig Reference - Docs on every TSConfig option。寫範例程式碼1234// src/sum.tstype sumType = (a: number, b: number) =&gt; number;const sum: sumType = (a, b) =&gt; a + b;export default sum;1234// src/main.tsimport sum from './sum';console.log(sum(1, 2));執行 main.js：12345$ yarn startyarn run v1.21.1$ ts-node src/main.ts3Done in 4.71s.或123456$ npm run start&gt; jest-typescript-101@1.0.0 start /home/titan/project/jest/jest-typescript-101&gt; ts-node src/main.ts3建立測試1234567891011121314// src/__tests__/sum.test.tsimport sum from '../sum';test('adds 1 + 2 to equal 3', () =&gt; &#123; // Arrange let x: number = 1, y: number = 2; let expected: number = 3; // Act let actual: number = sum(x, y); // Assert expect(actual).toBe(expected);&#125;);執行測試1$ yarn test或1$ npm run test測試通過：資料來源：ts-jestts-nodenodemonGetting Started · JestJest CLI Options · JestConfiguring Jest · JestTypeScript: TSConfig Reference - Docs on every TSConfig optionJest 24: 💅 Refreshing, Polished, TypeScript-friendly · Jest ↩︎","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"},{"name":"Node.js","slug":"node-js","permalink":"https://titangene.github.io/tags/node-js/"},{"name":"TypeScript","slug":"typescript","permalink":"https://titangene.github.io/tags/typescript/"}],"author":"Titangene"},{"title":"Jest：建置測試環境 (包含 Babel)","slug":"jest-build-test-env","date":"2020-05-24T15:50:20.000Z","updated":"2020-06-28T14:07:43.421Z","comments":true,"path":"article/jest-build-test-env.html","link":"","permalink":"https://titangene.github.io/article/jest-build-test-env.html","excerpt":"最近在學習單元測試，而 Jest 是在前端蠻常見的測試框架，可透過建立測試來確保自己寫的程式碼是否符合需求，而且當改動程式碼時，才能確保是否因不小心而產生的 bug，測試能讓我更有信心的去重構程式碼。","text":"最近在學習單元測試，而 Jest 是在前端蠻常見的測試框架，可透過建立測試來確保自己寫的程式碼是否符合需求，而且當改動程式碼時，才能確保是否因不小心而產生的 bug，測試能讓我更有信心的去重構程式碼。其他 Jest 相關文章可參閱 Jest 系列文章。那 Jest 可以用在哪些專案？你可為下面這些專案建立測試：BabelTypeScriptNodeAngular、Vue、React…等下面來介紹如何建置 Jest 的測試開發環境。建立開發環境建立 npm 專案1$ npm init -y安裝 Jest1$ yarn add -D jest或1$ npm install -D jest設定 package.json在 package.json 加上下面內容：12345&#123; \"scripts\": &#123; \"test\": \"jest\" &#125;&#125;寫範例程式碼12345// sum.jsfunction sum(a, b) &#123; return a + b;&#125;module.exports = sum;1234// main.jsconst sum = require('./sum');console.log(sum(1, 2));執行 main.js：12$ node main.js3建立測試1234567891011121314// sum.test.jsconst sum = require('./sum');test('adds 1 + 2 to equal 3', () =&gt; &#123; // Arrange let x = 1, y = 2; let expected = 3; // Act let actual = sum(x, y); // Assert expect(actual).toBe(expected);&#125;);執行測試1$ yarn test或1$ npm run test測試通過：從指令列執行測試例如：Jest 只執行 match my-test 的測試檔案，以及使用 config.json 作為配置檔案，並且在執行後顯示 native 的 OS 通知：1$ jest my-test --notify --config=config.jsonJest CLI option 說明：jest &lt;regexForTestFiles&gt;：match 到名為 &lt;regexForTestFiles&gt; (像此範例的 my-test ) 的檔案執行 Jest若在執行 jest 時使用了 &lt;regexForTestFiles&gt; argument，該 argument 會被視為 regex pattern，Jest 只會執行與 pattern match 的測試檔案有些 terminal 可能需要用引號把 argument 包起來，例如：jest &quot;my.*(complex)?pattern&quot;Windows 需使用 / 作為路徑分隔字元 (separator) 或將 \\ 轉義 (escape) 成 \\\\--config=&lt;path&gt;，-c=&lt;path&gt;：使用 &lt;path&gt; (像此範例的 config.json ) 作為配置檔案Jest 配置檔案的路徑來指定如何查找和執行測試如果在配置中未設定 rootDir，則假定包含配置檔案的目錄為專案的 rootDir也可以是 JSON-encoded value 作為 Jest 的配置--notify：執行完成後顯示原生的 OS 通知激活 (activates) 測試結果通知當你不希望自己的意識能夠專注於 JavaScript 測試以外的任何事物時，可用此 optionBeware：Jest 使用 node-notifier 來顯示桌面通知在 Windows 上，它在第一次使用時會建立一個新的 start menu entry，並且不會顯示通知。通知將在後續執行中正確顯示Jest Config使用下面指令生成 Jest 的基礎配置檔案 jest.config.js：1$ jest --init因為我沒有在 global 安裝 jest，所以需要透過 yarn 來執行 Jest CLI (或是可透過 npx 來執行)：123456789101112$ yarn test --inityarn run v1.21.1$ jest --initThe following questions will help Jest to create a suitable configuration for your project✔ Choose the test environment that will be used for testing › node✔ Do you want Jest to add coverage reports? … yes✔ Automatically clear mock calls and instances between every test? … no📝 Configuration file created at /home/titan/.local/share/Trash/files/jest.config.jsDone in 7.41s.第一個問題我選擇 node：123? Choose the test environment that will be used for testing › - Use arrow-keys. Return to submit.❯ node jsdom (browser-like)第二個問題：是否要測試涵蓋報告 (coverage reports)？我選擇 yes：1? Do you want Jest to add coverage reports? › (y/N)第三個問題：是否要在每個測試之間自動清除 mock calls 和 instance？我選擇 No：1? Automatically clear mock calls and instances between every test? › (y/N)下面是剛剛執行 jest init 時，所生成的 jest.config.js 設定：coverageDirectory：Jest 輸出的 coverage 檔案要放在哪個目錄預設：undefinedtestEnvironment：用於測試的測試環境預設：&quot;jsdom&quot; (類似瀏覽器的環境)若要建置 node service，可用 &quot;node&quot; 來使用類似 node 的環境1234module.exports = &#123; coverageDirectory: \"coverage\", testEnvironment: \"node\"&#125;;更多 Jest 配置設定，詳情可參閱 Configuring Jest · Jest。使用 Babel在安裝 Babel 前，將程式碼改成 ES6 語法：123// sum.jsconst sum = (a, b) =&gt; a + b;export default sum;1234// main.jsimport sum from './sum';console.log(sum(1, 2));1234567891011121314// sum.test.jsimport sum from './sum';test('adds 1 + 2 to equal 3', () =&gt; &#123; // Arrange let x = 1, y = 2; let expected = 3; // Act let actual = sum(x, y); // Assert expect(actual).toBe(expected);&#125;);跑測試會出錯，因為 Jest 需要透過 Babel 才能執行 ES6 的語法：1$ yarn test所以來安裝 Babel：1$ yarn add -D babel-jest @babel/core @babel/preset-env在專案根目錄建立 babel.config.js，此檔案用於配置與你當前 Node 版本相容的 Babel：12345678910111213// babel.config.jsmodule.exports = &#123; presets: [ [ '@babel/preset-env', &#123; targets: &#123; node: 'current', &#125;, &#125;, ], ],&#125;;再跑測試就會通過：1$ yarn test詳情可參閱 Babel 官方文件。資料來源：Getting Started · JestJest CLI Options · JestConfiguring Jest · Jest","categories":[{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"},{"name":"Node.js","slug":"node-js","permalink":"https://titangene.github.io/tags/node-js/"},{"name":"Babel","slug":"babel","permalink":"https://titangene.github.io/tags/babel/"}],"author":"Titangene"},{"title":"Sass：@import rule","slug":"sass-import-rule","date":"2020-05-17T15:54:46.000Z","updated":"2020-05-17T15:53:41.487Z","comments":true,"path":"article/sass-import-rule.html","link":"","permalink":"https://titangene.github.io/article/sass-import-rule.html","excerpt":"Sass 的 @import rule 可以引入 Sass 和 CSS stylesheet、提供對 mixin、function 和變數的存取，並且還能將多個 stylesheet 的 CSS 組合在一起。例如：main.scss 內使用 @import 引入 Sass 和 CSS 檔，在編譯 Sass 後，就只會產生一個 main.css 檔。","text":"Sass 的 @import rule 可以引入 Sass 和 CSS stylesheet、提供對 mixin、function 和變數的存取，並且還能將多個 stylesheet 的 CSS 組合在一起。例如：main.scss 內使用 @import 引入 Sass 和 CSS 檔，在編譯 Sass 後，就只會產生一個 main.css 檔。而 CSS 本身提供的 @import rule 會讓瀏覽器在呈現頁面時，有幾個 CSS 檔案是透過 @import 引入的，就要發出幾個 HTTP request，這與 Sass @import rule 的行為不同。同時引入多個檔案雖然 Sass 和 CSS 的引入語法相同，但 Sass 可以用逗號分隔，一次引入多個檔案，不需要每個檔案都各別用一行 @import 引入：12&#x2F;&#x2F; _button.scss.button &#123; color: #aaa; &#125;12&#x2F;&#x2F; _nav.scss.nav &#123; color: #bbb; &#125;1234&#x2F;&#x2F; main.scss@import &#39;button&#39;, &#39;nav&#39;;main &#123; color: #000; &#125;輸出：123.button &#123; color: #aaa; &#125;.nav &#123; color: #bbb; &#125;main &#123; color: #000; &#125;當 Sass 引入檔案時，會對該檔案進行估算，很像是將內容直接抄在你使用 @import 的位置上。在 @import 之前定義的任何 mixin、function 或變數 (甚至來自其他 @import 的) 都可以在你引入的 stylesheet 中使用他們。不要重複引入所以若對同一個檔案引入多次，就會造成編譯出來的 CSS 檔案內，會有重複的 stylesheet。例如：12345&#x2F;&#x2F; main.scss@import &#39;button&#39;;@import &#39;button&#39;;main &#123; color: #000; &#125;輸出：123.button &#123; color: #aaa; &#125;.button &#123; color: #aaa; &#125;main &#123; color: #000; &#125;除非你重複引入的檔案內，只有像是 mixin、function 或變數等不會產生樣式規則的東西，就不會產生重複的內容。引入不用寫副檔名另外，使用 Sass 的 @import rule 時，不用寫檔案的副檔名，因為 Sass 會自動幫你引入。例如：當你引入 @import &quot;a&quot; 時，Sass 會自動引入 a.scss、a.sass 或 a.css。但 CSS 本身提供的 @import rule 記得要寫檔案的副檔名才能正確的引入。引入路徑在引入 partials (以 _ 為開頭的檔案) 時，不用寫 _ 就能引入，且該檔案不會被編譯引入檔案時可省略 ./ 相對引入在使用 Sass CLI 時，若有提供 --load-path 或 -I option，就可以簡化引入的路徑詳情可參閱我之前寫的 Dart Sass 介紹 (使用與安裝)但引入時，Sass 會先解析相對於當前檔案的路徑，若沒有找到時，才會引入相對於 --load-path 提供的路徑內的檔案例如：在 node_modules/bootstrap/scss 目錄內正好有名為 _button.scss 的檔案，而我引入了 @import 'buttons'：12&#x2F;&#x2F; src&#x2F;_buttons.scss.button &#123; color: blue; &#125;1234&#x2F;&#x2F; src&#x2F;main.scss@import &#39;buttons&#39;;main &#123; color: #000; &#125;編譯 Sass (注意，我使用了 --load-path option，指定了 Bootstrap 內的路徑)：1$ sass --load-path=node_modules/bootstrap/scss src/main.scss但輸出的結果表名，我引入的 @import 'buttons' 指的是 src/_buttons.scss 這個檔案，而不是 node_modules/bootstrap/scss 目錄內的 _button.scss 這個檔案：12.button &#123; color: blue; &#125;main &#123; color: #000; &#125;因為在 src 目錄內，_buttons.scss 相對於 main.scss，所以不會引用到 Bootstrap 內的檔案。index 檔案若在資料夾 (例如：base 資料夾) 內建立 _index.scss 或 _index.sass 檔案，而 index 檔案內引入了該資料夾內的其他檔案 (例如：_code.scss 和 _list.scss ) 時，則可直接透過 @import 該資料夾來引入那些檔案。目錄結構：1234567$ tree.├── base│ ├── _code.scss│ ├── _index.scss│ └── _list.scss└── main.scss12&#x2F;&#x2F; base&#x2F;_code.scsscode &#123; padding: 4px; &#125;12&#x2F;&#x2F; base&#x2F;_list.scssul &#123; padding: 0; &#125;12&#x2F;&#x2F; base&#x2F;_index.scss@import &#39;code&#39;, &#39;list&#39;;1234&#x2F;&#x2F; main.scss@import &#39;base&#39;;main &#123; color: #000; &#125;輸出：123code &#123; padding: 4px; &#125;ul &#123; padding: 0; &#125;main &#123; color: #000; &#125;巢狀引入也可以巢狀引入，但要注意的是在巢狀引入 (nested import) 中定義的 mixin、function 或變數都還是全域定義的：12&#x2F;&#x2F; _button.scss.button &#123; color: #aaa; &#125;1234&#x2F;&#x2F; main.scssmain &#123; @import &#39;a&#39;;&#125;輸出：1main .button &#123; color: #aaa; &#125;若是巢狀引入的檔案內有使用 parent selectors (也就是 &amp; )，則會引用 stylesheet 巢狀在其中的選擇器 (估算的方式類似 mixin)，例如：123456789&#x2F;&#x2F; _theme.scssul li &#123; padding-left: 16px; [dir&#x3D;rtl] &amp; &#123; padding-left: 0; padding-right: 16px; &#125;&#125;1234&#x2F;&#x2F; style.scss.theme-sample &#123; @import &#39;theme&#39;;&#125;輸出：1234567.theme-sample ul li &#123; padding-left: 16px;&#125;[dir=rtl] .theme-sample ul li &#123; padding-left: 0; padding-right: 16px;&#125;引入 CSSSass 的 @import rule 除了可以引入 .scss 和 .sass 檔，也可以引入 .css 檔。但要記得在引入 .css 檔時，不可以像 @import 'file.css'; 這樣明確的寫你引入了 .css 檔，而是要忽略副檔名。因為當你明確的寫 .css 副檔名時，代表你想用 CSS 原本的 @import rule。以下這些引入方式都是 CSS 原本的 @import rule：以 .css 為結尾的 URL以 http:// 或 https:// 為開頭的 URL用 url() 來引入 URL具有 media query 的引入1234@import &quot;theme.css&quot;;@import &quot;http:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;Droid+Sans&quot;;@import url(theme);@import &quot;landscape&quot; screen and (orientation: landscape);Interpolation雖然 Sass imports 不能使用 interpolation，但 CSS 原本的 @import 是可以的。這樣就可以動態生成引入的 URL，例如：12345@mixin google-font($family) &#123; @import url(&quot;http:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;#&#123;$family&#125;&quot;);&#125;@include google-font(&quot;Droid Sans&quot;);輸出：1@import url(\"http://fonts.googleapis.com/css?family=Droid Sans\");資料來源：Sass: @import","categories":[{"name":"Web Dev","slug":"web-dev","permalink":"https://titangene.github.io/categories/web-dev/"}],"tags":[{"name":"Sass","slug":"sass","permalink":"https://titangene.github.io/tags/sass/"},{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/tags/css/"},{"name":"Dart Sass","slug":"dart-sass","permalink":"https://titangene.github.io/tags/dart-sass/"},{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"}],"author":"Titangene"},{"title":"Sass：@use rule","slug":"sass-use-rule","date":"2020-05-10T15:54:48.000Z","updated":"2020-05-10T23:03:19.504Z","comments":true,"path":"article/sass-use-rule.html","link":"","permalink":"https://titangene.github.io/article/sass-use-rule.html","excerpt":"若要模組化 Sass，最常用的就是 @import 規則。但在 Dart Sass 推出了一個新功能：模組系統，可用 @use 規則，並透過 namespace 來引入其他 stylesheet 中的成員。","text":"若要模組化 Sass，最常用的就是 @import 規則。但在 Dart Sass 推出了一個新功能：模組系統，可用 @use 規則，並透過 namespace 來引入其他 stylesheet 中的成員。Overview載入其他 Sass stylesheet 中的 mixin、函數和變數，並將多個 stylesheet 中的 CSS 組合在一起不管用 @use 載入幾次的任何樣式，都只會在編譯的 CSS 輸出中出現一次@use 必須放在所有規則之前 (除了 @forward 和變數宣告之外)便於了解成員是從哪些檔案載入的不用像使用 @import 時那樣，需把命名寫清楚，因為可透過 @use 提供的 namespace 來避免命名衝突只要使用 @use 引入的檔案，stylesheet 就會被全部引入，不管有無另外使用。語法123456789@use \"&lt;url&gt;\";@use \"&lt;url&gt;\" as &lt;namespace&gt;;@use \"&lt;url&gt;\" as *;@use \"&lt;url&gt;\" with ( &lt;variable&gt;: &lt;value&gt;, &lt;variable&gt;: &lt;value&gt;);載入成員用 @use 載入的 stylesheet 稱為「modules (模組)」。使用 @use 時，可透過 namespace 來存取另一個模組中的變數、函數和 mixin：變數：&lt;namespace&gt;.&lt;variable&gt;函數：&lt;namespace&gt;.&lt;function&gt;()mixin：@include &lt;namespace&gt;.&lt;mixin&gt;()預設的 &lt;namespace&gt; 就是模組 URL 的檔名 (不包含 _ 底線前綴和副檔名)用 @use 載入的成員有存取範圍，只有載入它們的 stylesheet 才能存取若其他 stylesheet 想存取這些成員，就必須自己寫 @use 載入例如：用 @use 引入的 styles/base/_color.scss 檔案會像下面這樣，而此模組的 namespace 就是 color：12// styles/base/_color.scss$blue: #2979ff;12345678// styles/_tool.scss@mixin rounded &#123; border-radius: 3px;&#125;@function px2em($pixel, $font-size-base: 16px) &#123; @return ($pixel / $font-size-base) * 1em;&#125;12345678910// styles/main.scss@use \"base/color\";@use \"tool\";.button &#123; padding: 10px; color: color.$blue; font-size: tool.px2em(32px); @include tool.rounded;&#125;輸出：123456.button &#123; padding: 10px; color: #2979ff; font-size: 2em; border-radius: 3px;&#125;設定 namespace語法：12@use \"&lt;url&gt;\" as &lt;namespace&gt;;@use \"&lt;url&gt;\" as *;自訂 namespace (很像設定 alias) 的情境：載入相同檔名的多個模組 (例如：第三方 library 和我的檔名相同)讓模組的名稱變短12// src/_mycolor.scss$blue: #2979ff;123456// src/main.scss@use \"src/mycolor\" as color;.button &#123; color: color.$blue;&#125;輸出：123.button &#123; color: #2979ff;&#125;也可用 * 來載入沒有 namespace 的模組，但建議使用在自己寫的 stylesheet 或 Sass 提供的內建模組，以避免引入名稱衝突的成員：例如：1234567@use 'sass:math' as *;$half: percentage(1/2);.button &#123; border-radius: $half;&#125;輸出：123.button &#123; border-radius: 50%;&#125;私有成員若你不想讓你定義的所有成員都可在 stylesheet 之外使用，就可在成員名稱的前面加上 - 或 _，來讓它們變成私有成員。123456// styles/_corner.scss$_radius: 3px;@mixin rounded &#123; border-radius: $_radius;&#125;1234567// styles/main.scss@use \"corner\";.button &#123; border-radius: corner.rounded; padding: corner.$_radius; // Error&#125;編譯會報錯：1234567$ npx sass styles:dict/stylesError: Private members can't be accessed from outside their modules. ╷5 │ padding: corner.$_radius; │ ^^^^^^^^^^^^^^^ ╵ src/scss/main.scss 5:12 root stylesheet配置模組stylesheet 可用 !default flag 來定義變數，會被新的值給覆蓋。若要載入帶有配置的模組，可用以下語法：1234@use \"&lt;url&gt;\" with ( &lt;variable&gt;: &lt;value&gt;, &lt;variable&gt;: &lt;value&gt;);配置的值會覆蓋變數的預設值。例如：123456// styles/base/_color.scss$blue: #2979ff !default;$red: #f44336 !default;$primary: $blue;$secondary: $red;12345678910111213// styles/main.scss@use \"base/color\" with ( $blue: #00f, $red: #f00);.button-primary &#123; background-color: color.$primary;&#125;.button-secondary &#123; background-color: color.$secondary;&#125;輸出：1234567.button-primary &#123; background-color: #00f;&#125;.button-secondary &#123; background-color: #f00;&#125;資料來源：Sass: @use","categories":[{"name":"Web Dev","slug":"web-dev","permalink":"https://titangene.github.io/categories/web-dev/"}],"tags":[{"name":"Sass","slug":"sass","permalink":"https://titangene.github.io/tags/sass/"},{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/tags/css/"},{"name":"Dart Sass","slug":"dart-sass","permalink":"https://titangene.github.io/tags/dart-sass/"},{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"}],"author":"Titangene"},{"title":"Dart Sass 介紹 (使用與安裝)","slug":"dart-sass","date":"2020-05-03T15:54:55.000Z","updated":"2020-05-10T23:03:26.624Z","comments":true,"path":"article/dart-sass.html","link":"","permalink":"https://titangene.github.io/article/dart-sass.html","excerpt":"Dart Sass 是 Sass 的主要實作，過去常見的是 Ruby Sass，而現今 Sass 官方推薦大家改用 Dart Sass，尤其是用 JavaScript 或 Node.js 開發的相關專案。","text":"Dart Sass 是 Sass 的主要實作，過去常見的是 Ruby Sass，而現今 Sass 官方推薦大家改用 Dart Sass，尤其是用 JavaScript 或 Node.js 開發的相關專案。Dart Sass 是 Sass 的 Dart 實作，效能比 Ruby Sass 還要快，且易於安裝，還可編譯成純 JavaScript，讓我們可以輕鬆的整合至現有的 Web 開發工作流程中。安裝有多種安裝和執行 Dart Sass 的方法：Standalone從 GitHub Release 頁面下載適用於你 OS 的 standalone Dart Sass archive，其中包含 Dart VM 和 executable 的 snapshot。使用方法很簡單，下載後並解壓縮，將解壓縮後的目錄新增至 PATH (這篇 提供各 OS 如何設定 PATH 的步驟)，接著重新啟動 terminal，然後就能執行 sass executable 開始使用！npm可透過 npm 安裝 Dart Sass，該套件是已編譯為 JavaScript，且沒有任何 native code 或外部依賴。提供 command-line sass executable 和 Node.js API。全域安裝：1$ npm install -g sasslocal 安裝：新增至專案12$ npm init -y$ npm install --save-dev sass其餘的安裝方式可參考 Dart Sass GitHub Repo 的 README 說明。為何用 Dart？在 Dart Sass GitHub Repo 的 README 有提到為何 Dart Sass 會取代 Ruby Sass，有以下幾個優點：效能快：比 Ruby 塊，且與 C++ 差不多免安裝：Dart VM 沒有外部依賴，可將應用程式編譯成獨立的 snapshot 檔案，因此可將 Dart Sass 只需發佈三個檔案 (VM、snapshot 和 wrapper script)可編譯成 JavaScript，所以可透過 npm 發佈容易寫：Dart 是比 C++ 更高級的語言，不需要太多的記憶體管理和建制系統的麻煩Dart 是靜態型別 (statically typed)，與 Ruby 相比 可更容易的進行大型重構對貢獻者更友好：Dart 比 Ruby 更容易學習Command LineDart Sass executable 有兩種使用模式：One-to-One Mode (一對一模式)Many-to-many Mode (多對多模式)One-to-One Mode1$ sass &lt;input.scss&gt; [output.css]一個輸入檔 ( input.scss ) 編譯成一個輸出檔 ( output.scss )若為提供輸出路徑，會將已編譯的 CSS 列印至 terminal 上若輸入檔的副檔名是：.scss：解析成 SCSS.sass：解析成 縮排語法 (indented syntax).css：解析成 純 CSS若都不是以上三種，或來至標準輸入，預設會解析成 SCSS也可用 --indented flag 來控制輸出格式Many-to-many Mode1$ sass [&lt;input.css&gt;:&lt;output.css&gt;] [&lt;input/&gt;:&lt;output/&gt;]...一個或多個輸入檔編譯成一個或多個輸出檔輸入和輸出用 : 字元來隔開可將目錄中的所有 Sass 檔編譯為另一個目錄中具有相同名稱的 CSS 檔例如：將 style.scss 編譯成 style.css1$ sass style.scss:style.css將 light.scss 和 dark.scss 編譯成 light.css 和 dark.css：1$ sass light.scss:light.css dark.scss:dark.css將 src/scss/ 目錄內的所有 Sass 檔編譯至 public/css/ 目錄中，且會編譯成 CSS 檔：1$ sass src/scss:public/css編譯整個目錄時，如果只想編譯出一個 CSS 檔案 (例如：main.css )，就要將主要檔案之外的其他檔案的名稱，改為以 _ 為開頭的 (例如：_color.scss，這種檔案被稱為 partial 檔案)。CLI option--indented指定輸入檔要解析成縮排語法 (indented syntax)--load-path，-I新增額外的載入路徑來查找 stylesheet此 option 可使用多次，代表提供多個載入路徑最先載入的會優先於較晚載入的路徑例如：如果沒有使用 --load-path option，要 import Bootstrap 就必須使用很長的路徑：123@import \"../node_modules/bootstrap/scss/functions\";@import \"../node_modules/bootstrap/scss/variables\";@import \"../node_modules/bootstrap/scss/mixins\";若使用 --load-path option，就能簡短 import Bootstrap 的路徑：1$ sass --load-path=node_modules src/main.scss dist/main.css123@import \"bootstrap/scss/functions\";@import \"bootstrap/scss/variables\";@import \"bootstrap/scss/mixins\";--style，-s指定 CSS 的輸出樣式。Dart Sass 支援兩種輸出樣式：expanded：預設，將每個選擇器和宣告寫在自己的那行上compressed：刪除盡可能多的多餘字元，並將整個 stylesheet 寫成一行1234567$ sass --style=expanded style.scssh1 &#123; font-size: 40px;&#125;$ sass --style=compressed style.scssh1&#123;font-size:40px&#125;--error-css當編譯期間發生錯誤時，會告訴 Sass 是否 emit CSS 檔案該 CSS 檔會在註解和 body::before 的 content property 中描述錯誤可在瀏覽器中察看錯誤訊息，而不會切回 terminal 察看預設若要編譯至少一個檔案 (不是標準輸出)，就會啟用 error CSS可在編譯成標準輸出時加上 --error-css 來啟用 error CSS也可以加上 --no-error-css 來禁用 error CSS禁用 error CSS 後，--update flag 和 --watch flag 會在發生錯誤時刪除 CSS 檔案例如：以下 Sass 檔的內容是錯誤的：12// main.scss$width: 15px + 2em;編譯此 Sass 檔會出現以下錯誤：1234567$ sass --error-css main.scss main.cssError: Incompatible units em and px. ╷1 │ $width: 15px + 2em; │ ^^^^^^^^^^ ╵ test.scss 1:9 root stylesheet而輸出的 main.css 檔的內容如下：1234567891011121314151617/* Error: Incompatible units em and px. * , * 1 | $width: 15px + 2em; * | ^^^^^^^^^^ * ' * test.scss 1:9 root stylesheet */body::before &#123; font-family: \"Source Code Pro\", \"SF Mono\", Monaco, Inconsolata, \"Fira Mono\", \"Droid Sans Mono\", monospace, monospace; white-space: pre; display: block; padding: 1em; margin-bottom: 1em; border-bottom: 2px solid black; content: \"Error: Incompatible units em and px.\\a \\2577 \\a 1 \\2502 $width: 15px + 2em;\\a \\2502 ^^^^^^^^^^\\a \\2575 \\a test.scss 1:9 root stylesheet\"; &#125;若用瀏覽器察看使用此 main.css 檔的頁面會像下圖這樣：--update當 stylesheets 的依賴更新時，Sass 就只會編譯 stylesheets更新 stylesheets 時，會列印狀態訊息12$ sass --update themes:public/cssCompiled themes/light.scss to public/css/light.css.--watch類似 --update，但是在完成第一次編譯後，Sass 保持 open 狀態，並在 stylesheets 或其依賴發生更改時繼續編譯 stylesheets。12345$ sass --watch themes:public/cssCompiled themes/light.scss to public/css/light.css.# Then when you edit themes/dark.scss...Compiled themes/dark.scss to public/css/dark.css.常用的 option開發用：--watch：watch 模式-I node_modules：新增額外載入的 node_modules 目錄1$ sass --watch -I node_modules src/scss:dict/styles部署用 (build)：-s compressed：CSS Minifier1$ sass -s compressed src/scss:dict/styles更多 CLI option 可參閱 Sass 文件。資料來源sass/dart-sass: The reference implementation of Sass, written in Dart.Sass: Ruby Sasssass - npmSass: Install SassCSS 預處理器 Sass 的預設實作將遷移到 Dart Sass - 分享 - Dart 中文社區Sass: Dart Sass Command-Line Interface","categories":[{"name":"Web Dev","slug":"web-dev","permalink":"https://titangene.github.io/categories/web-dev/"}],"tags":[{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"},{"name":"Sass","slug":"sass","permalink":"https://titangene.github.io/tags/sass/"},{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/tags/css/"},{"name":"Dart Sass","slug":"dart-sass","permalink":"https://titangene.github.io/tags/dart-sass/"},{"name":"CLI","slug":"cli","permalink":"https://titangene.github.io/tags/cli/"},{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"}],"author":"Titangene"},{"title":"npm / Yarn 套件管理器指令比對 cheatsheet","slug":"npm-and-yarn-cheatsheet","date":"2020-04-26T11:36:11.000Z","updated":"2020-05-03T14:05:17.000Z","comments":true,"path":"article/npm-and-yarn-cheatsheet.html","link":"","permalink":"https://titangene.github.io/article/npm-and-yarn-cheatsheet.html","excerpt":"npm 或 Yarn 都是最常見的 Node.js 套件管理器。本篇紀錄兩個 CLI 對應的指令。","text":"npm 或 Yarn 都是最常見的 Node.js 套件管理器。本篇紀錄兩個 CLI 對應的指令。建立新專案12$ npm init$ npm init -y12$ yarn init$ yarn init -y安裝專案 package.json 中的所有相依套件12$ yarn$ yarn install12$ npm install$ npm i安裝相依套件安裝相依套件，並將套件新增至不同類型的 dependencies：12$ npm i &lt;package&gt;$ npm install &lt;package&gt;123$ yarn add &lt;package&gt;$ yarn add &lt;package&gt;@&lt;version&gt;$ yarn add &lt;package&gt;@&lt;tag&gt;安裝套件並將此套件儲存至 package.json 中的 dependencies (目前 npm 的預設參數，不需加 -S 就有此功能，舊版 npm 需要加此 option 才會將安裝的套件存至 package.json )：12$ npm install &lt;package&gt; --save$ npm install &lt;package&gt; -S新增至不同類型的 dependencies安裝相依套件，並將套件新增至不同類型的 devDependencies：12$ npm install &lt;package&gt; --save-dev$ npm install &lt;package&gt; -D12$ yarn add &lt;package&gt; --dev$ yarn add &lt;package&gt; -D安裝相依套件，並將套件新增至不同類型的 optionalDependencies：12$ npm install &lt;package&gt; --save-optional$ npm install &lt;package&gt; -O12$ yarn add &lt;package&gt; --optional$ yarn add &lt;package&gt; -O安裝相依套件，並將套件新增至不同類型的 bundleDependencies：12$ npm install &lt;package&gt; --save-bundle$ npm install &lt;package&gt; -B安裝相依套件，並將套件新增至不同類型的 peerDependencies：12$ yarn add &lt;package&gt; --peer$ yarn add &lt;package&gt; -P不同類型的 dependencies 可參閱 Yarn 官方文件中的「依賴關係的種類」 這篇。安裝指定版本12$ npm install &lt;package&gt; --save-exact$ npm install &lt;package&gt; -E12$ yarn add &lt;package&gt; --exact$ yarn add &lt;package&gt; -E安裝次版號的最新版12$ yarn add &lt;package&gt; --tilde$ yarn add &lt;package&gt; -T在全域安裝套件1$ npm install -g &lt;package&gt;1$ yarn global add &lt;package&gt;升級相依套件升級目前專案的相依套件：12$ npm update$ npm update &lt;package&gt;12$ yarn upgrade$ yarn upgrade &lt;package&gt;全域的相依套件：12$ npm update -g$ npm update -g &lt;package&gt;12$ yarn global upgrade$ yarn global upgrade &lt;package&gt;升級至最新版1$ yarn upgrade &lt;package&gt; --latest升級相依套件可選擇是否升級1$ yarn upgrade-interactive &lt;package&gt;刪除套件刪除目前專案的相依套件：1$ npm uninstall &lt;package&gt;1$ yarn remove &lt;package&gt;刪除全域的相依套件：1$ npm uninstall -g &lt;package&gt;1$ yarn global remove &lt;package&gt;列出已安裝的套件1$ npm ls1$ yarn list資料來源migrating from npm | Yarnyarn add | Yarn","categories":[{"name":"Web Dev","slug":"web-dev","permalink":"https://titangene.github.io/categories/web-dev/"}],"tags":[{"name":"CLI","slug":"cli","permalink":"https://titangene.github.io/tags/cli/"},{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Node.js","slug":"node-js","permalink":"https://titangene.github.io/tags/node-js/"},{"name":"version manager","slug":"version-manager","permalink":"https://titangene.github.io/tags/version-manager/"},{"name":"npm","slug":"npm","permalink":"https://titangene.github.io/tags/npm/"},{"name":"Yarn","slug":"yarn","permalink":"https://titangene.github.io/tags/yarn/"}],"author":"Titangene"},{"title":"nvm：安裝、切換不同 Node.js 版本的管理器","slug":"nvm","date":"2020-04-19T15:56:52.000Z","updated":"2020-05-03T14:05:35.000Z","comments":true,"path":"article/nvm.html","link":"","permalink":"https://titangene.github.io/article/nvm.html","excerpt":"nvm 是 Node.js 的版本管理器 (version manager)，可在同一台主機上安裝多個版本的 Node.js 環境，因為不同專案可能會使用不同的 Node.js 版本，那就需要透過一個版本管理器來切換不同的 Node.js 版本。","text":"nvm 是 Node.js 的版本管理器 (version manager)，可在同一台主機上安裝多個版本的 Node.js 環境，因為不同專案可能會使用不同的 Node.js 版本，那就需要透過一個版本管理器來切換不同的 Node.js 版本。安裝 NVM可用 cURL 或 wget 指令使用安裝腳本安裝或更新 nvm：1$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash或1$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash此安裝腳本會將 nvm repo clone 到 ~/.nvm，並且將 source line 新增至你的 profile 設定 ( ~/.bash_profile、~/.zshrc、~/.profile 或 ~/.bashrc )：123export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion如果在 Linux 執行安裝腳本後，執行下面指令會顯示以下訊息或沒有任何訊息時，建議重開一個新的終端機 (terminal) 再重新執行一次 nvm 指令：12$ command -v nvmnvm: command not found如果還是無法使用 nvm，可執行下面指令立即應用 ZSH 的設定：1$ source .zshrc注意：使用 nvm 時，不需要 sudo 即可使用 npm -g 全域安裝模組，所以與其執行 sudo npm i -g，不如執行 npm i -g若你有 ~/.npmrc，請確保裡面不包含任何 prefix 的設定 (因為與 nvm 不相容)你可以 (但不應該) 保留以前在 “系統” 安裝的 Node.js，但 nvm 只對你的使用者帳戶 (用於安裝 nvm 的使用者帳戶) 可用。可能會導致版本不 match，因為其他使用者會使用 /usr/local/lib/node_modules/*，而使用者帳戶會使用 ~/.nvm/versions/node/vX.X.X/lib/node_modules/*--version：確認 NVM 是否安裝成功12$ nvm --version0.34.0install：利用 NVM 安裝 Node.js安裝 NVM 後，其實還沒安裝 Node 環境：12$ node zsh: command not found: node如果執行下面指令，會提醒你需要執行 install 指令才能安裝 Node.js：1234$ nvm use nodeN/A: version \"node -&gt; N/A\" is not yet installed.You need to run \"nvm install node\" to install it before using it.安裝最新版的 Node.js：12345678$ nvm install nodeDownloading and installing node v12.8.1...Downloading https://nodejs.org/dist/v12.8.1/node-v12.8.1-linux-x64.tar.xz...#################################################################################################### 100.0%Computing checksum with sha256sumChecksums matched!Now using node v12.8.1 (npm v6.10.2)Creating default alias: default -&gt; node (-&gt; v12.8.1)如果要指定安裝版本，可以直接指定版本號：1$ nvm install 8.9.1安裝的第一個版本的 Node.js 會成員 nvm 的預設版本，新的 shell 就會以預設版本的 Node.js 來使用 (例如：nvm alias default)。查看目前安裝 Node.js 的版本：12$ node -vv12.8.1ls-remote：察看可用的安裝版本可以看目前有哪些可用版本可安裝，在版本號前面的 -&gt; 箭頭符號代表目前 nvm 正在使用的 Node.js 版本：123456789$ nvm ls-remote... v10.16.1 (LTS: Dubnium) v10.16.2 (LTS: Dubnium) v10.16.3 (Latest LTS: Dubnium)... v12.7.0 v12.8.0-&gt; v12.8.1不過剛剛的 ls-remote 指令會把所有可用的版本都列出來，但通常會選擇安裝 LTS (Long-term support，長期支援) 版，所以只要加上 -lts 參數就可以指列出可用的 LTS 版：12345$ nvm ls-remote --lts... v10.16.1 (LTS: Dubnium) v10.16.2 (LTS: Dubnium) v10.16.3 (Latest LTS: Dubnium)如果版本號的文字有特殊顏色 (不是白色字)，則代表該版本的 Node.js 有透過 nvm 安裝過，例如：我的電腦就安裝了 v10.16.3 和 v12.8.1：ls：查看目前安裝了哪些版本ls 指令可以查看目前安裝了哪些版本：12345678910111213$ nvm ls v10.16.3-&gt; v12.8.1default -&gt; node (-&gt; v12.8.1)node -&gt; stable (-&gt; v12.8.1) (default)stable -&gt; 12.8 (-&gt; v12.8.1) (default)iojs -&gt; N/A (default)unstable -&gt; N/A (default)lts/* -&gt; lts/dubnium (-&gt; N/A)lts/argon -&gt; v4.9.1 (-&gt; N/A)lts/boron -&gt; v6.17.1 (-&gt; N/A)lts/carbon -&gt; v8.16.1 (-&gt; N/A)lts/dubnium -&gt; v10.16.3use：切換 Node.js 版本如果要使用 nvm 切換正在使用的 Node.js 版本，可用 use 指令：12$ nvm use v10.6.3Now using node v10.16.3 (npm v6.9.0)如果切換的目標版本還沒安裝，nvm 會提醒你要安裝：1234$ nvm use lts/carbon N/A: version \"lts/carbon -&gt; N/A\" is not yet installed.You need to run \"nvm install lts/carbon\" to install it before using it.透過 nvm 安裝 Node.js 時，nvm 會將不同的 Node.js 版本儲存在 ~/.nvm/versions/node/vX.X.X，然後再修改 $PATH，將指定版本的 Node.js 路徑加入：12345678910$ nvm currentv10.16.3$ echo $PATH /home/titan/.nvm/versions/node/v10.16.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin$ use v12.13.1$ nvm currentv12.13.1$ echo $PATH /home/titan/.nvm/versions/node/v12.13.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin在 nvm 的各個 Node.js 版本安裝的全域套件都會在各自版本的目錄內安裝，所以在切換至新安裝的 Node.js 版本後需要重新安裝，也因為如此，不同版本間的套件就不會有衝突問題。current：察看目前使用版本如果忘記自己切換到哪個版本，可以用 current 指令：12$ nvm currentv10.6.3run：直接執行 Node.js如果要直接執行 Node.js，可以使用下面指令：12345$ nvm run nodeRunning node v12.8.1 (npm v6.10.2)Welcome to Node.js v12.8.1.Type \".help\" for more information.&gt;exec：指定要執行的 Node.js 版本12345$ nvm exec 12.8.1 nodeRunning node v12.8.1 (npm v6.10.2)Welcome to Node.js v12.8.1.Type \".help\" for more information.&gt;which：察看 Node.js 的安裝路徑執行下面指令可以查看特定版本的 Node.js 的安裝路徑：12$ nvm which 12.8.1/home/titan/.nvm/versions/node/v12.8.1/bin/nodealias如下圖有些版本的文字是紅色或是顯示 N/A，就代表該版本未在電腦安裝：預設 alias 可以取代版本號：node：安裝最新版的 Node.jsiojs：安裝最新版的 io.jsstable：此 alias 已棄用，僅適用於 v0.12 以及更舊版，目前改為 node aliasunstable：此 alias 為 v0.11，最後一個 “unstable” (不穩定) Node release，在 v1.0 之後的版本都是穩定版 (in SemVer, versions communicate breakage, not stability)可在下面這些指令使用以上預設別名：nvm installnvm usenvm runnvm execnvm which… 等alias：察看別名、設定別名察看別名123456789101112$ nvm alias * ?default -&gt; v10.16.3node -&gt; stable (-&gt; v12.8.1) (default)stable -&gt; 12.8 (-&gt; v12.8.1) (default)iojs -&gt; N/A (default)unstable -&gt; N/A (default)lts/* -&gt; lts/erbium (-&gt; N/A)lts/argon -&gt; v4.9.1 (-&gt; N/A)lts/boron -&gt; v6.17.1 (-&gt; N/A)lts/carbon -&gt; v8.16.2 (-&gt; N/A)lts/dubnium -&gt; v10.17.0 (-&gt; N/A)lts/erbium -&gt; v12.13.0 (-&gt; N/A)設定別名12$ nvm alias titan-test v10.15.3 * ?titan-test -&gt; v10.15.3接著用 nvm alias 指令就會看到剛剛新增的別名所對應的 Node.js 版本：12345678910111213$ nvm alias * ?titan-test -&gt; v10.15.3default -&gt; v10.16.3node -&gt; stable (-&gt; v12.8.1) (default)stable -&gt; 12.8 (-&gt; v12.8.1) (default)iojs -&gt; N/A (default)unstable -&gt; N/A (default)lts/* -&gt; lts/erbium (-&gt; N/A)lts/argon -&gt; v4.9.1 (-&gt; N/A)lts/boron -&gt; v6.17.1 (-&gt; N/A)lts/carbon -&gt; v8.16.2 (-&gt; N/A)lts/dubnium -&gt; v10.17.0 (-&gt; N/A)lts/erbium -&gt; v12.13.0 (-&gt; N/A)資料來源nvm-sh/nvm: Node Version Manager","categories":[{"name":"Web Dev","slug":"web-dev","permalink":"https://titangene.github.io/categories/web-dev/"}],"tags":[{"name":"CLI","slug":"cli","permalink":"https://titangene.github.io/tags/cli/"},{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Node.js","slug":"node-js","permalink":"https://titangene.github.io/tags/node-js/"},{"name":"version manager","slug":"version-manager","permalink":"https://titangene.github.io/tags/version-manager/"}],"author":"Titangene"},{"title":"淺入 Git：detached HEAD","slug":"git-detached-head","date":"2020-04-12T15:54:32.000Z","updated":"2020-04-12T15:55:04.000Z","comments":true,"path":"article/git-detached-head.html","link":"","permalink":"https://titangene.github.io/article/git-detached-head.html","excerpt":"在 Git 的世界中，想回到過去，也許你會用 git checkout 跳至某個過去的 commit，但 Git 會提醒你正在「detached HEAD」狀態。那 detached HEAD 是什麼？它能做什麼？要怎麼離開 detached HEAD 狀態？","text":"在 Git 的世界中，想回到過去，也許你會用 git checkout 跳至某個過去的 commit，但 Git 會提醒你正在「detached HEAD」狀態。那 detached HEAD 是什麼？它能做什麼？要怎麼離開 detached HEAD 狀態？前言在之前的 深入 Git：HEAD refs 有談到 HEAD 通常會指向當前分支，而當前分支通常會指向該分支頂端的 commit (也就是該分支最新的 commit)。不過再某些情況下，會發生 HEAD 不是指向分支，而是指向某個 commit，而這個狀態的 HEAD 就被稱為「detached HEAD」。下面會用以下 Git 歷史紀錄作為範例來說明 detached HEAD。本專案內有四個檔案，分別是 a、b、c 和 d，我為每個檔案分別建立了一個 commit：12345678$ lsa b c d$ git log --oneline --graph --decorate* 71e5770 (HEAD -&gt; master, origin/master) feat: d* c3a31ea feat: c* b757c26 feat: b* 3b7be17 feat: a路人甲發生的情境下面是路人甲發生的情境，讓我們來看這個情境發生了什麼？現在 HEAD 指向 master 分支，而 master 分支指向名為 e2f2a4 的 commit：12345678910$ git log --oneline --graph --decorate* 71e5770 (HEAD -&gt; master, origin/master) feat: d* c3a31ea feat: c* b757c26 feat: b* 3b7be17 feat: a$ cat .git/HEADref: refs/heads/master$ cat .git/refs/heads/master71e57702f208a7c463a2b5cd069ea47cdbed9eba路人甲可能想回到過去的 commit，於是使用了 git checkout &lt;commit&gt; 跳至指定的 commit，假設要 checkout 至名為 b757c26 的 commit 就會看到以下訊息：12345678910111213$ git checkout b757c26Note: checking out 'b757c26'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b &lt;new-branch-name&gt;HEAD is now at b757c26 feat: b假設路人甲很少注意看 Git 提供的訊息，所以忽略了「detached HEAD」的提醒訊息。路人甲只想確定自己是不是回到過去，於是執行 git log 來察看，的確看到 HEAD 指向 b757c26 這個 commit：123$ git log --oneline --graph --decorate* b757c26 (HEAD) feat: b* 3b7be17 feat: a所以心滿意足的開始基於 7e347a4 這個 commit 開始建立兩個新的 commit：12345678910111213$ echo \"test1\" &gt; test1$ git add test1$ git commit -m \"feat: test1\"[detached HEAD 3936d06] feat: test1 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 test1$ echo \"test2\" &gt; test2$ git add test2$ git commit -m \"feat: test2\"[detached HEAD 845992a] feat: test2 1 file changed, 1 insertion(+) create mode 100644 test2所以現在 git log 變成這樣：12345$ git log --oneline --graph --decorate* 845992a (HEAD) feat: test2* 9fd0924 feat: test1* b757c26 feat: b* 3b7be17 feat: a當路人甲建立完 commit 後，突然想回到之前的 master 分支，所以執行 git checkout master：1234567891011121314$ git checkout masterWarning: you are leaving 2 commits behind, not connected toany of your branches: 845992a feat: test2 9fd0924 feat: test1If you want to keep them by creating a new branch, this may be a good timeto do so with: git branch &lt;new-branch-name&gt; 845992aSwitched to branch 'master'Your branch is up to date with 'origin/master'.回到 master 分支後，路人甲看 git log 變成下面這樣馬上傻眼，心想：「剛剛的那兩個 commit 呢？怎麼不見了！怎麼辦啊！還找的回來嗎？」：12345$ git log --oneline --graph --decorate* 71e5770 (HEAD -&gt; master, origin/master) feat: d* c3a31ea feat: c* b757c26 feat: b* 3b7be17 feat: a好，看到這個故事，你應該會發現，其實 Git 一直不停的在輸出訊息提醒你：在 checkout 至某個 commit 時，會提醒你正在「detached HEAD」狀態在「detached HEAD」狀態建立 commit 時，會像這樣提醒你：[detached HEAD 845992a] feat: test2在「detached HEAD」狀態建立 commit 後，checkout 回分支時，會像這樣提醒你：Warning: you are leaving 2 commits behind所以看輸出訊息很重要！我曾經就是那個不看輸出訊息的路人甲 XD此狀態有何用那「detached HEAD」狀態到底能做什麼？如果在 detached HEAD 狀態時建立的 commit 是實驗性的，那的確可以直接 checkout 至任何分支，把那些 commit 都丟棄 (但 Git 不會馬上刪除，會自動等到 Git GC 來回收，所以還救的回來)，這代表你放棄了在 detached HEAD 狀態下所做的任何 commit，而且這些操作都不會影響任何分支。那如果是像路人甲的情境那樣，你想保留那些 commit，那可以在該 commit 上建立 ref，讓該 ref 指向該 commit，ref 可以是分支或 tag。建立 ref 有很多種方式，下面會介紹幾種處理的方式。資料來源Git - git-checkout DocumentationGit Branching - Remote Branches | Pro Git, 2/e","categories":[{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"深入 Git","slug":"深入-git","permalink":"https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"}],"author":"Titangene"},{"title":"深入 Git：Git 物件儲存 - tag 物件","slug":"git-tag-object","date":"2020-04-05T15:40:46.000Z","updated":"2020-04-05T17:12:26.000Z","comments":true,"path":"article/git-tag-object.html","link":"","permalink":"https://titangene.github.io/article/git-tag-object.html","excerpt":"本篇將深入探討 Git tag 是什麼？如何建立 tag？Git 是如何儲存 tag？與 commit 和分支的差別在哪？","text":"本篇將深入探討 Git tag 是什麼？如何建立 tag？Git 是如何儲存 tag？與 commit 和分支的差別在哪？Git tagGit tag 常用於標記某個版本號碼，例如：v0.5、v1.0.1、9.1.0-rc.2、v2.6.0-beta.3。在 Git 中有兩種類型的 tag：lightweight tag (輕量標籤) 和 annotated tag (註解標籤)。先介紹兩者的共通點：提供更 friendlier 的名稱的標記都會指向某個 Git 物件 (通常為 commit 物件，但也可以是其他物件，也就是 tree 物件、blob 物件，甚至是其他 tag 物件)只是 lightweight tag 是直接指向某 Git 物件而 annotated tag 則是透過 tag 物件，間接指向某 Git 物件不會改變 tag 所指向的物件 (除非用 git tag -f 替換現有 tag)接著會說明各自的特性、要如何建立 lightweight tag 和 annotated tag，以及在 Git 中是如何儲存這些 tag 的。下面會用以下 Git 歷史紀錄的範例來說明：1234$ git log --oneline --decorate32aa934 (HEAD -&gt; master) feat: c9b6d639 feat: bd835d6b feat: alightweight tag (輕量標籤)很像不會移動的分支，tag 只會指向一個特定的 Git 物件若只作為暫時的標籤，且不想保留額外資訊，可用 lightweight tag建立 lightweight tag建立 lightweight tag 時，不要指定 -a、-s 或 -m option (建立 annotated tag 時才會用到，後面會說明)：1$ git tag &lt;tagname&gt; [&lt;commit&gt; | &lt;object&gt;]例如：1$ git tag v1.0-lw也可以指定某個 commit：1$ git tag v0.2-lw 9b6d639察看 lightweight tag若要透過 git show 指令察看 lightweight tag，就不會看到該標籤的額外資訊，只會顯示標籤所在的 commit 資訊：1234567891011121314$ git show v1.0-lwcommit 32aa934a24212ef22cc373e7838c30618952003d (HEAD -&gt; master, tag: v1.0-lw)Author: titangene &lt;titangene.tw@gmail.com&gt;Date: Sun Apr 5 21:36:25 2020 +0800 feat: cdiff --git a/c b/cnew file mode 100644index 0000000..f2ad6c7--- /dev/null+++ b/c@@ -0,0 +1 @@+clightweight tag 存在哪？Git 將 lightweight tag 存在 .git/refs/tag 目錄內：123456$ tree .git/refs/tags/.git/refs/tags/├── v0.2-lw└── v1.0-lw0 directories, 2 filestag ref 的內容就是該 tag 指向的 commit 物件 (也就是該 commit SHA-1 值)：12$ cat .git/refs/tags/v1.0-lw32aa934a24212ef22cc373e7838c30618952003d使用 git cat-file 來確定此 SHA-1 值真的是 commit 物件：123456789$ git cat-file -t 32aa93commit$ git cat-file -p 32aa93tree 04a59185a0c5f4047e4fd3fa87b0c84e671b00eeparent 9b6d6398e5e020a76f9a0f8d620e676a1decc78aauthor titangene &lt;titangene.tw@gmail.com&gt; 1586093785 +0800committer titangene &lt;titangene.tw@gmail.com&gt; 1586093785 +0800feat: c使用底層指令建立 lightweight tag使用 git update-ref 底層指令建立 lightweight tag 的 ref：1$ git update-ref refs/tags/v0.1-lw d835d6bf85258f2fe93c582f60f3f148900e0d7f察看該 tag ref 的確是指向剛剛指定的 SHA-1 值：12$ cat .git/refs/tags/v0.1-lw d835d6bf85258f2fe93c582f60f3f148900e0d7fannotated tag (註解標籤)會在 Git 的資料庫中儲存成完整的物件。它們將被計算校驗碼 (checksummed)包含：建立標籤的人 (tagger) 的名字、電子郵件和建立日期紀錄一個標籤訊息 (tagging message)指標 (也就是 Git 物件)可以簽名 (signed) 及透過 GNU Privacy Guard (GPG) 驗證若想紀錄與 tag 有關的資訊 (例如：建立 tag 的人、時間)，建議使用 annotated tag建立 annotated tag建立 annotated tag 時，可同時指定以下 option：-a，--annotate：製作一個 unsigned、annotated tag 物件 (未簽名且帶有註解的標籤物件)-m &lt;msg&gt;，--message=&lt;msg&gt;：指定標籤訊息，此訊息會和此標籤一起儲存若你沒有為標籤指定訊息，Git 就會開啟編輯器讓你輸入 (很像 git commit 沒有加上 -m option 那樣)若加上多組 -m option，會將這些值串聯成段落如果使用 -m option 但沒有加上 -a、-s 或 -u &lt;keyid&gt;，則代表是 -a (也就是建立 annotated tag)1$ git tag -a &lt;tagname&gt; -m &lt;msg&gt; [&lt;commit&gt; | &lt;object&gt;]例如：1$ git tag -a v1.0 -m \"version 1.0\"也可以指定某個 commit：1$ git tag -a v0.1 -m \"version 0.1\" d835d6b察看 annotated tag 資訊使用 git show 指令可查看標籤資訊，以及此標籤所標記的 commit 資訊：1234567891011121314151617181920$ git show v0.1tag v0.1Tagger: titangene &lt;titangene.tw@gmail.com&gt;Date: Sun Apr 5 21:39:01 2020 +0800version 0.1commit d835d6bf85258f2fe93c582f60f3f148900e0d7f (tag: v0.1)Author: titangene &lt;titangene.tw@gmail.com&gt;Date: Sun Apr 5 21:36:18 2020 +0800 feat: adiff --git a/a b/anew file mode 100644index 0000000..7898192--- /dev/null+++ b/a@@ -0,0 +1 @@+a以上面標籤資訊為例，包含：標籤名稱：v0.1建立標籤的人 (tagger) 的名字、電子郵件：Tagger: titangene &lt;titangene.tw@gmail.com&gt;標籤建立日期：Date: Sun Apr 5 21:39:01 2020 +0800標籤訊息：version 0.1指標：在 git show 沒有提供，下面會提到annotated tag 存在哪？Git 也將 annotated tag 存在 .git/refs/tag 目錄內：123456789$ tree .git/refs/tags/.git/refs/tags/├── v0.1├── v0.1-lw├── v0.2-lw├── v1.0└── v1.0-lw0 directories, 5 filestag ref 的內容就是該 tag 指向的 commit 物件 (也就是該 commit SHA-1 值)：12$ cat .git/refs/tags/v0.1530097c078c2fa4c16a532443170a40179599a69使用 git cat-file 來確定此 SHA-1 值時，會發現跟剛剛介紹的 lightweight tag 不一樣，lightweight tag 會直接指向 commit 物件，而 annotated tag 則是指向 tag 物件：123456789$ git cat-file -t 530097tag$ git cat-file -p 530097object d835d6bf85258f2fe93c582f60f3f148900e0d7ftype committag v0.1tagger titangene &lt;titangene.tw@gmail.com&gt; 1586093941 +0800version 0.1而這個 tag 物件才是真正指向 commit 物件的 ref。再次使用 git cat-file 指令，就能確定 tag 物件的確是指向 d835d6 這個 commit 物件：12345678$ git cat-file -t d835d6commit$ git cat-file -p d835d6tree aaff74984cccd156a469afa7d9ab10e4777beb24author titangene &lt;titangene.tw@gmail.com&gt; 1586093778 +0800committer titangene &lt;titangene.tw@gmail.com&gt; 1586093778 +0800feat: a使用底層指令建立 annotated tag建立 annotated tag 主要有兩個步驟：建立 tag 物件建立 tag ref，此 tag ref 會指向剛剛建立的 tag 物件我之前在 深入 Git：Git 物件儲存 - blob 物件 這篇有提到建立 Git 物件的底層指令 git hash-object，以及這個底層指令的原理。但是在使用 git hash-object 之前，必須要先準備好這個指令上的 --stdin option 要從 stdin (standard input，標準輸入) 讀取的內容，內容格式如下：123456object &lt;object-sha1&gt;type &lt;object-type&gt;tag &lt;tag-name&gt;tagger &lt;tagger-name&gt; &lt;&lt;tagger-email&gt;&gt; &lt;timestamp&gt;&lt;tag-message&gt;內容範例如下 (我先隨意將以下內容儲存在一個檔案內，任意檔名都可以，因為重點是檔案的內容)：12345678$ vim my-tag.txt$ cat my-tag.txtobject 61780798228d17af2d34fce4cfbdf35556832472type blobtag file-btagger titangene &lt;titangene.tw@gmail.com&gt; 1586097930 +0800file b因為這次要建立的是 tag 物件，所以需要在 git hash-object 指令上加上 -t option，並且指定 tag，代表要建立 tag 物件：12$ git hash-object -t tag -w --stdin &lt; my-tag.txt8785f7a44e2af5628544ecb0aa9dccf2adfa37ff這邊輸出的 8785f7 就是剛剛建立的 tag 物件的 SHA-1 值，我們用 git cat-file 來驗證一下：123456789$ git cat-file -t 8785f7tag$ git cat-file -p 8785f7object 61780798228d17af2d34fce4cfbdf35556832472type blobtag file-btagger titangene &lt;titangene.tw@gmail.com&gt; 1586097930 +0800file b接著處理第二步驟，使用 git update-ref 底層指令建立 annotated tag 的 ref：1$ git update-ref refs/tags/file-b 8785f7a44e2af5628544ecb0aa9dccf2adfa37ff察看該 tag ref 的確是指向剛剛指定的 SHA-1 值 (在這邊就是 tag 物件)：12$ cat .git/refs/tags/file-b 8785f7a44e2af5628544ecb0aa9dccf2adfa37ff在 git log 察看 tag使用 git log 察看剛剛建立的 tag 都貼上哪個 commit 上面 (也就是那些 tag 都指向哪個 commit)：1234$ git log --oneline --decorate32aa934 (HEAD -&gt; master, tag: v1.0-lw, tag: v1.0) feat: c9b6d639 (tag: v0.2-lw) feat: bd835d6b (tag: v0.1-lw, tag: v0.1) feat: a另外提一下 (雖然上面有介紹到)，不管是 lightweight tag 還是 annotated tag，如果是指向 commit 物件之外的其他 Git 物件 (也就是 blob 物件或 tree 物件，甚至是其他 tag 物件)，都無法在 git log 的輸出察看，只能透過 git show 或是透過 cat 和 git cat-file 指令來察看該 tag 是指向哪個 Git 物件。下面以 annotated tag 為例，透過這些指令來找到名為 file-b 的 tag 指向 SHA-1 值為 8785f7 的 tag 物件，而該 tag 物件是指向 SHA-1 值為 617807 的 blob 物件：1234567891011121314$ git tag -a file-c -m \"file c\" f2ad6c$ cat .git/refs/tags/file-cfebbaa9a5276f0321d72232c4bc3aa561bfc38c5$ git cat-file -t febbaatag$ git cat-file -p febbaaobject f2ad6c76f0115a6ba5b00456a849810e7ec0af20type blobtag file-ctagger titangene &lt;titangene.tw@gmail.com&gt; 1586100520 +0800file c察看所有 tag執行 git tag 指令可以察看所有建立的 tag：12345678$ git tagfile-bfile-cv0.1v0.1-lwv0.2-lwv1.0v1.0-lwcommit vs tagcommit 物件紀錄的指標只能是 tree 物件，不能是其他 Git 物件tag 物件通常紀錄的指標是 commit 物件，當然也可以是其他 Git 物件，包括 tree 物件、blob 物件，甚至是其他 tag 物件分支 vs tag那分支和 tag 都可以指向 commit 物件，那他們有何差別？分支：在提交新的 commit 時，會將分支指向該分支的末端，也就是新的 commit 物件lightweight tag 和 annotated tag 這兩種 tag 都是永遠不會改變 tag 所指向的物件，只是提供更 friendlier 的名稱的標記而已lightweight tag：很像不會移動的分支，此 tag ref 只會指向一個特定的 Git 物件annotated tag：此 tag ref 會指向 tag 物件，而 tag 物件會指向一個特定的 Git 物件資料來源：Git Internals - Git References | Pro Git, 2/eGit 基礎 - 標籤 | Pro Git, 2/ehash - What is the format of a git tag object and how to calculate its SHA? - Stack Overflow","categories":[{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"深入 Git","slug":"深入-git","permalink":"https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"}],"author":"Titangene"},{"title":"深入 Git：HEAD refs","slug":"git-head-ref","date":"2020-03-29T15:55:33.000Z","updated":"2020-03-29T15:57:32.000Z","comments":true,"path":"article/git-head-ref.html","link":"","permalink":"https://titangene.github.io/article/git-head-ref.html","excerpt":"本篇將深入探討 Git HEAD 是什麼？儲存在 repo 的哪裡？以及跟 git branch 和 git checkout 之間的關係。","text":"本篇將深入探討 Git HEAD 是什麼？儲存在 repo 的哪裡？以及跟 git branch 和 git checkout 之間的關係。上次提到的 Git 分支 ref，可用來紀錄不同的工作過程，例如最常見的 master 和 develop 分支，master 分支通常用來紀錄發佈的版本，而 develop 分支通常用來紀錄正在開發的版本。那 Git 是如何知道你正在哪一個分支？其實是透過 HEAD 檔案來紀錄的。這個檔案通常會放在 .git 路徑底下。通常 HEAD 檔案是對當前所在分支的 symbolic reference [1]，也就是紀錄你正在哪一個分支的檔案：12$ cat .git/HEADref: refs/heads/master如果執行 git checkout 來切換分支，Git 就會更新 HEAD 檔案：1234$ git checkoutSwitched to branch 'test'$ cat .git/HEADref: refs/heads/test在執行 git commit 時，為何當前所在的分支會一直指向最新的 commit？這是因為 HEAD 會指向當前分支，而當前分支會指向該分支的末端，也就是說，當執行 git commit 時，Git 會建立新的 commit 物件，而分支會被更新成指向該分支的末端 (也就是新的 commit 物件)。通常 HEAD 會指向當前分支，若 HEAD 檔案的內容為 Git 物件的 SHA-1 值時，則代表 detached HEAD 狀態。這種情況會在你使用 git checkout 切換至 tag、commit 或遠端分支時發生。在此狀態下，沒有分支會與 working tree 關聯。12345678910111213$ git checkout 665439e Note: checking out '665439e'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b &lt;new-branch-name&gt;HEAD is now at 665439e feat: a手動編輯 HEAD 檔案模擬 checkout 分支我們來手動編輯此 HEAD 檔案，驗證改變 HEAD 檔案的內容就等同於在 git checkout 至某個分支。假設目前正在 test 分支，然後將 HEAD 檔案的內容從 ref: refs/heads/test 變成 ref: refs/heads/master：12345678$ git branch* test master$ cat .git/HEADref: refs/heads/test$ echo \"ref: refs/heads/master\" &gt; .git/HEAD然後用 git branch 就能驗證現在已經「checkout」至 master 分支：123$ git branch test* master使用 symbolic-ref 底層指令雖然剛剛有提到可以手動編輯 HEAD 檔案，但建議使用 Git 提供的底層指令 git symbolic-ref 來編輯和讀取 HEAD 檔案：讀取 HEAD 檔案 (察看當前所在分支)：12$ git symbolic-ref HEADrefs/heads/master加上 --short option 會只顯示分支名稱，不會顯示分支 ref 的路徑：12$ git symbolic-ref HEAD --shortmaster設定 HEAD 檔案 (等同於 git checkout &lt;branch&gt; )：123$ git symbolic-ref HEAD refs/heads/test$ cat .git/HEADref: refs/heads/test一定要用 refs/ 為開頭的 ref 才能設定 HEAD 檔案，要不然會報錯：12$ git symbolic-ref HEAD testfatal: Refusing to point HEAD outside of refs/資料來源：Git Internals - Git References | Pro Git, 2/eGit - gitglossary Documentation ↩︎","categories":[{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"深入 Git","slug":"深入-git","permalink":"https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"}],"author":"Titangene"},{"title":"深入 Git：分支 refs","slug":"git-branch-ref","date":"2020-03-22T10:49:50.000Z","updated":"2020-03-29T14:33:30.000Z","comments":true,"path":"article/git-branch-ref.html","link":"","permalink":"https://titangene.github.io/article/git-branch-ref.html","excerpt":"本篇將深入探討 Git 分支到底是什麼？建立分支時到底建立了什麼？如何紀錄分支要指向哪個 commit？","text":"本篇將深入探討 Git 分支到底是什麼？建立分支時到底建立了什麼？如何紀錄分支要指向哪個 commit？Git 參考 (references 或 refs) 都存在 .git/refs 目錄內，目錄結構如下：123456$ tree .git/refs/.git/refs/├── heads└── tags2 directories, 0 files因為「深入 Git」此文章系列都是探討如何用 Git 的底層指令來模擬 Git 高階指令的操作。在之前建立 blob、tree 和 commit 物件時，都還沒建立 Git refs，所以 .git/refs 目錄內的資料夾中，才沒有其他紀錄指標的檔案。若用平常使用的高階指令就會幫你建立很多 Git refs，目錄可能像下面這樣：123456789101112131415$ tree .git/refs/.git/refs/├── heads│ ├── develop│ └── master├── original│ └── refs│ └── heads│ └── master├── remotes│ └── origin│ ├── develop│ └── master└── tags └── v1.0那我們就開始試著利用底層指令來手動建立 Git refs 吧！建立分支 ref若沒有 Git refs，就要像這樣指定 commit 的 SHA-1 值才能看到歷史紀錄：123$ git log --oneline --decorate 200c91200c91c second commit9079eb3 first commit若有一個指標指向該 commit 的 SHA-1 值就不用再記住了，省很多麻煩。而 master 就是最常見的指標，要建立分支的指標其實很簡單，只要在 .git/refs/heads 目錄內，建立該分支名稱的檔案，而檔案內容就是你要指定的 commit SHA-1 值，例如：我要將 master 分支指向 200c91 這個 commit 上，可執行以下指令建立分支 ref：1$ echo 200c91c4acb82e529fb8205ea786a17cc10008b6 &gt; .git/refs/heads/master建立分支後，就可以使用剛剛建立的 head ref (分支頂端的 commit 的 named reference，通常儲存在 .git/refs/heads 目錄中) [1] 來察看歷史紀錄：123$ git log --oneline --decorate master200c91c (HEAD -&gt; master) second commit9079eb3 first commit不過，不建議你自己編輯 ref 檔案。Git 提供 git update-ref 這個底層指令可讓你更新 ref (可不用輸入完整的 commit SHA-1 值，因為 Git 會自動找到對應的 Git 物件)：1$ git update-ref refs/heads/master 200c91剛剛建立的 head ref 就是分支。分支只是一個指標 (不是像樹的分岔樹枝)，用來紀錄正在開發的分支的最新 commit (或 head) 的 SHA-1 值：12$ cat .git/refs/heads/master200c91c4acb82e529fb8205ea786a17cc10008b6要察看此 repo 有哪些 Git ref，可用 Git 提供的 git show-ref 這個底層指令來察看：12$ git show-ref200c91c4acb82e529fb8205ea786a17cc10008b6 refs/heads/master所以你在執行 git branch &lt;branch&gt; 指令時，Git 基本上會執行 git update-ref 指令，將你當前所在分支的最後一個 commit 的 SHA-1 新增至你想建立的新 reference (也就是分支 ref)。資料來源：Git - Git References | Pro Git, 2/eGit - gitglossary Documentation ↩︎","categories":[{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"深入 Git","slug":"深入-git","permalink":"https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"}],"author":"Titangene"},{"title":"深入 Git：Git 物件儲存 - commit 物件","slug":"git-commit-object","date":"2020-03-15T15:58:26.000Z","updated":"2020-03-22T15:51:58.000Z","comments":true,"path":"article/git-commit-object.html","link":"","permalink":"https://titangene.github.io/article/git-commit-object.html","excerpt":"本篇將深入探討 Git 如何運作，在執行 git commit 時，Git 會如何建立和儲存 commit 物件。","text":"本篇將深入探討 Git 如何運作，在執行 git commit 時，Git 會如何建立和儲存 commit 物件。tree 物件會指向追蹤專案的不同 snapshot，若要取得這些 snapshot 就會遇到一些問題：必須記得這些 tree 物件的 SHA-1 值 (麻煩)snapshot 是誰儲存的snapshot 是何時儲存的為何要儲存 snapshot以上這些就是 commit 物件為你儲存的資訊。準備下面會以這個檔案結構為範例：1234567891011121314151617$ mkdir demo$ cd demo$ git initInitialized empty Git repository in /home/titan/project/demo/.git/$ mkdir styles$ echo \"index\" &gt; index.html$ echo \"# README\" &gt; README.md$ echo \"/* style */\" &gt; styles/main.css$ tree .├── index.html├── README.md└── styles └── main.css1 directories, 3 files將第一個檔案加入 index，並建立 tree 物件先將 index.html 加入 index，接著將 index 寫至 tree 物件中：12345$ cat index.htmlindex$ git add index.html$ git write-tree2dce93ea08ed9059be0a838c6bcf62b7b5c28907註：git add 看起來只是將檔案加入 index，但在 Git 的運作原理其實做了很多步驟，詳情可參閱我之前寫的這幾篇，本篇就不再重複說明這些內容：深入 Git：Git 物件儲存 - blob 物件深入 Git：Git 物件儲存 - tree 物件深入 Git：index 檔案此時在 .git/object 目錄內，已經有兩個 Git 物件，分別為：9015a7 blob 物件：透過 index.html 此檔案產生的2dce93 tree 物件：對應到專案根目錄1234567891011121314151617181920$ tree .git/objects.git/objects├── 2d│ └── ce93ea08ed9059be0a838c6bcf62b7b5c28907├── 90│ └── 15a7a32ca0681be64471d3ac2f8c1f24c1040d├── info└── pack4 directories, 2 files$ git cat-file -t 9015a7blob$ git cat-file -p 9015a7 index$ git cat-file -t 2dce93tree$ git cat-file -p 2dce93100644 blob 9015a7a32ca0681be64471d3ac2f8c1f24c1040d index.html建立第一個 commit 物件要建立 commit 物件需使用 git commit-tree 指令，指定一個 tree 物件的 SHA-1 值以及前一個 commit 物件 (第一個 commit 不需要)。下面使用剛剛建立的 2dce93 的 tree 物件來建立 commit 物件，並且提供 commit 訊息：12$ echo 'first commit' | git commit-tree 2dce939079eb3c74f72f1409dc47ef5d7c8763dbd128f6commit 物件會根據建立的時間和作者的資訊而建立不同的 SHA-1 值。使用 git cat-file 指令察看剛剛建立的 commit 物件：12345678$ git cat-file -t 9079ebcommit$ git cat-file -p 9079ebtree 2dce93ea08ed9059be0a838c6bcf62b7b5c28907author titangene &lt;titangene.tw@gmail.com&gt; 1584281436 +0800committer titangene &lt;titangene.tw@gmail.com&gt; 1584281436 +0800first commitcommit 物件的格式包含以下內容：專案 snapshot 的頂層 tree：也就是專案根目錄對應的 tree 物件author/committer 訊息：使用 user.name 和 user.email 的配置和 timestampauthor 就是編輯檔案內容的人committer 就是 commit 的人通常 author 和 committer 會是同一個人若透過 email 來發送 patch，就可能發生 author 和 committer 是不同人 [1] [2]一個空行 (blank line)commit 訊息將另外兩個檔案加入 index，並建立 tree 物件接著將 README.md 和 styles/main.css 加入 index，接著再將 index 寫至 tree 物件中：12345678910$ cat README.md# README$ git add README.md$ cat styles/main.css/* style */$ git add styles/main.css$ git write-tree563b8123edfdfd28aeb8bd6cde392a4be9adba2d此時在 .git/object 目錄內，多了 4 個 Git 物件，分別為：7e5960 blob 物件：透過 README.md 此檔案產生的202479 blob 物件：透過 styles/main.css 此檔案產生的0bb8d2 tree 物件：對應到 styles 目錄563b81 tree 物件：對應到專案根目錄1234567891011121314151617181920212223242526272829303132333435363738394041$ tree .git/objects.git/objects├── 0b│ └── b8d2a25db76aec1c38bc948ba579959d443790├── 20│ └── 2479c888bf25f40895164be873c63f556a1b76├── 2d│ └── ce93ea08ed9059be0a838c6bcf62b7b5c28907├── 56│ └── 3b8123edfdfd28aeb8bd6cde392a4be9adba2d├── 7e│ └── 59600739c96546163833214c36459e324bad0a├── 90│ ├── 15a7a32ca0681be64471d3ac2f8c1f24c1040d│ └── 79eb3c74f72f1409dc47ef5d7c8763dbd128f6├── info└── pack8 directories, 7 files$ git cat-file -t 7e5960blob$ git cat-file -p 7e5960# README$ git cat-file -t 202479blob$ git cat-file -p 202479/* style */$ git cat-file -t 0bb8d2tree$ git cat-file -p 0bb8d2100644 blob 202479c888bf25f40895164be873c63f556a1b76 main.css$ git cat-file -t 563b81tree$ git cat-file -p 563b81100644 blob 7e59600739c96546163833214c36459e324bad0a README.md100644 blob 9015a7a32ca0681be64471d3ac2f8c1f24c1040d index.html040000 tree 0bb8d2a25db76aec1c38bc948ba579959d443790 styles建立第二個 commit 物件接著使用剛剛建立的 563b81 的 tree 物件來建立第二個 commit，並且提供 commit 訊息和指定前一個 commit (也就是 parent commit)：-p &lt;parent&gt;：指定 parent commit 的 ID，在此範例是第一個 commit 物件的 SHA-1 值12$ echo 'second commit' | git commit-tree 563b81 -p 9079eb200c91c4acb82e529fb8205ea786a17cc10008b6123456789$ git cat-file -t 200c91commit$ git cat-file -p 200c91tree 563b8123edfdfd28aeb8bd6cde392a4be9adba2dparent 9079eb3c74f72f1409dc47ef5d7c8763dbd128f6author titangene &lt;titangene.tw@gmail.com&gt; 1584285257 +0800committer titangene &lt;titangene.tw@gmail.com&gt; 1584285257 +0800second commit編輯檔案後加入 index，並建立 tree 物件接著編輯 index.html 後，將變更加入 index，接著再將 index 寫至 tree 物件中：1234567$ cat index.htmlindex$ echo 'index v2' &gt; index.html$ git add index.html$ git write-treebdaf4c7dc919738d7d59a27ef2ef3d5ff3107ae6此時在 .git/object 目錄內，多了 2 個 Git 物件，分別為：b2e53d blob 物件：透過 index.html 此檔案產生的bdaf4c tree 物件：對應到專案根目錄1234567891011$ git cat-file -t b2e53dblob$ git cat-file -p b2e53dindex v2$ git cat-file -t bdaf4ctree$ git cat-file -p bdaf4c100644 blob 7e59600739c96546163833214c36459e324bad0a README.md100644 blob b2e53d55f22bdb2eafcdfaff9b1b37829309ae50 index.html040000 tree 0bb8d2a25db76aec1c38bc948ba579959d443790 styles建立第三個 commit 物件接著使用剛剛建立的 bdaf4c 的 tree 物件來建立第三個 commit，並且提供 commit 訊息和指定前一個 commit (也就是 parent commit)：-p &lt;parent&gt;：指定 parent commit 的 ID，在此範例是第一個 commit 物件的 SHA-1 值12$ echo 'third commit' | git commit-tree bdaf4c -p 200c9164fd0be6f2b66bc48d26c7c77cab62fab1477072123456789$ git cat-file -t 64fd0bcommit$ git cat-file -p 64fd0btree bdaf4c7dc919738d7d59a27ef2ef3d5ff3107ae6parent 200c91c4acb82e529fb8205ea786a17cc10008b6author titangene &lt;titangene.tw@gmail.com&gt; 1584892171 +0800committer titangene &lt;titangene.tw@gmail.com&gt; 1584892171 +0800third commit察看歷史紀錄不過到目前為止，都還無法透過 git log 指令來察看剛剛建立的 commit 歷史紀錄，這是因為我們從一開始就是使用底層指令 (plumbing 指令) 來模擬平常我們在用的指令 (porcelain 指令)，而在過程中都沒有建立 master 分支：12$ git logfatal: your current branch 'master' does not have any commits yet但我們可在 git log 指令上，另外指定最後一個建立的 commit 物件，這樣就能看到剛剛建立的 Git 歷史紀錄了：--stat：顯示每個 commit 的 diff 資訊 (diffstat)12345678910111213141516171819202122232425262728$ git log --stat 64fd0bcommit 64fd0be6f2b66bc48d26c7c77cab62fab1477072Author: titangene &lt;titangene.tw@gmail.com&gt;Date: Sun Mar 22 23:49:31 2020 +0800 third commit index.html | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)commit 200c91c4acb82e529fb8205ea786a17cc10008b6 (HEAD -&gt; master)Author: titangene &lt;titangene.tw@gmail.com&gt;Date: Sun Mar 15 23:14:17 2020 +0800 second commit README.md | 1 + styles/main.css | 1 + 2 files changed, 2 insertions(+)commit 9079eb3c74f72f1409dc47ef5d7c8763dbd128f6Author: titangene &lt;titangene.tw@gmail.com&gt;Date: Sun Mar 15 22:10:36 2020 +0800 first commit index.html | 1 + 1 file changed, 1 insertion(+)Git 物件關聯圖以上這些就是 Git 在執行 git add 和 git commit 指令時所做的事情：儲存已變更檔案的 blob 物件更新 index利用 index 建立 tree 物件建立指向頂層 tree 和 parent commit 的 commit 物件這些物件都存在 .git/objects 目錄內。123456789$ find .git/objects -type f.git/objects/2d/ce93ea08ed9059be0a838c6bcf62b7b5c28907 # Tree: ./ dir v1.git/objects/20/0c91c4acb82e529fb8205ea786a17cc10008b6 # Commit: second commit.git/objects/20/2479c888bf25f40895164be873c63f556a1b76 # Blob: main.css.git/objects/7e/59600739c96546163833214c36459e324bad0a # Blob: README.md.git/objects/0b/b8d2a25db76aec1c38bc948ba579959d443790 # Tree: styles dir.git/objects/90/79eb3c74f72f1409dc47ef5d7c8763dbd128f6 # Commit: first commit.git/objects/90/15a7a32ca0681be64471d3ac2f8c1f24c1040d # Blob: index.html.git/objects/56/3b8123edfdfd28aeb8bd6cde392a4be9adba2d # Tree: ./ dir v2下圖是這些 Git 物件的關聯圖：雖然看起來很像目錄和子目錄的關係，但在 Git 中是沒有層級關係的，commit 物件形成有向無環圖 (directed acyclic graph，DAG)，commit 物件有 parent commit (有向)，並且 commit 物件的圖是無環的 (從開始到結束不會是同一個物件) [3]。資料來源：10.2 Git Internals - Git Objects | Pro Git, 2/eGit - Viewing the Commit History ↩︎Git - Maintaining a Project ↩︎Git - gitglossary Documentation ↩︎","categories":[{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"深入 Git","slug":"深入-git","permalink":"https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"}],"author":"Titangene"},{"title":"深入 Git：index 檔案","slug":"git-index","date":"2020-03-08T15:56:40.000Z","updated":"2020-03-08T18:41:13.000Z","comments":true,"path":"article/git-index.html","link":"","permalink":"https://titangene.github.io/article/git-index.html","excerpt":"git add 會將檔案加入 index，究竟 index 到底存在哪？其實，通常會放在 .git/index，本篇將深入探討此檔案式如何紀錄有哪些檔案被加入 index。","text":"git add 會將檔案加入 index，究竟 index 到底存在哪？其實，通常會放在 .git/index，本篇將深入探討此檔案式如何紀錄有哪些檔案被加入 index。index 是一個二進位檔案，通常放在 .git/index，其中包含路徑名稱的排序列表、每個路徑名稱的權限和 blob 物件的 SHA-1 值。而 git ls-files 指令可顯示 index 的內容。透過 git ls-files 來認識 index使用 git ls-files 底層指令來察看 index 檔案，但指令預設只會顯示有哪些檔名，所以加上一些選項：-c，--cached：預設選項，只在輸出顯示已暫存的檔案-s，--stage：在輸出中顯示 stage 內容的 mode bit、物件名稱和 stage number12$ git ls-files -s100644 9015a7a32ca0681be64471d3ac2f8c1f24c1040d 0 index.html從上面輸出可得知：index.html 的 file mode bits 為 100644，代表是 regular non-executable fileindex.html 的 blob 物件名稱為 9015a7...stage number 在合併衝突處理時會用到檔案名稱file mode bits (6 位數) 是檔案權限的八進位表示法，也可以是以二進位的方式讀取。這邊的 100644 ( 0b1000000110100100 ) 代表檔案是 regular non-executable file，檔案擁有者可以讀寫，檔案群組中的其他使用者可以讀取，而其他使用者也可以讀取。這類似 Unix 的檔案屬性 [1]，用來表示該檔案的類型 (檔案、目錄、link) 和權限 (可讀、可寫、可執行)，以下是常見的 (用二進位和八進位表示) [2] [3]：0100000000000000 ( 040000 )：Directory1000000110100100 ( 100644 )：Regular non-executable file1000000110110100 ( 100664 )：Regular non-executable group-writeable file1000000111101101 ( 100755 )：Regular executable file1010000000000000 ( 120000 )：Symbolic link1110000000000000 ( 160000 )：Gitlink註：二進位表示法 [4]前 4-bit：物件 type1000：regular file1010：symbolic link1110：gitlink中間 3-bit：沒有使用後面 9-bit：unix 權限regular file 只能用 0755 和 0644symbolic link 和 gitlink 在此 field 中的值為 0blob 物件只對 100644、100664 和 100755 這三種 mode 有效。在 git add 指令期間沒有真正使用不同的 stage number，用於處理合併衝突：0：normal，無衝突，一切正常1：base，共同 ancestor 版本2：ours，目標 ( HEAD ) 版本3：theris，被合併的版本.git/index 內部對 Git index 檔案 .git/index 進行位元轉儲 (bits dump)：1234567891011121314151617181920212223242526272829$ xxd -b -c 4 .git/index00000000: 01000100 01001001 01010010 01000011 DIRC00000004: 00000000 00000000 00000000 00000010 ....00000008: 00000000 00000000 00000000 00000001 ....0000000c: 01011110 01011011 11000111 10010001 ^[..00000010: 00101111 00001011 00100011 00101010 /.#*00000014: 01011110 01011011 11000111 10010001 ^[..00000018: 00100111 00101111 10101000 11100000 '/..0000001c: 00000000 00000000 00001000 00000100 ....00000020: 00000000 10111000 00001101 01001111 ...O00000024: 00000000 00000000 10000001 10100100 ....00000028: 00000000 00000000 00000011 11101000 ....0000002c: 00000000 00000000 00000011 11101000 ....00000030: 00000000 00000000 00000000 00001011 ....00000034: 10111011 11011110 11111001 00101010 ...*00000038: 11101111 00001111 11101100 11111000 ....0000003c: 00100111 00000100 01110000 10100110 '.p.00000040: 00011111 11101000 10010101 00101010 ...*00000044: 01101010 11111101 01011011 10011010 j.[.00000048: 00000000 00001010 01101001 01101110 ..in0000004c: 01100100 01100101 01111000 00101110 dex.00000050: 01101000 01110100 01101101 01101100 html00000054: 00000000 00000000 00000000 00000000 ....00000058: 00000000 00000000 00000000 00000000 ....0000005c: 00101000 01000001 00101101 00100001 (A-!00000060: 00011010 10000111 01011011 00010011 ..[.00000064: 01101111 01010010 10010111 01110010 oR.r00000068: 11001010 01001100 01110011 11110011 .Ls.0000006c: 10110011 11001100 00110011 00001000 ..3.或以十六進位轉儲 (hex dump) 版本：12345678$ xxd .git/index 00000000: 4449 5243 0000 0002 0000 0001 5e5b c791 DIRC........^[..00000010: 2f0b 232a 5e5b c791 272f a8e0 0000 0804 /.#*^[..'/......00000020: 00b8 0d4f 0000 81a4 0000 03e8 0000 03e8 ...O............00000030: 0000 000b bbde f92a ef0f ecf8 2704 70a6 .......*....'.p.00000040: 1fe8 952a 6afd 5b9a 000a 696e 6465 782e ...*j.[...index.00000050: 6874 6d6c 0000 0000 0000 0000 2841 2d21 html........(A-!00000060: 1a87 5b13 6f52 9772 ca4c 73f3 b3cc 3308 ..[.oR.r.Ls...3.index 檔案包含以下資訊：12-byte header多個排序的 index entriesExtensions，它們通過簽名 (signature) 來識別此 checksum 和之前的 index 檔案內容的 160-bit SHA-1Headerindex 以 12-byte 的 header 開頭：1hex: 4449 5243 0000 0002 0000 0001由代表 “DirCache” 的 4-btye 簽名 “DIRC” ( 0x44495243 ) 組成4-byte 是 Git index 格式的當前版本號 “2” ( 0x00000002 )32-bit 的 index entries “1” ( 0x00000001 )Index Entry在 index.html 此 index entry 中包括：64-bit ctimectime 是 change time，也就是檔案的 metadata 在最後修改的時間前面 32-bit：ctime seconds後面 32-bit：ctime nanosecond fractions1hex: 5e5b c791 2f0b 232a可用 stat 指令來取得 index.html 的最後修改時間：12$ stat -c 'ctime: %z (%Z)' index.htmlctime: 2020-03-01 22:32:49.789259050 +0800 (1583073169)然後用下面指令驗證：1234$ printf '%x' 15830731695e5bc791%$ printf '%x' 7892590502f0b232a%64-bit mtimemtime 是 modify time，也就是檔案的資料在最後修改的時間前面 32-bit：mtime seconds後面 32-bit：mtime nanosecond fractions1hex: 5e5b c791 272f a8e0可用 stat 指令來取得 index.html 的最後修改時間：12$ stat -c 'mtime: %y (%Y)' index.htmlmtime: 2020-03-01 22:32:49.657434848 +0800 (1583073169)然後用下面指令驗證：1234$ printf '%x' 15830731695e5bc791%$ printf '%x' 657434848272fa8e0%32-bit dev檔案所在的裝置：1hex: 0000 0804可用 stat 指令來取得 index.html 檔案所在的裝置：12$ stat -c '%D' index.html80432-bit ino檔案 inode number：1hex: 00b8 0d4f可用 stat 指令來取得 index.html 檔案所在的裝置：12$ stat -c '%i' index.html12062031然後用下面指令驗證：12$ printf '%x' 12062031b80d4f%32-bit mode檔案權限以十六進位表示12hex: 0000 81a4bin: 00000000 00000000 10000001 10100100可用 stat 指令來取得 index.html 檔案的權限：12$ stat -c '%f' index.html81a432-bit uid當前使用者的 user identifier1hex: 0000 03e8可用 stat 指令來取得 index.html 檔案的 uid：12$ stat -c '%u' index.html1000然後用下面指令驗證：12$ printf '%x' 10003e8%32-bit gid當前使用者的 group identifier1hex: 0000 03e8可用 stat 指令來取得 index.html 檔案的 gid：12$ stat -c '%g' index.html1000然後用下面指令驗證：12$ printf '%x' 10003e8%32-bit file size檔案大小1hex: 0000 000b可用 stat 指令來取得 index.html 檔案的大小：12$ stat -c '%s' index.html11然後用下面指令驗證：12$ printf '%x' 11b%160-bit SHA-1 Object ID12hex: bbde f92a ef0f ecf8 2704 70a6 1fe8 952a 6afd 5b9a可用 git hash-object 指令來取得 index.html 檔案的 blob 物件 ID：12$ git hash-object index.htmlbbdef92aef0fecf8270470a61fe8952a6afd5b9a16-bit ‘flags’ field1hex: 000a分為：1-bit：assume-valid flag1-bit：extended flag (在版本 2 中必須為零)2-bit：stage (合併期間)如果 length 小於 0xFFF，則為 12-bit name length；否則，將 0xFFF 儲存在此 field 中16-bit field(版本 3 或更新版) 當前面的 16-bit field 的 “extended flag” 為 1 時適用1-bit：為未來保留1-bit：skip-worktree flag (用於 sparse checkout)1-bit：intent-to-add flag (用於 git add -N )13-bit：未使用，必須為零忽略此部份，因為我目前使用的 Git 的版本為 2：12$ git --versiongit version 2.17.1檔案路徑相對於 top level 目錄 (不包含斜線) 的 entry 路徑名稱 (可變長度)/ 作為路徑分隔字元不允許使用特殊路徑元件 .、.. 和 .git不允許使用斜線確切的編碼不確定，但 . 和 / 字元會以 7-bit ASCII 編碼，並且編碼不能包含 NUL byte (UNIX 路徑名稱)1hex: 696e 6465 782e 6874 6d6c12$ printf 'index.html' | xxd00000000: 696e 6465 782e 6874 6d6c index.html1-8 NUL byte使用 1-8 NUL byte 將 entry 填充為 8 byte 的倍數，同時保持名稱 NUL-terminated1hex: 0000 0000 0000 0000Extensions忽略此部份，因本範例的 index 無 extensions。SHA-1 Index Checksum在 index 檔案內容的最後 160-bit 是 index checksum，是由這 160-bit 之前的 index 檔案內容透過 SHA-1 計算的12hex: 2841 2d21 1a87 5b13 6f52 9772 ca4c 73f3 b3cc 3308用下面指令驗證：head -c：列印檔案的前幾個 byte12$ cat .git/index | head -c92 | sha1sum 28412d211a875b136f529772ca4c73f3b3cc3308 -如果 index 損壞，就能透過此 SHA-1 Index Checksum 來確認，並會說明 index 檔案已損壞：123$ git statuserror: bad index file sha1 signaturefatal: index file corrupt鳥哥的 Linux 私房菜 – 第五章、Linux 的檔案權限與目錄配置 ↩︎file permissions - How to read the mode field of git-ls-tree’s output - Stack Overflow ↩︎30 天精通 Git 版本控管 第 09 天：比對檔案與版本差異 by 保哥 ↩︎git/index-format.txt at master · git/git ↩︎","categories":[{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"深入 Git","slug":"深入-git","permalink":"https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"}],"author":"Titangene"},{"title":"深入 Git：Git 物件儲存 - tree 物件","slug":"git-tree-object","date":"2020-03-01T15:58:39.000Z","updated":"2020-03-01T15:57:02.000Z","comments":true,"path":"article/git-tree-object.html","link":"","permalink":"https://titangene.github.io/article/git-tree-object.html","excerpt":"本篇將深入探討 Git 如何運作，Git 是如何建立和儲存 tree 物件。","text":"本篇將深入探討 Git 如何運作，Git 是如何建立和儲存 tree 物件。之前講到 blob 物件是由檔案內容來產生的，那 Git 是如何知道這些檔案內容是分別存在哪個目錄內的檔案名稱中？目錄名稱和檔案名稱就是由 tree 物件來管理。一個 tree 物件可以紀錄包含哪些 blob 物件 (也就是檔案內容)，以及該 blob 物件對應的檔案名稱，以及其他 tree 物件和其對應的目錄名稱。例如：1$ git cat-file -pGit 儲存內容的方式類似 Unix 檔案系統，所有內容在 Git 都儲存成 tree 物件和 blob 物件，tree 物件對應於 Unix directory entries (目錄項目)，而 blob 物件是對應 inode (記錄檔案的權限與相關屬性) [1] 或檔案內容 [2]。每個 tree 物件可包含一個或多個 tree entries，每個 tree entry 都包含一個指向 blob 物件或 subtree 的 SHA-1 指標 (hash 值) 以及關聯模式 (associated mode)、物件類型、檔名。例如：先建立一個 commit：123456789101112131415161718192021$ git initInitialized empty Git repository in /home/titan/project/demo/.git/$ mkdir styles$ touch index.html README.md styles/main.css$ git add .$ tree .git/objects.git/objects├── e6│ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391├── info└── pack3 directories, 1 file$ git commit -m \"init\" [master (root-commit) 158f5a2] init 3 files changed, 0 insertions(+), 0 deletions(-) create mode 100644 README.md create mode 100644 index.html create mode 100644 styles/main.cssmaster^{tree} 代表由 master 分支上的最後一次 commit 所指向的 tree 物件：12345678910111213$ tree.├── index.html├── README.md└── styles └── main.css1 directory, 3 files$ git cat-file -p master^&#123;tree&#125;100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 README.md100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 index.html040000 tree c6d62294a2323c2047b43787d55a44ff8c94f565 stylesstyles 子目錄是指向另一個名為 c6d622 的 tree 物件，而這個 tree 物件又指向另一個名為 e69de2 的 blob 物件：12$ git cat-file -p c6d622100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 main.css建立 index初始化 Git repo：1234567891011121314151617181920$ git initInitialized empty Git repository in /home/titan/project/git/pro-git/.git/$ tree .git .git├── branches├── config├── description├── HEAD├── hooks│ └── ...├── info│ └── exclude├── objects│ ├── info│ └── pack└── refs ├── heads └── tags9 directories, 15 files建立專案需要的檔案：12345678910$ mkdir styles$ touch index.html README.md styles/main.css$ tree.├── index.html├── README.md└── styles └── main.css1 directory, 3 files現在 Git 還未追蹤這些檔案：12345678910111213$ git status On branch masterNo commits yetUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) README.md index.html styles/nothing added to commit but untracked files present (use \"git add\" to track)建立 blob 物件：12345678910$ git hash-object -w index.html9015a7a32ca0681be64471d3ac2f8c1f24c1040d$ tree .git/objects .git/objects├── 90│ └── 15a7a32ca0681be64471d3ac2f8c1f24c1040d├── info└── pack3 directories, 1 file在將 commit 之前，Git 會根據 staging area (預存區或稱暫存區) 或 index 來建立 tree 物件，所以必須在建立 tree 物件之前，先暫存物件來建立 index。使用 update-index 底層指令來為單一檔案建立 index。因為 index 之前沒有該檔案，甚至連 index 都還沒建立 (也就是沒有 .git/index 檔案)，所以必須加上 --add 選項。另外，因為要增加的檔案還不在工作目錄中，而是在資料庫 (也就是 .git/object 目錄內) 中，所以需要加上 --cacheinfo 選項，--cacheinfo 選項後面必須指定相關 mode、物件 SHA-1 值、檔名。git update-index 指令：將 working tree 中的檔案內容註冊至 index--add：如果指定的檔案不在 index 中，就會新增該檔案至 index預設行為 (也就是不加上 --add 選項時) 會忽略新檔案--cacheinfo &lt;mode&gt; &lt;object&gt; &lt;path&gt; 或 --cacheinfo &lt;mode&gt;,&lt;object&gt;,&lt;path&gt;：將指定的資訊直接插入 index用於註冊不在當前工作目錄中的檔案。對於最小 checkout 合併很有用為了向後相容，還可將這三個參數作為三個單獨的參數提供，但是鼓勵新的使用者使用單一參數形式123456789101112131415161718$ git update-index --add --cacheinfo \\ 100644 9015a7a32ca0681be64471d3ac2f8c1f24c1040d index.html$ git statusOn branch masterNo commits yetChanges to be committed: (use \"git rm --cached &lt;file&gt;...\" to unstage) new file: index.htmlUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) README.md styles/這邊指定的 100644 是 mode，代表是個普通的檔案。這類似 Unix 的檔案屬性 [3]，用來表示該檔案的類型 (檔案、目錄、link) 和權限 (可讀、可寫、可執行)，以下是常見的 (用二進位和八進位表示) [4] [5]：0100000000000000 ( 040000 )：Directory1000000110100100 ( 100644 )：Regular non-executable file1000000110110100 ( 100664 )：Regular non-executable group-writeable file1000000111101101 ( 100755 )：Regular executable file1010000000000000 ( 120000 )：Symbolic link1110000000000000 ( 160000 )：Gitlink註：.git/index 的二進位表示法 [6]前 4-bit：物件 type1000：regular file1010：symbolic link1110：gitlink中間 3-bit：沒有使用後面 9-bit：unix 權限regular file 只能用 0755 和 0644symbolic link 和 gitlink 在此 field 中的值為 0blob 物件只對 100644、100664 和 100755 這三種 mode 有效。接著使用 write-tree 指令將 index 寫至 tree 物件中。不需要使用 -w 選項，如果該 tree 物件還不存在，則呼叫 write-tree 會根據 index 的狀態自動建立 tree 物件：123456$ git write-tree2dce93ea08ed9059be0a838c6bcf62b7b5c28907$ git cat-file -p 2dce93100644 blob 9015a7a32ca0681be64471d3ac2f8c1f24c1040d index.html$ git cat-file -t 2dce93tree如果使用 index.html 的第二版和一個新檔案來建立新的 tree 物件：123456789101112131415161718192021$ echo 'text' &gt;&gt; index.html$ cat index.html indextext$ git update-index index.html$ git update-index --add README.md$ git status On branch masterNo commits yetChanges to be committed: (use \"git rm --cached &lt;file&gt;...\" to unstage) new file: README.md new file: index.htmlUntracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) styles/1234567891011121314151617181920$ tree .git/objects .git/objects├── 2d│ └── ce93ea08ed9059be0a838c6bcf62b7b5c28907├── 70│ └── f702d2c1492a9989a64c8e68bedf7c81052898├── 7e│ └── 59600739c96546163833214c36459e324bad0a├── 90│ └── 15a7a32ca0681be64471d3ac2f8c1f24c1040d├── info└── pack6 directories, 4 files$ git cat-file -p 70f702 indextext$ git cat-file -p 7e5960# README建立 tree 物件 (將 staging area 的狀態或 index 紀錄到一個 tree 物件)：12345$ git write-tree436d33ce00a9bbf0a1ce763b2c36330b6faf309b$ git cat-file -p 436d33 100644 blob 7e59600739c96546163833214c36459e324bad0a README.md100644 blob 70f702d2c1492a9989a64c8e68bedf7c81052898 index.html鳥哥的 Linux 私房菜 – 第七章、Linux 磁碟與檔案系統管理 ↩︎Git - Git Objects ↩︎鳥哥的 Linux 私房菜 – 第五章、Linux 的檔案權限與目錄配置 ↩︎file permissions - How to read the mode field of git-ls-tree’s output - Stack Overflow ↩︎30 天精通 Git 版本控管 第 09 天：比對檔案與版本差異 by 保哥 ↩︎git/index-format.txt at master · git/git ↩︎","categories":[{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"深入 Git","slug":"深入-git","permalink":"https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"}],"author":"Titangene"},{"title":"處理 Git 斷行字元的問題","slug":"git-auto-crlf","date":"2020-02-23T15:42:23.000Z","updated":"2020-04-26T11:39:05.000Z","comments":true,"path":"article/git-auto-crlf.html","link":"","permalink":"https://titangene.github.io/article/git-auto-crlf.html","excerpt":"在使用 Git 的過程中，若在不同作業系統編輯同一個 repo 的檔案，可能就會發生斷行字元的問題。Git 在 config 提供了 core.autocrlf 選項並用 .gitAttributes 檔案來處理斷行字元的問題。","text":"在使用 Git 的過程中，若在不同作業系統編輯同一個 repo 的檔案，可能就會發生斷行字元的問題。Git 在 config 提供了 core.autocrlf 選項並用 .gitAttributes 檔案來處理斷行字元的問題。之前我在 Windows 建立一個專案，是用來專門放用 Markdown 檔案的筆記，而且是用 Git 來作版本控制。但最近我在這台筆電安裝完雙系統 (Windows 10 和 Ubuntu 18.04) 後，有時候會在 Ubuntu 開發並將過程寫成筆記，所以這個筆記專案就會需要在不同 OS 下編輯。也因為以上需求讓我多學習到不同系統其實預設使用的文字檔案的斷行字元是不同的，Windows 是使用 CRLF ( \\r\\n，0x0D 0x0A )，而 Linux 則是使用 LF 字元 ( \\n，0x0A )。也因如此，Windows 上的每個檔案的每一行結尾都會比 Liunx 還要多一個字元，也就是多了很多 CR ( \\r ) 字元。註：CR 是 Carriage Return 的意思，也就是 Enter 字元LF 是 Line Feed 的意思，也就是真正的換行字元macOS 的斷行字元也是 LF 字元 ( \\n，0x0A )那為何會提到斷行字元？因為當我執行 git status 指令後，發現竟然檔案有被修改過，但我除了切換 OS 之外，根本沒有修改筆記啊！1234567891011$ git statusOn branch masterYour branch is up to date with 'origin/master'.Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: note.mdno changes added to commit (use \"git add\" and/or \"git commit -a\")其實這跟剛剛提到的斷行字元有關。如果用 git diff 指令就會看到筆記內的每行文字的結尾都多出了 ^M 這個東西，而且有些編輯器 (例如：VS Code) 可能會看不出來：12345678910111213141516$ git diff note.mddiff --git a/note.md b/note.mdindex e27815a..6b5682e 100644--- a/note.md+++ b/note.md@@ -1,5 +1,5 @@-Note-===--something+Note^M+===^M+^M+something^M This is the last line\\ No newline at end of file其實 ^M 恰好是 vim 用來顯示 0x0D 的方式，而 0x0D 就是剛剛提到 Windows 檔案內的每一行結尾，都會比 Linux 多出 CR ( \\r ) 這個字元。所以 ^M 其實就等同於 CR ( \\r，0x0D )。註：^M 其中的 ^ 代表 Ctrl，所以 ^M 也就代表 Ctrl + M (也就是 Enter)^M 雖然看是兩個字元，但在終端機上實際只有一個字元。在大部分的終端機系統中，包括 Windows 的 cmd、Linux 和 FreeBSD 都可用 Ctrl 來表示 ^ 字元 (caret)0x0D 是以十六進位表示的 13，而 M 正好是英文字母中第 13 個字母不過，如果有多個檔案的每一行都要刪掉 ^M 就會很麻煩，所以 Git 提供一種自動轉換斷行符號的功能：core.autocrlf。那 Git 的自動轉換斷行符號功能到底做了什麼？當你執行 git add 將檔案加入 index 時，Git 可將 CRLF 自動傳成 LF。當你執行 git checkout 將程式碼 checkout 出檔案系統時，Git 可將 LF 自動轉成 CRLF。如果要在全域設定可執行下面指令來設定：1$ git config --global core.autocrlf true如果是要在各別的 repo 設定，就需要在 repo 的根目錄下建立一個名為 .gitattributes 的檔案，當這個檔案被 commit 至 repo 時，就會覆蓋 core.autocrlf 的設定，以確保管理此 repo 的協作者的設定一致。下面是 .gitattributes 這個檔案的範例模板：1234567891011121314# Set the default behavior, in case people don&#39;t have core.autocrlf set.* text&#x3D;auto# Explicitly declare text files you want to always be normalized and converted# to native line endings on checkout.*.c text*.h text# Declare files that will always have CRLF line endings on checkout.*.sln text eol&#x3D;crlf# Denote all files that are truly binary and should not be modified.*.png binary*.jpg binary此檔案的設定格式：1pattern attr1 attr2 ...pattern 和屬性的中間要以空格分隔。當 pattern 匹配相關路徑時，後面的屬性的設定會應用在那些路徑。text 這個屬性是用於啟用並控制行尾的正規化。正規化文字檔後，行尾會在 repo 中轉換為 LF。如果要控制工作目錄中使用的行尾樣式，請針對該檔案設定 eol 屬性 ( eol 就 end-of-line 的縮寫)，並且對所有文字檔設定 core.eol 變數。如果將 core.autocrlf 設為 true 或 input 會覆蓋 core.eol 的設定。詳情可參考 Git - git-config Documentation 文件中對於 core.eol 設定的定義。text=auto：路徑被標記為自動轉換行尾。如果 Git 確定該內容為文字，那該檔案的行尾就會在 checkin 時轉換成 LF。當用 CRLF commit 檔案時，則不會進行轉換。資料來源：Configuring Git to handle line endings - GitHub HelpGit 在 Windows 平台處理斷行字元 (CRLF) 的注意事項 | The Will Will WebASCII - Wikiunix - What does ^M character mean in Vim? - Stack OverflowGit - gitattributes DocumentationGit - Git AttributesGit - Git Configuration","categories":[{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"}],"author":"Titangene"},{"title":"深入 Git：Git 物件儲存 - blob 物件","slug":"git--blob-object","date":"2020-02-16T15:56:20.000Z","updated":"2020-03-16T03:20:40.000Z","comments":true,"path":"article/git--blob-object.html","link":"","permalink":"https://titangene.github.io/article/git--blob-object.html","excerpt":"本篇將深入探討 Git 如何運作，在執行 git add 將檔案加入 index 時，Git 會如何建立和儲存 blob 物件。","text":"本篇將深入探討 Git 如何運作，在執行 git add 將檔案加入 index 時，Git 會如何建立和儲存 blob 物件。Git 是一個 content-addressable (按內容定址，按檔案內容定位) 的檔案系統，這代表 Git 的核心是一個 key-value data store (資料儲存) [1]。我們只要提供檔案內容，Git 就會透過一些演算法計算成 key，未來就可透過該 key 來檢索出對應的內容。Git 有四種 type (類型) 的物件：blob、tree、commit 和 tag。下面會使用 git hash-object 這個底層指令來介紹物件名稱是如何產生的。手動建立 blob 物件首先，先執行 git init 初始化 repo：12$ git initInitialized empty Git repository in /home/titan/project/git-demo/.git/初始化新的 repo 時，Git 會在 .git 目錄中初始化 objects 目錄，並在裡面建立 pack 和 info 子層的空目錄：1234$ tree .git/objects.git/objects├── info└── pack使用底層指令 hash-object 將資料儲存至 .git 目錄中，並獲得對應的 key (也就是物件名稱，或稱 SHA-1 值)。下面是 hash-object 的 option：-w：將物件寫入至物件資料庫 (也就是 .git/objects 目錄內)，並輸出該物件的 key (也就是 SHA-1 checksum)若不用此 option，就只會輸出 key，不會儲存物件--stdin：從 stdin (standard input，標準輸入) 讀取內容若不用此 option，hash-object 指令預設會從檔案中讀取，所以必須在 hash-object 指令之後加上指定的檔案路徑例如：git hash-object README.md12$ echo 'test content' | git hash-object -w --stdind670460b4b4aece5915caf5c68d12f560a9fe3e4hash-object 指令會輸出 40 個字元的 checksum hash，這是個 SHA-1 hash (後面會介紹 SHA-1)，是由儲存的內容和 header 資訊所計算出來的 checksum。在 Git 的儲存方式是一份內容就存成一個檔案，都放在 .git/objects 目錄內，子目錄為 SHA-1 的前 2 個字元，檔名為剩餘的 38 個字元。123456$ tree .git/objects.git/objects├── d6│ └── 70460b4b4aece5915caf5c68d12f560a9fe3e4├── info└── pack使用 cat-file 指令察看物件資訊使用 cat-file 指令取得物件的內容，可用於檢查物件。使用 -p option 找出內容的 type 並輸出該內容：12$ git cat-file -p d67046test content使用 -t option 可獲得該物件的 type：12$ git cat-file -t d67046blob剛剛建立的 d67046 就是 Git 的 blob 物件。變更檔案內容後再次建立 blob 物件那如果變更檔案內容後，再建立 blob 物件又會如何？看下面範例：先建立一個全新的專案，並使用 git init 初始化 Git repo：1234$ mkdir git-demo-2$ cd git-demo-2$ git initInitialized empty Git repository in /home/titan/project/git-demo-2/.git/接著建立一個名為 test.txt 的檔案，內容為 v1，使用 git hash-object 建立的 blob 物件為 626799，後來將內容修改為 v2，再次建立的 blob 物件為 8c1384：12345678910111213$ echo 'v1' &gt; test.txt$ git hash-object -w test.txt626799f0f85326a8c1fc522db584e86cdfccd51f$ git cat-file -t 626799blob$ echo 'v2' &gt; test.txt$ git hash-object -w test.txt8c1384d825dbbe41309b7dc18ee7991a9085c46e$ git cat-file -t 8c1384blob可以看到當檔案內容不同時，就可以產生不同的 blob 物件：12345678$ tree .git/objects.git/objects├── 62│ └── 6799f0f85326a8c1fc522db584e86cdfccd51f├── 8c│ └── 1384d825dbbe41309b7dc18ee7991a9085c46e├── info└── pack建立內容相同，但檔名不同的檔案當你建立檔案內容相同，但檔名不同的檔案時，在 repo 內也只會存一份，因為物件的名稱是由檔案內容來決定的，而不是依檔名決定。不過，git hash-object 指令還是會重新產生同一個 blob 物件 (因為該物件的檔案時間被更新了)。範例如下：在建立 other-test.txt 檔案之前，.git/objects/8c/6799f... 的檔案時間是 23:38：1234567891011121314151617181920212223242526$ tree .git/objects.git/objects├── 62│ └── 6799f0f85326a8c1fc522db584e86cdfccd51f├── 8c│ └── 1384d825dbbe41309b7dc18ee7991a9085c46e├── info└── pack$ ls -lR .git/objects.git/objects:總計 16drwxr-xr-x 2 titan titan 4096 2月 16 23:39 62drwxr-xr-x 2 titan titan 4096 2月 16 23:40 8cdrwxr-xr-x 2 titan titan 4096 2月 16 23:39 infodrwxr-xr-x 2 titan titan 4096 2月 16 23:39 pack.git/objects/62:總計 4-r--r--r-- 1 titan titan 18 2月 16 23:38 6799f0f85326a8c1fc522db584e86cdfccd51f.git/objects/8c:總計 4-r--r--r-- 1 titan titan 18 2月 16 23:39 1384d825dbbe41309b7dc18ee7991a9085c46e...在建立 other-test.txt 檔案之後，.git/objects/8c/6799f... 的檔案時間變成 23:40：123456789101112131415161718192021222324252627282930$ echo 'v2' &gt; other-test.txt$ git hash-object -w other-test.txt8c1384d825dbbe41309b7dc18ee7991a9085c46e$ tree .git/objects.git/objects├── 62│ └── 6799f0f85326a8c1fc522db584e86cdfccd51f├── 8c│ └── 1384d825dbbe41309b7dc18ee7991a9085c46e├── info└── pack$ ls -lR .git/objects.git/objects:總計 16drwxr-xr-x 2 titan titan 4096 2月 16 23:39 62drwxr-xr-x 2 titan titan 4096 2月 16 23:40 8cdrwxr-xr-x 2 titan titan 4096 2月 16 23:39 infodrwxr-xr-x 2 titan titan 4096 2月 16 23:39 pack.git/objects/62:總計 4-r--r--r-- 1 titan titan 18 2月 16 23:40 6799f0f85326a8c1fc522db584e86cdfccd51f.git/objects/8c:總計 4-r--r--r-- 1 titan titan 18 2月 16 23:39 1384d825dbbe41309b7dc18ee7991a9085c46e...hash-object 計算物件名稱的演算法那 Git 的物件名稱 (也就是 SHA-1) 是如何計算的？不同的 Git 物件有不同的計算方式，這邊先說明 blob 物件的部份。Git 物件都是使用 zlib 壓縮，物件名稱的 SHA-1 hash 值就是 header 加上檔案內容，演算法如下 [2]：1&lt;type&gt; &lt;content_length&gt;\\0&lt;content&gt;前面的 &lt;type&gt; &lt;content_length&gt;\\0 代表 header，而 &lt;content&gt; 代表檔案內容。下面舉個例子：建立名為 hello.txt 的檔案，檔案內容為 hello：1$ echo \"hello\" &gt; hello.txt使用 cat 指令並加上 -A 選項察看檔案內容：-A：相當於 -vET 整合選項-E：將結尾的斷行字元以 $ 顯示-T：將 TAB 字元以 ^I 顯示-v：除了換行及 TAB 字元外，使用 ^ 及 M- 表示法顯示字元 (列出一些看不出來的特殊字元)12$ cat -A hello.txthello%檔案內容的結尾 % 代表 LF (line Feed，\\n )，我是在 Linux 建立 hello.txt 此檔案的，而 Linux 的換行字元是使用 LF 字元，所以在每一行的結尾才會多了 LF 這個字元。所以依照上面建立物件名稱的演算法就會像這樣，下面分別代表：blob：要建立的物件是 blob 物件6：檔案內容長度\\0：Null 結束字元hello\\n：檔案內容1blob 6\\0hello\\n所以如果使用以下指令就能算出此 blob 物件的 SHA-1 hash 值：echo 的 -n 選項：不輸出結尾的換行字元 (trailing newline)sha1sum：計算 SHA-1 值12$ echo -n \"blob 6\\0hello\\n\" | sha1sum ce013625030ba8dba906f756967f9e9ca394464a實作 Git 物件名稱演算法如果用 Python 實作此演算法：123456789101112131415import osimport zlibfrom hashlib import sha1content = 'hello\\n'header = 'blob &#123;&#125;\\0'.format(len(content))store = header + contenthash = sha1(store.encode('utf-8')).hexdigest()zlib_content = zlib.compress(store.encode('utf-8'))path = '.git/objects/&#123;&#125;/&#123;&#125;'.format(hash[:2], hash[2:])os.makedirs(os.path.dirname(path), exist_ok=True)with open(path, 'wb+') as file: file.write(zlib_content)驗證剛剛實作的 blob 物件是否有效：12$ git cat-file -p ce0136hello看到檔案內容就代表實作成功 😃。驗證 Git 物件Git 物件名稱可以用來檢查物件的 type 和物件內容是否一致，如果 Git 物件的檔案名稱或內容被惡意修改，就可以很容易的發現有錯誤。Git 可用 git fsck 指令來如何驗證資料庫中的物件是否有效，如果驗證成功就會像這樣輸出：12$ git fsckChecking object directories: 100% (256/256), done.假設我惡意修改剛剛建立的 blob 物件，使用 git fsck 指令就會告知該物件有問題：1234567$ vim .git/objects/ce/013625030ba8dba906f756967f9e9ca394464a$ git fsck error: inflate: data stream error (incorrect header check)error: unable to unpack header of .git/objects/ce/013625030ba8dba906f756967f9e9ca394464aerror: ce013625030ba8dba906f756967f9e9ca394464a: object corrupt or missing: .git/objects/ce/013625030ba8dba906f756967f9e9ca394464aChecking object directories: 100% (256/256), done.missing blob ce013625030ba8dba906f756967f9e9ca394464aSHA-1SHA-1 (Secure Hash Algorithm 1) 是一種 hash (雜湊) 演算法，它可生成 160 bit (20 byte) 的 hash 值，通常以 40 個十六進位 (hex) 的數字表示 [3]。hash 演算法的特性 [4]：給定訊息很容易計算出 hash 值很難用已知的 hash 值推算出原始訊息很難修改訊息而 hash 值不變很難讓不同的訊息有相同的 hash 值所以 Git 有以下優點 [5]：Git 可透過比較物件名稱 (也就是 SHA-1) 來快速確定兩個物件是否相同在每個 repo 中都以相同的方式計算物件名稱，所以儲存在不同 repo 內的相同內容會以相同的名稱來儲存可以透過檢查物件名稱來確認其內容的 SHA-1 hash 值，Git 可在讀取物件時檢查錯誤Git Internals - Git Objects | Pro Git 2/e ↩︎Git - user-manual Documentation ↩︎SHA-1 - Wiki ↩︎密碼雜湊函式 - Wiki ↩︎Git - user-manual Documentation ↩︎","categories":[{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"深入 Git","slug":"深入-git","permalink":"https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"}],"author":"Titangene"},{"title":"Git - 刪除遠端分支 (以 GitHub、GitLab 為例)","slug":"git-delete-remote-branch","date":"2020-02-09T15:45:52.000Z","updated":"2020-02-09T15:43:21.000Z","comments":true,"path":"article/git-delete-remote-branch.html","link":"","permalink":"https://titangene.github.io/article/git-delete-remote-branch.html","excerpt":"本篇將介紹如何刪除 GitHub 或 GitLab 的遠端分支，以及透過是否可刪除遠端 master 分支 (雖然通常不會這樣做)，以了解如何在 GitHub 和 GitLab 修改預設分支。","text":"本篇將介紹如何刪除 GitHub 或 GitLab 的遠端分支，以及透過是否可刪除遠端 master 分支 (雖然通常不會這樣做)，以了解如何在 GitHub 和 GitLab 修改預設分支。如果某分支已合併至遠端的 master 分支 (或穩定版的分支) 時，可在 git push 指令加上 --delete 或 -d 選項來刪除遠端分支 [1]：12$ git push &lt;remote&gt; --delete &lt;remoteBranchName&gt;$ git push &lt;remote&gt; -d &lt;remoteBranchName&gt;123$ git push origin --delete devTo github.com:titangene/git-demo.git - [deleted] dev或是在 ref (在這邊指的是下面指令中的 &lt;remoteBranchName&gt; ) 之前加上冒號 ( : ) 也可以刪除遠端分支：1$ git push &lt;remote&gt; :&lt;remoteBranchName&gt;123$ git push origin :devTo github.com:titangene/git-demo.git - [deleted] dev此指令是在 origin repo 中找到與 dev match 的 ref (例如：refs/heads/dev )，然後將該遠端分支刪除 [2]，其實就是刪除遠端 server 上的分支指標。Git Server 會將資料保留一段時間，直到執行 GC (garbage collection，垃圾回收) 為止。所以如果誤刪了分支都很容易恢復。刪除多個遠端分支如果要刪除多個遠端分支，可直接將多個指定遠端分支加在後面：1234$ git push origin -d feature masterTo github.com:titangene/git-demo.git - [deleted] feature - [deleted] master無法刪除的遠端分支通常預設會無法刪除遠端的 master 分支，因為遠端通常會將 master 分支作為預設分支：1234$ git push origin -d masterTo github.com:titangene/git-demo.git ! [remote rejected] master (refusing to delete the current branch: refs/heads/master)error: failed to push some refs to 'git@github.com:titangene/git-demo.git'預設是無法刪除 GitHub 和 GitLab 遠端 repo 的 master 分支。刪除 GitHub 的遠端分支如果要刪除 GitHub 遠端 repo 的 master 分支，只要將該 repo 的預設分支改成其他分支，這樣就可以刪掉了。在 repo 的「Settings &gt; Branches &gt; Default branch &gt; 將預設分支改為其他分支 &gt; Update」，如圖：123$ git push origin -d masterTo github.com:titangene/git-demo.git - [deleted] master刪除 GitLab 的遠端分支刪除 GitLab 遠端 repo 的 master 分支時，會發生以下錯誤，錯誤訊息中直接說明 master 分支是預設分支，所以無法刪除：12345$ git push gitlab -d masterremote: GitLab: The default branch of a project cannot be deleted.To gitlab.com:titangene/git-demo.git ! [remote rejected] master (pre-receive hook declined)error: failed to push some refs to 'git@gitlab.com:titangene/git-demo.git'在 repo 的「Settings &gt; Repository &gt; Default branch &gt; 將預設分支改為其他分支 &gt; Save changes」，如圖：那如果將預設分支改成其他分支呢？結果還是不能刪除：12345$ git push gitlab -d masterremote: GitLab: You can only delete protected branches using the web interface.To gitlab.com:titangene/git-demo.git ! [remote rejected] master (pre-receive hook declined)error: failed to push some refs to 'git@gitlab.com:titangene/git-demo.git'其實原因也寫在錯誤訊息內，因為 GitLab 會預設將 repo 的 master 分支設為受保護的分支 (protected branch) [3] [4]，所以才不能刪除。如果要刪除受保護的分支，那就讓他不受保護就可以囉 XD。在 repo 的「Settings &gt; Repository &gt; Protected Branches &gt; Unprotect master 分支」，如圖：設定後就可以刪除 master 分支了：123$ git push gitlab -d masterTo gitlab.com:titangene/git-demo.git - [deleted] master察看是否刪除遠端分支另外，如果用 git branch -vv 可以看到該分支已被刪除 (輸出訊息中的 gone )：123$ git branch -vv* dev 44fdaf6 [origin/dev: gone] feat: d master 49135dc [origin/master] feat: bGit - Remote Branches | Pro Git, 2/e ↩︎Git - git-push Documentation ↩︎Permissions · User · Help · GitLab ↩︎Protected branches · Project · User · Help · GitLab ↩︎","categories":[{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"GitHub","slug":"github","permalink":"https://titangene.github.io/tags/github/"},{"name":"GitLab","slug":"gitlab","permalink":"https://titangene.github.io/tags/gitlab/"},{"name":"Branch","slug":"branch","permalink":"https://titangene.github.io/tags/branch/"},{"name":"Remote","slug":"remote","permalink":"https://titangene.github.io/tags/remote/"}],"author":"Titangene"},{"title":"重新認識 CSS - 總結 & 系列目錄","slug":"css-series-catalog","date":"2019-10-15T13:20:42.000Z","updated":"2020-02-09T16:03:34.000Z","comments":true,"path":"article/css-series-catalog.html","link":"","permalink":"https://titangene.github.io/article/css-series-catalog.html","excerpt":"終於來到鐵人賽的最後一天！本篇對「重新認識 CSS」此系列做個總結，並整理此系列中的每篇文章可對應到哪些 CSS Spec。","text":"終於來到鐵人賽的最後一天！本篇對「重新認識 CSS」此系列做個總結，並整理此系列中的每篇文章可對應到哪些 CSS Spec。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - 總結 &amp; 系列目錄「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog就如前言所說，經過這次的鐵人賽，透過看 spec 來學習 CSS 的真實面貌，而不是未經驗證或自行腦補來切版，讓自己能真正的「重新認識 CSS」。這個月以來都是當天看 spec 當天寫文，所以每天都有鐵人賽的感覺。起初看 spec 的時候，腦中天旋地轉，好多以前重來沒看過的專有名詞，還好有好想工作室的夥伴跟我一起討論 spec，加快我理解的速度。我第一次寫連續這麼多天的文章，雖然沒有像以前參加鐵人賽的前輩們說的那樣：「到後面幾天就會不知道要寫什麼了」，所以建議我在開賽前，事先規劃好這 30 天要寫什麼。不過我也沒有特別事先安排寫文的順序，因為我原本就預計會按照 CSS 2.2 的大綱來啃 spec，所以我不怕沒有主題可以寫，只怕自己理解的速度跟不上發文的速度 QQ，還好最後成功完賽 😄。雖然鐵人完賽了，但這只是我學習旅程的開始，如果未來還有後續的學習紀錄，都會分享在我的 blog「Titangene Blog」，歡迎大家來光顧。如果想知道我之前寫過哪些專案，可以到我的 Github：titangene 看看。下面是我對於這次系列「重新認識 CSS」的整理，讓大家可以更快知道哪些內容可以對應到哪些 spec。簡介簡介 CSS，並說明如何在 HTML 使用 CSS。系列如下：重新認識 CSS - CSS 簡介對應 spec 的以下幾篇：HTM 4.01 - 14. Style SheetsHTML Living Standard - 4.2.4. The link elementSelectorSelector 是寫 CSS 時，必須掌握的東西，熟悉 selector 才會選到正確的元素。而此系列是依據 Selectors Level 3 的分類來各別介紹的。系列如下：重新認識 CSS - Simple Selector &amp; Groups of selector重新認識 CSS - Attribute selector (屬性選擇器)重新認識 CSS - Pseudo-class (偽類) (1)重新認識 CSS - Pseudo-class (偽類) (2)重新認識 CSS - Pseudo-element (偽元素)對應 spec 的以下幾篇：CSS 2.2 - 5. SelectorsCSS 2.2 - 12.1. The :before and :after pseudo-elementsSelectors Level 3Selectors Level 4CSS Pseudo-Elements Module Level 4Values &amp; Units在開始認識 CSS 屬性之前，可以先認識屬性有哪些值和單位可以使用。系列如下：重新認識 CSS - CSS 屬性值對應 spec 的以下幾篇：CSS 2.2 - 4.3. ValuesCSS Values and Units Module Level 3CSS Values and Units Module Level 4Assigning property values, Cascading, and Inheritance了解在 CSS 中，繼承和權重這些重要的觀念之後，接著就可以更深入的了解 CSS 是如何處理屬性值的。系列如下：重新認識 CSS - Inheritance (繼承)重新認識 CSS - Cascading &amp; Specificity重新認識 CSS - CSS 如何處理屬性值對應 spec 的以下幾篇：CSS 2.2 - 6. Assigning property values, Cascading, and InheritanceCSS Cascading and Inheritance Level 3CSS Cascading and Inheritance Level 4@media &amp; @import rules引入其他 CSS 檔案或在多個裝置、解析度、螢幕尺寸下要應用哪個 style sheet (樣式表)，就需要了解如何使用 @media 和 @import。系列如下：重新認識 CSS - Media type重新認識 CSS - Media query重新認識 CSS - @import對應 spec 的以下幾篇：CSS 2.2 - 7. Media typesMedia QueriesMedia Queries Level 4CSS 2.2 - 6.3 The @import ruleBox modelBox model 是用來描述 document tree 中的每個元素所產生的矩形框。系列如下：重新認識 CSS - Box model (前傳)重新認識 CSS - Box model：border重新認識 CSS - box-sizing重新認識 CSS - Collapsing margins對應 spec 的以下幾篇：CSS 2.2 - 8. Box modelCSS Box Model Module Level 3CSS Basic User Interface Module Level 3 (CSS3 UI) - 3. Box Model additionCSS Backgrounds and Borders Module Level 3 - 4. BordersVisual formatting modelVisual formatting model 是用來描述 UA 會如何處理視覺媒體 (visual media) 的 document tree，document tree 中的每個元素都會根據 box model 來產生 0 個或多個 box。而這些 box 的位置和大小都是相對於稱為 containing block 的矩形框的邊緣計算的。系列如下：重新認識 CSS - Containing block對應 spec 的以下幾篇：CSS 2.2 - 9.1.2. Containing blocksCSS 2.2 - 10.1. Definition of “containing block”Controlling box generation元素產生的 box 的 type，可以使用 display 屬性來指定，而 box 的 type 會影響 box 在 visual formatting model 中的行為。系列如下：重新認識 CSS - Visual formatting model：Box generation (block)重新認識 CSS - Visual formatting model：Box generation (inline)重新認識 CSS - display對應 spec 的以下幾篇：CSS 2.2 - 9.2. Controlling box generationCSS Display Module Level 3Formatting context &amp; Normal flowNormal flow 中的 box 屬於某種 formatting context，可是 block 或 inline，不同的 box 會參與不同的 formatting context。block-level box 會參與 BFC，inline-level box 會參與 IFC。系列如下：重新認識 CSS - formatting context &amp; independent formatting context重新認識 CSS - Block formatting context (BFC)重新認識 CSS - Inline formatting context (IFC)對應 spec 的以下幾篇：CSS 2.2 - 9.4.1. Block formatting contextsCSS 2.2 - 9.4.2. Inline formatting contextsCSS Display Module Level 3CSS Inline Layout Module Level 3Positioning schemes在 CSS 2.2 中，position 和 float 屬性這些定位方案都可以對 box 進行佈局。系列如下：重新認識 CSS - position重新認識 CSS - float對應 spec 的以下幾篇：CSS 2.2 - 9.3. Positioning schemesCSS Positioned Layout Module Level 3Layered presentation除了水平和垂直的位置之外，如果想讓 box 可以有類似圖層的概念來排版，就能使用 z-index 屬性，這些 box 可以沿著 z 軸來排列，讓一個 box 可以疊在另一個 box 的上面。系列如下：重新認識 CSS - z-index &amp; stacking context對應 spec 的以下幾篇：CSS 2.2 - 9.9. Layered presentationVisual effects當 block box 的內容超出 box 的 content edge 時，就可能會發生 overflow。使用 overflow 屬性就能指定超出的部份要如何處理 (例如：提供捲動機制來訪問被剪裁的內容)。而 visibility 屬性則可以指定是否要 render 由元素產生的 box，可用來顯示或隱藏 box。系列如下：重新認識 CSS - overflow重新認識 CSS - visibility對應 spec 的以下幾篇：CSS 2.2 - 11. Visual effectsCSS 2.2 - 17.5.5. Dynamic row and column effects","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - z-index & stacking context","slug":"css-z-index-and-stacking-context","date":"2019-10-14T13:20:42.000Z","updated":"2020-02-09T15:01:57.000Z","comments":true,"path":"article/css-z-index-and-stacking-context.html","link":"","permalink":"https://titangene.github.io/article/css-z-index-and-stacking-context.html","excerpt":"本篇將介紹 CSS 的 z-index 屬性和 stacking context。","text":"本篇將介紹 CSS 的 z-index 屬性和 stacking context。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - z-index &amp; stacking context「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog從 CSS 2.1 開始，每個 box 在三維空間上都有一個位置，除了水平和垂直的位置之外，這些 box 還會沿著 z 軸來排列，讓一個 box 可以疊在另一個 box 的上面，這個概念就類似於圖層。當使用者面對螢幕時，元素的 z-index 屬性設定的數值愈大，則該元素就會愈靠近使用者。z-index 屬性下面是 z-index 屬性的定義表：此元素的 initial value 為 auto只適用於定位元素，也就是元素的 position 屬性不為預設值 static，包括：absolute、relative、fixed此元素為不可繼承屬性z-index 屬性是對 positioned box 指定了：當前 stacking context 中 box 的 stack level該 box 是否建立 stacking context下面介紹各屬性值：&lt;integer&gt;：該整數是當前 stacking context 中產生的 box 的 stack level。該 box 還建立了一個新的 stacking contextauto：當前 stacking context 中產生的 box 的 stack level 為 0。如果該 box 具有 position: fixed 或是 root，則它還會建立新的 stacking contextstacking context原本元素會 in-flow 來排列，當元素使用 position 屬性設定排列的位置時，會從原本的位置移至指定的位置，甚至是 out-of-flow，此時就會建立新的 stacking contextrender tree 繪製 (painted) 到 canvas 上的順序是根據 stacking context 來決定的每個 box 都屬於一個 stacking context，並且每個定位的 box 都有一個整數的 stack levelstack level：代表該 box 在 z 軸上相對於同一個 stacking context 中其他 stack level 的位置stack level 較高的 box 會在 stack level 較低的 box 前面box 的 stack level 可能為負數在 stacking context 中，stack level 相同的 box 會根據 document tree 的順序來堆疊 (stacked)，也就是越寫在 HTML 後面的元素會蓋住前面的元素stacking context 可以包含其他 stacking context如以下範例：12&lt;div class=\"box box1\"&gt;box1&lt;/div&gt;&lt;div class=\"box box2\"&gt;box2&lt;/div&gt;123456789101112.box &#123; width: 100px; height: 100px; font-size: 36px;&#125;.box1 &#123; background-color: lightblue; margin: 0 0 -50px 50px;&#125;.box2 &#123; background-color: lightslategray;&#125;Demo：Codepen 連結.box2 元素在 .box1 元素之後，所以 .box2 元素會蓋住 .box1 元素：123456789101112131415161718192021222324&lt;div id=\"div1\"&gt; &lt;h2&gt;div #1&lt;/h2&gt; &lt;code&gt;position: relative;&lt;br/&gt;z-index: 5;&lt;/code&gt;&lt;/div&gt;&lt;div id=\"div2\"&gt; &lt;h2&gt;div #2&lt;/h2&gt; &lt;code&gt;position: relative;&lt;br/&gt;z-index: 2;&lt;/code&gt;&lt;/div&gt;&lt;div id=\"div3\"&gt; &lt;div id=\"div4\"&gt; &lt;h2&gt;div #4&lt;/h2&gt; &lt;code&gt;position: relative;&lt;br/&gt;z-index: 6;&lt;/code&gt; &lt;/div&gt; &lt;h2&gt;div #3&lt;/h2&gt; &lt;code&gt;position: absolute;&lt;br/&gt;z-index: 4;&lt;/code&gt; &lt;div id=\"div5\"&gt; &lt;h2&gt;div #5&lt;/h2&gt; &lt;code&gt;position: relative;&lt;br/&gt;z-index: 1;&lt;/code&gt; &lt;/div&gt; &lt;div id=\"div6\"&gt; &lt;h2&gt;div #6&lt;/h2&gt; &lt;code&gt;position: absolute;&lt;br/&gt;z-index: 3;&lt;/code&gt; &lt;/div&gt;&lt;/div&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960* &#123; margin: 0; &#125;html &#123; padding: 20px; &#125;div &#123; position: relative; opacity: 0.7;&#125;#div1,#div2 &#123; background-color: #cfc; padding: 10px; border: 1px dashed #696;&#125;#div1 &#123; width: 160px; height: 280px; margin-bottom: -220px; left: 300px; z-index: 5;&#125;#div2 &#123; width: 500px; padding-top: 240px; z-index: 2;&#125;#div3 &#123; background-color: #fdd; padding: 40px 20px 20px; border: 1px dashed #900; position: absolute; top: 40px; left: 100px; width: 340px; z-index: 4; opacity: 1;&#125;#div4,#div5 &#123; background-color: #ffc; border: 1px dashed #996;&#125;#div4 &#123; padding: 25px 10px 5px; margin-bottom: 15px; z-index: 6;&#125;#div5 &#123; padding: 5px 10px; margin-top: 15px; z-index: 1;&#125;#div6 &#123; width: 180px; background-color: #ddf; padding: 300px 20px 20px; border: 1px dashed #009; position: absolute; top: 20px; left: 200px; z-index: 3;&#125;Demo：Codepen 連結範例如圖：See the Pen stacking context: z-index by Titangene (@titangene) on CodePen.資料來源：CSS 2.2 - 9.9.1. Specifying the stack level: the z-index propertyThe stacking context - CSS: Cascading Style Sheets | MDN","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - visibility","slug":"css-visibility","date":"2019-10-13T13:20:42.000Z","updated":"2020-02-09T14:59:05.000Z","comments":true,"path":"article/css-visibility.html","link":"","permalink":"https://titangene.github.io/article/css-visibility.html","excerpt":"本篇將介紹 CSS 的 visibility 屬性。","text":"本篇將介紹 CSS 的 visibility 屬性。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - visibility「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blogvisibility 屬性visibility 屬性是用於指定是否 render 由元素產生的 box，可用來顯示或隱藏 box，而無需更改文件的佈局。下面是 visibility 屬性的定義表：此元素的 initial value 為 visible適用於所有元素此元素為可繼承屬性，descendant 會繼承父元素的 visibility 屬性設定下面介紹各屬性值：visiblevisibility 屬性的 initial value產生的 box 是可見的hidden產生的 box 是不可見的 (完全透明，不會繪製 (drawn) 在畫面上)但不可見的 box 還是會影響佈局如果元素的 descendant 設定 visibility: visible，則它們將是可見的如以下範例，.outer 元素設定 visibility: hidden，而 .outer 元素有兩個 descendant，所有 descendant 都會繼承父元素 .outer 的 visibility 屬性設定：.inner-hidden 元素：因為沒有在此元素設定 visibility: visible，所以元素為不可見的.inner-visible 元素：也就是畫面中的紅色矩形，因為有在此元素設定 visibility: visible，所以元素就變為可見的在紅色矩形上面所空出的空間，其實就是 .inner-hidden 元素佔用的。雖然 .inner-hidden 元素是不可見的，但它只是被隱藏而已，元素所產生的 box 不會從文件佈局中刪除，所以 box 還是會影響佈局。1234&lt;div class=\"outer\"&gt; &lt;div class=\"inner inner-hidden\"&gt;&lt;/div&gt; &lt;div class=\"inner inner-visible\"&gt;&lt;/div&gt;&lt;/div&gt;12345678910111213141516body &#123; outline: 3px solid;&#125;.outer &#123; width: 100px; background-color: gray; visibility: hidden;&#125;.inner &#123; width: 60px; height: 60px; background-color: red;&#125;.inner-visible &#123; visibility: visible;&#125;Demo：Codepen 連結See the Pen descendant visibility: visible by Titangene (@titangene) on CodePen.collapse在表格的 row 或 column (row、row group、column 和 column group 元素，也就是分別為 HTML 中的 tr、tbody、col 和 colgroup 元素) 使用 visibility: collapse 時：會導致整個 row 或 column 從顯示結果中刪除，原本佔用的空間會讓其他內容使用，也就是說顯示結果很像是將 display: none 應用在表格的 row 或 column 一樣與 collapsed column 或 row (合併欄或合併列) 相交 (intersect) 的 spanned row 或 column (跨欄或跨列) 的內容會被裁切掉 (clipped)可以在不強制重新佈局 (re-layout) 表格的情況下，使用動態效果來刪除表格的 row 或 column對 table cell (也就是 HTML 中的 td 或 th 元素) 使用 visibility: collapse 時，效果相當於 visibility: hidden除了上述以外的其他元素使用 visibility: collapse 時，效果相當於 visibility: hidden下面是表格的範例：1234567891011121314151617&lt;table&gt; &lt;tr&gt; &lt;td&gt;1.1&lt;/td&gt; &lt;td class=\"collapse\"&gt;1.2&lt;/td&gt; &lt;td&gt;1.3&lt;/td&gt; &lt;/tr&gt; &lt;tr class=\"collapse\"&gt; &lt;td&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.1&lt;/td&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;td&gt;3.3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;1234567891011table&#123; outline: 1px solid; font-size: 24px; padding: 10px;&#125;td &#123; outline: 1px solid red;&#125;.collapse &#123; visibility: collapse;&#125;Demo：Codepen 連結如下圖，此範例為 3 x 3 的表格，在沒有設定 visibility: collapse 之前，表格原本長這樣：如果對 1.2 此 table cell 和第二列設定 visibility: collapse：1.2 此 table cell 只會被隱藏，不會刪除原本佔用的空間第二列會被隱藏，並且刪除原本佔用的空間See the Pen table row &amp; column：visibility: collapse by Titangene (@titangene) on CodePen.display: none 與 visibility: hidden 的差異display: none 和 visibility: hidden 都是可以隱藏元素，但差別在於：display: none 會將元素所產生的 box 從文件佈局中刪除visibility: hidden 不會將元素所產生的 box 從文件佈局中刪除所以，如果將元素設定 display: none，就會影響到其他元素的佈局，而 visibility: hidden 就不會，因為就只是「真正」意義上的隱藏元素而已。visibility 屬性用於動態效果可以使用 JavaScript 控制哪個元素要顯示或是隱藏。下面是 visibility 屬性的動態效果範例：Demo：Codepen 連結See the Pen dynamic visibility by Titangene (@titangene) on CodePen.在一開始進入範例頁面時，A 元素是使用 visibility 的預設值 visible，而 B 元素是設定 visibility: hidden 隱藏元素。在此範例中，A 元素和 B 元素都是使用絕對定位，並設定在相同的位置，所以當要顯示一個元素，並隱藏另一個元素時，畫面的動態效果就很像是一個元素替換成另一個元素。CSS 樣式如下：12345.box &#123; position: absolute; top: 50px; left: 10px;&#125;範例中有兩個按鈕：點擊 A 按鈕會顯示 A 元素 (也就是顯示 “Name: A” )，並隱藏 B 元素 (也就是隱藏 “Name: B”)點擊 B 按鈕會顯示 B 元素 (也就是顯示 “Name: B” )，並隱藏 A 元素 (也就是隱藏 “Name: A”)顯示元素其實就是將元素設定成 visibility: visible，在 JavaScript 可以使用下面程式碼來設定：1element.style.visibility = 'visible'隱藏元素則是元素設定成 visibility: hidden，在 JavaScript 可以使用下面程式碼來設定：1element.style.visibility = 'hidden'這樣就可以實作出 A 和 B 元素切換的動態效果。此範例的完整原始碼如下：1234567&lt;div&gt; &lt;span&gt;choose one:&lt;/span&gt; &lt;button class=\"buttonA\"&gt;A&lt;/button&gt; &lt;button class=\"buttonB\"&gt;B&lt;/button&gt;&lt;/div&gt;&lt;div id=\"A\" class=\"box\"&gt;Name: A&lt;/div&gt;&lt;div id=\"B\" class=\"box\"&gt;Name: B&lt;/div&gt;1234567div, button &#123; font-size: 20px &#125;.box &#123; position: absolute; top: 50px; left: 10px;&#125;#B &#123; visibility: hidden; &#125;1234567891011121314151617181920var buttonA = document.querySelector('.buttonA');var buttonB = document.querySelector('.buttonB');function show(elementIdName) &#123; var element = document.getElementById(elementIdName); element.style.visibility = 'visible';&#125;function hide(elementIdName) &#123; var element = document.getElementById(elementIdName); element.style.visibility = 'hidden';&#125;buttonA.addEventListener('click', function() &#123; show('A'); hide('B');&#125;);buttonB.addEventListener('click', function() &#123; show('B'); hide('A');&#125;);JavaScript 跑錯棚啦 XD資料來源：CSS 2.2 - 11.2. Visibility: the visibility propertyCSS 2.2 - 17.5.5. Dynamic row and column effectsvisibility - CSS: Cascading Style Sheets | MDN","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - overflow","slug":"css-overflow","date":"2019-10-12T13:20:42.000Z","updated":"2020-02-09T14:58:18.000Z","comments":true,"path":"article/css-overflow.html","link":"","permalink":"https://titangene.github.io/article/css-overflow.html","excerpt":"本篇將介紹 CSS 的 overflow 屬性。","text":"本篇將介紹 CSS 的 overflow 屬性。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - overflow「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blogoverflow 的情境通常 block box 的內容僅限於 box 的 content edge。在某些情況下，box 可能會 overflow (溢出)，代表 box 的部分或全部內容都位於 box 的外面，例如：一行文字不換行，導致 line box 比 block box 還要寬在 containing block 裡面的 block-level box 的寬度比 containing block 還寬 (也就是當元素的 width 屬性值設定大於 containing block 的寬度時會發生)元素設定 height 屬性將 containing block 的高度設定成小於元素的內容高度 (也就是元素內容的高度大於 containing block 的高度，containing block 的高度由 height 屬性決定，而不是內容高度決定)descendant box 設定 position: absolute 時超出 containing blockdescendant box 將 margin 設為負值時超出 containing block設定 text-indent 屬性導致第一行 text 縮排超出 containing block下面根據上面這幾個狀況分別舉例，如以下範例：1234567891011121314151617181920212223242526272829&lt;h3&gt;一行文字不換行&lt;/h3&gt;&lt;div class=\"containing-block\"&gt; &lt;span class=\"inner not-wrap\"&gt;Lorem ipsum dolor sit, amet consectetur elit.&lt;/span&gt;&lt;/div&gt;&lt;h3&gt;裡面的 block-level box 太寬&lt;/h3&gt;&lt;div class=\"containing-block\"&gt; &lt;div class=\"inner box-too-wide\"&gt;block-level box is too wide&lt;/div&gt;&lt;/div&gt;&lt;h3&gt;內容太高&lt;/h3&gt;&lt;div class=\"containing-block\"&gt; &lt;div class=\"inner height-exceeds\"&gt;element's height exceeds&lt;/div&gt;&lt;/div&gt;&lt;h3&gt;絕對定位&lt;/h3&gt;&lt;div class=\"containing-block\"&gt; &lt;div class=\"inner absolute\"&gt;absolute&lt;/div&gt;&lt;/div&gt;&lt;h3&gt;margin 設為負值&lt;/h3&gt;&lt;div class=\"containing-block\"&gt; &lt;div class=\"inner negative-margins\"&gt;negative margins&lt;/div&gt;&lt;/div&gt;&lt;h3&gt;text-indent 屬性讓第一行 text 縮排超出&lt;/h3&gt;&lt;div class=\"containing-block\"&gt; &lt;div class=\"inner text-indent\"&gt;'text-indent' property&lt;/div&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031.containing-block &#123; width: 200px; height: 40px; outline: 2px solid; background-color: lightgray;&#125;.inner &#123; background-color: #8bf;&#125;.not-wrap &#123; white-space: nowrap;&#125;.box-too-wide &#123; width: 250px; height: 30px;&#125;.height-exceeds &#123; height: 60px;&#125;.absolute &#123; width: 60px; height: 30px; position: absolute; left: 190px;&#125;.negative-margins &#123; margin-right: -50px;&#125;.text-indent &#123; text-indent: 11.5rem;&#125;Demo：Codepen 連結See the Pen overflow 情境 by Titangene (@titangene) on CodePen.overflow 屬性下面是 overflow 屬性的定義表：此屬性指定 block container 元素的內容 overflow 元素 box 時是否被裁切。它會影響所有元素內容的裁切，但其 containing block 是該元素的 viewport 或 ancestor 的任何 descendant 元素 (及其各自的內容和 descendant) 除外。值具有以下含義：visible：內容沒有被裁切，也就是可以在 block box 外呈現hidden：內容被裁切，並且不應提供捲動 UI 來查看裁切區域之外的內容scroll：內容已被裁切，並且如果 UA 使用螢幕上可見的捲動機制 (例如：scroll bar 或 panner)，則無論該內容是否有內容，都應在 box 上顯示該機制被裁切。這避免了滾動條在動態環境中出現和消失的任何問題。指定此值且目標 medium 為 print 時，可能會列印出 overflow 的內容。在 table box 上使用時，此值與 visible 具有相同的含義auto：此值的行為取決於 UA，但應導致為 overflow 的 box 提供捲動機制。在 table box 上使用時，此值與 visible 具有相同的含義資料來源：話說 Overflow 是什麼呢？ - 每天來點 CSS Specification - iT 邦幫忙CSS 2.2 - 11. Visual effects","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Inline formatting context (IFC)","slug":"css-ifc","date":"2019-10-11T13:20:42.000Z","updated":"2020-02-09T14:56:04.000Z","comments":true,"path":"article/css-ifc.html","link":"","permalink":"https://titangene.github.io/article/css-ifc.html","excerpt":"本篇將介紹 CSS 的 inline formatting context (IFC)。","text":"本篇將介紹 CSS 的 inline formatting context (IFC)。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Inline formatting context (IFC)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog在 IFC 中，box 會從一個 containing block 的頂端開始一個接著一個的方式來水平排列，而 box 之間會受到水平的 margin、border 和 padding 影響，但不會被垂直的 margin、border 和 padding 所影響，如以下範例：12box 可以以不同的方式垂直對齊：它們的 bottom 或 top 可以對齊box 內的 text 的 baseline 可以對齊包含形成行 (line) 的 box 的矩形區域被稱為 line box，line box 的寬度是由 containing block 和 float 來決定，line box 的高度是由 line-heightUA 會將 inline-level box 排列 (flow) 至 line box 的垂直 stack 內，line box 的高度以下面方式來決定：計算 line box 中每個 inline-level box 的高度。對於 replaced 元素、inline-block 元素和 inline-table 元素，這是它們的 margin box 的高度。對於 inline box，這是它們的 line-height。inline box (inner display type 為 flow 的 non-replaced inline-level box) 的內容會參與跟該 inline box 本身相同的 IFCblock container 在某些情境下會建立新的 IFC：IFC 是由不包含 block-level box 的 block container 所建立的。當元素的 block container 只包含 inline-level content 時，block container 會建立新的 IFC，然後該元素還會產生一個 root inline box，該 root inline box 會 wrap 那些 inline content。root inline box 是一個 anonymous inline box，該 box 會自動產生可以容納 block container 的所有 inline-level content。有關 anonymous inline box 的詳情，可參閱我前幾天寫的「重新認識 CSS - Visual formatting model：Box generation (inline)」，內有提供實際範例說明，在此篇就不再追述。資料來源：CSS 2.2 - 9.4.2 Inline formatting contextsCSS Display Module Level 3CSS Inline Layout Module Level 3","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Block formatting context (BFC)","slug":"css-bfc","date":"2019-10-10T13:20:42.000Z","updated":"2020-02-09T14:55:28.000Z","comments":true,"path":"article/css-bfc.html","link":"","permalink":"https://titangene.github.io/article/css-bfc.html","excerpt":"本篇將介紹 CSS 的 block formatting context (BFC)。","text":"本篇將介紹 CSS 的 block formatting context (BFC)。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Block formatting context (BFC)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog以下是 MDN 對於在何種情境下會建立 BFC 的定義：以下情境會建立 BFC：文件中的 root 元素 (在 HTML 中是 html 元素)float 屬性不為 none 的元素position 屬性為 absolute 或 fixed 的元素display 屬性為 inline-block、flow-root、table-cell 或 table-caption 的元素由 display 屬性為 table、table-row、table-row-group、table-header-group、table-footer-group 或 inline-block 的元素 implicitly 建立的 anonymous table celloverflow 屬性不為 visible 的 block 元素contain 屬性為 layout、content 或 paint 的元素flex item ( display 屬性為 flex 或 inline-flex 的元素的子元素)grid item ( display 屬性為 grid 或 inline-grid 的元素的子元素)multicol container ( column-count 或 column-width 屬性不為 auto 的元素，包含 column-count: 1 的元素)column-span: all 應該始終建立一個新的 formatting context，即使該元素沒有包含在 multicol container 中float 的定位和 clear 規則都只會適用於同一個 BFC 中的內容：float 屬性不會影響其他 BFC 中的內容佈局clear 屬性只能 clear 同一個 BFC 中有設定 clear 屬性的元素之前的 float 元素，不會影響到元素本身內部或其他 BFC 中的 float 元素當兩個 block 都在同一個 BFC 時，它們的 margin 才會發生 margin collapsing。資料來源：Block formatting context - Developer guides | MDN","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - formatting context & independent formatting context","slug":"css-formatting-context","date":"2019-10-09T13:20:42.000Z","updated":"2020-02-09T14:54:19.000Z","comments":true,"path":"article/css-formatting-context.html","link":"","permalink":"https://titangene.github.io/article/css-formatting-context.html","excerpt":"本篇將介紹 CSS 的 formatting context 和 independent formatting context。","text":"本篇將介紹 CSS 的 formatting context 和 independent formatting context。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - formatting context &amp; independent formatting context「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blogformatting context看一下在不同 CSS level 的 spec 中是如何定義 formatting context。在 CSS 2.1 內的「9.4 Normal flow」 是這樣定義 formatting context：Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. Block-level boxes participate in a block formatting context. Inline-level boxes participate in an inline formatting context.也就是說，在 CSS 2.1 定義 normal flow 中的 box 屬於某種 formatting context，可是 block 或 inline，但不能同時使用。而不同的 box 會參與不同的 formatting context：block-level box 會參與 BFC (block formatting context)inline-level box 會參與 IFC (inline formatting context)但是在 CSS 2.2 內的同一個章節中，將定義改成以下內容：Boxes in the normal flow belong to a formatting context, which in CSS 2.2 may be table, block or inline. In future levels of CSS, other types of formatting context will be introduced. Block-level boxes participate in a block formatting context. Inline-level boxes participate in an inline formatting context. Table formatting contexts are described in the chapter on tables.資料來源：CSS 2.2 - Appendix C. Changes也就是說，在 CSS 2.2 定義 formatting context 可以是 table、block 或 inlline，並且說明在將來的 CSS level 會引入其他 type 的 formatting context。另外也可以看到在 CSS 2.2 刪掉了 CSS 2.1 中的 “but not both simultaneously” 這句，也就是其實 BFC 和 IFC 可以同時使用。後來在 CSS Display Module Level 3 內也有定義 formatting context：A formatting context is the environment into which a set of related boxes are laid out. Different formatting contexts lay out their boxes according to different rules. For example, a flex formatting context lays out boxes according to the flex layout rules [CSS3-FLEXBOX], whereas a block formatting context lays out boxes according to the block-and-inline layout rules [CSS2].也就是說，formatting context 是一種環境，相關的 box 會在此環境中佈局，不同的 formatting context 會根據不同的規則來佈局這些的 box。例如：BFC (block formatting context) 會根據 block 和 inline 佈局規則來佈局 boxFFC (flex formatting context) 會根據 flex 佈局規則來佈局 boxGFC (grid formatting context) 會根據 grid 佈局規則來佈局 boxindependent formatting context一個 box 有兩種選擇：建立一個新的 independent formatting context繼續參與該 box 的 containing block 的 formatting context而 box 建立的 formatting context 的 type 是由其 inner display type 來決定。例如：grid container 建立新的 GFC (grid formatting context)ruby container 建立新的 RFC (ruby formatting context)block container 可以建立新的 BFC 和/或新的 IFC詳情可參閱 Spec 中的 display 屬性表格。(安麗自己的 display 文章)資料來源：CSS 2.1 - 9.4. Normal flowCSS 2.2 - 9.4. Normal flowCSS Display Module Level 3","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - float","slug":"css-float","date":"2019-10-08T13:20:42.000Z","updated":"2020-02-09T14:52:54.000Z","comments":true,"path":"article/css-float.html","link":"","permalink":"https://titangene.github.io/article/css-float.html","excerpt":"本篇將介紹 CSS 的 float 屬性。","text":"本篇將介紹 CSS 的 float 屬性。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - float「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog原本 float 屬性是為了可以實作出簡單的文書排版，例如：報紙中的文繞圖。如下圖：圖片來源：Wikipediafloat 的特性box 會先根據 normal flow 來佈局，然後 box 會脫離 normal flow，並將 box 在該行 (current line) 向左或向右移動，直到 box 的外邊緣 (outer edge) 接觸到 containing block 的邊緣或另一個 float 的外邊緣。float box 的外部頂端 (outer top) 與當前 line box 的頂端對齊。如果水平空間沒有空間可以 float，就會將 box 向下移動，直到有適合 (fits) 的空間或不再有 float 為止。因為 float box 脫離了 normal flow，所以在 float box 之前和之後建立的 non-positioned block box 會以垂直排列，就很像 float box 不存在一樣。跟 float 元素在同一個 line box 或之後的 line box 都會因 float 元素而縮短 (shortened) line box，如果 float 元素有設定 margin，line box 也會縮短 margin box 所佔用的空間。當垂直位置滿足以下所有四個條件時，line box 會與 float 相鄰：在 line box 頂端或之下在 line box 底部或之上在 float 的 top margin edge 之下在 float 的 bottom margin edge 之上而 float box 的內容會沿著 float box 的那一側排列 (flow along its side)，可以透過 clear 屬性來禁止此行為：float: left：內容從 left-floated box 的右側往下排列float: right：內容從 right-floated box 的左側往下排列float box 不會縮短 line box 的情況以下狀況 float box 不會縮短 line box：外部高度 (outer height) 為 0外部高度為負數直接看範例，下面是外部高度為負數的範例：1234&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;floats with negative outer height not shorten line box&lt;/div&gt; &lt;p&gt;Lorem ipsum dolor sit...&lt;/p&gt;&lt;/div&gt;123456789101112131415.container &#123; width: 400px; outline: 3px solid black; font-size: 20px; color: #999;&#125;.box &#123; width: 300px; height: 100px; margin: 20px 20px -150px 20px; background-color: lightblue; color: red; float: left; font-size: 30px;&#125;Demo：Codepen 連結.box 元素：height 為 100pxmargin-top 為 20pxmargin-bottom 為 -150px所以 .box 元素的外部高度計算為 100 + 20 - 150 = -10px，因此外部高度為負數。如下圖結果，就算 .box 元素有設定 float: left 也不會縮短 line box：See the Pen floats with negative outer height not shorten line box by Titangene (@titangene) on CodePen.接著是外部高度為 0 的範例：1234&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;floats with zero outer height not shorten line box&lt;/div&gt; &lt;p&gt;Lorem ipsum dolor sit...&lt;/p&gt;&lt;/div&gt;123456789101112.container &#123; width: 400px; outline: 3px solid black; font-size: 24px; color: #999;&#125;.box &#123; height: 0; color: red; float: left; font-size: 36px;&#125;Demo：Codepen 連結因為 .box 元素的 height 為 0，而且也沒有設定 margin，所以 .box 元素的外部高度為 0。如下圖結果，就算 .box 元素有設定 float: left 也不會縮短 line box：See the Pen floats with zero outer height not shorten line box by Titangene (@titangene) on CodePen.","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - position","slug":"css-position","date":"2019-10-07T13:20:42.000Z","updated":"2020-02-09T14:49:38.000Z","comments":true,"path":"article/css-position.html","link":"","permalink":"https://titangene.github.io/article/css-position.html","excerpt":"本篇將介紹 CSS 的 position 屬性，包括 static、relative、absolute 和 fixed。","text":"本篇將介紹 CSS 的 position 屬性，包括 static、relative、absolute 和 fixed。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - position「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogPositioning schemes (定位方案)在 CSS 2.2 中，可根據三種定位方案對 box 進行佈局：Normal flow：block-level box 的 block formattinginline-level box 的 inline formattingblock-level 和 inline-level box 的相對定位Float：在 float model 中，box 會先根據 normal flow 來佈局，然後 box 會被移出 flow，並儘可能的向左或向右移動。內容可能會沿著 float 的那一側排列 (Content may flow along the side of a float.)絕對定位：在絕對定位 model 中，box 會從 normal flow 中完全刪除 (它不會影響到以後的 sibling)，並根據 containing block 來分配位置如果一個元素是 float 的、絕對定位的或者是 root 元素，則該元素被稱為 out of flow。如果元素不是 out of flow，則稱為 in-flow。position 屬性下面是 position 屬性的定義表：圖片來源：CSS 2.2 - 9.3.1. Choosing a positioning scheme: position propertystaticbox 是 normal box，按照 normal flow 來佈局top、right、bottom 和 left 屬性不適用relativebox 的位置是根據 normal flow 來計算的 (這稱為 normal flow 中的位置)，然後 box 相對於其正常位置 (normal position) 偏移當 box B 相對定位時，計算下一個 box 的位置，就好像 B 沒有偏移一樣position:relative 對 table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-column、table-cell、table-caption 元素的影響未定義absolutebox 的位置 (可能還有大小) 由 top、right、bottom 和 left 屬性指定這些屬性指定相對於 box 的 containing block 的偏移量絕對定位的 box 會從 normal flow 中取出，也就是說它們不會影響到以後的 sibling 的佈局同樣，儘管絕對定位的 box 具有 margin，但它們不會與其他 margin 發生 collapsing marginfixedbox 的位置是根據 absolute model 計算得出的，但除此之外，該 box 相對於某些參考是 fixed (固定的)與 absolute model 一樣，box 的 margin 不會與其他任何 margin 一起 collapse當 media type 為 screen 時，該 box 相對於 viewport 是 fixed，捲動時不會移動資料來源：CSS 2.2 - 9. Visual formatting model","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - display","slug":"css-display","date":"2019-10-06T13:20:42.000Z","updated":"2020-02-09T14:46:39.000Z","comments":true,"path":"article/css-display.html","link":"","permalink":"https://titangene.github.io/article/css-display.html","excerpt":"本篇將介紹 CSS 中的各種 display 屬性值。","text":"本篇將介紹 CSS 中的各種 display 屬性值。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - display「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blogdisplay 屬性block：使元素產生 principal block boxinline-block：使元素產生 principal inline-level block container (inline-block 的內部被格式化為 block box，元素本身被格式化為 atomic inline-level box)inline：使元素產生一個或多個 inline boxlist-item：使元素 (例如：HTML 中的 li 元素) 產生 principal block box 和 marker box。有關列表的資訊和列表格式 (list formatting) 的範例，請參閱列表的部分none：使元素不會出現在 formatting structure 中 (也就是在 visual media 中，該元素不產生任何 box 且對佈局沒有影響)descendant 元素也不產生任何 box元素及其內容將從 formatting structure 中完全刪除如果元素設為 display: none 時，其 descendant 元素無法用其他 display 屬性值來覆蓋父元素的 display 設定請注意，display: none 不會建立不可見的 box；它根本不會建立任何 box。CSS 包括使元素能夠在 formatting structure 中產生影響 formatting 但本身不可見的 box 的機制。有關詳細資訊，請查閱 visibility 部分table、inline-table、table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-column、table-cell、table-caption：使元素的行為類似於表格元素除了定位元素、float 元素 (請參閱 display、position 和 float 之間的關係) 和 root 元素之外，computed value 與 specified value 相同。對於 root 元素，computed value 將按照 display、position 和 float 之間的關係部分中所述進行變更。請注意，儘管 display 的 initial value 為 inline，但 UA 的預設樣式表中的規則可能會覆蓋該值。請參閱附錄中的 HTML 4 範例樣式表。資料來源：CSS 2.2 - 9.2.4. The display propertyCSS Display Module Level 3","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Visual formatting model：Box generation (inline box)","slug":"css-box-generation-inline-box","date":"2019-10-05T13:20:42.000Z","updated":"2020-02-09T14:43:36.000Z","comments":true,"path":"article/css-box-generation-inline-box.html","link":"","permalink":"https://titangene.github.io/article/css-box-generation-inline-box.html","excerpt":"在 visual formatting model 中，document tree 中的每個元素都會根據 box model 生成 0 個或多個 box，box 分為兩種不同的 type：block 和 inline。本篇將介紹 inline box。","text":"在 visual formatting model 中，document tree 中的每個元素都會根據 box model 生成 0 個或多個 box，box 分為兩種不同的 type：block 和 inline。本篇將介紹 inline box。使用 display 屬性可以決定 box 的 type，不同的 box type 會影響 UA 在 visual formatting model 中要如何去佈局，之前介紹了 block 部份，本篇會來介紹 inline 部份。如果想瞭解 block 部份，可參閱在此系列中的另一篇「重新認識 CSS - Visual formatting model：Box generation (block)」。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Visual formatting model：Box generation (inline box)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogInline-level elements and inline boxesinline-level 元素：source document 中不構成新內容的 block 的元素 (例如：段落內的 em 元素)內容以 line 分佈 (例如：段落內的強調 (emphasized) text 片段、inline 圖片等)產生 inline-level box 的元素當元素的 display 屬性值為 inline、inline-table 或 inline-block 時，則該元素就會成為 inline-level 元素inline-level box：參與 IFC 的 boxinline box：既是 inline-level box，且該 box 的內容會參與該 box 的 containing IFC 的 boxdisplay 屬性值為 inline 的 non-replaced 元素會產生 inline boxatomic inline-level box：不是 inline box 的 inline-level box，作為 single opaque (不透明) box 參與該 box 的 IFC，例如：replaced inline-level 元素inline-block 元素 (元素會產生 principal inline-level block container，inline-block 的內部會被格式化為 block box，元素本身會被格式化為 atomic inline-level box)inline-table 元素 (參與 IFC 的 rectangular block)如下圖：Anonymous inline boxes任何直接包含在 block container 元素內 (不在 inline 元素內) 的 text 都必須被視為 anonymous inline 元素。例如：1&lt;p&gt;Some &lt;em&gt;emphasized&lt;/em&gt; text&lt;/p&gt;p 元素產生 block box，其中包含幾個 inline box：“emphasized” 文字的 box 是由 inline 元素 (也就是 em 元素) 產生的 inline box其他 box (“Some” 和 “text”) 都是由 block-level 元素 (也就是 p 元素) 產生的 inline box而此 box 被稱為 anonymous inline box，因為它們都沒有關聯 (associated) 的 inline-level 元素此類的 anonymous inline box 從其 block parent box 繼承可繼承的屬性。非繼承屬性具有其 initial value。在此範例中，anonymous inline box 的 color 會繼承至 p 元素，但是 background 會是透明的。本文的內容主要是依據 CSS 2.2 中的定義來說明，如有錯誤之處，歡迎告知，感謝 😃。資料來源：CSS 2.2 - 9.2. Controlling box generationCSS Display Module Level 3視覺格式化模型-Box generation(中) - iT 邦幫忙Visual Formatting Model - inline - iT 邦幫忙","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Visual formatting model：Box generation (block box)","slug":"css-box-generation-block-box","date":"2019-10-04T13:20:42.000Z","updated":"2020-02-09T14:42:27.000Z","comments":true,"path":"article/css-box-generation-block-box.html","link":"","permalink":"https://titangene.github.io/article/css-box-generation-block-box.html","excerpt":"在 visual formatting model 中，document tree 中的每個元素都會根據 box model 生成 0 個或多個 box，box 分為兩種不同的 type：block 和 inline。本篇將介紹 block box。","text":"在 visual formatting model 中，document tree 中的每個元素都會根據 box model 生成 0 個或多個 box，box 分為兩種不同的 type：block 和 inline。本篇將介紹 block box。使用 display 屬性可以決定 box 的 type，不同的 box type 會影響 UA 在 visual formatting model 中要如何去佈局，本篇來介紹 block 部份，之後則會介紹 inline 部份。如果想瞭解 inline 部份，可參閱在此系列中的另一篇「重新認識 CSS - Visual formatting model：Box generation (inline)」。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Visual formatting model：Box generation (block box)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogBlock-level 元素 &amp; block boxesblock-level 元素：source document 中以視覺化的方式格式化為 block 的元素 (例如：p 元素)產生 block-level principal box 的元素當元素的 display 屬性值為 block、list-item 或 table 時，該元素就會成為 block-level 元素block-level box：參與 BFC 的 boxblock container 元素：當該元素的 principal box 是 block container box 時，則該元素為 block container 元素block container box：block container 要麼只包含參與 IFC 的 inline-level box，要麼只包含參與 BFC 的 block-level box (可能會產生 anonymous block box 以確保此約束，後面會介紹)只包含 inline-level content 的 block container 會建立新的 IFC，然後該元素還會產生一個 root inline box，該 root inline box 會 wrap 那些 inline content當 non-replaced 元素的 display 屬性值為 block、list-item 或 inline-block 時，該元素會產生 block container box註：root inline box 的概念是在 CSS Display Module Level 3 中提出的，此概念取代了在 CSS 2 中提到的 anonymous inline box。不是所有的 block container box 都是 block-level box，例如以下這些都是 block container box，而不是 block-level box：non-replaced inline blocknon-replaced table cell相反的，不是所有的 block-level box 都是 block container box，例如以下這些都是 block-level box，而不是 block container box：block-level replaced 元素 ( display: block )flex container ( display: flex )table boxreplaced 元素的 principal boxBlock-level boxes that are also block containers are called block boxes.The three terms “block-level box,” “block container box,” and “block box” are sometimes abbreviated as “block” where unambiguous.也就是說，若 box 同時為 block container box 和 block-level box 時，可被稱為 block box，此時也可被簡稱為 “block”。如下圖：Anonymous block boxes直接看範例，假設 div 元素和 p 元素都是 display：block，div 元素內有 inline 內容和 block 內容：1234&lt;div&gt; Some text &lt;p&gt;More text&lt;/p&gt;&lt;/div&gt;上圖說明匿名 block box 如何在匿名內容的周圍出現。div 元素產生 block container box，裡面有一個 block-level box (也就是範例中的 p 元素所產生的)，那就會強制在 block container box 裡面只會有 block-level box。所以在 div 的 box 內有兩個包含 text 的矩形 box：第一個是 anonymous block box，內容為 “Some text”第二個是 p 元素的 box，內容為 “More text”本文的內容主要是依據 CSS 2.2 中的定義來說明，如有錯誤之處，歡迎告知，感謝 😃。資料來源：CSS 2.2 - 9.2. Controlling box generationCSS Display Module Level 3","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Containing block","slug":"css-containing-block","date":"2019-10-03T13:20:42.000Z","updated":"2020-02-09T14:38:11.000Z","comments":true,"path":"article/css-containing-block.html","link":"","permalink":"https://titangene.github.io/article/css-containing-block.html","excerpt":"本篇將介紹 CSS 的 Containing block。","text":"本篇將介紹 CSS 的 Containing block。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Containing block「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogContaining block下面是 CSS 2.2 對於 containing block 的定義：In CSS 2.2, many box positions and sizes are calculated with respect to the edges of a rectangular box called a containing block. In general, generated boxes act as containing blocks for descendant boxes; we say that a box “establishes” the containing block for its descendants. The phrase “a box’s containing block” means “the containing block in which the box lives,” not the one it generates.很多 box 的位置和大小都是根據某種矩形框 (rectangular box) 來計算的，在 CSS 定義中，就將此 box 稱為 containing block。通常會把產生的 box 作為 descendant box 的 containing block，也就是說一個 box 會為它的 descendant 建立 containing block。當我們在說 “一個 box 的 containing block” 是代表 “box 所在的 containing block”，而不是該 box 所產生的 containing block。元素的 containing block 定義如下：root 元素 (也就是 &lt;html&gt; ) 所在的 containing block 是一個被稱為 initial containing block 的矩形。對於 continuous media 來說，containing block 的尺寸是由 viewport 的尺寸，並且被固定 (anchored) 在 canvas 的開始位置 (origin)；對於 paged media 來說，containing block 的尺寸就是 page area當其他元素的 position 屬性為 relative 或 relative 時，containing block 是由最近的 ancestor box 的 content edge 所構成，該 ancestor box 是 block container 或建立了 formatting context如果元素為 position: fixed 時，則在 continuous media 的情況下由 viewport 建立 containing block，在 paged media 的情況下由 page area 建立 containing block如果元素為 position: absolute 時，則 containing block 是由最近的 position 屬性為 absolute、relative 或 relative 的 ancestor 建立，方法如下：如果該 ancestor 是 inline 元素時，containing block 是為該元素產生的第一個和最後一個 inline box 的 padding box 周圍的 bounding box (邊界框)。在 CSS 2.2 中，如果將 inline 元素分割 (split across) 為多行時，則 containing block 未定義否則，containing block 是由該 ancestor 的 padding edge 所構成如果沒有這樣的 ancestor，則 containing block 就是 initial containing block雖然每個 box 都會根據其 containing block 來決定位置，但不會被 containing block 所限制，可能會發生 overflow。當發生 overflow 時，可以使用 CSS 提供的 overflow 屬性來處理，這在之後會提到。有關 overflow 的詳情，可參閱我之後寫的「重新認識 CSS - overflow」。資料來源：CSS 2.2 - 9.1.2. Containing blocksCSS 2.2 - 10.1. Definition of “containing block”","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Collapsing margins","slug":"css-collapsing-margins","date":"2019-10-02T11:50:42.000Z","updated":"2020-02-09T14:39:34.000Z","comments":true,"path":"article/css-collapsing-margins.html","link":"","permalink":"https://titangene.github.io/article/css-collapsing-margins.html","excerpt":"兩個 box 之間的 margin 相鄰 (adjoining) 時，可能會讓 margin 發生合併，這個現象就被稱為 collapsing margin，而合併的 margin 就被稱為 collapsed margin。","text":"兩個 box 之間的 margin 相鄰 (adjoining) 時，可能會讓 margin 發生合併，這個現象就被稱為 collapsing margin，而合併的 margin 就被稱為 collapsed margin。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Collapsing margins「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog兩個 box 之間的 margin 相鄰 (adjoining) 時，可能會讓 margin 發生合併，這個現象就被稱為 collapsing margin，而合併的 margin 就被稱為 collapsed margin。在下列這些情況會發生 collapsing margin：兩個 block 都是 in-flow block-level box，且參與相同的 BFC兩個 block 沒有 line box、clearance、padding 或沒有 border 將它們的 margin 隔開垂直相鄰的 box edge：box 的 margin-top 和第一個 in-flow 子元素的 margin-topbox 的 margin-bottom 和下一個 in-flow 之後的 sibling 的 margin-top最後一個 in-flow 子元素的 margin-bottom 和其父元素的 margin-bottom，且父元素的高度為 auto未建立新的 BFC，且 min-height 為 0、height 為 auto，且沒有 in-flow children 的 box 的 margin-top 和 margin-bottom而下面這些情況不會發生 collapsing margin：root 元素的 box 的 margin有 clearance水平的 margin建立新的 BFC (block formatting context) 的元素的 margin 不會與 in-flow 的子元素 collapse，例如：float 的元素、overflow 屬性值不為 visible 的元素position: absolute 的元素的 margininline-block box 的 margin資料來源：CSS 2.2 - 8.3.1 Collapsing margins","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - box-sizing","slug":"css-box-sizing","date":"2019-10-01T11:30:15.000Z","updated":"2020-02-09T14:35:36.000Z","comments":true,"path":"article/css-box-sizing.html","link":"","permalink":"https://titangene.github.io/article/css-box-sizing.html","excerpt":"本篇將介紹 box-sizing 屬性是如何設定計算元素的總寬度和總高度。","text":"本篇將介紹 box-sizing 屬性是如何設定計算元素的總寬度和總高度。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。本文同步發表於 iT 邦幫忙：重新認識 CSS - box-sizing在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog下圖是 box-sizing 屬性的定義：可以看到 box-sizing 屬性能用在任何元素，而且初始值為 content-box。在 CSS box model 中，對元素指定寬度和高度會應用於 content box，如果又在該元素設定 border 或 padding 時，在視覺上會很像是增加元素的大小。也就是說當你想要讓該元素為某寬度或高度時，需要自行手動減去 border 或 padding 所佔用的空間，才能讓元素符合原本預期的寬高。例如：12&lt;div class=\"box-1\"&gt;&lt;/div&gt;&lt;div class=\"box-2\"&gt;&lt;/div&gt;1234567891011121314.box-1 &#123; width: 100px; height: 100px; background-color: lightgreen; margin: 10px;&#125;.box-2 &#123; width: 100px; height: 100px; background-color: rgba(0, 0, 0, .4); padding: 10px; border: 10px solid; margin: 10px;&#125;如下圖，.box-1 元素和 .box-2 元素的 width 和 height 都一樣 (都是 100px)：但是可以看出這兩個元素的大小明顯不同，這是因為 .box-2 元素比 .box-1 元素多了 padding 和 border：各元素在視覺上所佔用的空間：.box-1 元素：寬：width (100px)高：height (100px).box-2 元素：寬佔用：border-left-width (10px) + padding-left (10px) + width (100px) + padding-right (10px) + border-right-width (10px) = 140px高佔用：border-top-height (10px) + padding-top (10px) + height (100px) + padding-bottom (10px) + border-bottom-height (10px) = 140px如果要 .box-2 元素要保留 border 和 padding，又要只佔用寬度和高度各 100px 就只能手動減去 border 或 padding，以上面範例就會改成這樣：12345678.box-2 &#123; width: 60px; height: 60px; background-color: rgba(0, 0, 0, .4); padding: 10px; border: 10px solid; margin: 10px;&#125;雖然在視覺上，.box-1 元素和 .box-2 元素所佔用的空間變成一樣了，但是要自行計算 width 和 height 會很麻煩。這時就可以改用 box-sizing: border-box，它就會幫你自動計算扣除 border 或 padding 所剩餘的空間，應用在 content width 和 content height。123456789.box-2 &#123; width: 100px; height: 100px; background-color: rgba(0, 0, 0, .4); padding: 10px; border: 10px solid; box-sizing: border-box; margin: 10px;&#125;如下圖，不用修改 width 和 height 就可以達到預期的效果：content-box：box-sizing 屬性的初始值指定的寬度和高度 (以及對應的最小/最大屬性) 分別應用於元素 content box 的寬度和高度各種 box-sizing reset 方法舊的 box-sizing reset 方法使用 universal selector 選擇所有元素，並將所有元素都設為 box-sizing: border-box。這個方法雖然可以對所有元素做設定，但沒有對 pseudo-element 設定 box-sizing：123* &#123; box-sizing: border-box;&#125;例如：123&lt;div class=\"container\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;1234567891011121314151617181920212223* &#123; box-sizing: border-box;&#125;.container &#123; width: 400px; padding: 10px; border: 10px solid gray;&#125;.child &#123; width: 300px; height: 100px; padding: 10px; border: 10px solid lightblue; margin-bottom: 10px;&#125;.container::after &#123; content: ''; display: block; width: 300px; height: 100px; padding: 10px; border: 10px solid lightgreen;&#125;Demo：Codepen 連結如下圖，pseudo-element 的 box-sizing 還是預設值 content-box，所以 content box 的寬為 300px，高為 100px：selector 詳情可參考我前幾天寫的：重新認識 CSS - CSS Selector (前傳)重新認識 CSS - Pseudo-element (偽元素)Universal box-sizing後來也使用 universal selector 來選擇 pseudo-element：123*, *::before, *::after &#123; box-sizing: border-box;&#125;若延續前面的範例，就可以看到 pseudo-element 也使用了 box-sizing: border-box：繼承 box-sizing剛剛的方法看似可行，但忽略了有些地方還是有 box-sizing: content-box 的需求：如果想要讓所有元素都使用 box-sizing: border-box，最常見的作法是在 html 元素上設定 box-sizing 屬性，而所有其他元素則是使用 inherit 這個關鍵字來繼承該值：123456html &#123; box-sizing: border-box;&#125;*, *::before, *::after &#123; box-sizing: inherit;&#125;資料來源：CSS Basic User Interface Module Level 3 (CSS3 UI) - 3.1. Changing the Box Model: the box-sizing property","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Box model：border","slug":"css-border","date":"2019-09-30T11:30:15.000Z","updated":"2020-02-09T14:31:10.000Z","comments":true,"path":"article/css-border.html","link":"","permalink":"https://titangene.github.io/article/css-border.html","excerpt":"本篇將介紹 CSS 的 Box model 中的 border。","text":"本篇將介紹 CSS 的 Box model 中的 border。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Box model：border「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogBorder widthborder width 屬性指定 border area 的寬度。border-top-width、border-right-width、border-bottom-width、border-left-width 屬性：initial value：mediumcomputed value：absolute length；如果 border 樣式為 none 或 hidden，則為 0border-width 是下列屬性的簡寫屬性：border-top-widthborder-right-widthborder-bottom-widthborder-left-width此屬性引用的 &lt;border-width&gt; value type 可在以下幾個當中選一個使用：thinmediumthick&lt;length&gt;：指定明確的屬性值，border width 不能使用負數前三個值的解譯 (interpretation) 方式取決於 UA。但是，必須滿足以下關係：thin &lt;= medium &lt;= thick。例如：1234h1 &#123; border-width: thin; &#125; /* thin thin thin thin */h1 &#123; border-width: thin thick; &#125; /* thin thick thin thick */h1 &#123; border-width: thin thick medium; &#125; /* thin thick medium thick */h1 &#123; border-width: thin thick medium thin; &#125; /* thin thick medium thin */Border colorborder color 屬性指定 box 的 border 的顏色。border-top-color、border-right-color、border-bottom-color、border-left-color 屬性：initial value：color 屬性值computed value：color 屬性的 computed value，否則使用指定的顏色border-color 是下列屬性的簡寫屬性：border-top-colorborder-right-colorborder-bottom-colorborder-left-colorborder-color 屬性設定四個 border 的顏色。value 具有以下含義：&lt;color&gt;：指定顏色值transparent：透明的 border (就算有設定 border 寬度也會是透明的)如果未使用 border 屬性指定元素的 border 顏色，則 UA 必須使用元素的 color 屬性的值作為 border 顏色的 computed value。例如：實線 (solid) 的 border：12345p &#123; color: black; background: white; border: solid;&#125;Border styleborder 樣式屬性指定 box 的 border 的 line 樣式。border-top-style、border-right-style、border-bottom-style、border-left-style 屬性：initial value：none，也就是除非有設定 border 樣式，否則不會顯示任何 bordercomputed value：specified valueborder-style 是下列屬性的簡寫屬性：border-top-styleborder-right-styleborder-bottom-styleborder-left-style此屬性引用的 &lt;border-width&gt; value type 可在以下幾個當中選一個使用：none、hidden、dotted、dashed、solid、double、groove、ridge、inset、outset。樣式如下圖：Demo：Codepen 連結See the Pen border style by Titangene (@titangene) on CodePen.四個方位的 border 設定就如之前所說，border-width、border-color、border-style 和 border 屬性都可以設定 1 至 4 個值，分別代表：1234屬性: 上下左右;屬性: 上下 左右;屬性: 上 左右 下;屬性: 上 右 下 左;例如：水平 border 為 solid垂直 border 為 dotted1h1 &#123; border-style: solid dotted; &#125;詳情可參考我之前寫的「重新認識 CSS - Box model (前傳)」，內有使用 1 至 4 個值的實際範例，因此在此不再追述。資料來源：CSS 2.2 - 8. Box modelCSS Backgrounds and Borders Module Level 3 - 4. Borders","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Box model","slug":"css-box-model","date":"2019-09-29T11:30:15.000Z","updated":"2020-02-09T14:29:50.000Z","comments":true,"path":"article/css-box-model.html","link":"","permalink":"https://titangene.github.io/article/css-box-model.html","excerpt":"在佈局 document 時，UA 的渲染引擎會根據 CSS box model 將每個元素表示為一個矩形框 (rectangular box)。CSS 會確定這些 box 的大小、位置和屬性 (顏色、背景、border 大小…等)。本篇將介紹 CSS 的 Box model。","text":"在佈局 document 時，UA 的渲染引擎會根據 CSS box model 將每個元素表示為一個矩形框 (rectangular box)。CSS 會確定這些 box 的大小、位置和屬性 (顏色、背景、border 大小…等)。本篇將介紹 CSS 的 Box model。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Box model「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog每個 box 都是由下面這四個區域 (area) 所組成：content area (例如：文字、圖片 … 等)padding areaborder areamargin area這些區域 (area) 都是由各邊緣 (edge) 所定義：content edge環繞著由 box 的 width 和 [height] 指定的矩形 (rectangle)通常取決於元素的 render 內容padding edgepadding edge 環繞著 box padding如果 padding 為 0 時，那 padding edge 也是 content edgeborder edgeborder edge 環繞著 box border如果 border 為 0 時，那 border edge 也是 content edgemargin edgemargin edge 環繞著 box margin如果 margin 為 0 時，那 margin edge 也是 content edge如下圖：用 Chrome DevTools (開發者工具) 也可以看到 box model：上圖中的各種顏色由外而內分別為：白色：position (與 box model 無關，之後會介紹此部份)橘色：margin黃色：border綠色：padding藍色：content圖片來源：CSS Box Model Module Level 3margin、border 和 padding 可分為 top、right、bottom 和 left 四個部份，可用各自的 CSS 屬性來設定，語法都很類似。如果要各別指定上下左右，下面以 padding 的語法為例：1234padding-top: 10px;padding-right: 20px;padding-bottom: 30px;padding-left: 40px;如果要同時設定多個部份，可以使用簡寫屬性來設定，語法如下：1234屬性: 上下左右;屬性: 上下 左右;屬性: 上 左右 下;屬性: 上 右 下 左;下面以 padding 這個簡寫屬性為例，只在此簡寫屬性指定 1 個屬性值時，代表同時指定 padding 的上下左右部份，例如：1padding: 10px;等同於：1234padding-top: 10px;padding-right: 10px;padding-bottom: 10px;padding-left: 10px;如果在簡寫屬性指定 2 個屬性值時，代表分別指定 padding 的上下、左右部份，例如：1padding: 10px 20px;等同於：1234padding-top: 10px;padding-right: 20px;padding-bottom: 10px;padding-left: 20px;如果在簡寫屬性指定 3 個屬性值時，代表分別指定 padding 的上、左右和下部份，例如：1padding: 10px 20px 30px;等同於：1234padding-top: 10px;padding-right: 20px;padding-bottom: 30px;padding-left: 20px;如果在簡寫屬性指定 4 個屬性值時，代表分別指定 padding 的上、右、下、左部份 (以順時針的方向會比較好記憶)，例如：1padding: 10px 20px 30px 40px;等同於：1234padding-top: 10px;padding-right: 20px;padding-bottom: 30px;padding-left: 40px;contentcontent area (例如：文字、圖片 … 等)content area 的大小：content width 和 content height，取決於幾個因素：生成該 box 的元素是否設定了 width 或 height 屬性該 box 是否包含 text 或其它 box該 box 是不是表格… 等通常有 background-color 或 background-image資料來源：CSS 2.2 - 8. Box modelCSS Box Model Module Level 3前端新手村 垂直排列 與 Box Model","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - @import","slug":"css-import","date":"2019-09-28T11:30:15.000Z","updated":"2020-02-09T14:22:38.000Z","comments":true,"path":"article/css-import.html","link":"","permalink":"https://titangene.github.io/article/css-import.html","excerpt":"CSS 的 @import 規則可以從其他 style sheet 中 import 樣式規則，本篇將介紹如何使用。","text":"CSS 的 @import 規則可以從其他 style sheet 中 import 樣式規則，本篇將介紹如何使用。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。本文同步發表於 iT 邦幫忙：重新認識 CSS - @import在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog@import 語法@import 語法有兩種寫法：url() 內包含 style sheet 的 URI直接寫 style sheet 的 URI 的字串例如：12@import \"mystyle.css\";@import url(\"mystyle.css\");解析語法錯誤處理如果 @import 規則符合下面任一項，UA 就會忽略該 @import 規則：在其他所有規則之後使用 @import 規則 ( @charset 規則除外)在 block 內使用 @import 規則，例如：在 @media block 內使用在其他所有規則之後使用 @import例如：如果 CSS 2.2 parser 遇到以下 style sheet：123@import \"subs.css\";h1 &#123; color: blue &#125;@import \"list.css\";根據 CSS 2.2 規範，上面範例中的第二個 @import 規則 (也就是 @import &quot;list.css&quot;; ) 會無效，因為 @import 必須寫在其他規則的前面，所以 CSS 2.2 parser 會忽略第二個 @import 規則，最後會將 style sheet 縮減以下這樣：12@import \"subs.css\";h1 &#123; color: blue &#125;在 block 內使用 @import例如：如果只想在 print media 上 import style sheet，第二個 @import 規則 (也就是 @import &quot;print-main.css&quot;; ) 會無效，因為此 @import 規則不能在 @media block 內使用：123456@import \"subs.css\";@media print &#123; @import \"print-main.css\"; body &#123; font-size: 10pt &#125;&#125;h1 &#123;color: blue &#125;正確的寫法是在 @import 規則後面加上要指定的 media type，例如：123456@import \"subs.css\";@import \"print-main.css\" print;@media print &#123; body &#123; font-size: 10pt &#125;&#125;h1 &#123;color: blue &#125;如果想了解其他 media type，可參閱在此系列中的另一篇「重新認識 CSS - media type」。資料來源：CSS 2.2 - 6.3 The @import ruleCSS 2.2 - 4.1.5 At-rulesMedia QueriesMedia Queries Level 4","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Media query","slug":"css-media-query","date":"2019-09-27T11:30:15.000Z","updated":"2020-02-09T14:20:29.000Z","comments":true,"path":"article/css-media-query.html","link":"","permalink":"https://titangene.github.io/article/css-media-query.html","excerpt":"今天來介紹 CSS 的 media query 和 media feature。","text":"今天來介紹 CSS 的 media query 和 media feature。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。本文同步發表於 iT 邦幫忙：重新認識 CSS - Media query在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog使用 media query 可以針對指定裝置來指定要應用哪個 style sheet複習一下昨天提到的 media type，如果要在不同 media type 指定不同的 style sheet，可以在 HTML 的 link 元素上的 media 屬性，為外部 style sheet 指定目標 media。例如：在螢幕上顯示時使用無襯線字體在列印時使用襯線字體12&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"sans-serif.css\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"print\" href=\"serif.css\"&gt;其他為 style sheet 指定 media 的方法可參閱在此系列中的另一篇「重新認識 CSS - media type」。Media Queriesmedia query 是由 media type 和零個或多個表達式組成，這些表達式會檢查指定的 media feature 條件。media query 是一個邏輯表達式，可以為 true 或 false。如果 media query 的 media type 與執行 UA 的裝置的 media type match (例如：“Applies to” 那行所定義的)，並且 media query 中的所有表達式均為 true，則 media query 為 true。all 關鍵字如果要適用所有 media type 的 media query，可以使用簡寫語法省略掉 all 這個關鍵字 (後面接著 and )。也就是說，如果沒有明確指定 media type 時，就等同於 all 這個關鍵字。例如：下面兩個 media query 相同：12@media all and (min-width:500px) &#123; … &#125;@media (min-width:500px) &#123; … &#125;下面兩個也相同：12@media (orientation: portrait) &#123; … &#125;@media all and (orientation: portrait) &#123; … &#125;Combining Media Queries：可在 media query 列表中組合多個 media query，並以逗號 , 分隔。如果 media query 列表的任何 component media query 為 true，則為 true；若所有 component media query 為 false 才會為 false。例如：如果 media type 為 screen 且為彩色裝置，或 media type 為 projection 且為彩色裝置：1@media screen and (color), projection and (color) &#123; … &#125;and 關鍵字下面是在 HTML 的 link 元素上的 media 屬性使用 and 關鍵字：1&lt;link rel=\"stylesheet\" media=\"screen and (color)\" href=\"test.css\" /&gt;跟上面一樣的 media query，只是下面是在 CSS 中使用 @import-rule 寫的：1@import url(color.css) screen and (color);資料來源：CSS 2.2 - 7. Media typesMedia QueriesMedia Queries Level 4","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - media type","slug":"css-media-type","date":"2019-09-26T11:30:15.000Z","updated":"2020-02-09T15:08:59.000Z","comments":true,"path":"article/css-media-type.html","link":"","permalink":"https://titangene.github.io/article/css-media-type.html","excerpt":"如果同將一份文件應用在不同的 media 上呈現，就可以使用 media type 來指定適用的 media。本篇將介紹 CSS 的 media type。","text":"如果同將一份文件應用在不同的 media 上呈現，就可以使用 media type 來指定適用的 media。本篇將介紹 CSS 的 media type。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Media type「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog有些 CSS 屬性只在某些 media 上適用，例如：page-break-before 屬性僅適用於 paged media，而 visual 是 media group，如下圖：不同 media type 的 style sheet 可以對同一個元素的同一個屬性進行設定，但是各屬性有不同的設定值。例如：font-size 在電腦螢幕上通常都會比在紙上還要大，所以可以在不同 media type 分別設定不同的字體大小。指定與 media 相關的 style sheet下面有幾種方法可以為 style sheet 指定 media：使用 @media 規則指定目標 media：123456@media screen &#123; body &#123; font-size: 10pt; &#125;&#125;@media print &#123; body &#123; font-size: 10pt; &#125;&#125;使用 @import 規則指定目標 media：12@import url(\"style.css\") screen;@import url(\"print.css\") print;在 HTML 要引入 style sheet 時，在 link 元素上的 media 屬性指定外部 style sheet 的目標 media：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" media=\"screen\" href=\"./style.css\"&gt; &lt;link rel=\"stylesheet\" media=\"print\" href=\"./print.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;@media 規則可在同一個 style sheet 內，為各種 media 使用 style sheet 規則：123456789@media print &#123; body &#123; font-size: 10pt; &#125;&#125;@media screen &#123; body &#123; font-size: 13px; &#125;&#125;@media screen, print &#123; body &#123; line-height: 1.2; &#125;&#125;media type常用的 media type：all：適用於所有裝置screen：主要用於彩色電腦螢幕 (包含手機和平版)speech：適用於語音合成器 (speech synthesizer)、語音朗讀裝置print：適用於 paged material 和在列印預覽模式下在螢幕上查看的文件，例如：用瀏覽器的「列印預覽」模式察看文件 (如下圖)print 的 paged media 部份可參閱 CSS 2.2 - paged media。在 CSS 2.1 定義了其他幾種比較少見的 media type：braille、embossed、handheld、projection、tty、tv 和 aural，但這些 media type 在 Media Queries Level 4 已被棄用，所以不建議使用這些 media type。當初在決定有哪些 media type 的時候，不同的 media type 有很大的區別，例如：screen 和 handheld，分別為電腦螢幕和手持裝置 (例如：PDA)，但後來這兩個的界線從愈來愈模糊，變成沒有界線。資料來源：CSS 2.2 - 7. Media typesCSS 2.2 - 13. Paged mediaMedia QueriesMedia Queries Level 4","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Cascading & Specificity","slug":"css-cascading-and-specificity","date":"2019-09-25T11:20:15.000Z","updated":"2020-02-09T14:01:29.000Z","comments":true,"path":"article/css-cascading-and-specificity.html","link":"","permalink":"https://titangene.github.io/article/css-cascading-and-specificity.html","excerpt":"CSS 可以在同份文件上使用多個 style sheet 來設定文件的樣式。如果你在不同 style sheet 內對同一個元素或屬性設定值時，就會 CSS 會透過 cascading 這個特性來解決這個衝突。本篇將介紹 CSS 的 Cascading 和 specificity。","text":"CSS 可以在同份文件上使用多個 style sheet 來設定文件的樣式。如果你在不同 style sheet 內對同一個元素或屬性設定值時，就會 CSS 會透過 cascading 這個特性來解決這個衝突。本篇將介紹 CSS 的 Cascading 和 specificity。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Cascading &amp; Specificity「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogCascadingcascade 接受給定 (given) 元素上的給定屬性的 declared value 的無序列表，根據如下所述按照其宣告的優先度對它們進行排序，並輸出一個 cascaded valuecascade 會使用各元素上屬性的 declared value 的無序列表，透過下面所述的 Cascading 流程，以宣告的優先度從高到低進行排序，並輸出一個 cascaded value：Origin and ImportanceSpecificityOrder of AppearanceOrigin and ImportanceOrigin：根據宣告的來源 (origin)Importance：該屬性值是否被宣告為 !important各種來源的優先度按降序 (高到低) 排列：Transition declarations CSS TransitionsImportant user agent declarationsImportant user declarationsImportant author declarationsAnimation declarations CSS Animations Level 1Normal author declarationsNormal user declarationsNormal user agent declarationsSpecificity選擇器的 specificity 計算方式的背後是計算 a、b、c 和 d 個四個數字，此方法會分別在各個 selector 上計算，四個數字各別如下：a：如果在直接在 HTML 元素上設定 style 屬性，那 a = 1，否則為 0b：計算使用 ID selector 的數量c：計算使用 class selector、attributes selector 和 pseudo-class 的數量d：計算使用 type selector 和 pseudo-element 的數量另外還有幾點要特別注意：specificity 會忽略 universal selector如果你用 attributes selector 來 match id 屬性 (例如：[id=titan] )，也還是算成 attributes selector (也就是 a = 0、b = 0、c = 1 和 d = 0 )下面是 CSS 2.2 提供的 specificity 範例：下面舉個實際的範例；12345678&lt;head&gt; &lt;style type=\"text/css\"&gt; #titan &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=\"titan\" style=\"color: green\"&gt;&lt;/body&gt;因為 p 元素有設定 style 屬性，會覆蓋 style 元素中 以 ID selector #titan 的宣告 (因為 style 屬性的 specificity 更高)，所以 p 元素的文字結果為綠色。Order of Appearance越放在 HTML 最後的宣告優先度越高：imported style sheet 中的宣告會按順序來排序HTML 外部連結的 style sheet 中的宣告會按順序來排序style 屬性的宣告是根據 style 屬性出現在該元素的文件順序來排序，並且全部放在任何 style sheet 之後資料來源：CSS 2.2 - 6. Assigning property values, Cascading, and InheritanceCSS Cascading and Inheritance Level 3","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - CSS 如何處理屬性值","slug":"css-value-processing","date":"2019-09-24T08:30:15.000Z","updated":"2020-01-22T12:33:37.000Z","comments":true,"path":"article/css-value-processing.html","link":"","permalink":"https://titangene.github.io/article/css-value-processing.html","excerpt":"今天來介紹 CSS 如何處理屬性值。","text":"今天來介紹 CSS 如何處理屬性值。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - CSS 如何處理屬性值「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog每個屬性的定義表 (definition table) 都定義了：Name：屬性名稱Value：屬性值Initial：initial value 為何Applies to：此屬性適用於哪些元素Inherited：是否為 inherited propertiesPercentages：百分比值如何 interpretedMedia：該屬性適用於哪些 media groupComputed value：如何計算 Computed value如下圖：圖片來源：CSS 2.2 - 1.4.2 CSS property definitions詳情可參閱 CSS 2.2 Spec - 1.4.2 CSS property definitionsValue ProcessingUA 解析了文件並在建構了 document tree 之後，UA 必須為 tree 中的每個元素以及 formatting structure (格式化結構) 中的每個 box 分配對應於目標 media type 的屬性值。document tree：source document (原始文件，在這邊可以指 HTML 或 XML) 中編碼的元素的 tree。該 tree 中的每個元素都只有一個父元素，但 root 元素 (在 HTML 中就是 &lt;html&gt; 元素) 除外。所以每個屬性都會有一個值，而這些值 (也就是說元素或 box 的 CSS 屬性的 final value) 會通過下面幾個步驟來計算決定。在說明步驟之前先來說這個計算過程中會用到的幾種值：declared valuecascaded valuespecified valuecomputed valueused valueactual valueDeclared values為了找到 declared value，應用於每個元素的每個屬性宣告，都會以 filtering declarations (過濾宣告) 的方式來標識出 (identify) 可以適用於每個元素的所有宣告。只要符合下列情況，宣告就適用於各元素：宣告屬於當前適用於此文件的 style sheet宣告不符合，帶有錯誤條件的條件規則 CSS Conditional Rules Module Level 3宣告屬於該 selector 與該元素 match 的樣式規則。 (必要時需要考慮範圍 (scope) )有效語法：宣告的屬性是已知的屬性名稱，並且 declared value 與該屬性的語法 match適用於每個元素上的每個屬性的 declared value 會形成 declared value 的列表，此列表會由 cascade 來進行優先度排序。Cascaded valuescascade 會使用各元素上屬性的 declared value 的無序列表，透過 Cascading (明天會介紹) 流程選擇一個 “winning value”，也就是按照宣告的優先度來進行排序，優先度最高的宣告就會輸出一個 cascaded value (也可以說是在 cascade 的輸出 (output of the cascade) 中排在最前面的值)。如果 cascade 的輸出為空 (empty) 列表時，則沒有 cascade value。cascade 的輸出 (output of the cascade)：每元素上的每個屬性的 declared value 的排序列表 (可能為 empty)。Specified ValuesSpecified value 是由 style sheet 的作者 (也就是網頁開發者) 針對該元素指定的屬性值。cascaded value 會透過 defaulting 流程來計算 specified value，以確保每個元素上的每個屬性都有一個 specified value，流程如下：是否為 inherited properties：是：通過繼承從該父元素中取得 initial value否：採用該屬性的 initial valueExplicit Defaulting (顯式預設)：當 cascaded value 為下面某個 CSS-wide keywords 時 (所有屬性都可以使用這些關鍵字)，會有對應的處理方式initial：將 initial value 作為屬性的 specified valueinherit：將 computed value 作為屬性的 specified value 和 computed valueunset：是否為 inherited property：是：等同於 inherit 的作用否：等同於 initial 的作用如果沒有 cascaded value 時，也會依照上面流程來決定 specified value。Computed Valuescomputed value 是解析屬性定義表 (definition table) 中的 “Computed Value” 定義的 specified value 的計算結果通常將其絕對化以準備繼承Order of Appearance越放在 HTML 最後的宣告優先度越高：imported style sheet 中的宣告會按順序來排序HTML 外部連結的 style sheet 中的宣告會按順序來排序style 屬性的宣告是根據 style 屬性出現在該元素的文件順序來排序，並且全部放在任何 style sheet 之後資料來源：CSS 2.2 - 6. Assigning property values, Cascading, and InheritanceCSS Cascading and Inheritance Level 3123456789101112131415161718192021224.1 Declared Values4.2 Cascaded Values4.3 Specified Values4.4 Computed Values x5 Filtering6 Cascading 上半部，詳細順序還沒提到，下一篇會提到### Origin and Importance### Specificity### Order of Appearance x7 Defaulting7.1 Initial Values7.2 Inheritance7.3 Explicit Defaulting之後寫：- Cascaded values - Cascading- Specified Values - Defaulting - Explicit Defaulting：三個 CSS-wide keywords","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Inheritance (繼承)","slug":"css-inheritance","date":"2019-09-23T11:20:15.000Z","updated":"2019-10-29T15:37:45.000Z","comments":true,"path":"article/css-inheritance.html","link":"","permalink":"https://titangene.github.io/article/css-inheritance.html","excerpt":"今天來介紹 CSS 的 Inheritance (繼承) 以及 inherit 這個關鍵字的屬性值。","text":"今天來介紹 CSS 的 Inheritance (繼承) 以及 inherit 這個關鍵字的屬性值。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Inheritance (繼承)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogInheritance (繼承)某些值是由 document tree 中的元素的 children 繼承。每個屬性都定義了是否繼承。像下圖是 color 屬性的定義，可以看到在 Inherited 欄位中是定義為可被繼承：例如：下面範例中，如果沒有在 em 元素設定 color 屬性，就會繼承 h1 元素的 color 屬性：1&lt;h1&gt;The headline &lt;em&gt;is&lt;/em&gt; important!&lt;/h1&gt;如果 h1 元素的 color 設為藍色，那 em 元素的 color 也會是藍色：1h1 &#123; color: blue; &#125;發生繼承時，元素會繼承 computed value。來自父元素的 computed value 會同時成為子元素上的 specified value 和 computed value。例如以下範例：h1 元素的 font-size 屬性的 computed value 會是 13px ( 130% x 10px，也就是使用父元素 body 的 font-size 屬性值：10px，乘上 h1 元素的 130% )em 元素繼承了 h1 元素的 font-size 屬性的 computed value，因此 em 元素也會是 13px 的 computed value如果 UA 沒有可用的 13px 字體，則 h1 和 em 元素的 font-size 的 actual value 可能會是 12px (例如：瀏覽器預設最小字體為 12px )123&lt;body&gt; &lt;h1&gt;A &lt;em&gt;large&lt;/em&gt; heading&lt;/h1&gt;&lt;/body&gt;12body &#123; font-size: 10px; &#125;h1 &#123; font-size: 130%; &#125;繼承屬性值：inherit每個屬性都可以使用 inherit 這個繼承屬性值，只要設定了這個值，該屬性就會將元素的 parent 的 computed value 作為 specified value，也就是說，inherit 這個值是用於強制繼承，也可用於原本在屬性定義表中定義為 Inherited: no 的屬性，讓該屬性變成可繼承的父元素。如果在 root 元素的屬性上設定了 inherit 值，則會為該屬性設定其 initial value。例如：在 body 元素上設定了 color 和 background 屬性所有其他元素的 color 屬性設為 inherit，並且 background 屬性設為 transparent (也就是透明背景)12345678body &#123; color: black !important; background: white !important;&#125;* &#123; color: inherit !important; background: transparent !important;&#125;如果上面這些規則都是使用者的 style sheet，則會在整個文件中強制使用白底黑字 (因為其他元素的 color 屬性會繼承 body 元素的黑色，而其他元素都被設為透明色的背景)。資料來源：CSS 2.2 - 6. Assigning property values, Cascading, and InheritanceCSS Cascading and Inheritance Level 3","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - CSS 屬性值","slug":"css-attribute-value","date":"2019-09-22T13:20:15.000Z","updated":"2020-01-22T12:29:31.000Z","comments":true,"path":"article/css-attribute-value.html","link":"","permalink":"https://titangene.github.io/article/css-attribute-value.html","excerpt":"在介紹各種 CSS 屬性之前，先來介紹屬性值，CSS 的屬性值分為：整數和實數、Lengths (長度)、百分比、URLs 和 URIs、Counters (計數器)、顏色、字串。","text":"在介紹各種 CSS 屬性之前，先來介紹屬性值，CSS 的屬性值分為：整數和實數、Lengths (長度)、百分比、URLs 和 URIs、Counters (計數器)、顏色、字串。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - CSS 屬性值「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog屬性值分為：整數和實數Lengths (長度)百分比URLs &amp; URIsCounters (計數器)顏色字串整數和實數整數 (包括正整數、0 和負整數)，例如：16、-10。實數 (包括整數、小數…等)，例如：7.5。Lengths (長度)格式為實數 + 單位，例如：16px、-10px、7.5em。有些屬性可以使用負長度值，但這樣可能會使 formatting model 複雜化，並且可能會有某些實作上的限制。如果不支援負長度值，則應換成可支援的最接近值。如果在不支援負長度值的屬性使用，就會忽略該宣告。如果不支援長度值，UA 必須將它近似為實際值 (actual value)。長度單位有兩種：相對單位絕對單位相對單位相對單位有：em：等於使用該元素的 font-size 屬性的計算值ex：由元素的第一個可用字體定義，關於字體的 “x-height”x-height通常等於小寫字母 “x” 的高度即使不包含 “x” 的字體也定義了 ex字體的 x-height 可以通過不同的方式找到：某些字體本身就有包含 x-height 的資訊 (可靠指標，reliable metrics)如果沒有可靠的字體指標，UA 可以根據小寫字形的 height 來確定 x-height例如：以小寫字母 “o” 的字形 (glyph) 在 baseline 以下延伸的距離，並從其 bounding box (邊界框) 的頂端減去該值如果還是無法確定 x-height，就會將 x-height 設為 0.5em圖片來源：CSS Inline Layout Module Level 3只要在 font-size 屬性值中使用 em 和 ex 單位，各別就會引用父元素的 em 或 ex 單位。例如：原本 p 元素的預設字體大小為 16px，如果這時設定以下樣式：123&lt;div class=\"box\"&gt; &lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;&lt;/div&gt;1p &#123; font-size: 2em; &#125;p 元素的計算值就會是 2 x 16px，所以計算值的結果為 32px，並且上下的 margin 也會變成各 32px，因為瀏覽器預設 margin 為 1em：如果在 p 元素的容器上設定，CSS 樣式變成這樣：12.box &#123; font-size: 10px; &#125;p &#123; font-size: 2em; &#125;那 p 元素的字體大小就不會是剛剛的 32px，而是變成 20px。這是因為 em 這個單位會拿容器的大小來算出計算值，也就是 2 x 10px，所以計算值的結果為 20px，並且上下的 margin 也會變成各 20px：將 em 單位用在 line-height 是常見的用法。例如：設定以下樣式，就代表將 h1 元素的 line height 設定成比 h1 元素的字體大 20%：1h1 &#123; line-height: 1.2em; &#125;另外，當使用 em 和 ex 單位時，子元素是繼承父元素的計算值，不是繼承父元素指定的相對值。例如：h1 元素是 body 元素的子元素，h1 元素的 text-indent 屬性的計算值會是 36px，而不是 45px：123&lt;body&gt; &lt;h1&gt;Lorem ipsum dolor sit amet.&lt;/h1&gt;&lt;/body&gt;12345body &#123; font-size: 12px; text-indent: 3em; /* i.e., 36px */&#125;h1 &#123; font-size: 15px; &#125;(O)：因為在 body 元素的 text-indent 屬性的計算值是 36px，而子元素 p 只會繼承父元素 body 的計算值 36px。(X)：而不是因為 p 元素的字體大小為 15px，所以 p 元素的 text-indent 屬性的計算值是 45px。絕對單位絕對單位有：in：inches (英寸)，1in 等於 2.54cmcm：公分mm：毫米pt：points (點)，CSS 使用的 points 等於 1/72nd of 1inpc：picas (派卡)，1pc 等於 12ptpx：pixel units (像素單位)，1px 等於 0.75pt各種絕對單位之間的關係：1in = 2.54cm = 25.4mm = 72pt = 6pc。當解析度為 72dpi 時，1px = 1pt。百分比每個 CSS 屬性都會定義是否可以使用百分比值，如果可以使用會引用哪裡的值來作為依據。百分比值可以是：相同元素的另一個屬性的值ancestor 元素的屬性的值formatting context 的值 (例如：containing block 的寬度，containing block 的部份之後會說明)下面是「相同元素的另一個屬性的值」的範例：1234p &#123; font-size: 10px; line-height: 120%; /* 120% of 'font-size' */&#125;將 p 元素的字體大小設為 10px，如果又再 p 元素上設定 line-height: 120%，那 p 元素的 line-height 的計算值結果會是 12px (因為 10px x 120% )。下面是「ancestor 元素的屬性的值」的範例：1&lt;p&gt;&lt;span&gt;Lorem&lt;/span&gt; ipsum dolor sit amet.&lt;/p&gt;12p &#123; font-size: 20px; &#125;span &#123; line-height: 120%; &#125;將 p 元素的字體大小設為 20px，span 元素的 line-height 屬性會繼承父元素 p 的 font-size 值 20px，所以 span 元素的 line-height 屬性的計算值結果就會是 24px (因為 20px x 120% )。URLs &amp; URIs有些 CSS 的屬性值可以使用 URI，語法範例如下：1body &#123; background: url(\"http://www.ex.com/image.png\"); &#125;URI (Uniform Resource Identifiers) 包括 URL、URN 等，詳情請參閱 RFC3986 標準。url() 內的雙引號 ( &quot; ) 也可以改為單引號 ( ' )。另外，在前單引號或前單引號之前，以及後雙引號或後雙引號之後都可以加上可選的空白字元 (white space)，可依照各自偏好來決定 coding style，例如：12body &#123; background: url( \"http://www.ex.com/image.png\" ); &#125;body &#123; background: url( 'http://www.ex.com/image.png' ); &#125;沒有引號下面是沒有引號的範例：1li &#123; list-style: url(http://www.ex.com/titan.png) disc; &#125;如果在沒有加引號的 URI 中使用某些字元，例如：括號 ( (、) )、空白字元 ( )、單引號 ( ' ) 和雙引號 ( &quot; )，就必須在該字元之前加上反斜線跳脫 (escaped with a backslash)，例如：1li &#123; list-style: url(http://www.ex.com/titan\\(test\\).png) disc; &#125;也可以將上述字元按照 RFC3986 中的描述，轉換成 URI 換碼字元，例如：( 等於 %28，而 ) 等於 %29。剛剛上面的範例就會變成：1li &#123; list-style: url(http://www.ex.com/titan%28test%29.png) disc; &#125;相對 URI另外也可以使用相對 URI。例如下面的 CSS 檔案放在：1http:&#x2F;&#x2F;www.ex.org&#x2F;style&#x2F;basic.cssCSS 檔內如下：1body &#123; background: url(\"titan.png\"); &#125;那這個 &quot;titan.png&quot; 的完整 URI 就會是：1http:&#x2F;&#x2F;www.ex.org&#x2F;style&#x2F;titan.png也就代表相對 URI 會使用 base URI 來解析成完整的 URI。不過要注意的是，對 CSS style sheet 來說，base URI 是 style sheet 的 base URI (在上面範例中是 http://www.ex.org/style/ )，而不是 source document (原始文件，也就是 HTML 文件) 的 base URI。在 RFC3986 的第五節定義了此過程的規範演算法。不可用在 URI 中使用註解下面範例看似註解了 x 這個字元，但其實此 URI 還是 /*x*/pic.png，而不是 pic.png：1body &#123; background: url(/*x*/pic.png); &#125;註：在 CSS 中的註解語法是：1/* 我是註解 */Counters (計數器)直接看範例：1234567891011&lt;h1&gt;First&lt;/h1&gt;&lt;h2&gt;First-First&lt;/h2&gt;&lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;&lt;h2&gt;First-Second&lt;/h2&gt;&lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;&lt;h1&gt;Second&lt;/h1&gt;&lt;h2&gt;Second-First&lt;/h2&gt;&lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;&lt;h2&gt;Second-Second&lt;/h2&gt;&lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;12345678910body &#123; counter-reset: chapter; &#125;h1::before &#123; content: \"Chapter \" counter(chapter) \". \"; counter-increment: chapter;&#125;h1 &#123; counter-reset: section; &#125;h2::before &#123; content: counter(chapter) \".\" counter(section) \". \"; counter-increment: section;&#125;Demo：Codepen 連結讓 h1 和 h2 元素的文字之前會自動為章節編號：See the Pen automatic counters and numbering by Titangene (@titangene) on CodePen.詳情可參考：CSS 2.2 - 4.3.5. CountersCSS 2.2 - 12.4. Automatic counters and numbering顏色&lt;color&gt; 可用關鍵字或數字 RGB 規範的數值。基本顏色關鍵字在 CSS 2.2 中定義了 13 種顏色關鍵字：aqua、black、blue、fuchsia、gray、green、lime、maroon、navy、olive、orange、purple、red、silver、teal、white 和 yellow。下面是這 17 種顏色各別對應的色碼：使用範例：123body &#123;color: black; background: white; &#125;h1 &#123; color: maroon; &#125;h2 &#123; color: olive; &#125;Numerical color valuesRGB color valuesRGB 分別代表紅色、綠色和藍色。下面是 RGB 顏色值的格式：十六進位表示法有兩種格式：三個字元：#rgb，例如：#f00六個字元：#rrggbb，例如：#ff0000#ffbb00 可簡寫為 #fb0，兩者代表相同的顏色三位 RGB 表示法 ( #rgb ) 是通過複製數字，而不是通過加零轉換為六位形式 ( #rrggbb )rgb(r,g,b)：r、g 和 b 用逗號 ( , ) 分隔，三個數值可以都是整數值或百分比值整數值的 255 等於百分比值的 100%十六進位表示法中的 F 或 FF：rgb(255, 255, 255) = rgb(100%, 100%, 100%) = #FFF例如：rgb(255, 0, 0)rgb(100%, 0%, 0%)使用範例：1234em &#123; color: #f00; &#125; /* #rgb */em &#123; color: #ff0000; &#125; /* #rrggbb */em &#123; color: rgb(255, 0, 0); &#125;em &#123; color: rgb(100%, 0%, 0%); &#125;RGBA color values而 RGBA 顏色值的格式只是在 RGB 顏色值的格式最後再加上一個 “alpha” 值。“alpha” 值：可指定顏色的透明度值的範圍為 0.0 至 1.00.0：完全透明1.0：不透明註：使用十六進位表示法 (也就是 #rgb 或 #rrggbb ) 無法指定顏色的透明度。當 “alpha” 值為 1.0 時，代表不透明，因此下面四個都為相同顏色：1234em &#123; color: rgb(255, 0, 0); &#125; /* 紅色 */em &#123; color: rgba(255, 0, 0, 1); &#125; /* 紅色 */em &#123; color: rgb(100%, 0%, 0%); &#125; /* 紅色 */em &#123; color: rgba(100%, 0%, 0%, 1); &#125; /* 紅色 */使用範例：12em &#123; color: rgba(255, 0, 0, 0.5); &#125; em &#123; color: rgb(100%, 0%, 0%, 0.5); &#125;HSL color valuesHSL 是 hue-saturation-lightness 的縮寫，分別代表色相、飽和度和亮度。有 RGB 就夠用了，為何還需要有 HSL？這是因為 HSL 使用起來會更加直覺，用色相、飽和度和亮度可以更直觀的指定顏色，RGB 還需要思考光的三原色：紅色、綠色、藍色，要分別設定多少才會變成指定顏色。使用範例：12345* &#123; color: hsl(0, 100%, 50%) &#125; /* red */* &#123; color: hsl(120, 100%, 50%) &#125; /* lime */* &#123; color: hsl(120, 100%, 25%) &#125; /* dark green */* &#123; color: hsl(120, 100%, 75%) &#125; /* light green */* &#123; color: hsl(120, 75%, 75%) &#125; /* pastel green */HSLA color values而 HSLA 顏色值的格式只是在 HSL 顏色值的格式最後再加上一個 “alpha” 值。“alpha” 值：可指定顏色的透明度值的範圍為 0.0 至 1.00.0：完全透明1.0：不透明當 “alpha” 值為 1.0 時，代表不透明，因此下面兩個都為相同顏色：12em &#123; color: hsl(120, 100%, 50%); &#125; /* 純綠色 */em &#123; color: hsla(120, 100%, 50%, 1); &#125; /* 純綠色 */使用範例：12em &#123; color: hsla(30, 100%, 50%, 0.1); &#125; /* 半透明的純藍色 */em &#123; color: hsla(240, 100%, 50%, 0.5); &#125; /* 很透明的純橘色 */transparent color keyword顧名思義就是透明色background-color 屬性的 initial value 就是 transparent使用範例：1em &#123; background-color: transparent; &#125;currentColor color keywordCSS1 和 CSS2 將 border-color 屬性的 initial value 定義為 color 屬性的值，但未定義相應的關鍵字。SVG 意識到了這種遺漏，因此 SVG 1.0 為 fill、stroke、stop-color、flood-color 和 lighting-color 屬性引入了 currentColor 值。在 CSS3 時，擴充了顏色值，新增 currentColor 這個關鍵字，以允許其與接受顏色值的所有屬性一起使用，這樣就簡化了 CSS3 中的這些屬性的定義。currentColor 關鍵字：color 屬性的值currentColor 關鍵字的 used value 是 color 屬性的 computed value如果在 color 屬性本身上設定了 currentColor 關鍵字，則將其視為 color: inherit例如：border-color 屬性使用了 currentColor 關鍵字，此關鍵字的 used value 就是 color 屬性的 computed value，所以就等同於是將 border-color 設為 blue (也就是 color 屬性的顏色)。1&lt;div class=\"box\"&gt;&lt;/div&gt;123456789.box &#123; width: 100px; height: 100px; background-color: lightblue; border-width: 10px; border-style: solid; border-color: currentColor; color: blue;&#125;如果想更多顏色值的相關內容，詳情可參考：CSS 2.2 - 4.3.6. ColorsCSS Color Module Level 3。字串字串可用雙引號 ( &quot; ) pair 或單引號 ( ' ) pair 包起來。使用範例：12p::before &#123; content: 'hello '; &#125;p::after &#123; content: \"!\"; &#125;字串中的引號字元要使用跳脫字元雙引號 pair 裡面不能直接使用雙引號，同理，單引號也是如此，除非在引號 pair 之前加上跳脫字元。雙引號：使用 \\&quot; 或 \\22單引號：使用 \\' 或 \\27使用範例：1234567/* 雙引號 */.test1::before &#123; content: \"this is a \\\"string\\\"\"; &#125;.test2::before &#123; content: 'this is a \\22string\\22'; &#125;/* 單引號 */.test3::before &#123; content: 'this is a \\'string\\''; &#125;.test4::before &#123; content: 'this is a \\27string\\27'; &#125;如果不想另外加上跳脫字元，可以在改在雙引號字串中使用單引號，或是在單引號字串中使用雙引號，例如：12.test5::before &#123; content: \"this is a 'string'\"; &#125;.test6::before &#123; content: 'this is a \"string\"'; &#125;換行字元 (newline)字串不能直接包含換行字元 (newline)。要在字串中包含換行字元，請使用跳脫字元來表示 ISO-10646 ( U+000A ) 中的換行字元，例如：\\A 或 \\00000a 這些字元都代表 CSS 中的換行字元。使用範例：1&lt;h1&gt;Titan&lt;/h1&gt;1234h1:before &#123; white-space: pre; content: \"hello\\A\"&#125;Demo：Codepen 連結如範例，hello 字串之後會換行就是因為使用了 \\A 這個換行字元：將字串分成多行如果要將字串分成多行，換行字元本身必須使用反斜線 ( \\ ) 來進行跳脫 (escaped)。使用範例：12a[title=\"a not s\\o very long title\"] &#123; ... &#125;等同於：1a[title=\"a not so very long title\"] &#123; ... &#125;資料來源：CSS 2.2 - 4. Syntax and basic data types實數 - WikipediaCSS Inline Layout Module Level 3CSS Values and Units Module Level 3CSS Values and Units Module Level 4CSS Color Module Level 3CSS Backgrounds and Borders Module Level 3鉄人28號FX 鉄人6號「字級羊」font-size - 鉄人28號FX系列 - iT 邦幫忙","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Pseudo-element (偽元素)","slug":"css-selector-pseudo-element","date":"2019-09-21T11:50:42.000Z","updated":"2019-10-15T06:54:56.000Z","comments":true,"path":"article/css-selector-pseudo-element.html","link":"","permalink":"https://titangene.github.io/article/css-selector-pseudo-element.html","excerpt":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 pseudo-element (偽元素)，包括 ::before 和 ::after。","text":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 pseudo-element (偽元素)，包括 ::before 和 ::after。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Pseudo-element (偽元素)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogPseudo-elementspseudo-element 代表不直接存在於 document tree 中的元素。document language (文件語言) 不提供存取元素內容的第一個字母或第一行的機制，但是可以用 ::first-letter 和 ::first-line 這兩個 pseudo-element 選到，這樣就可以對這些元素設定樣式。另外，pseudo-element 還可以表示原始文件 (source document) 中根本不存在的內容，例如 ::before 和 ::after 這兩個 pseudo-element 可以在任何元素的內容之前或之後插入其他內容。pseudo-class 和 pseudo-element 都不會出現在 document source 或 document tree 中，或是不會對其進行修改。所以，pseudo-class 和 pseudo-element 都不會影響到 structural pseudo-class 或與它們的 originating (原始) 元素 或其 tree 有關的其他 selector 的解譯 (interpretation)。Structural pseudo-class 詳情可參考我前幾天寫的「重新認識 CSS - Pseudo-class (偽類) (2)」。originating (原始) 元素是什麼？pseudo-element 綁定到頁面上的某個元素，而此元素就稱為 originating 元素。例如：1div a::before &#123; content: 'Hi '; &#125;在 selector div a::before 中，與 selector match 的 a 元素就是 originating 元素。如果想更了解 pseudo-element，可以看它在以下這些 CSS Spec 的定義：CSS 2.1Selectors Level 3CSS Pseudo-Elements Module Level 4Generated Content Pseudo-elements: ::before and ::after::before：在 originating 元素的內容之前建立的 child pseudo-element::after：在 originating 元素的內容之後建立的 child pseudo-element::before 和 ::after 的 CSS content 屬性的初始值為 normal，計算值為 none。當 ::before 和 ::after 的計算 content 值不為 none 時，這些 pseudo-element 就會產生 box，就好像它們是其 originating (原始) 元素的直接子元素一樣，並且可以像在 document tree 中任何 normal document-sourced (基於文件) 的元素一樣進行樣式設定例如：在 class 為 note 的 p 元素的內容之前插入字串 &quot;Note: &quot;在 class 為 note 的 p 元素的內容之後插入字串 “!”1&lt;p class=\"note\"&gt;test&lt;/p&gt;12p.note::before &#123; content: \"Note: \"; &#125;p.note::after &#123; content: \"!\"; &#125;Demo：Codepen 連結::before 和 ::after 的 display 的初始值為 inline，所以會生成 inline box。與 p 元素的其他 inline children 一樣，它會參與 p 元素的 IFC (inline formatting context)，有可能與其他內容共享一行。就如下面範例那樣，因為 ::before 和 ::after 都是 display: inline，並且在 p 元素的內容 test 之前加上 ::before 的內容 &quot;Note: &quot;，以及在 test 之後加上 ::after 的內容 &quot;！&quot;，所以在畫面上顯示的結果就變成 Note: test!。See the Pen Generated Content Pseudo-elements: `::before` and `::after` by Titangene (@titangene) on CodePen.content 字串換行如果想在 content 屬性內將字串換行要怎麼做？只要在字串中加入 \\A 這個 escape sequence (轉義序列)，它就會在 generated content 中包含 newline，而這個插入的 line break 也會受到 white-space 屬性的影響。有關 \\A escape sequence 的詳情可參 CSS 2 的 字串 和 字元與大小寫 部份。123456h2:before &#123; display: block; text-align: center; white-space: pre; content: \"Hello\\A Titan\"&#125;最後今天介紹一些 ::before 和 ::after 這兩個 pseudo-element，接下來幾天會接續介紹其他 selector。資料來源：CSS 2.2 Specification - SelectorsSelectors Level 3Selectors Level 4CSS Pseudo-Elements Module Level 4CSS Generated Content Module Level 3CSS Cascading and Inheritance Level 4","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Pseudo-class (偽類) (2)","slug":"css-selector-pseudo-class-2","date":"2019-09-20T08:20:52.000Z","updated":"2019-10-14T00:23:24.000Z","comments":true,"path":"article/css-selector-pseudo-class-2.html","link":"","permalink":"https://titangene.github.io/article/css-selector-pseudo-class-2.html","excerpt":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 structural pseudo-class (偽類)，包括 :root、nth-child、nth-of-type …等 selector。","text":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 structural pseudo-class (偽類)，包括 :root、nth-child、nth-of-type …等 selector。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Pseudo-class (偽類) (2)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog之前有提到以下這些都是 simple selector：type selectoruniversal selectorattribute selectorclass selectorID selectorpseudo-class本篇會介紹 pseudo-class，如果想了解其他 simple selector 可參閱之前介紹的 重新認識 CSS - Simple Selector &amp; Groups of selector。如之前所說，pseudo-class 是以 : 為開頭，後面接著 pseudo-class 的名稱，有些會在後面加上括號 ()，並在括號之間加上值。例如：:nth-child(2)。注意：pseudo-class 和 pseudo-element 不相同pseudo-class 是以 : 為開頭pseudo-element 是以 :: 為開頭，但也可以以 : 為開頭，因為在舊版的 W3C Spec 中沒有將 pseudo-class 和 pseudo-element 區分成 : 和 ::。如果你寫 pseudo-element 是用 :，大部份瀏覽器也還是會支援這種語法。Structural pseudo-classes當使用 structural pseudo-class 時，它會計算各 sibling 元素的位置：不計算 standalone (獨立) text 和其他非元素節點index 編號從 1 開始只適用於 document tree 中的元素，不會 match 到 pseudo-element:root pseudo-class:root pseudo-class 代表文件的 root 元素在 DOM 文件中，:root pseudo-class 與 Document 物件的 root 元素會 match在 HTML 中，root 元素就是 &lt;html&gt; 元素Child-indexed Pseudo-classes此 pseudo-class 會根據 inclusive sibling 之間的 index 來選擇元素。選擇 index 為多少的 sibling (兄弟，同層) 元素，元素的第一個子元素的 index 是 1。只有開頭為 nth 的 Child-indexed Pseudo-classes 和 Typed Child-indexed Pseudo-classes 都可以在 () 括號裡面可以使用下面這幾種值：an + b：n 可以是任何​​正整數或 0 的數值a 和 b 的值必須是整數 (正數、負數或 0)當 a 和 b 都大於 0 時，可以更好的將 sibling 元素劃分為元素群組 (groups of a elements)，並選擇每個群組的第 b 個元素， 例如：3n + 1 可以 match 到第 1、4、7…等子元素0n + 5 等同於 5當 a 為負值，且 n &gt;= 0 時，只有 an + b 為正值才可以代表 document tree 中的元素odd：奇數的所有 sibling 元素，等同於 2n + 1even偶數的所有 sibling 元素，等同於 2n語法詳情可參閱 Selectors Level 3 的「6.6.5.2. :nth-child() pseudo-class」章節部份。Child-indexed Pseudo-classes 有下面這些 selector：:nth-child(an+b)：選擇指定 index 的所有 sibling 元素，從第一個 sibling 元素開始數:nth-last-child(an+b)：選擇指定 index 的所有 sibling 元素，從最後一個 sibling 元素開始數:first-child()：選擇 sibling 列表中的第一個元素等同於 :nth-child(1):last-child()：選擇 sibling 列表中的最後一個元素等同於 :nth-last-child(1):only-child()：選擇沒有 sibling 的元素等同於 :first-child:last-child 或 :nth-child(1):nth-last-child(1)，但 specificity 較低Typed Child-indexed Pseudo-classes此 pseudo-class 類似於 Child Index Pseudo-classes，但此 pseudo-class 是基於 sibling 列表中相同 type (tag 名稱) 的元素之間的元素 index 來解析。Typed Child-indexed Pseudo-classes 有下面這些 selector：:nth-of-type(an+b)：選擇指定 index 的所有相同 type 的 sibling 元素，從第一個 sibling 元素開始數:nth-last-of-type(an+b)選擇指定 index 的所有相同 type 的 sibling 元素，從最後一個 sibling 元素開始數:first-of-type()選擇 sibling 列表中的第一個相同 type 的元素等同於 :nth-of-type(1):last-of-type()選擇 sibling 列表中的最後一個相同 type 的元素等同於 :nth-last-of-type(1):only-of-type()選擇沒有相同 type 的 sibling 元素等同於 :first-of-type:last-of-type 或 :nth-of-type(1):nth-last-of-type(1)，但 specificity 較低:nth-of-type() 與 :nth-child() 的差異下面是 :nth-of-type() 和 :nth-child() 的範例：123456789101112131415161718192021222324&lt;ul&gt; &lt;li&gt;1 (1 li)&lt;/li&gt; &lt;li&gt;2 (2 li)&lt;/li&gt; &lt;div&gt;3 (div)&lt;/div&gt; &lt;li&gt;4 (3 li) &lt;ul class=\"nested-list\"&gt; &lt;li&gt;4-1&lt;/li&gt; &lt;li&gt;4-2&lt;/li&gt; &lt;li&gt;4-3&lt;/li&gt; &lt;li&gt;4-4&lt;/li&gt; &lt;li&gt;4-5&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;5 (4 li)&lt;/li&gt; &lt;li&gt;6 (5 li)&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;1 (1 li)&lt;/li&gt; &lt;li&gt;2 (2 li)&lt;/li&gt; &lt;div&gt;3 (div)&lt;/div&gt; &lt;li&gt;4 (3 li)&lt;/li&gt; &lt;li&gt;5 (4 li)&lt;/li&gt; &lt;li&gt;6 (5 li)&lt;/li&gt;&lt;/ul&gt;12345678910div &#123; color: olive; &#125;li:nth-of-type(odd) &#123; margin: 2px; outline: 2px solid red;&#125;li:nth-child(odd) &#123; border: 2px solid blue;&#125;這個範例有兩個 ul 元素，裡面各有五個 li 元素，而且在與第二個 li 元素同層的後面加上一個 div 元素，這是用來驗證 :nth-of-type() 和 :nth-child() 的差異用的。另外，在第一個 ul 元素裡面還有一個巢狀 &lt;ul class=&quot;nested-list&quot;&gt; 元素，它放在第四個 li 元素裡面，這是用來巢狀的元素也可以被 selector 選到。每個元素的前面都有一個編號，代表在 sibling 元素之間的 index。而後面的括號是用來告訴你它是 li 元素還是 div 元素，如果是 li 元素就會註記是第幾個 li 元素。例如：4 (3 li) 就代表是第四個 sibling 元素，並且是第三個 li 元素。可以看到那些有紅色 outline 的元素都有 match 到 li:nth-of-type(odd)，因為此 pseudo-class 是以 of-type 為結尾，所以此 selector 只會找相同 type 的 sibling 元素 (OS：就很像是忽略了 div 元素的存在)。只要是奇數的 sibling 元素都會被選起來，套用紅色的 outline 樣式。而那些有藍色 border 的元素都有 match 到 li:nth-child(odd)，因為此 pseudo-class 是以 child 為結尾，所以此 selector 會直接找是 li 的 sibling 元素，並且要是奇數的 sibling 元素。不過，第三個 sibling 元素是 div 元素，不是 li 元素，因此 li:nth-child(odd) 就不會 match 到此 div 元素而巢狀 &lt;ul class=&quot;nested-list&quot;&gt; 元素裡面只有五個 li 元素，沒有其他 type 的元素，所以都會選到奇數的 sibling 元素 (因為沒有亂路的元素)。Demo：Codepen 連結See the Pen :nth-child &amp; :nth-of-type by Titangene (@titangene) on CodePen.The negation pseudo-class:not(X) 是一個函數符號，可將一個 simple selector (不包括 :not(X) 本身) 作為參數。:not(X) 代表不選擇 match 到 X simple selector 的元素。註：以下這些都是 simple selector：type selector：例如 divuniversal selector：例如 *attribute selector：例如 div[foo]class selector：例如 .myclassID selector：例如 #myidpseudo-class：例如 a:hover不能巢狀使用，所以 :not(:not(...)) 是無效的。另外請注意，因為 pseudo-element 不是 simple selector，所以 pseudo-element 不是 :not() 的有效參數。例如：match HTML 文件中所有未被禁用的 button 元素：1button:not([disable])註：[disable] 是 attribute selector，詳情請參閱我前幾天寫的「重新認識 CSS - Attribute selector (屬性選擇器)」。match 除了 #titan 元素之外的所有元素：1*:not(#titan)註：#titan 是 ID selector，詳情請參閱我前幾天寫的「重新認識 CSS - Simple Selector &amp; Groups of selector」。最後今天介紹一些 structural pseudo-class，接下來幾天會接續介紹其他 selector。資料來源：CSS 2.2 Specification - SelectorsSelectors Level 3Selectors Level 4","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Pseudo-class (偽類) (1)","slug":"css-selector-pseudo-class-1","date":"2019-09-19T08:20:52.000Z","updated":"2019-10-14T00:33:48.000Z","comments":true,"path":"article/css-selector-pseudo-class-1.html","link":"","permalink":"https://titangene.github.io/article/css-selector-pseudo-class-1.html","excerpt":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 pseudo-class (偽類)。","text":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 pseudo-class (偽類)。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Pseudo-class (偽類) (1)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene Blog之前有提到以下這些都是 simple selector：type selectoruniversal selectorattribute selectorclass selectorID selectorpseudo-class本篇會介紹 pseudo-class，如果想了解其他 simple selector 可參閱之前介紹的「重新認識 CSS - Simple Selector &amp; Groups of selector」。Pseudo-classespseudo-class 是以 : 為開頭，後面接著 pseudo-class 的名稱，有些會在後面加上括號 ()，並在括號之間加上值。例如：:nth-child(2)。注意：pseudo-class 和 pseudo-element 不相同pseudo-class 是以 : 為開頭pseudo-element 是以 :: 為開頭，但也可以以 : 為開頭，因為在舊版的 W3C Spec 中沒有將 pseudo-class 和 pseudo-element 區分成 : 和 ::。如果你寫 pseudo-element 是用 :，大部份瀏覽器也還是會支援這種語法。Dynamic pseudo-classesDynamic pseudo-classes 不會出現在 document source 或 document tree 中。Dynamic pseudo-classes 又分為：link pseudo-classes：:link 和 :visiteduser action pseudo-classes：:hover、:active 和 :focusThe link pseudo-classes：:link 和 :visitedUA (User agent，對 HTML 來說就是瀏覽器) 以不同的方式來顯示連結是否已訪問：:link：未訪問過的連結:visited：已訪問過的連結不過，過了一段時間之後，UA 可以將已訪問的連結從 :visited 變回 :link 的狀態。12&lt;h3&gt;&lt;a href=\"https://titangene.github.io\"&gt;Titangene Blog&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=\"https://titangene.github.io/article/css-selector-pseudo-class-1.html\"&gt;重新認識 CSS - CSS Selector (3)&lt;/a&gt;&lt;/h3&gt;12a:visited &#123; color: red; &#125;a:link &#123; color: green; &#125;Demo：Codepen 連結See the Pen link pseudo-class: :visited &amp; :link by Titangene (@titangene) on CodePen.The user action pseudo-classes：:hover、:active 和 :focus用於 response 使用者的操作：:hover：當 cursor (滑鼠指標) hover 在元素上時，visual UA 就可以應用此 pseudo-class不支援 互動式 media 的 UA 不用支援此 pseudo-class:active：在使用者按下滑鼠按鈕並放開它之間的時間會應用此 pseudo-class如果滑鼠上有多個按鈕時，:active 只適用於主要或主要 actived 的按鈕 (通常為滑鼠左鍵) …等:focus：當元素有焦點時會應用此 pseudo-class，例如：按鍵盤的 Tab 鍵所選到的元素12&lt;h3&gt;&lt;a href=\"https://titangene.github.io\"&gt;Titangene Blog&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=\"https://titangene.github.io/article/css-selector-pseudo-class-1.html\"&gt;重新認識 CSS - CSS Selector (3)&lt;/a&gt;&lt;/h3&gt;1234a &#123; color: black; &#125;a:hover &#123; color: red; &#125;a:focus &#123; color: gray; &#125;a:active &#123; color: purple; &#125;Demo：Codepen 連結See the Pen user action pseudo-class by Titangene (@titangene) on CodePen.也可以一次使用多個 dynamic pseudo-class，如下範例：同時有 :focus 和 :hover 的狀態同時有 :link 和 :active 的狀態12a:focus:hover &#123; color: teal; &#125;a:link:active &#123; color: fuchsia; &#125;The target pseudo-classes：:target有些 URI 的最後會以 # (number sign) 為結尾，後面會接著 anchor identifier (也稱為 fragment identifier)，代表該 URI 是指向資源中的某個位置。通常帶有 fragment identifier 的 URL 會 link 到文件中的某些元素，該元素被稱為 target 元素。例如：在下面的 HTML 文件中有名為 hello 的 anchor (錨點) (也就是 &lt;a href=&quot;#hello&quot;&gt;Hello&lt;/a&gt; 這個連結)：1234&lt;h1&gt;&lt;a href=\"#hello\"&gt;Hello&lt;/a&gt;&lt;/h1&gt;&lt;div id=\"hello\"&gt; &lt;h2&gt;Target&lt;/h2&gt;&lt;/div&gt;1#hello:target &#123; color: red; &#125;Demo：Codepen 連結如果此 HTML 的 URL 為：1https:&#x2F;&#x2F;s.codepen.io&#x2F;titangene&#x2F;debug&#x2F;jONegME&#x2F;vWkRwRNmBvOM在還沒點擊 #hello 錨點時，畫面如下：只要點擊 #hello 錨點後，下面的 “Target” 文字就會變成紅色 (也就是會應用 #hello:target 的樣式)，畫面如下：並且 URL 的最後會加上 #hello，而 #hello 就是 fragment identifier。剛剛點擊的錨點會 link 到 target 元素，而 target 元素就是 &lt;div id=&quot;hello&quot;&gt;，所以 selector 才會 match 到 #hello:target。See the Pen target pseudo-classes :target by Titangene (@titangene) on CodePen.在 MDN 有一個範例也蠻有趣的，可以用 :target pseudo-class 來實作 lightbox：運作原理是用 display: none 和 display: block 來控制 lightbox 是否開啟，觸發的機制就是用剛剛介紹的 :target pseudo-class 來做的。這個範例很有趣，以前用 JavaScript 才能做到的事情，沒想到也能用純 CSS 來實作出來。UI element states pseudo-classes分為：:enabled：處於啟用狀態的 UI 元素:disabled：處於禁用狀態的 UI 元素:checked：選取 radio 或勾選 checkbox 元素時會應用:enabled &amp; :disabled pseudo-class直接看範例：123456789101112131415&lt;form&gt; &lt;label for=\"enabledField\"&gt;enabled field:&lt;/label&gt; &lt;input type=\"text\" id=\"enabledField\" value=\"Lorem\"&gt; &lt;br&gt;&lt;br&gt; &lt;label for=\"disabledField\"&gt;disabled field:&lt;/label&gt; &lt;input type=\"text\" id=\"disabledField\" value=\"Lorem\" disabled&gt; &lt;br&gt;&lt;br&gt; &lt;label for=\"enabledCheckbox\"&gt;enabled checkbox:&lt;/label&gt; &lt;input type=\"checkbox\" id=\"enabledCheckbox\"&gt; &lt;br&gt;&lt;br&gt; &lt;label for=\"disabledCheckbox\"&gt;disabled checkbox:&lt;/label&gt; &lt;input type=\"checkbox\" id=\"disabledCheckbox\" disabled&gt; &lt;br&gt;&lt;br&gt; &lt;input type=\"button\" value=\"Submit\"&gt;&lt;/form&gt;12input:enabled &#123; outline: 3px solid red; &#125;input:disabled &#123; outline: 3px solid blue; &#125;Demo：Codepen 連結只要被加上 disabled 屬性的 input 元素都代表該元素處於禁用狀態，所以這些元素就會套用 input:disabled 此 selector 的樣式。其餘的元素則會套用 input:enabled 此 selector 的樣式。不過要注意的事元素有無啟用，跟一些會影響使用者互動 UI 元素的 CSS 屬性沒關係，這些都不會影響 selector 是否 match 到 :enabled 或 :disabled。例如：display 和 visibility 屬性都會讓元素在畫面上消失，但是都不會影響到啟用或禁用的狀態。display: none 不會讓元素出現在 formatting structure 中，很像不在畫面上，會完全消失visibility: hidden 生成的 box 是看不見的，完全透明，不會 draw 任何內容，但會影響佈局，也就是會在畫面上佔用空間，但會看不到元素的樣子See the Pen :enabled and :disabled pseudo-classes by Titangene (@titangene) on CodePen.:checked pseudo-class直接看範例：123456789&lt;input type=\"checkbox\" id=\"firstCheckbox\" checked&gt;&lt;label for=\"firstCheckbox\"&gt;First checkbox&lt;/label&gt;&lt;input type=\"checkbox\" id=\"secondCheckbox\"&gt;&lt;label for=\"secondCheckbox\"&gt;Second checkbox&lt;/label&gt;&lt;br&gt;&lt;input type=\"radio\" id=\"firstRadio\" checked&gt;&lt;label for=\"firstRadio\"&gt;First radio&lt;/label&gt;&lt;input type=\"radio\" id=\"secondRadio\"&gt;&lt;label for=\"secondRadio\"&gt;Second radio&lt;/label&gt;12input + label &#123; color: red; &#125;input:checked + label &#123; color: blue; &#125;Demo：Codepen 連結See the Pen :checked pseudo-class by Titangene (@titangene) on CodePen.最後今天介紹一些 pseudo-class，接下來幾天會接續介紹其他 selector。資料來源：CSS 2.2 Specification - SelectorsSelectors Level 3Selectors Level 4:target - CSS | MDNAbout MDN by Mozilla Contributors is licensed under CC-BY-SA 2.5","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Attribute selector (屬性選擇器)","slug":"css-attribute-selector","date":"2019-09-18T08:20:52.000Z","updated":"2019-10-13T05:45:19.000Z","comments":true,"path":"article/css-attribute-selector.html","link":"","permalink":"https://titangene.github.io/article/css-attribute-selector.html","excerpt":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 attribute selector (屬性選擇器)。","text":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 attribute selector (屬性選擇器)。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Attribute selector (屬性選擇器)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogAttribute selectorSelector 允許表示元素的屬性。當 selector 作為 expression (表達式) 來 match 元素時，如果該元素具有與 attribute selector (屬性選擇器) 表示的屬性 match 的屬性，則必須將 attribute selector 視為與元素 match。Attribute presence and value selectorCSS2 引入了四個 attribute selector：[att]：代表具有 att 屬性的元素，無論屬性的值為何[att=val]：代表具有 att 屬性的元素，且該屬性值為 val[att~=val]：代表具有 att 屬性的元素，該屬性的值是以空格分隔的單詞列表，其中一個正好是 val如果 val 包含空格，就不會 match 任何內容 (因為單字之間是用空格來分隔)如果 val 是空字串，就不會 match 任何內容[att|=val]：代表具有 att 屬性的元素，且該屬性值為 val 或以 val 為開頭，後面接著 - (也就是以 val- 為開頭)直接看範例：1234567891011121314151617181920&lt;h1&gt;Titan&lt;/h1&gt;&lt;h1 title=\"hello\"&gt;Hello&lt;/h1&gt;&lt;h1 title=\"titan\"&gt;Titan&lt;/h1&gt;&lt;h2 title=\"hello\"&gt;Hello&lt;/h2&gt;&lt;h2 title=\"titan\"&gt;Titan&lt;/h2&gt;&lt;h1 class=\"highlight\"&gt;highlight Titan&lt;/h1&gt;&lt;h1 title=\"titan\" class=\"highlight\"&gt;highlight Titan&lt;/h1&gt;&lt;h1 class=\"text text-primary text-bold\"&gt;Text&lt;/h1&gt;&lt;h1 class=\"text-primary text\"&gt;Text&lt;/h1&gt;&lt;h2 class=\"text\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"textPrimary\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"text-primary\"&gt;Text&lt;/h2&gt;&lt;h1 class=\"alert\"&gt;Text&lt;/h1&gt;&lt;h1 class=\"alert-primary\"&gt;Text&lt;/h1&gt;123456h1[title] &#123; color: red; &#125;h2[title=\"titan\"] &#123; color: green; &#125;h1[title=\"titan\"][class=\"highlight\"] &#123; color: blue; &#125;h1[class~=\"text\"] &#123; color: purple; &#125;h2[class|=\"text\"] &#123; color: olive; &#125;h1[class=\"alert\"], h1[class=\"alert-primary\"] &#123; color: gray; &#125;h1[title]：帶有 title 屬性的 h1 元素h2[title=&quot;titan&quot;]：帶有 title 屬性的 h2 元素，並且該屬性值為 titanh1[title=&quot;titan&quot;][class=&quot;highlight&quot;]：帶有 title 和 class 屬性的 h1 元素，並且 title 的屬性值為 titan 以及 class 屬性值為 highlighth1[class~=&quot;text&quot;]：帶有 class 屬性的 h1 元素，並且該屬性值需包含 texth2[class|=&quot;text&quot;]：帶有 class 屬性的 h2 元素，並且該屬性值為需為 text 或以 text- 為開頭h1[class=&quot;alert&quot;], h1[class=&quot;alert-primary&quot;]：帶有 class 屬性的 h1 元素，並且該屬性值為 alert，以及帶有 class 屬性的 h1 元素，並且該屬性值為 alert-primary註：[title=&quot;titan&quot;] 中的 title 是屬性名稱，titan 是名為 title 的屬性值。Demo：Codepen 連結See the Pen Attribute presence and value selectors by Titangene (@titangene) on CodePen.如上述所說，[att~=val] 有以下兩項語法規則，下面會分別以範例來說明：如果 val 包含空格，就不會 match 任何內容 (因為單字之間是用空格來分隔)如果 val 是空字串，就不會 match 任何內容123&lt;h1 class=\"text text-primary text-bold\"&gt;Text&lt;/h1&gt;&lt;h1 class=\"text-primary text\"&gt;Text&lt;/h1&gt;&lt;h1 class=\"text\"&gt;Text&lt;/h1&gt;12345678h1[class~=\"text\"] &#123; color: olive; &#125;/* 以下 selector 都不會 match 任何內容 */h1[class~=\"text \"] &#123; color: red; &#125;h1[class~=\" text\"] &#123; color: green; &#125;h1[class~=\" text \"] &#123; color: blue; &#125;h1[class~=\" \"] &#123; color: purple; &#125;h1[class~=\"\"] &#123; color: gray; &#125;Demo：Codepen 連結See the Pen Attribute presence and value selectors：[att~=val] by Titangene (@titangene) on CodePen.Substring matching attribute selector在 Selectors Level 3 提供了三個額外的 attribute selector，用於 match 屬性值中的子字串：[att^=val]：代表具有 att 屬性的元素，該屬性值以 val 為開頭。如果 val 是空字串，則 selector 不會 match 任何內容[att$=val]：代表具有 att 屬性的元素，該屬性值以 val 為結尾。如果 val 是空字串，則 selector 不會 match 任何內容[att*=val]：代表具有 att 屬性的元素，該屬性值至少包含 val 這個子字串。如果 val 是空字串，則 selector 不會 match 任何內容直接看範例：12345678910&lt;h2 class=\"text\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"textPrimary\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"text-primary\"&gt;Text&lt;/h2&gt;&lt;h2&gt;&lt;a href=\"https://titangene.github.io/article/css-attribute-selector.html\"&gt;重新認識 CSS - CSS Selector (2)&lt;/a&gt;&lt;/h2&gt;&lt;h2&gt;&lt;a href=\"https://titangene.github.io\"&gt;Titangene Blog&lt;/a&gt;&lt;/h2&gt;&lt;h2 class=\"my-alert\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"myAlertPrimary\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"my-alert-primary\"&gt;Text&lt;/h2&gt;123h2[class^=\"text\"] &#123; color: red; &#125;a[href$=\".html\"] &#123; color: gray; &#125;h2[class*=\"alert\"] &#123; color: green; &#125;h2[class^=&quot;text&quot;]：代表具有 class 屬性的元素，該屬性值以 text 為開頭a[href$=&quot;.html&quot;]：代表具有 href 屬性的元素，該屬性值以 .html 為結尾 (也就是該頁面為 .html 檔)h2[class*=&quot;alert&quot;]：代表具有 class 屬性的元素，該屬性值至少包含 alert 這個子字串Demo：Codepen 連結See the Pen Substring matching attribute selectors by Titangene (@titangene) on CodePen.最後今天介紹一些 attribute selector，接下來幾天會接續介紹其他 selector。資料來源：CSS 2.2 - 5. SelectorsSelectors Level 3Selectors Level 4","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - Simple Selector & Groups of selector","slug":"css-selector-1","date":"2019-09-17T10:20:52.000Z","updated":"2019-10-14T14:42:12.000Z","comments":true,"path":"article/css-selector-1.html","link":"","permalink":"https://titangene.github.io/article/css-selector-1.html","excerpt":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。","text":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - Simple Selector &amp; Groups of selector「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogSelector 語法Selector 是由一個或多個 sequence of simple selector (簡單選擇器) 所組合，並用 combinator 分隔的一串東西。sequence of simple selectors：由多個 simple selector 組成，沒有被 combinator 分隔以 type selector 或 universal selector 為開頭以下這些都是 simple selector：type selector：例如 Euniversal selector：例如 *attribute selector：例如 E[foo]class selector：例如 .myclassID selector：例如 #myidpseudo-class：例如 E:hovercombinator 是 (空白字元)、&gt;、+、~，例如：1234E F &#123; color: red; &#125;E &gt; F &#123; color: red; &#125;E + F &#123; color: red; &#125;E ~ F &#123; color: red; &#125;simple selector 與 combinator 之間可以加上空白，不加空白也可以。例如：下面兩個選擇器是相同的：12E &gt; FE&gt;F不過，通常在之間都會加空白，因為可讀性較佳。所有 CSS 語法在 ASCII 範圍內都不分大小寫 (也就是 [a-z] 等於 [A-Z] )，但不受 CSS 控制的部分除外。例如：HTML 的 id 和 class 屬性值、字體名稱和 URI 是否分大小寫都超出 CSS Spec 的定義範圍。另外，HTML 的元素名稱是不分大小寫的，但在 XML 就有分大小寫。雖然在 CSS 2.2 spec 是說 pseudo-element 和 pseudo-class 的名稱不分大小寫，但通常會使用小寫。在 CSS 中，identifier (包括 selector 中的元素名稱、class 和 ID) 只能包含字元 [a-zA-Z0-9] 和 ISO 10646 字元中的 U+0080 及之後的字元，以及 hyphen ( - ) 和底線 ( _ )；它們不能以數字、兩個 hyphen 或 hyphen 後面接著數字為開頭。詳情可參閱 CSS 2.2 - 4.1.3. Characters and case。Groups of selector當多個選擇器共享相同的宣告時，它們可以用逗號來分隔每個選擇器，每個選擇器都會選到 match 的所有元素，例如：123&lt;h1&gt;header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h3&gt;header 3&lt;/h3&gt;123h1 &#123; color: red; &#125;h2 &#123; color: red; &#125;h3 &#123; color: red; &#125;等同於：1h1, h2, h3 &#123; color: red; &#125;Demo：Codepen 連結See the Pen Groups of selector by Titangene (@titangene) on CodePen.不要要注意的是，上面兩個範例會有一樣的結果是因為所有選擇器都是有效的選擇器 (valid selector)。如果其中一個選擇器為無效時，就會讓整個選擇器群組都無效。不過，若將三個選擇器分開宣告時，就只有那一個會失效。例如：123&lt;h1&gt;header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h3&gt;header 3&lt;/h3&gt;123h1 &#123; color: red; &#125;h2..foo &#123; color: red; &#125;h3 &#123; color: red; &#125;不等於：1h1, h2..foo, h3 &#123; color: red; &#125;Demo：Codepen 連結如下圖，因為上面其中的 h2..foo 是無效選擇器 (invalid selector)，所以會造成 h1, h2..foo, h3 完全無效，並且會刪除這個樣式規則：如果是分開宣告，就只會刪除 h2..foo 這個樣式規則，如下圖：See the Pen Groups of selector: valid selector by Titangene (@titangene) on CodePen.Simple selector以下這些都是 simple selector：type selectoruniversal selectorattribute selectorclass selectorID selectorpseudo-classType selector與 HTML 的 element type 的名稱 (也就是 HTML tag 名稱) match。例如：match 所有 h1 元素：1&lt;h1&gt;header 1&lt;/h1&gt;1h1 &#123; color: red; &#125;Demo：Codepen 連結See the Pen type selector by Titangene (@titangene) on CodePen.Universal SelectorUniversal selector 是使用 * 來 match 任何 element type 的名稱。例如：下面範例可以選到所有元素：1234&lt;h1&gt;header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h3&gt;header 3&lt;/h3&gt;&lt;a href=\"https://titangene.github.io/\"&gt;Titangene Blog&lt;/a&gt;1* &#123; color: red; &#125;Demo：Codepen 連結See the Pen Universal Selector by Titangene (@titangene) on CodePen.Class selector如果要對多個元素需要相同的樣式時，就可以用 class 這個屬性來標識它們。在 CSS 是使用 . 來代表 class 屬性，也等同於 ~= 表示法 (notation)，屬性值必須在 . 之後。例如：12&lt;h1&gt;header 1&lt;/h1&gt;&lt;h1 class=\"highlight\"&gt;highlight header 1&lt;/h1&gt;1h1.highlight &#123; color: red; &#125;等同於：1h1[class~=highlight] &#123; color: red; &#125;Demo：Codepen 連結第一個 h1 元素的字體顏色不會變成紅色，只有第二個 h1 元素才會變紅色：See the Pen class selector by Titangene (@titangene) on CodePen.如果只單獨使用 class selector (也就是 . )，也等同於在前面加上 universal selector (也就是 * )。例如：1234&lt;h1&gt;header 1&lt;/h1&gt;&lt;h1 class=\"highlight\"&gt;highlight header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h2 class=\"highlight\"&gt;highlight header 2&lt;/h2&gt;1*.highlight &#123; color: red; &#125;1.highlight &#123; color: red; &#125;Demo：Codepen 連結第一個 h1 和 h2 元素的字體顏色不會變成紅色，只有第二個 h1 和 h2 元素才會變紅色：See the Pen class selector &amp; universal selector by Titangene (@titangene) on CodePen.如果需要同時指定某元素上的兩個 class，可以寫成這樣：1234&lt;h1&gt;header 1&lt;/h1&gt;&lt;h1 class=\"text-primary highlight\"&gt;highlight header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h2 class=\"highlight\"&gt;highlight header 2&lt;/h2&gt;1.text-primary.highlight &#123; color: red; &#125;註：在 HTML 要對某元素上同時設定多個 class，是使用空白字元來分隔多個 class。以上面範例來說，第二個 h1 上有兩個 class，分別是 text-primary 和 highlight。Demo：Codepen 連結See the Pen multi class selector by Titangene (@titangene) on CodePen.ID selector如果要對某個元素作唯一的標示，就可以用 id 這個屬性來標識它們。在 CSS 是使用 # 來代表 id 屬性，屬性值必須在 # 之後。例如：1234&lt;h1&gt;header 1&lt;/h1&gt;&lt;h1 id=\"titan\"&gt;header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h2 id=\"titan\"&gt;header 2&lt;/h2&gt;1#titan &#123; color: red; &#125;Demo：Codepen 連結See the Pen id selector by Titangene (@titangene) on CodePen.如果只想選擇帶有 titan 這個 id 的 h2 元素，可以寫成這樣：1h2#titan &#123; color: red; &#125;Demo：Codepen 連結See the Pen id selector: specific element by Titangene (@titangene) on CodePen.Pseudo-classpseudo-class 會在之後的兩篇中介紹到：重新認識 CSS - Pseudo-class (偽類) (1)重新認識 CSS - Pseudo-class (偽類) (2)最後今天介紹一些 simple selector，接下來幾天會接續介紹其他 selector。資料來源：CSS 2.2 - 5. SelectorsCSS 2.2 - 4.1.3. Characters and caseSelectors Level 3Selectors Level 4","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"重新認識 CSS - CSS 簡介","slug":"css-introduction","date":"2019-09-16T10:10:11.000Z","updated":"2019-09-16T13:58:19.000Z","comments":true,"path":"article/css-introduction.html","link":"","permalink":"https://titangene.github.io/article/css-introduction.html","excerpt":"CSS 是 Cascading Style Sheets 的縮寫，是一種 style sheet (樣式表) 語言，可將自訂的樣式 (例如：字體、顏色) 附加在 HTML 文件上。這篇會先簡介 CSS，以及如何在 HTML 設定 CSS。","text":"CSS 是 Cascading Style Sheets 的縮寫，是一種 style sheet (樣式表) 語言，可將自訂的樣式 (例如：字體、顏色) 附加在 HTML 文件上。這篇會先簡介 CSS，以及如何在 HTML 設定 CSS。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。CSS 規則是由 selector 和宣告 (declaration) 組成，以下面程式碼的 CSS 規則為例，h1 就是 selector，color: red 就是宣告。在 HTML 中，元素名稱不分大小寫，例如：H1 和 h1 相同，但通常會寫小寫。宣告又由屬性名稱和屬性值組成，以下面程式碼為例，color 就是屬性名稱，red 就是屬性值。123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;1h1 &#123; color: red; &#125;在 HTML 設定 CSS要在 HTML 內設定 CSS 有三種方法：Inline CSS：元素上的 style 屬性Internal CSS：style 元素External CSS：link 元素引入外部 CSSInline CSS：元素上的 style 屬性在指定的元素上透過 style 屬性來設定 CSS 樣式相同的樣式無法共用，如果要在不同元素設定相同的樣式，就需要在每個元素上設定 style 屬性CSS 樣式與 HTML 結構寫在一起，可讀性差，不建議這樣寫12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 style=\"color: red;\"&gt;Title&lt;/h1&gt; &lt;h2 style=\"color: red;\"&gt;Title&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt;Demo：See the Pen Inline CSS by Titangene (@titangene) on CodePen.Internal CSS：style 元素直接在 HTML 原始碼內利用 style 元素來設定 CSS只能在單獨的 HTML 內使用 style 元素裡的樣式123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h1 &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;Demo：External CSS：link 元素引入外部 CSS使用 link 元素引入外部 CSS 檔案內的樣式可將 HTML 與 CSS 的原始碼分開管理若要更改樣式，只要更換成其他 CSS 檔案或修改外部 CSS 檔案內的樣式同一份 CSS 樣式可套用至多個 HTML 文件使用常見會使用 CDN (Content Delivery Network)link 元素 上的設定：用 rel 屬性 (relationships) 設定連結類型：stylesheet用 href 屬性 (hyperlink reference) 指定的 CSS 路徑12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;下面內容為 style.css：1h1 &#123; color: red; &#125;Demo：Multiple Style Sheets如果以不同的方式來對同一個元素設定樣式，則會使用最後設定的樣式。例如：同時使用 internal CSS 和 external CSS 的方式設定 CSS：12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\" type=\"text/css\"&gt; &lt;style&gt; h1 &#123; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;下面內容為 style.css：1h1 &#123; color: red; &#125;那 h1 的顏色會是綠色：如果更換 style 和 link 元素的順序，h1 的顏色則會是紅色：12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h1 &#123; color: green; &#125; &lt;/style&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\" type=\"text/css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;資料來源：Style Sheets in HTML documentsHTML Standard - 4.2.4 The link element","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"},{"name":"HTML","slug":"css/html","permalink":"https://titangene.github.io/categories/css/html/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"author":"Titangene"},{"title":"套用自訂 HackMD 暗主題","slug":"hackmd-dark-theme","date":"2019-05-18T12:16:35.000Z","updated":"2019-05-19T16:02:51.000Z","comments":true,"path":"article/hackmd-dark-theme.html","link":"","permalink":"https://titangene.github.io/article/hackmd-dark-theme.html","excerpt":"HackMD 是我常用的寫作平台，因官方沒有提供暗主題的瀏覽模式，所以我就刻了自訂的暗主題，也將自訂主題開源在 GitHub，歡迎大家發 PR 給我，並記得幫我按個 ⭐️ 星。","text":"HackMD 是我常用的寫作平台，因官方沒有提供暗主題的瀏覽模式，所以我就刻了自訂的暗主題，也將自訂主題開源在 GitHub，歡迎大家發 PR 給我，並記得幫我按個 ⭐️ 星。應該有很多人在瀏覽器安裝 Dark reader 這個擴充功能吧？通常使用的原因大多是想把畫面變成深色瀏覽模式，比較保護眼睛。但是有些網站使用這個擴充功能之後，有些顏色不是你習慣或喜歡的，尤其是在個人常用的網站上會感覺沒那麼習慣。而 HackMD 是我常用來寫技術筆記的寫作平台，尤其是程式碼的 highlight，我個人偏好 VS Code 預設的暗主題 (Dark+ 這個主題)，所以我就在網頁上加上自己自訂的 CSS 去改成我想要的主題。那如何將自定的 CSS 加在指定的網站上呢？原本我是用 Stylish 來管理自訂的網頁樣式，但後來因為一些原因這個擴充功能多了在背景上傳資訊的功能 (雖然官方說不會上傳個資)，於是我就改用 Stylus 來管理樣式。Stylus 是 Stylish 的分支，刪除了任何與分析、回傳資料的功能。如何使用主題在瀏覽器安裝 Stylus 擴充功能，Stylus 目前提供這幾種瀏覽器版本的擴充功能：ChromeFirefoxOpera下載我自定的 HackMD dark theme 至 Stylus下載樣式後會自動套用，開啟 HackMD 就會看到介面變成暗主題囉！如果是之前就開啟的 HackMD 頁面，有時會需要重新整理頁面才會套用暗主題。就是這麼簡單 😄。這邊要另外說明一下，雖然剛剛提到因為 Stylish 有收集資料的問題，所以我改用 Stylus 來管理自定樣式，但是要將自定的樣是分享給別人使用，還是要註冊 Stylish 官方平台的帳號，將要分享的樣式上傳至這個平台，讓其他人可以下載使用。不過如果只是下載別人的主題是不需要註冊帳號，所以不用擔因。原始碼這就是我自定 HackMD 樣式的原始碼：titangene/hackmd-dark-theme如果發現需修正的地方，歡迎發 pull request 給我 😎。如果喜歡，記得幫我按個 ⭐️ 星，Thanks。畫面截圖OverviewRecentView modeBook modeSlide modeEmoji &amp; Todo list &amp; Code block highlightGithub GistLaTeX &amp; UMLTableToC (Table of Contents)HistoryPermissionComment小結其實這個 side project 我在 2017 年 8 月就開始做了，期間做了一些不定期的更新，這次的更新算是所有我發現想改的部分 (洞) 都填好了 (有可能我眼殘沒發現的部分也需要改 XD，歡迎大家發 PR 給我)，包括最近 HackMD 官方推出的可分享文件給指定帳號的功能，我也把介面變成暗主題了。套用暗主題的其他秘訣在 HackMD 擔任 Developer 的 黃鈺凱 在我發文的 Facebook 社團 Markdown 台灣，跟大家分享另一種可以套用暗主題的小秘訣，而且這個方法可以將你自定的樣式，套用至你分享的筆記，或是跟夥伴參與的共筆，讓大家都能共享同樣的暗主題。這個祕訣就是在筆記內，加上 HackMD 的內嵌筆記語法，例如：1&#123;%hackmd BJrTq20hE %&#125;以 https://hackmd.io/IpJEFpXkQg2yvdsY9IbTVg?both (這個連結是由 黃鈺凱 大大提供) 這個筆記為例，在這個筆記內可以看到 HackMD 的內嵌筆記語法，而且可以看到我沒有在 Stylus 開啟我自定的 HackMD dark theme，竟然還可以保有暗主題的樣式：原因就發生在這個 HackMD 的內嵌筆記語法，因為這個語法背後幫你多加了暗主題的樣式。那是怎麼做到的呢？於是我就從 BJrTq20hE 這個看似奇怪亂碼的東西下手。馬上就直覺想到，其實 BJrTq20hE 是另一篇筆記的編號，這個筆記的完整連結像是下面這樣，網址其中的 s 是 HackMD 的發表模式 (應該是叫這樣吧？)：1https:&#x2F;&#x2F;hackmd.io&#x2F;s&#x2F;BJrTq20hE進入這個連結後，可以看到整個筆記畫面沒有任何文字內容，但是一樣在沒有套用自訂暗主題的情況下，還能有暗主題的樣式。接著我進入這個筆記的編輯模式就發現答案已揭曉，原來這個看似沒內文的筆記中，有我寫的暗主題樣式，這些樣式直接被寫在這篇 HackMD 的筆記裡面，並且放在 &lt;style&gt; 的 HTML element 內：也就是說如果未來想在其他筆記也套用相同的主題樣式，只要建立專門放樣式的筆記，然後將這個筆記透過 HackMD 的內嵌筆記語法套用至其他筆記上，這樣那些筆記都會共享相同的樣式囉！好神奇啊！感謝 HackMD Developer 大大的分享！","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"},{"name":"CSS","slug":"blog/css","permalink":"https://titangene.github.io/categories/blog/css/"}],"tags":[{"name":"Markdown","slug":"markdown","permalink":"https://titangene.github.io/tags/markdown/"},{"name":"Dark Theme","slug":"dark-theme","permalink":"https://titangene.github.io/tags/dark-theme/"}],"author":"Titangene"},{"title":"透過 Docker Compose 設定 network","slug":"networking-in-docker-compose","date":"2019-05-15T13:03:15.000Z","updated":"2019-05-15T13:02:26.000Z","comments":true,"path":"article/networking-in-docker-compose.html","link":"","permalink":"https://titangene.github.io/article/networking-in-docker-compose.html","excerpt":"Docker Compose 預設會建立 default network，這篇會告訴你如何自訂 network、如何使用現有的 network，以及如何自訂 network 名稱。","text":"Docker Compose 預設會建立 default network，這篇會告訴你如何自訂 network、如何使用現有的 network，以及如何自訂 network 名稱。Docker Compose 預設會幫你的應用程式設定一個 network，service 的每個容器都會加入 default network，並且該 network 上的其他容器都可以連接 (reachable) 以及發現 (discoverable) 與容器名稱相同的 hostname。預設的 network 名稱是基於 “專案目錄名稱”，並加上 _default。例如：你的應用程式放在名為 myapp 的專案目錄中，而 docker-compose.yml 的內容如下：1234567891011version: '3'services: web: build: . ports: - '8000:8000' db: image: postgres ports: - '8001:5432'當你執行 docker-compose up 指令時，會發生以下情況：建立一個名為 myapp_default 的 network使用 web 的設定建立容器，並以 web 這個名稱加入名為 myapp_default 的 network使用 db 的設定建立容器，並以 db 這個名稱加入名為 myapp_default 的 network當然你也可以使用 --project-name (可簡寫成 -p ) 參數 或使用 COMPOSE_PROJECT_NAME 這個 環境變數 來複寫專案名稱。現在，每個容器都可以找到名為 web 或 db 的 hostname，並獲得對應容器的 IP 位址。例如：web 的應用程式的程式碼可以連接到 postgres://db:5432 的 URL，並開始使用 Postgres 資料庫。不過要注意 HOST_PORT 和 CONTAINER_PORT 之間的差別。以上面範例中的 db 來說，HOST_PORT 是 8001，CONTAINER_PORT 是 5432 (postgres 的預設 port)。Networked service-to-service 通訊使用 CONTAINER_PORT。定義 HOST_PORT 之後，service 也可以在 swarm 外部存取。在 web 的容器中，如果要連接到 db 的連接字串會看起來像是 postgres://db:5432 這樣，而從 host machine 來看，連接字串看起來像是 postgres://{DOCKER_IP}:8001。更新容器如果有變更 service 的設定，請執行 docker-compose up 指令來更新 service，它會刪除舊的容器，而新容器會以不同的 IP 位址加入相同名稱的 network。執行中的容器可以找到該名稱並連接到新的 IP 位址，而舊的 IP 位址就無法使用。如果任何容器對舊容器開放連線，那這些容器就會被關閉連線。容器有責任檢測這個情況，再次找到名稱並重新連接。Linkslink 到另一個 service 中的容器。透過 link 可以指定 service 名稱和 link 別名 ( SERVICE:ALIAS ），或僅指定 service 名稱。透過該別名可以從其他 service 存取到 service。link 不需要啟用 service 進行通訊 - 預設情況下，任何 service 都可以通過該 service 的名稱存取任何其他 service。鏈接 (linked) service 的容器可在別名相同的 hostname 上存取，如果未指定別名，則可以存取 service 名稱。在下面範例中，可以從 web 的 hostname db 和 database 存取到 db：123456789version: '3'services: web: build: . links: - 'db:database' db: image: postgreslink 和 depends_on 都是以相同的方式表達 service 之間的依賴關係，因此可以使用它們來決定 service 啟動的順序。如果同時定義 links 和 networks，則它們之間具有 links 的 service 必須共享至少一個共同的網絡才能進行通訊。建議使用 network在 swarm 模式下使用 Compose 檔案 (v3) 部署 stack 時，會忽略 links 這個 option--link 參數為 legacy 功能，可能會被刪除。不建議使用 --link，建議使用 user-defined networks (使用者定義的網路) 來促成兩個容器之間的溝通。user-defined networks 不支援你用 --link 參數在容器之間共享環境變數。但是，你可以使用其他機制 (例如：volume)，以更可控的方式在容器之間共享環境變數。詳情可參考官方的 Compose file version 3 reference | Docker Documentation 文件。Multi-host networking注意：本節中的說明只適用於 legacy Docker Swarm 的相關操作，並且只有目標為 legacy Swarm 叢集才有用。有關將 compose 專案部署至較新的整合 swarm mode，請參考Docker Stacks 文件。將 Compose 應用程式部署至 Swarm 叢集 時，可以使用內建的 overlay driver 在容器之間啟用 multi-host 通訊，而無需更改 Compose 檔案或應用程式的程式碼。想了解如何設定 Swarm 叢集可參考官方的 Multi-host networking 這篇。叢集預設是使用 overlay driver，不過也可以參考下一節指定其他 driver。指定自定 network若不想使用預設的 app network，可以使用 top-level networks key 來指定自己的 network，讓你可以建立更複雜的拓撲，並指定 custom network driver 和 option。還可以使用它，將 service 連接到不由 Compose 管理，而是由外部建立的 network。每個 service 都可以使用 service-level networks key 指定要連接的 network，該 key 是引用至 top-level networks key 下的名稱。以下面定義的兩個自定 network 的 Compose 檔案為例，proxy service 與 db service 隔離，因為它們不共享共同的 network，只有 app 可以與兩者溝通：123456789101112131415161718192021222324252627version: '3'services: proxy: build: ./proxy networks: - frontend app: build: ./app networks: - frontend - backend db: image: postgres networks: - backendnetworks: frontend: # Use a custom driver driver: custom-driver-1 backend: # Use a custom driver which takes special options driver: custom-driver-2 driver_opts: foo: '1' bar: '2'通過為每個連接 (attached) 的 network 設定 ipv4_address 和/或 ipv6_address，可以為 network 設定靜態 IP 位址。設定 default network透過在 top-level networks key 內，名為 default network 下定義 entry，來更改應用程序範圍 (app-wide) 的 default network 的設定：1234567891011121314version: '3'services: web: build: . ports: - '8000:8000' db: image: postgresnetworks: default: # Use a custom driver driver: custom-driver-1使用 pre-existing network如果希望容器加入預先定義好的 network，就可以使用 external option。如果 external 設為 true，就會指定已在 Compose 之外先建立的那個 network，所以 docker-compose up 不會嘗試建立此 network。如果此 network 不存在，會因為找不到參考的目標 network 而發生錯誤。錯誤如下：12$ docker-compose upERROR: Network my_network declared as external, but could be found. Please create the network manually using `docker network create my_network` and try again.如果找不到此 network，可以執行 docker network create [network_name] 來建立 network。在 Compose v3.3 以及更舊版的檔案格式下，external 不能跟其他 network configuration keys 一起使用，包括：driver、driver_opts、ipam 和 internal 。Compose v3.4 以及更新版的格式就沒有這個限制。下面範例的 Compose 會找到名為 my-network-name 的已存在的 network，並將應用程式的容器連接到該 network，這樣就不會嘗試建立一個名為 [projectname]_default 的 network：123456789101112version: \"3.7\"services: app: image: whatever networks: - my-networknetworks: my-network: external: name: my-network-name在下面範例中，proxy 是通往外部世界的 gateway，所以不需要建立一個名為 [projectname]_outside 的 network。Compose 會找到一個名為 outside 的已存在的 network，並將 proxy service 的容器連接到 outside network。12345678910111213141516version: \"3.7\"services: proxy: build: ./proxy networks: - outside - default app: build: ./app networks: - defaultnetworks: outside: external: true下面範例的 Compose 不會嘗試建立一個名為 [projectname]_default 的 network，Compose 會找到名為 my-pre-existing-network 的 network，並將應用程式的容器連接到該 network。123456version: \"3.7\"networks: default: external: name: my-pre-existing-networkexternal.name 在 Compose v3.5 檔案格式 中已被棄用，請改用同版本新增的 name，下一節會說明。自訂 network 名稱network 也可以自訂名稱，name 屬性可引用包含特殊字元的 network。下面以這個 Compose 為例，介紹如何自訂 network 名稱：1234567891011version: '3.5'services: app: image: whatever networks: - my-networknetworks: my-network: name: my-app-network在 top-level networks key先把 Compose 裡面的 version 改成 3.5 以上，因為在 v3.5 版才開始提供自訂 network 名稱 (也就是增加 name 屬性)在 service-level networks key 裡面 (也就是自訂的 service 內的 networks )，加入自訂的 network 名稱 (此範例為 my-network )network 的詳細定義是寫在 top-level networks key (也就是通常寫在檔案最後面的 networks ) 裡面。這裡的 network 名稱要和 service-level networks key 裡面自訂的名稱對應 (也就是 my-network 這個 network 名稱要和上面 services 內的一樣)，在 my-network 下面就可以使用 name 屬性來自定 network 名稱 ( my-app-network 就是你真正自訂的 network 名稱 )詳情可參考官方的 Compose file version 3 reference | Docker Documentation 文件。也可以與 external 屬性一起使用：123456version: \"3.7\"networks: network1: external: true name: my-app-network參考來源Networking in Compose | Docker DocumentationCompose file version 3 reference | Docker Documentation","categories":[{"name":"DevOps","slug":"devops","permalink":"https://titangene.github.io/categories/devops/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://titangene.github.io/tags/docker/"},{"name":"Container","slug":"container","permalink":"https://titangene.github.io/tags/container/"},{"name":"Docker Compose","slug":"docker-compose","permalink":"https://titangene.github.io/tags/docker-compose/"}],"author":"Titangene"},{"title":"在 GCP 建立 Network Load Balancer 和 HTTP Load Balancer","slug":"gcp-network-and-http-load-balancer","date":"2019-04-24T14:22:43.000Z","updated":"2019-04-24T14:21:10.000Z","comments":true,"path":"article/gcp-network-and-http-load-balancer.html","link":"","permalink":"https://titangene.github.io/article/gcp-network-and-http-load-balancer.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Set Up Network and HTTP Load Balancers」這個 quest 所學到的內容，包括如何建立多個 web server instance，以及如何建立 network load balancer 和 HTTP load balancer。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Set Up Network and HTTP Load Balancers」這個 quest 所學到的內容，包括如何建立多個 web server instance，以及如何建立 network load balancer 和 HTTP load balancer。在此 lab 中，你將了解 network load balancer 和 HTTP load balancer 之間的差異，以及如何為 Google Compute Engine (GCE) VM 上執行的應用程式設定 load balancer。你可通過多種方式在 GCP 內進行負載平衡 (load balance)。此 lab 將教你完成以下 load balancer 的設定：L3 (Network Layer) Network Load BalancerL7 (Application Layer) HTTP(s) Load Balancer本篇將會做什麼？設定 network load balancer設定 HTTP load balancer透過實作，了解 network load balancer 和 HTTP load balancer 之間的差異準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)：勾選同意服務條款：之後就可以開始使用 GCP Console 囉：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：gcloud 是 GCP 的 command-line 工具，他已預先安裝在 Cloud Shell 上，並且支援 tab 自動補齊 (tab-completion)。使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]詳情可參考官方的 Google Cloud gcloud Overview 文件。為所有資源設定預設的 region 和 zone在 Cloud Shell 中，執行以下指令設定預設 zone 為 us-central1-a：12$ gcloud config set compute/zone us-central1-aUpdated property [compute/zone].在 Cloud Shell 中，執行以下指令設定預設 region 為 us-central1：12$ gcloud config set compute/region us-central1Updated property [compute/region].詳情可參考官方的 Regions &amp; Zones 文件。注意：在自己的機器上執行 gcloud 時，config 設定在 session 中保持不變 (persist across)。在 Cloud Shell 中，你需要為每個新的 session 或重新連接設定此項。建立多個 web server instance為了模擬來至一個叢集主機的服務，請使用 Instance Templates 和 Managed Instance Groups 建立一個簡單的 Nginx web server 叢集來提供靜態內容。Instance Templates 定義叢集中每個 VM 的規格 (硬碟、CPU、記憶體…等)，Managed Instance Groups 使用 Instance Templates 實例化 (instantiate) 多個 VM instance。要建立一個 Nginx web server 叢集，請建立以下內容：一個用來在每個 VM instance 啟動時設定 Nginx server 的 startup script一個要使用 startup script 的 instance template一個 target pool一個使用 instance template 的 managed instance group建立 startup script在 Cloud Shell 執行下面指令，建立要讓每個 VM instance 使用的 startup script。此 script 會在啟動時設定 Nginx server：1234567cat &lt;&lt; EOF &gt; startup.sh#! /bin/bashapt-get updateapt-get install -y nginxservice nginx startsed -i -- 's/nginx/Google Cloud Platform - '\"\\$HOSTNAME\"'/' /var/www/html/index.nginx-debian.htmlEOF建立 instance template建立一個使用 startup script 的 instance template：nginx-template：instance template 的名稱--metadata-from-file startup-script=startup.sh：--metadata-from-file 參數會從 local 檔案中找到指定的 startup script12$ gcloud compute instance-templates create nginx-template \\ --metadata-from-file startup-script=startup.sh輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/instanceTemplates/nginx-template].NAME MACHINE_TYPE PREEMPTIBLE CREATION_TIMESTAMPnginx-template n1-standard-1 2019-04-22T04:53:53.045-07:00如果上面指令沒有提供明確的 template 設定，gcloud compute 會使用以下預設值建立 template：機型：n1-standard-1image：最新版的 Debian image開機磁碟：以 instance 命名的新標準開機磁碟網路：default VPC 網路IP 位址：臨時的外部 IP 位址詳情可參考官方的 gcloud compute instance-templates 文件。若想了解更多建立 instance template 的方法，詳情可參考官方的 Creating Instance Templates 文件。建立 target pooltarget pool 資源定義了一組可以從 forwarding rules 接收收到流量的 instance。當 forwarding rules 將流量導向到 target pool 時，Google Cloud Load Balancing 會根據 source IP 和 port 以及目標 IP 和 port 的 hash 值，從這些 target pool 中選擇一個 instance。建立 target pool，target pool 允許單個存取點到群組中的所有 instance，而且對於之後步驟的負載平衡來說是必需的：1$ gcloud compute target-pools create nginx-pool輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../regions/us-central1/targetPools/nginx-pool].NAME REGION SESSION_AFFINITY BACKUP HEALTH_CHECKSnginx-pool us-central1 NONE詳情可參考官方文件：建立 target pool 指令：gcloud compute target-pools createNetwork Load Balancing ConceptsUsing Target Pools建立 managed instance group使用 instance template 建立 managed instance group：nginx-group：instance group 的名稱--base-instance-name nginx：其中的 nginx 是指在此 managed instance group 中建立的 instance 使用的名稱。由於這些 instance 都一樣，系統會用隨機字串來作為 instance 名稱的一部分，例如：如果 base 名稱是 nginx，instance 的名稱就可能會是 nginx-cl3t、nginx-sqgw … 等--size 2：instance group 的大小--template nginx-template：用於此群組的 instance template 的名稱--target-pool nginx-pool：要新增此 instance group 的 target pool 的名稱 (可多個 target pool)12345$ gcloud compute instance-groups managed create nginx-group \\ --base-instance-name nginx \\ --size 2 \\ --template nginx-template \\ --target-pool nginx-pool輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../zones/us-central1-a/instanceGroupManagers/nginx-group].NAME LOCATION SCOPE BASE_INSTANCE_NAME SIZE TARGET_SIZE INSTANCE_TEMPLATE AUTOSCALEDnginx-group us-central1-a zone nginx 0 2 nginx-template no詳情可參考官方的 Creating groups of managed instances 文件。執行上面的指令後，會建立兩個 VM instance，名稱會以 nginx- 為前綴，可能需要等幾分鐘。接著查看已建立的所有 compute engine instance：1$ gcloud compute instances list輸出：123NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSnginx-cl3t us-central1-a n1-standard-1 10.128.0.3 35.193.149.246 RUNNINGnginx-sqgw us-central1-a n1-standard-1 10.128.0.2 130.211.208.12 RUNNING設定防火牆設定防火牆後，就可以透過 EXTERNAL_IP 位址和 80 port 來連接機器：1$ gcloud compute firewall-rules create www-firewall --allow tcp:80輸出：1234Creating firewall...⠛Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/firewalls/www-firewall].Creating firewall...done.NAME NETWORK DIRECTION PRIORITY ALLOW DENY DISABLEDwww-firewall default INGRESS 1000 tcp:80 False執行上面的指令後，應該就能透過外部 IP 位址 (也就是 http://EXTERNAL_IP/ ) 來連接剛剛建立的兩個 instance，可以在各別的頁面中，看到各個 instance 的名稱：建立 Network Load BalancerNetwork load balancing 允許你依據收到的 IP 協定資料 (例如：位址、port 和協定類型) 來平衡系統的負載。你還可以取得 HTTP(S) load balancing 沒有提供的一些選項。例如：可以對其他基於 TCP/UDP 的協定 (例如：SMTP 流量) 進行負載平衡。如果你的應用程式對 TCP 連接相關的特性感興趣，network load balancing 也允許你的應用程式去檢查封包，而 HTTP(S) load balancing 則沒有提供。詳情可參考官方的 Setting Up Network Load Balancing 文件。針對你的 instance group 來建立 L3 network load balancer：1234$ gcloud compute forwarding-rules create nginx-lb \\ --region us-central1 \\ --ports=80 \\ --target-pool nginx-pool輸出：1Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../regions/us-central1/forwardingRules/nginx-lb].Forwarding rule 要與 target pool 一起使用，以支援 load balancing 功能，要使用 load balancing 就必須建立 forwarding rule，這樣才會將流量導向到特定的 target pool (用於 load balancing)，而下面指令中的 --ports=80 代表指向 target pool 的外部 port 範圍。列出專案中所有 Google Compute Engine (GCE) 的 Forwarding rule：1$ gcloud compute forwarding-rules list輸出：12NAME REGION IP_ADDRESS IP_PROTOCOL TARGETnginx-lb us-central1 35.202.173.185 TCP us-central1/targetPools/nginx-pool接著透過 http://IP_ADDRESS/ 來存取 load balancer，IP_ADDRESS 是上面執行的指令中所輸出的 IP 位址。建立 HTTP(S) Load BalancerHTTP(S) Load Balancing 提供全球性的 load balancing，能將 HTTP 請求送往你的 instance。你可以設定 URL 規則，將一些 URL 路由 (route) 到一組 instance，並將其他 URL 路由到其他 instance。請求都會路由到最接近使用者的 instance group，前提是該 group 具有足夠的資源，並且適合請求。如果最近的 group 沒有足夠的資源，那請求將會送至具有足夠資源，並且是最接近使用者的 group。詳情可參考官方的 HTTP(S) Load Balancer 文件。首先，建立 health check。health check 可以確認 instance 是否有回應 HTTP 或 HTTPS 流量，其他的 http-basic-check 是 legacy health check 的名稱。在專案中，每個 legacy health check 的名稱不能重複：1$ gcloud compute http-health-checks create http-basic-check輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/httpHealthChecks/http-basic-check].NAME HOST PORT REQUEST_PATHhttp-basic-check 80 /定義 HTTP service，並將 port 號 map 到 instance group 的相關 port。現在 load balancing service 可以將流量 forward 到指定的 port 號：123$ gcloud compute instance-groups managed \\ set-named-ports nginx-group \\ --named-ports http:80輸出：1Updated [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../zones/us-central1-a/instanceGroups/nginx-group].詳情可參考官方的 Creating groups of managed instances 文件。建立 後端服務 (backend service)：1234$ gcloud compute backend-services create nginx-backend \\ --protocol HTTP \\ --http-health-checks http-basic-check \\ --global輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/backendServices/nginx-backend].NAME BACKENDS PROTOCOLnginx-backend HTTP將 instance group 加到後端服務中：1234$ gcloud compute backend-services add-backend nginx-backend \\ --instance-group nginx-group \\ --instance-group-zone us-central1-a \\ --global輸出：1Updated [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/backendServices/nginx-backend].建立一個預設的 URL map，將所有收到的請求導向你的所有 instance：12$ gcloud compute url-maps create web-map \\ --default-service nginx-backend輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/urlMaps/web-map].NAME DEFAULT_SERVICEweb-map backendServices/nginx-backend若要根據請求的 URL 將流量導向不同的 instance，詳情可參考官方的 content-based routing 文件。建立 target HTTP proxy，將請求路由到 URL map：12$ gcloud compute target-http-proxies create http-lb-proxy \\ --url-map web-map輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/targetHttpProxies/http-lb-proxy].NAME URL_MAPhttp-lb-proxy web-map建立 global forwarding rule，以處理和路由收到的請求。forwarding rule 會根據指定的 IP 位址、IP 協定和 port，將流量送至特定的 target HTTP 或 HTTPS proxy。global forwarding rule 不支援多 port。1234$ gcloud compute forwarding-rules create http-content-rule \\ --global \\ --target-http-proxy http-lb-proxy \\ --ports 80輸出：1Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/forwardingRules/http-content-rule].建立 global forwarding rule 後，設定可能需要幾分鐘才能傳播 (propagate)：1$ gcloud compute forwarding-rules list輸出：123NAME REGION IP_ADDRESS IP_PROTOCOL TARGEThttp-content-rule 34.96.77.47 TCP http-lb-proxynginx-lb us-central1 35.202.173.185 TCP us-central1/targetPools/nginx-pool複製 forwarding rule 內的 http-content-rule 中的 IP_ADDRESS。你可能需要幾分鐘才能透過瀏覽器連接到 http://IP_ADDRESS/。如果無法連接 (就像下圖這樣)，請稍等一下，再重新整理瀏覽器：下面兩張圖就是多次連接 http://IP_ADDRESS/ 的時候，常會看到畫面在這兩個之前建立的 VM instance 間切換：參考來源Set Up Network and HTTP Load Balancers","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"HTTP","slug":"http","permalink":"https://titangene.github.io/tags/http/"},{"name":"Load Balancer","slug":"load-balancer","permalink":"https://titangene.github.io/tags/load-balancer/"}],"author":"Titangene"},{"title":"Google Kubernetes Engine (GKE) 入門","slug":"getting-started-with-google-k8s-engine","date":"2019-04-19T09:30:24.000Z","updated":"2019-04-30T16:00:09.000Z","comments":true,"path":"article/getting-started-with-google-k8s-engine.html","link":"","permalink":"https://titangene.github.io/article/getting-started-with-google-k8s-engine.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Kubernetes Engine: Qwik Start」這個 quest 所學到的內容，包括如何透過 GKE 建立容器和部署容器化應用程式。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Kubernetes Engine: Qwik Start」這個 quest 所學到的內容，包括如何透過 GKE 建立容器和部署容器化應用程式。Google Kubernetes Engine (GKE) 提供了一個代管環境，可以使用 Google 基礎架構來部署、管理和擴展容器化應用程式。GKE 提供的環境是由多台機器 (特別是 Google Compute Engine instance) 組成，組成一個容器叢集。在此 lab 中，你將透過 GKE 來實際練習如何建立容器和部署應用程式。GKE 的叢集編排管理 (orchestration)GKE 叢集是由 Kubernetes 開源叢集管理系統提供技術支援。你可以透過 Kubernetes 提供的機制與容器叢集互動。可以使用 Kubernetes 指令和資源來部署以及管理應用程式、執行管理任務、制訂政策，以及監控已部署工作負載 (workload) 的健康狀態。Kubernetes 採用相同的設計原則來執行常用的 Google 服務，並提供相同的優勢：應用程序容器的自動管理、監控與有效性探測 (liveness probe)、自動擴展，滾動升級…等。當您在容器叢集上執行應用程序時，你所使用的技術是由 Google 在容器中執行 production 工作負載的十餘年經驗的技術。GCP 上的 Kubernetes執行 GKE 叢集時，你也可以獲得 GCP 所提供的進階叢集管理功能優點，其中包括：Google Compute Engine (GCE) instances 提供的負載平衡節點池 (Node Pools) 可以指定叢集中的子集節點，以獲得額外的靈活性自動擴展 (Automatic scaling) 叢集的節點 instance 數量自動升級叢集的節點軟體自動修復節點：可維護節點的健康狀態和可用性使用 Stackdriver 來記錄 (logging) 和監控，用於查看叢集的狀態準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)：勾選同意服務條款：之後就可以開始使用 GCP Console 囉：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：gcloud 是 GCP 的 command-line 工具，他已預先安裝在 Cloud Shell 上，並且支援 tab 自動補齊 (tab-completion)。使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]詳情可參考官方的 Google Cloud gcloud Overview 文件。設定預設的 compute zonecompute zone 是你的叢集及其資源所在的大概區域位置，例如：us-central1-a 是 us-central1 region 中的一個 zone。在 Cloud Shell 中啟用新的 session 並執行以下指令，將預設 compute zone 設為 us-central1-a：12$ gcloud config set compute/zone us-central1-aUpdated property [compute/zone].詳情可參考官方的 Managing clusters 文件。建立 GKE 叢集一個叢集包含至少一個叢集主要 (master) 機器和多個稱為 node 的工作 (worker) 機器組成。node 是 Google Compute Engine (GCE) 的 VM instance，執行 Kubernetes 的必要程序 (process)，使它們成為叢集的一部分。若要建立叢集，請執行以下指令，並將 [CLUSTER-NAME] 替換為自訂的叢集名稱 (例如：my-cluster )。叢集名稱必須以字母開頭，結尾必須是字母或數字，且不能超過 40 個字元。1$ gcloud container clusters create [CLUSTER-NAME]你可以無視下面這些輸出內的任何警告：1234567WARNING: In June 2019, node auto-upgrade will be enabled by default for newly created clusters and node pools. To disable it, use the `--no-enable-autoupgrade`flag.WARNING: Starting in 1.12, new clusters will have basic authentication disabled by default. Basic authentication can be enabled (or disabled) manually using the `--[no-]enable-basic-auth` flag.WARNING: Starting in 1.12, new clusters will not have a client certificate issued. You can manually enable (or disable) the issuance of the client certificate using the `--[no-]issue-client-certificate` flag.WARNING: Currently VPC-native is not the default mode during cluster creation. In the future, this will become the default mode and can be disabled using `--no-enable-ip-alias` flag. Use `--[no-]enable-ip-alias` flag to suppress this warning.WARNING: Starting in 1.12, default node pools in new clusters will have their legacy Compute Engine instance metadata endpoints disabled by default. To create a cluster with legacy instance metadata endpoints disabled in the default node pool, run `clusters create` with the flag `--metadata disable-legacy-endpoints=true`.This will enable the autorepair feature for nodes. Please see https://cloud.google.com/kubernetes-engine/docs/node-auto-repair for more information on node autorepairs.WARNING: Starting in Kubernetes v1.10, new clusters will no longer get compute-rw and storage-ro scopes added to what is specified in --scopes (though the latter will remain included in the default --scopes). To use these scopes, add them explicitly to --scopes. To use the new behavior, set container/new_scopes_behavior property (gcloud config set container/new_scopes_behavior true).建立叢集可能需要一些時間，很快應該會看到類似下面的輸出：12NAME LOCATION MASTER_VERSION MASTER_IP MACHINE_TYPE NODE_VERSION NUM_NODES STATUSmy-cluster us-central1-a 1.11.7-gke.12 104.154.18.48 n1-standard-1 1.11.7-gke.12 3 RUNNING詳情可參考官方的 Creating a cluster 文件。取得叢集的驗證憑證建立叢集後，需要取得驗證憑證 (authentication credentials) 才能操作叢集。執行下面指定來對叢集進行驗證，將 [CLUSTER-NAME] 替換成叢集名成：1$ gcloud container clusters get-credentials [CLUSTER-NAME]輸出如下：12Fetching cluster endpoint and auth data.kubeconfig entry generated for my-cluster.詳情可參考官方的 Cluster access for kubectl 文件。將應用部署至叢集現在你已經建立了一個叢集，可以將容器化應用程式部署到該叢集。在此 lab 中，你將在叢集中執行 hello-app。GKE 使用 Kubernetes 物件來建立和管理叢集的資源。Kubernetes 提供 Deployment 物件來部署 stateless 的應用，例如：web server。Service 物件定義了從網際網路上存取應用程式的規則和負載平衡。在 Cloud Shell 中執行下面的 kubectl run 指令，從 hello-app 容器 image 建立新的名為 hello-server 的 Deployment：12$ kubectl run hello-server --image=gcr.io/google-samples/hello-app:1.0 --port 8080deployment.apps \"hello-server\" created我在 Github 上面找到 hello-app image 的專案原始碼：GoogleCloudPlatform/kubernetes-engine-samples如果想在自己的專案上使用自己建置的容器 image，並將此 image 的應用部署至 GKE，可參考官方的 Deploying a containerized web application 文件。此 Kubernetes 指令建立一個代表 hello-app 的 Deployment 物件。在此指令中：--image：指定要部署的容器 image。在這種情況下，該指令從 Google Container Registry bucket 中 pull 範例 image。gcr.io/google-samples/hello-app:1.0 代表這個指令要 pull 的特定 image 版本。如果未指定版本，會使用最新版--port：指定容器要公開的 port將應用公開發佈到網際網路根據預設，在 GKE 上執行的容器無法從網際網路存取，因為這些容器沒有外部 IP 位址。所以你必須執行 kubectl expose 這個指令：12$ kubectl expose deployment hello-server --type=\"LoadBalancer\"service/hello-server exposed此指令會建立一個 Kubernetes Service，它是一個 Kubernetes 資源。GKE 會為應用程式建立外部 IP，明確地將應用程序公開給來自網際網路的流量 (外部流量)。加上 type=&quot;LoadBalancer&quot; 參數會為容器建立一個 GCE 的 Load Balancer (在自己的專案上使用需要計費)。GKE 會將外部 IP 位址指派給 Service 資源，而不是指派給 Deployment。如果你想要找出 GKE 為應用程式佈建 (provisioned) 的外部 IP，可執行 kubectl get service 來檢查 hello-server Service：1$ kubectl get service hello-server產生外部 IP 位址可能需要一分鐘。如果 EXTERNAL-IP 欄位顯示為 pending 狀態時 (如下)，請等待一段時間後，再次執行上面的指令：12NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEhello-server LoadBalancer 10.39.249.21 &lt;pending&gt; 8080:31693/TCP 51s確認應用程式的外部 IP 位址後 ( EXTERNAL-IP 欄位提供的 IP)，請複製此 IP 位址，以下面的輸出範例來說，要複製的 Service 外部 IP 位址就是 35.222.35.96：12NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEhello-server LoadBalancer 10.39.249.21 35.222.35.96 8080:31693/TCP 1m接著將剛剛複製的外部 IP 位址，加上公開的 port，網址格式就會像下面這樣：1http:&#x2F;&#x2F;[EXTERNAL-IP]:8080使用瀏覽器開啟此網址，查看應用程式是否能存取。看到的頁面應該會像下圖這樣：清除執行下面的指令來刪除 Service，此步驟將取消分配為你的 Service 所建立的 Cloud Load Balancer：1$ kubectl delete service hello-server執行下面的指令來刪除容器叢集，此步驟會一併刪除容器叢集的組成資源，例如：運算執行個體、磁碟和網路資源：12345$ gcloud container clusters delete [CLUSTER-NAME]The following clusters will be deleted. - [my-cluster] in [us-central1-a]Do you want to continue (Y/n)?當出現提示時，輸入 Y 進行確認。刪除叢集可能需要一些時間。刪除叢集後的輸出會像下面這樣：1234567The following clusters will be deleted. - [my-cluster] in [us-central1-a]Do you want to continue (Y/n)? yDeleting cluster my-cluster...done.Deleted [https://container.googleapis.com/v1/projects/qwiklabs-gcp-deb218c6553ee39c/zones/us-central1-a/clusters/my-cluster].詳情可查看官方的 Deleting a cluster | Google Kubernetes Engine 文件。參考來源Kubernetes Engine: Qwik Start | Qwiklabs","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"Container","slug":"container","permalink":"https://titangene.github.io/tags/container/"},{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"Load Balancer","slug":"load-balancer","permalink":"https://titangene.github.io/tags/load-balancer/"},{"name":"Kubernetes","slug":"kubernetes","permalink":"https://titangene.github.io/tags/kubernetes/"}],"author":"Titangene"},{"title":"Google Cloud Shell 入門：gcloud & gsutil","slug":"getting-started-with-cloud-shell-gcloud-and-gsutil","date":"2019-04-17T08:56:38.000Z","updated":"2019-04-17T08:56:02.000Z","comments":true,"path":"article/getting-started-with-cloud-shell-gcloud-and-gsutil.html","link":"","permalink":"https://titangene.github.io/article/getting-started-with-cloud-shell-gcloud-and-gsutil.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Getting Started with Cloud Shell &amp; gcloud」這個 quest 所學到的內容，包括如何使用 gcloud 指令，以及如何使用 gsutil 工具來管理 Cloud Storage 資源，將檔案上傳至指定的 bucket。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Getting Started with Cloud Shell &amp; gcloud」這個 quest 所學到的內容，包括如何使用 gcloud 指令，以及如何使用 gsutil 工具來管理 Cloud Storage 資源，將檔案上傳至指定的 bucket。Google Cloud Shell 為你提供 gcloud command-line 存取 GCP 上託管的運算資源。Cloud Shell 是基於 Debian 的 VM，具有 5 GB persistent disk 的 home 目錄，讓你可以輕鬆管理 GCP 專案和資源。你需要的 Cloud SDK gcloud 和其他工具都已預裝在 Cloud Shell 中，讓你可以快速啟動和執行。若想了解如何 在 GCP 上建立 VM 架設 NIGNX Web server 可參考此篇。若想了解如何 在 GCP 上建立 VM 架設 Windows Server 可參考此篇。準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)：勾選同意服務條款：之後就可以開始使用 GCP Console 囉：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：gcloud 是 GCP 的 command-line 工具，他已預先安裝在 Cloud Shell 上，並且支援 tab 自動補齊 (tab-completion)。使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]理解 Regions 和 ZonesCompute Engine 資源位於不同的 regions (地區) 或 zones (區域)。region 是你可以執行資源的所在特定地理位置。每個 region 都有一個或多個 zones。例如，us-central1 region 代表美國中部地區，其中包含的 Zones 有 us-central1-a、us-central1-b、us-central1-c 與 us-central1-f。圖片來源：Creating a Virtual Machine | Qwiklabs位於 zone 中的資源都稱為 zonel (區域) 資源，VM instance (實例) 和 persistent disk (永久磁碟) 都位於 zone 中，如果要將 persistent disk 附加到 VM instance，這兩個資源都必須位於同一個 zone 中。同樣，如果要將靜態 IP 位址分配到 instance，此 instance 就必須與靜態 IP 位於同一個 region 中。詳情可參考 GCP 官方的 Regions &amp; Zones 文件。使用 command line在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕開啟新的 Cloud Shell session：啟用 Cloud Shell 後，你可以使用 command line invoke Cloud SDK gcloud 指令或 VM instance 上可用的其他工具，還可以在不同專案和 Cloud Shell session 之間，將要存取的檔案儲存在 persistent disk storage 的 $HOME 目錄內。$HOME 目錄是私有的，其他使用者無法存取。可以在任何 gcloud 指令的末端加上 -h 參數來查看使用指南：1$ gcloud -h加上 --help 參數或執行 gcloud help 可以查看更詳細的 help 內容：1$ gcloud config --help透過按 Enter 或空白建來捲動瀏覽 help 內容，按 q 按鍵會退出內容。下面兩個指令是一樣的意思，都是用來查看詳細的 help 內容：12$ gcloud config --help$ gcloud help config使用你的 home 目錄現在讓我們試試你的 HOME 目錄。就算去終止和重啟 VM，Cloud Shell HOME 錄的內容都會在所有 Cloud Shell session 之間的專案中保留。變更目前的工作目錄：1$ cd $HOME使用 vi 打開 .bashrc 設定檔：1$ vi ./.bashrc使用 gcloud 指令檢視環境內的設定列表：1$ gcloud config list如果要檢查其他屬性的設定，請在指令後面加上 --all 參數：1$ gcloud config list --all管理 Cloud Storage 資料可以使用 Cloud Shell 中的 gsutil 工具來管理 Cloud Storage 資源，包括建立和刪除 bucket 和物件、複製和移動儲存資料以及管理 bucket 和物件 ACLs (Access Control List)。gsutil 還能將資料傳入和傳出 Cloud Shell instance。bucket 是用於儲存資料的基本容器，儲存在 Cloud Storage 的所有資料都必須放在 bucket 中。你可以用 bucket 來整理資料、控制資料的存取權，但 bucket 不能像目錄和資料夾可以巢狀儲存。由於建立和刪除 bucket 有一些限制，所以你設計的儲存應用程式應儘量執行密集的物件作業和相對較少的 bucket 作業。詳情可參考官方的 Buckets、Creating Storage Buckets 和 Access Control List (ACL) 文件。嘗試建立 Cloud Storage bucket，bucket 名稱不能重複，因此請將 unique-name 替換為其他名稱，或者 append 名稱讓它不重複。1$ gsutil mb gs://unique-name像我是使用名為 unique-name-titan 的 bucket，剛好沒有重複，所以成功建立了 bucket：12$ gsutil mb gs://unique-name-titanCreating gs://unique-name-titan/...如果使用重複的 bucket 名稱就會出現類似下面的訊息：123$ gsutil mb gs://unique-nameCreating gs://unique-name/...ServiceException: 409 Bucket unique-name already exists.現在來建立一些資料，上傳到你的 bucket。首先，建立一個測試檔案：1$ vi test.dat加一些資料進去：1Welcome to gcloud!存儲檔案：1:wq現在，上傳一些檔案到你建立的 bucket，請將 unique-name 取代成你的 storage bucket：1$ gsutil cp test.dat gs://unique-name剛剛我是使用 unique-name-titan 的 bucket，所以上傳指令如下，可以看到我已成功上傳：1234$ gsutil cp test.dat gs://unique-name-titanCopying file://test.dat [Content-Type=application/octet-stream]...- [1 files][ 19.0 B/ 19.0 B]Operation completed over 1 objects/19.0 B.如果是使用重複的 bucket 名稱上傳，就會出現類似下面的訊息：123$ gsutil cp test.dat gs://unique-nameCopying file://test.dat [Content-Type=application/octet-stream]...BadRequestException: 400 Project does not exist: 666160882299若要查看你的 bucket 和檔案，請開啟導航選單，然後選擇「Storage &gt; Browser」：然後點擊你的 bucket：你應該會看到 test.dat 這個檔案：參考來源Getting Started with Cloud Shell &amp; gcloud | Qwiklabs (本篇大多數的圖片來源)","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"VM","slug":"vm","permalink":"https://titangene.github.io/tags/vm/"}],"author":"Titangene"},{"title":"在 GCP 上建立 VM 架設 Windows Server","slug":"gcp-vm-windows-server","date":"2019-04-16T13:17:46.000Z","updated":"2019-04-30T15:56:57.000Z","comments":true,"path":"article/gcp-vm-windows-server.html","link":"","permalink":"https://titangene.github.io/article/gcp-vm-windows-server.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Compute Engine: Qwik Start - Windows」這個 quest 所學到的內容，包括如何透過 GCP Console 在 GCP 建立 instance 架設 Windows Server，以及如何使用 Chrome RDP for GCP 擴充功能直接從瀏覽器進行 RDP 連接至 Windows Server。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Compute Engine: Qwik Start - Windows」這個 quest 所學到的內容，包括如何透過 GCP Console 在 GCP 建立 instance 架設 Windows Server，以及如何使用 Chrome RDP for GCP 擴充功能直接從瀏覽器進行 RDP 連接至 Windows Server。Google Compute Engine 可讓你在 Google 基礎架構上建立和執行 VM。 Compute Engine 提供擴展、效能和價值，讓你可以輕鬆地在 Google 基礎架構上啟動大型運算群集。你可以在 Google Compute Engine 上執行 Windows 應用程式，並利用 VM instance 可用的許多優勢，例如：可靠的儲存選項、Google 網路的速度和自動擴展 (Autoscaling)。在此 lab 中，你將學習如何在 Google Compute Engine 中啟動 Windows Server instance，並使用遠端桌面協定連接到該 instance。若想了解如何 在 GCP 上建立 VM 架設 NIGNX Web server 可參考此篇。如果你未在 local 主機上使用 Windows，請安裝第三方的 RDP client，例如：FusionLabs 的 Chrome RDP。準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)勾選同意服務條款：之後就可以開始使用 GCP Console 囉：建立 VM instance在 GCP Console 的左上角，點選「Navigation menu &gt; Compute Engine &gt; VM Instances」：接著點擊「Create」按鈕建立新的 instance：在「Boot disk」部分中，點擊「Change」按鈕以開始配置 boot disk：選擇「Windows Server 2012 R2 Datacenter」，然後點擊「Select」按鈕：將所有其他設定都保留為預設值。設定好之後，點擊「Create」按鈕建立 instance：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]詳情可參考官方的 Google Cloud gcloud Overview 文件。測試 Windows Startup 的狀態在「VM Instances」頁面上看到帶有綠色狀態的 icon 就代表該 instance 已建立完成，如下圖：但是，它可能尚未準備好接受 RDP 連接，因為所有 OS 元件初始化都需要一段時間。要查看 server 是否已準備好進行 RDP 連接，請在 Cloud Shell terminal command-line 中執行以下指令，其中的 instance-1 是剛剛建立的 instance 名稱：1$ gcloud compute instances get-serial-port-output instance-1 --zone us-central1-a重複這個指令，直到指令輸出以下內容為止。這個指令的輸出會告訴你 OS 元件已初始化，並且 Windows Server 已準備好接受 RDP 連接 (嘗試下一步)。1Finished running startup scripts.這個指令完整的輸出訊息會類似下面這樣：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566$ gcloud compute instances get-serial-port-output instance-1 --zone us-central1-aSeaBIOS (version 1.8.2-20190322_093631-google)Total RAM Size = 0x00000000f0000000 = 3840 MiBCPUs found: 1 Max CPUs supported: 1found virtio-scsi at 0:3virtio-scsi vendor='Google' product='PersistentDisk' rev='1' type=0 removable=0virtio-scsi blksize=512 sectors=104857600 = 51200 MiBdrive 0x000f29f0: PCHS=0/0/0 translation=lba LCHS=1024/255/63 s=104857600Booting from Hard Disk 0...2019/04/15 15:39:21 GCEWindowsAgent: GCE Agent Started (version 4.6.0@1)2019/04/15 15:39:56 GCEInstanceSetup: Starting sysprep specialize phase.2019/04/15 15:39:57 GCEInstanceSetup: All networks set to DHCP.2019/04/15 15:39:57 GCEInstanceSetup: Running 'netsh' with arguments 'interface ipv4 set interface Ethernet mtu=1460'2019/04/15 15:39:57 GCEInstanceSetup: --&gt; Ok.2019/04/15 15:39:58 GCEInstanceSetup: MTU set to 1460.2019/04/15 15:39:58 GCEInstanceSetup: Running 'route' with arguments '/p add 169.254.169.254 mask 255.255.255.255 0.0.0.0 if 12 metric 1'2019/04/15 15:39:58 GCEInstanceSetup: --&gt; OK!2019/04/15 15:39:58 GCEInstanceSetup: Added persistent route to metadata netblock via first netkvm adapter.2019/04/15 15:39:58 GCEInstanceSetup: Getting hostname from metadata server.2019/04/15 15:39:58 GCEInstanceSetup: Changing hostname from WIN-MQ2QFF14J03 to instance-1.2019/04/15 15:39:58 GCEInstanceSetup: Renamed from WIN-MQ2QFF14J03 to instance-1.2019/04/15 15:39:58 GCEMetadataScripts: Starting specialize scripts (version 4.2.1@1).2019/04/15 15:39:58 GCEMetadataScripts: No specialize scripts to run.2019/04/15 15:39:58 GCEMetadataScripts: Finished running specialize scripts.2019/04/15 15:39:58 GCEInstanceSetup: Finished with sysprep specialize phase, restarting...2019/04/15 15:39:59 GCEWindowsAgent: GCE Agent StoppedSeaBIOS (version 1.8.2-20190322_093631-google)Total RAM Size = 0x00000000f0000000 = 3840 MiBCPUs found: 1 Max CPUs supported: 1found virtio-scsi at 0:3virtio-scsi vendor='Google' product='PersistentDisk' rev='1' type=0 removable=0virtio-scsi blksize=512 sectors=104857600 = 51200 MiBdrive 0x000f29f0: PCHS=0/0/0 translation=lba LCHS=1024/255/63 s=104857600Booting from Hard Disk 0...2019/04/15 15:40:36 GCEWindowsAgent: GCE Agent Started (version 4.6.0@1)2019/04/15 15:40:43 GCEInstanceSetup: Disabled Ctrl + Alt + Del.2019/04/15 15:40:43 GCEInstanceSetup: Enable RDP firewall rules.2019/04/15 15:40:43 GCEInstanceSetup: Running 'netsh' with arguments 'advfirewall firewall set rule group=remote desktop new enable=Yes'2019/04/15 15:40:43 GCEInstanceSetup: --&gt; Updated 3 rule(s).2019/04/15 15:40:43 GCEInstanceSetup: --&gt; Ok.2019/04/15 15:40:43 GCEInstanceSetup: Restarting Terminal Service services, to enable RDP.2019/04/15 15:40:44 GCEInstanceSetup: Enabled Remote Desktop.2019/04/15 15:40:44 GCEInstanceSetup: Configuring WinRM...2019/04/15 15:40:47 GCEInstanceSetup: Running 'netsh' with arguments 'advfirewall firewall add rule profile=any name=Windows Remote Management (HTTPS-In) dir=in localport=5986 protocol=TCP action=allow'2019/04/15 15:40:47 GCEInstanceSetup: --&gt; Ok.2019/04/15 15:40:48 GCEInstanceSetup: Setup of WinRM complete.2019/04/15 15:40:48 GCEInstanceSetup: Running startup scripts from metadata server.2019/04/15 15:40:48 GCEInstanceSetup: Running 'schtasks' with arguments '/run /tn GCEStartup'2019/04/15 15:40:48 GCEInstanceSetup: --&gt; SUCCESS: Attempted to run the scheduled task \"GCEStartup\".2019/04/15 15:40:48 GCEInstanceSetup: ------------------------------------------------------------2019/04/15 15:40:48 GCEInstanceSetup: Instance setup finished. instance-1 is ready to use.2019/04/15 15:40:48 GCEInstanceSetup: ------------------------------------------------------------2019/04/15 15:40:51 GCEInstanceSetup: Checking instance license activation status.2019/04/15 15:40:51 GCEInstanceSetup: instance-1 needs to be activated by a KMS Server.2019/04/15 15:40:51 GCEInstanceSetup: Key Management Service machine name set to kms.windows.googlecloud.com successfully.2019/04/15 15:40:51 GCEInstanceSetup: Installed product key W3GGN-FT8W3-Y4M27-J84CP-Q3VJ9 successfully.2019/04/15 15:40:51 GCEInstanceSetup: Activating instance...2019/04/15 15:40:52 GCEInstanceSetup: Activating Windows(R), ServerDatacenter edition (00091344-1ea4-4f37-b789-01750ba6988c) ...2019/04/15 15:40:52 GCEInstanceSetup: Product activated successfully.2019/04/15 15:40:52 GCEInstanceSetup: Activation successful.2019/04/15 15:40:53 GCEMetadataScripts: Starting startup scripts (version 4.2.1@1).2019/04/15 15:40:53 GCEMetadataScripts: No startup scripts to run.2019/04/15 15:40:53 GCEMetadataScripts: Finished running startup scripts.Specify --start=4643 in the next get-serial-port-output invocation to get only the new output starting from here.連接 instance點擊 VM 的名稱：在「Remote Access」部分點擊「Set Windows Password」按鈕：輸入 username 後，點擊「Set」按鈕來產生此 Windows instance 的密碼。如果沒有此 username 的 Windows 帳號，就會建立該帳號並使用新密碼，如果已有此帳號，密碼則會被重設：複製密碼並儲存，稍後登入 instance 時會用到：使用遠端桌面 (RDP) 進入 Windows Server可以使用 Chrome RDP for Google Cloud Platform 擴充功能直接從瀏覽器進行 RDP 連接，點擊「RDP」按鈕進行連接：如果剛剛是用 Chrome 的無痕模式登入帳號，就會發生點擊「RDP」按鈕沒有反應的狀況，換成原本的模式就可以正常使用。它會提示你安裝 RDP 擴充功能。安裝完成後，GCP 會打開像下圖的登入畫面，請使用 Windows 使用者和密碼登入 (貼上之前儲存的密碼)：點擊「Continue」按鈕以確認你要連接：打開 Server Manager 時，就會連接到 Windows Server 上的 VM instance。使用 RDP client 複製和貼上登入到 instance 後，可以按 Ctrl + V 貼上資料 (如果是 Mac 的使用者，按 Cmd + V 會無法貼上）。如果要貼至 PuTTY 和 Powershell，請按滑鼠右鍵就可以貼上。如果在 Powershell 視窗中，請確保已點擊該視窗，否則會無法貼上。參考來源Compute Engine: Qwik Start - Windows (本篇大多數的圖片來源)","categories":[{"name":"Windows Server","slug":"windows-server","permalink":"https://titangene.github.io/categories/windows-server/"},{"name":"Cloud","slug":"windows-server/cloud","permalink":"https://titangene.github.io/categories/windows-server/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"VM","slug":"vm","permalink":"https://titangene.github.io/tags/vm/"}],"author":"Titangene"},{"title":"GCP (Google Cloud Platform) 入門","slug":"getting-started-with-gcp","date":"2019-04-15T14:20:20.000Z","updated":"2019-04-16T12:05:50.000Z","comments":true,"path":"article/getting-started-with-gcp.html","link":"","permalink":"https://titangene.github.io/article/getting-started-with-gcp.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「A Tour of Qwiklabs and the Google Cloud Platform」這個 quest 所學到的內容，包括如何使用以及認識 Qwiklab 和 GCP。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「A Tour of Qwiklabs and the Google Cloud Platform」這個 quest 所學到的內容，包括如何使用以及認識 Qwiklab 和 GCP。Google Cloud Platform (GCP) 是託管在 Google 基礎架構上的一套雲端服務，從計算和儲存，到資料分析、機器學習、網路、GCP 提供各種服務和 API，可以與任何雲端計算應用程式或專案整合 - 無論是個人還是企業。在這個入門等級的 lab 中，可透過使用 GCP console (瀏覽器內的 UI，可讓您存取和管理 Google Cloud 服務) 來練習使用 GCP，了解 GCP 的主要功能，必了解 Qwiklabs 的環境。你會學到什麼了解如何使用特定憑證存取 GCP console認識 GCP 專案了解如何使用 GCP 的導航選單來識別 GCP 服務的類型了解 primitive roles 並使用 Cloud IAM 服務檢查特定使用者的可用操作了解 Cloud Shell 並使用 gcloud toolkit 來執行指令了解 API library 並查看其主要功能若想了解如何 在 GCP 上建立 VM 架設 NIGNX Web server 可參考此篇。若想了解如何 在 GCP 上建立 VM 架設 Windows Server 可參考此篇。其他關於 Qwiklab 的介紹，可至原文 A Tour of Qwiklabs and the Google Cloud Platform 查看。存取 GCP Console如果已經點擊右上角的「Start Lab」開始，應該會看到左側的「Open Google Console」按鈕變成可以被點擊，而且可以看到有帳號、密碼以及 GCP 專案 ID：GCP 專案 IDGCP 專案是你的 Google 雲端資源的組織實體，包含資源和服務，例如：可以包含一個 VM 的 pool，一組資料庫以及將它們彼此連接的網路，專案還包含設定和權限，這些設定和權限可以指定安全規則以及設定誰有權存取哪些資源。而 GCP Project ID 不會重複，用於將 GCP 資源和 API 連接到你的特定專案。帳號和密碼帳號和密碼是表示在 GCP 身份和存取管理 (Identity and Access Management，IAM) 服務中，具有存取權限身份 (一個或多個角色) 的憑證，允許你在已分配的專案中使用 GCP 資源。這些憑證是臨時的，只能在 lab 限制的存取時間內使用，所以只要計時器倒數到 0 之後，你就無法再使用這些憑證存取這個的 GCP 專案。登入 GCPLab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)勾選同意服務條款：之後就可以開始使用 GCP Console 囉：GCP Console 中的專案GCP Console 的左上角，會看到一個名為 Project info 的面板，畫面如下：一個專案會有名稱、ID、編號，在使用 GCP 服務時會經常使用這些東西。不過你可以存取多個 GCP 專案。在某些 lab 中，可能會使用多個專案來完成分配的任務。如果點擊帶有專案名稱的下拉式選單並選擇「ALL」，就會看到「Qwiklabs Resources」專案也可見：目前不要切換到 Qwiklabs 資源專案！但是，你可以稍後在其他 lab 中使用它。GCP 的大型企業或有經驗的使用者擁有數十到數千個 GCP 專案的情況還蠻常見的，組織會以不同的方式使用 GCP，因此專案分離在雲端運算服務 (以團隊或產品為例) 是個好方法。“Qwiklabs Resources” 是一個包含某些 lab 的檔案，資料集和機器 image 的專案，可以從每個 GCP lab 環境存取。要注意是 “Qwiklabs Resources” 與所有 Qwiklabs 使用者共享資源 (read only)，也就代表你無法刪除或修改它。你正在使用名為類似於 qwiklabs-gcp-xxx 的 GCP 專案是臨時的，也就代表專案及其包含的所有內容會在 lab 結束後刪除。每次使用的 lab 都可以存取一個或多個新的 GCP 專案，並且在那裡 (不是 “Qwiklabs Resources” ) 執行所有 lab 的步驟。導航選單和服務在畫面的左上角有一個類似「三」的 icon：點擊此按鈕會顯示 (或隱藏) GCP 核心服務的導航選單，如果選單沒有打開，請點擊此 icon 並捲動查看所有提供的服務類型：在導航選單可以快速存取平台的服務，可看到共有 7 類 GCP 的服務：Compute：包含支援任何類型的工作負載的各種機型。通過不同的運算選項，可以決定你希望如何參與 operational details 和基礎架構等Storage：結構化或非結構化、關係資料或非關係資料的資料儲存和資料庫選項Networking：平衡應用程式流量和提供安全規則的服務Stackdriver：一套跨雲端日誌記錄 (cross-cloud logging)、監控、追蹤和其他服務的可靠性工具Tools：管理部署和應用程式建置 pipeline 的開發人員的服務Big Data：用於處理和分析大量資料集的服務Artificial Intelligence (AI)：可在 GCP 上執行特定的 AI 和機器學習 (ML，machine learning) 任務的一套 API詳情可查看官方的 About the GCP Services | Google Cloud 文件。角色和權限除了雲端運算服務之外，GCP 還包含一組權限和角色，用於定義誰可以存取哪些資源，我們就可以使用雲端身份和存取管理 (Cloud Identity and Access Management，IAM) 服務來檢查和修改角色和權限。請打開導航選單，然後點擊「IAM &amp; admin」，畫面會跳至包含使用者列表的頁面，該頁面指定給予特定帳號的權限和角色。嘗試篩選這些並找到你登入的 “@qwiklabs” 此使用者名稱：類似下圖：member 欄位被設為 google23396_student@qwiklabs.net（與你登入的帳號一樣），name 欄位被設為 google23396_student@qwiklabs.net student。會看到 Role 欄位被設為 Editor，這是 GCP 提供的三種 primitive roles 的其中之一。除非另有指定，否則 primitive roles 是設定專案等級的權限，它們控制對所有 GCP 服務的存取和管理。下表是從角色文件中提取的定義，其中提供了 viewer、editor 和 owner 角色權限的 overview：角色名稱權限roles/viewer不影響狀態的 read-only 操作的權限，例如：查看 (但不能修改) 現有的資源或資料roles/editor所有 viewer 的權限，以及修改狀態的操作的權限，例如：修改現有資源roles/owner所有 editor 權限和以下操作的權限：- 管理專案的角色和權限以及專案中的所有資源- 設定專案的計費方式因此 editor 能夠建立、修改和刪除 GCP 資源。但是無法在 GCP 專案中新增或刪除 member。API 和服務Google Cloud API 是 GCP 中重要的部分。與服務類似，從企業管理到機器學習等領域的 200 多個 API 都可以輕鬆地與 GCP 專案和應用程式整合。API 是 “Application Programming Interfaces”，可以直接或通過 Google Cloud client library 呼叫 (call) 它們。 Cloud API 使用官方的 Google API Design Guide 中描述的資源導向的設計原則。當 Qwiklabs 為 lab instance 提供新的 GCP 專案時，它可以在背後啟用大多數的 API，以便你可以立即處理 lab 的任務。但要注意的事，當你在 Qwiklabs 之外建立自己的 GCP 專案時，必須自己啟用某些 API。大多數雲端 API 會為你提供有關專案使用該 API 的詳細資訊 (包括流量、錯誤率、延遲時間)，幫助你快速找到使用 Google服務的應用程序問題。你可以通過打開導航選單並點擊「APIs &amp; Services &gt; Library」來查看此資訊：在 API 搜尋欄中，輸入 “Dialogflow” 並選擇 Dialogflow API 後，就會看到下圖的頁面：Dialogflow API 可讓你建置對話式 (conversational) 應用程式 (例如，for Google Assistant)，而無需擔心底層機器學習和自然語言理解 (Natural Language Understanding) schema。點擊「ENABLE」按鈕後會跳至新頁面，接著點擊瀏覽器的返回按鈕就可看到「API enabled」：點擊「Try this API」按鈕會以新分頁的方式開啟 Dialogflow API 的文件，並且可以指定可用的 API 方法。詳情可查看 Google Cloud 中名為 APIs Explorer 的 hands-on 工具。Cloud ShellCloud Shell 是在瀏覽器內的指令提示 (command prompt) 執行環境，允許你在終端提示 (terminal prompt) 下輸入指令來管理 GCP 專案中的資源和服務。Cloud Shell 能讓你在不離開 console 的情況下執行所有 shell 指令，並有預裝的 command-line 工具。在 console 的右上角點擊「Activate Cloud Shell」按鈕，然後在出現提示時點擊「START CLOUD SHELL」按鈕：接著會在 console 底部出現一個新的黑色視窗，視窗內會出現類似以下內容的訊息和提示，這代表你已啟動並執行 Cloud Shell session：1234Welcome to Cloud Shell! Type \"help\" to get started.Your Cloud Platform project in this session is set to qwiklabs-gcp-76ad0f1342e20013.Use \"gcloud config set project [PROJECT_ID]\" to change to a different project.gcpstaging23396_student@cloudshell:~ (qwiklabs-gcp-76ad0f1342e20013)$接著將下面指令複製並貼 (或輸入) 至 Cloud Shell 上，然後按 Enter 鍵執行，應該會看到類似下面的輸出：123456$ gcloud auth listCredentialed AccountsACTIVE ACCOUNT* gcpstaging23396_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`其中 ACTIVE ACCOUNT 是設為你的 GCP IAM 身份 (也就是 googlexxxxxx_student@qwiklabs.net )，gcloudauth list 指令會列出 GCP 專案中有憑證的帳號。此帳號名稱與之前登入到 console 的 Qwiklabs 帳號相同。：如之前所說的，Cloud Shell 預裝了特定的 command-line 工具，主要的 GCP toolkit 是 gcloud，是用於平台上的許多任務，例如：資源管理和使用者身份驗證。除了預裝的 toolkit，Cloud Shell 還附帶標準的 unix CLI 工具和 nano 等文字編輯器，在 Cloud Shell 中可以利用它們來建立和編輯檔案。參考來源A Tour of Qwiklabs and the Google Cloud Platform (本篇大多數的圖片來源)","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"}],"author":"Titangene"},{"title":"在 GCP 上建立 VM 架設 NIGNX Web server","slug":"gcp-vm-nignx-web-server","date":"2019-04-14T02:17:46.000Z","updated":"2019-04-30T15:57:08.000Z","comments":true,"path":"article/gcp-vm-nignx-web-server.html","link":"","permalink":"https://titangene.github.io/article/gcp-vm-nignx-web-server.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Creating a Virtual Machine」這個 quest 所學到的內容，包括如何透過 GCP Console 和 command-line 工具 gcloud 在 GCP 建立 instance，如何使用 gcloud 透過 SSH 連接到你的 instance，以及如何在 VM 上部署 NIGNX web server。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Creating a Virtual Machine」這個 quest 所學到的內容，包括如何透過 GCP Console 和 command-line 工具 gcloud 在 GCP 建立 instance，如何使用 gcloud 透過 SSH 連接到你的 instance，以及如何在 VM 上部署 NIGNX web server。透過 Google Compute Engine，可在 Google 基礎架構上，建立執行不同作業系統的 VM (virtual machine，虛擬機)，包括多種 Linux (Debian、Ubuntu、Suse、Red Hat、CoreOS) 和 Windows Server。可以學到如何使用 Google Cloud Platform (GCP) Console 和 gcloud command-line 建立各種機器類型的虛擬機 instance (實例)，還能學習如何將 NGINX web server 連接到 VM。若想了解如何 在 GCP 上建立 VM 架設 Windows Server 可參考此篇。本篇將會做什麼？使用 GCP Console 建立 VM使用 gcloud command-line 建立 VM在 VM 上部署 web server準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)勾選同意服務條款：之後就可以開始使用 GCP Console 囉：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：gcloud 是 GCP 的 command-line 工具，他已預先安裝在 Cloud Shell 上，並且支援 tab 自動補齊 (tab-completion)。未來可使用 gcloud 的下面指令並透過 PROJECT_ID 來更換成其他專案：1$ gcloud config set project [PROJECT_ID]使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]理解 Regions 和 ZonesCompute Engine 資源位於不同的 regions (地區) 或 zones (區域)。region 是你可以執行資源的所在特定地理位置。每個 region 都有一個或多個 zones。例如，us-central1 region 代表美國中部地區，其中包含的 Zones 有 us-central1-a、us-central1-b、us-central1-c 與 us-central1-f。圖片來源：Creating a Virtual Machine | Qwiklabs位於 zone 中的資源都稱為 zonel (區域) 資源，VM instance (實例) 和 persistent disk (永久磁碟) 都位於 zone 中，如果要將 persistent disk 附加到 VM instance，這兩個資源都必須位於同一個 zone 中。同樣，如果要將靜態 IP 位址分配到 instance，此 instance 就必須與靜態 IP 位於同一個 region 中。詳情可參考 GCP 官方的 Regions &amp; Zones 文件。從 Cloud Console 建立新的 instance在 GCP Console 的右上角，點選「Navigation menu &gt; Compute Engine &gt; VM Instances」：接著點擊「Create」建立新的 instance：建立新的 instance 時可以設定很多參數。在此 lab 中會使用以下設定：欄位值額外資訊namegcelabregionus-central1 (Iowa)或asia-south1 (Mumbai)更多關於 regions 的資訊zoneus-central1-c或asia-south1-c注意：記住你選擇的 zone，之後會用到更多關於 zones 的資訊Machine Type2 vCPU這是一個 ( n1-standard-2 )2-CPU, 7.5 GB RAM instance有很多機型可以選擇，從 micro instance 類型的到 32-core/208 GB RAM 的都有，詳情可參考機型種類文件注意：新專案具有預設的資源配額，可能會限制 CPU 核心數。可在此 lab 之外的專案上申請到更高的規格Boot DiskNew 10 GB standard persistent diskOS Image: Debian GNU/Linux 9 (Stretch)有很多 images 可以選擇，包括：Debian、Ubuntu、CoreOS，以及 premium images，像是 RedHat Enterprise Linux 和 Windows Server，詳情可參考 OS 文件Firewall勾選 Allow HTTP traffic，勾選此選項才能存取之後安裝的 web server注意：這會自動建立防火牆規則，允許 80 port 的 HTTP 流量設定好之後，點擊「Create」：等待 instance 建立：看到下面畫面就代表 instance 已建立完成，接著點擊右邊的「SSH」按鈕，會開啟新的瀏覽器頁面：此頁面是直接從瀏覽器啟動 SSH client 連接到 VM：詳情可參考官方的 Connect to an instance using ssh 文件。安裝 NGINX web server透過 SSH 連接 VM 之後，請使用 sudo 取得 root 的存取權限：1$ sudo su -更新 OS：12345$ apt-get updateGet:1 http://security.debian.org stretch/updates InRelease [94.3 kB]Ign:2 http://deb.debian.org/debian stretch InRelease Get:3 http://deb.debian.org/debian stretch-updates InRelease [91.0 kB] ...安裝 NGINX：1$ apt-get install nginx -y檢查 NGINX 是否正在執行：12345$ ps auwx | grep nginxroot 2339 0.0 0.0 159532 1628 ? Ss 06:37 0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;www-data 2340 0.0 0.0 159864 3200 ? S 06:37 0:00 nginx: worker processwww-data 2341 0.0 0.0 159864 3200 ? S 06:37 0:00 nginx: worker processroot 2350 0.0 0.0 12780 952 pts/0 S+ 06:37 0:00 grep nginx註：如果關掉 NGINX 就不會出現關於 NGINX 的 process：1234$ service nginx stop$ ps auwx | grep nginxroot 2359 0.0 0.0 12780 1012 pts&#x2F;0 S+ 14:23 0:00 grep nginx使用下面指令可以啟動 NGINX：1$ service nginx start回到 Cloud Console，並點擊 VM instance 的 External IP 連結：就會開啟新分頁，可以看到 NGINX web server 的預設網頁：使用 gcloud 建立新的 instance前面介紹的是利用 GCP Console 來建立 VM instance，這邊要介紹的是可以使用預裝在 Google Cloud Shell 中的 command-line 工具 gcloud 來完成一樣的事。Cloud Shell 是基於 Debian 的 VM，預載你所需的所有開發工具 (gcloud、git … 等其他)，並提供 5 GB persistent disk 的 home 目錄。詳情可參考 gcloud command line tool guide。在 Cloud Shell 使用 command-line 工具 gcloud 建立一台新的 VM instance，將 [YOUR_ZONE] 替換成前面使用的 zone：1$ gcloud compute instances create gcelab2 --machine-type n1-standard-2 --zone [your_zone]像我前面的 zone 是用 asia-south1-c，所以指令如下：1234$ gcloud compute instances create gcelab2 --machine-type n1-standard-2 --zone asia-south1-cCreated [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-f9d61ede8167e6b0/zones/asia-south1-c/instances/gcelab2].NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSgcelab2 asia-south1-c n1-standard-2 10.160.0.3 35.244.6.170 RUNNING建立的 instance 具有以下預設值：最新的 Debian 9 (stretch) image預設機型 (machine type) 為 n1-standard-2，在此 lab 中，你也可以使用 n1-highmem-4 或 n1-highcpu-4 其他機型。在 lab 之外的專案可以指定自訂的機型root persistent disk 預設與 instance 的名稱一樣，disk 會自動附加到 instance執行下面指令可以查看所有預設值：1$ gcloud compute instances create --helpNote：如果你總是使用同一個 region/zone，並且不希望每次都使用 --zone 參數，就可以使用下面指令，將指定的 region 和 zones 設為預設：12$ gcloud config set compute/zone ...$ gcloud config set compute/region ...詳情可參考官方的 gcloud compute | Compute Engine Documentation 文件。若要查看剛剛建立的 instance 是否成功建立，就要回到「Navigation menu &gt; Compute Engine &gt; VM Instances」頁面，如果還是沒有看到，就可以點擊「REFRESH」按鈕重新整理此頁面，應該就會看到剛剛建立名為 gcelab2 的 instance：接著你也可以使用 gcloud 透過 SSH 連接到你的 instance，連線時，請確認指令後面 --zone 參數的 [YOUR_ZONE] 是否和當初建立的一樣，或是如果你已在全域設定預設 (上面 Note 提到的部分)，就可以省略 --zone 參數：1$ gcloud compute ssh gcelab2 --zone [YOUR_ZONE]像我沒有在全域設定預設，所以需要在指令後面加上 --zone 參數，[YOUR_ZONE] 則是當初建立的 asia-south1-c，指令如下：12345678910$ gcloud compute ssh gcelab2 --zone asia-south1-cWARNING: The public SSH key file for gcloud does not exist.WARNING: The private SSH key file for gcloud does not exist.WARNING: You do not have an SSH key for gcloud.WARNING: SSH keygen will be executed to generate a key.This tool needs to create the directory[/home/google3043863_student/.ssh] before being able to generate SSHkeys.Do you want to continue (Y/n)?接著會出現下面畫面，請輸入 Y 繼續：1Do you want to continue (Y/n)? y此時會產生一對公鑰 (public key) 和私鑰 (private key)，接著按 Enter 鍵，不輸入也不設定 passphrase (如果是在真正的專案就建議輸入 passphrase，因為當別人拿走你的私鑰時，就無法直接登入主機，還要輸入 passphrase，安全性會比較高)：1234567891011121314151617181920212223242526272829Generating public&#x2F;private rsa key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in &#x2F;home&#x2F;google3043863_student&#x2F;.ssh&#x2F;google_compute_engine.Your public key has been saved in &#x2F;home&#x2F;google3043863_student&#x2F;.ssh&#x2F;google_compute_engine.pub.The key fingerprint is:SHA256:LJMylIaZY1aNf2v0uP&#x2F;a83TSVw506GazmtvrTyPCxqU google3043863_student@cs-6000-devshell-vm-8e6e4e18-0f7e-4771-ac48-22ab57ceb161The key&#39;s randomart image is:+---[RSA 2048]----+| .o || &#x3D;... . || B +. o .|| o + .oo o . || o +oS+ .* .|| o o+ + oo *.|| . . E .+.*|| . ..o&#x3D;.+o|| .oo*&#x3D;&#x3D;o.|+----[SHA256]-----+Warning: Permanently added &#39;compute.3226821850929314737&#39; (ECDSA) to the list of known hosts.Linux gcelab2 4.9.0-8-amd64 #1 SMP Debian 4.9.144-3.1 (2019-02-19) x86_64The programs included with the Debian GNU&#x2F;Linux system are free software;the exact distribution terms for each program are described in theindividual files in &#x2F;usr&#x2F;share&#x2F;doc&#x2F;*&#x2F;copyright.Debian GNU&#x2F;Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Creating directory &#39;&#x2F;home&#x2F;google3043863_student&#39;.使用 gcloud 設定防火牆如果我已經跟著之前的步驟安裝完 NGINX 了，就會發現剛剛建立的 instance 沒有做防火牆設定，也就是不允許 80 port 的 HTTP 流量，所以就可以是用下面指令來設定：1$ gcloud compute firewall-rules create nginx --allow tcp:80執行指令後會看到下面訊息，訊息內容是無法建立防火牆，這是因為請求的身分權限不足：123Creating firewall...failed.ERROR: (gcloud.compute.firewall-rules.create) Could not fetch resource: - Insufficient Permission: Request had insufficient authentication scopes.那如何知道目前的有效帳號名稱？可以使用下面指令來查看，可以看到目前的帳號不是之前 lab 暫時給我們用的帳號：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* 721269751803-compute@developer.gserviceaccount.comTo set the active account, run: $ gcloud config set account `ACCOUNT`所以必須登入之前的帳號，可以使用下面指令：123456789101112131415$ gcloud auth loginYou are running on a Google Compute Engine virtual machine.It is recommended that you use service accounts for authentication.You can run: $ gcloud config set account `ACCOUNT`to switch accounts if necessary.Your credentials may be visible to others with access to thisvirtual machine. Are you sure you want to authenticate withyour personal account?Do you want to continue (Y/n)?接著會出現下面畫面，請輸入 Y 繼續：1Do you want to continue (Y/n)?接著會出現一長串的連結，點擊這個連結：12345678Do you want to continue (Y/n)? yGo to the following link in your browser: https://accounts.google.com/o/oauth2/auth?redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob&amp;prompt=select_account&amp;response_type=code&amp;client_id=32555940559.apps.googleusercontent.com&amp;scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloud-platform+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fappengine.admin+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcompute+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Faccounts.reauth&amp;access_type=offlineEnter verification code:該連結就是要你用 lab 提供的帳號登入：接著要同意 Google Cloud SDK 存取此帳號：接著複製此授權碼，將授權碼貼至剛剛的 shell：12345678Enter verification code: 4&#x2F;KwEnGIyzJ0P_ZvFeKt5264lP_3CdzZhUb-ZXoEJ0TbVFQVUQyYSBF58WARNING: &#96;gcloud auth login&#96; no longer writes application default credentials.If you need to use ADC, see: gcloud auth application-default --helpYou are now logged in as [google3043863_student@qwiklabs.net].Your current project is [qwiklabs-gcp-f9d61ede8167e6b0]. You can change this setting by running: $ gcloud config set project PROJECT_ID登入成功後，可以再次執行下面指令看一下目前有效帳號的名稱，變成 lab 暫時給我們用的帳號囉：12345678$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT 721269751803-compute@developer.gserviceaccount.com* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`接著再次執行下面指令，就可以成功設定防火牆：12345$ gcloud compute firewall-rules create nginx --allow tcp:80Creating firewall...⠶Created [https:&#x2F;&#x2F;www.googleapis.com&#x2F;compute&#x2F;v1&#x2F;projects&#x2F;qwiklabs-gcp-f9d61ede8167e6b0&#x2F;global&#x2F;firewalls&#x2F;nginx].Creating firewall...done.NAME NETWORK DIRECTION PRIORITY ALLOW DENY DISABLEDnginx default INGRESS 1000 tcp:80 False雖然 GCP Console 介面上 VM instance 的 External IP 沒有變成可以點擊的連結，但可以將 External IP 複製到新的瀏覽器分頁：就能成功看到 NGINX web server 的預設網頁：下圖就是我成功完成此 quest 的畫面：參考來源Creating a Virtual Machine | QwiklabsA Tour of Qwiklabs and the Google Cloud Platform | Qwiklabs在 GCP 上開立一台虛擬機 | Ray’s Coding Journey","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"VM","slug":"vm","permalink":"https://titangene.github.io/tags/vm/"},{"name":"NIGNX","slug":"nignx","permalink":"https://titangene.github.io/tags/nignx/"},{"name":"Web Server","slug":"web-server","permalink":"https://titangene.github.io/tags/web-server/"}],"author":"Titangene"},{"title":"Python 爬蟲常用技巧 (持續更新)","slug":"python-crawler-note","date":"2019-02-28T09:33:51.000Z","updated":"2019-09-21T01:59:47.000Z","comments":true,"path":"article/python-crawler-note.html","link":"","permalink":"https://titangene.github.io/article/python-crawler-note.html","excerpt":"紀錄個人常用的 Python 爬蟲技巧，未來還會持續更新其他技巧。","text":"紀錄個人常用的 Python 爬蟲技巧，未來還會持續更新其他技巧。載入常用套件12345678910import jsonimport shutilimport xml.etree.ElementTree as ETfrom urllib.parse import urlparse, parse_qs, urlunparseimport requestsfrom bs4 import BeautifulSoupfrom user_agent import generate_user_agentimport numpy as npimport pandas as pd解析 HTML123456import requestsfrom bs4 import BeautifulSoupresponse = requests.get(url)soup = BeautifulSoup(response.text, 'lxml')html = soup.find(id='some_id')解析網址12345from urllib.parse import urlparse, parse_qs, urlunparseurl = 'http://xxx.com/api/data?id=123&amp;sub_code=06A1297'link_parse = urlparse(url)print(link_parse)輸出：1ParseResult(scheme&#x3D;&#39;http&#39;, netloc&#x3D;&#39;xxx.com&#39;, path&#x3D;&#39;&#x2F;api&#x2F;data&#39;, params&#x3D;&#39;&#39;, query&#x3D;&#39;id&#x3D;123&amp;sub_code&#x3D;06A1297&#39;, fragment&#x3D;&#39;&#39;)將 ParseResult 物件轉成網址字串12url = urlunparse(link_parse)print(url)輸出：1&#39;http:&#x2F;&#x2F;xxx.com&#x2F;api&#x2F;data?id&#x3D;123&amp;sub_code&#x3D;06A1297&#39;解析網址 query123456link_query = parse_qs(link_parse.query)print(link_query)id = link_query['id'][0]sub_code = link_query['sub_code'][0]print(id, sub_code)輸出：12&#123;&#39;id&#39;: [&#39;123&#39;], &#39;sub_code&#39;: [&#39;06A1297&#39;]&#125;123 06A1297隨機生成 user-agentfake_useragent 套件123456789import requestsfrom fake_useragent import UserAgentdef set_header_user_agent(): user_agent = UserAgent() return user_agent.randomuser_agent = set_header_user_agent()response = requests.get(url, headers=&#123; 'user-agent': user_agent &#125;)user_agent 套件12345import requestsfrom user_agent import generate_user_agentuser_agent = generate_user_agent()response = requests.get(url, headers=&#123; 'user-agent': user_agent &#125;)讀取表格資料123456789import requestsfrom bs4 import BeautifulSoupimport numpy as npimport pandas as pdresponse = requests.get(url)soup = BeautifulSoup(response.text, 'lxml')html = soup.find(id='table_id')df = pd.read_html(str(html), header=0)[0]讀取/解析 JSON123456789import json# 讀取with open('data.json', encoding='utf-8') as file: datas = json.load(file)# 解析with open('data.json', 'w', encoding='utf-8') as file: json.dump(datas, file, ensure_ascii=False)讀取/解析 XML讀取 XML 檔1234import xml.etree.ElementTree as ETtree = ET.parse('data.xml')root = tree.getroot()讀取 XML 字串123import xml.etree.ElementTree as ETroot = ET.fromstring(some_xml_strings)以下面的 XML 為範例：123456789101112131415161718&lt;?xml version=\"1.0\"?&gt;&lt;bookstore&gt; &lt;book ISBN=\"10-000000-001\"&gt; &lt;title&gt;Book 1&lt;/title&gt; &lt;price&gt;300&lt;/price&gt; &lt;comments&gt; &lt;userComment rating=\"4\"&gt;xxx...&lt;/userComment&gt; &lt;userComment rating=\"2\"&gt;yyy...&lt;/userComment&gt; &lt;/comments&gt; &lt;/book&gt; &lt;book ISBN=\"10-000000-999\"&gt; &lt;title&gt;Book 2&lt;/title&gt; &lt;price&gt;500&lt;/price&gt; &lt;comments&gt; &lt;userComment rating=\"3\"&gt;zzz...&lt;/userComment&gt; &lt;/comments&gt; &lt;/book&gt;&lt;/bookstore&gt;迴圈取得子元素12for child in root: print(child.tag, child.attrib)輸出：12book &#123;&#39;ISBN&#39;: &#39;10-000000-001&#39;&#125;book &#123;&#39;ISBN&#39;: &#39;10-000000-999&#39;&#125;用 index 取得某元素123root[0][1].tagroot[0][1].textroot[0].attrib輸出：123&#39;price&#39;&#39;300&#39;&#123;&#39;ISBN&#39;: &#39;10-000000-001&#39;&#125;搜尋指定元素使用 root.iter()：123for comment in root.iter('userComment'): print(comment.attrib) print('comment: &#123;&#125;'.format(comment.text))輸出：123456&#123;&#39;rating&#39;: &#39;4&#39;&#125;comment: xxx...&#123;&#39;rating&#39;: &#39;2&#39;&#125;comment: yyy...&#123;&#39;rating&#39;: &#39;3&#39;&#125;comment: zzz...使用 root.findall()：1234for book in root.findall('book'): ISBN = book.get('ISBN') title = book.find('title').text print(ISBN, title)1210-000000-001 Book 110-000000-999 Book 2下載圖片response.raw 是 file-like 物件，預設不會解壓縮 response (使用 gzip 或 deflate，參考至 Requests 原始碼)，可以透過在 requests.get() 方法中，新增參數 stream=True 來強制解壓縮，並且可以避免立即將大的 response 內容讀入記憶體內，接著使用 shutil.copyfileobj() 讓 Python 將 串流資料轉成檔案物件。12345678import requestsimport shutilurl = \"http://www.xxx.com/xxx.png\"response = requests.get(url, stream=True)file_name = url.split('/')[-1]with open(file_name, 'wb') as file: shutil.copyfileobj(response.raw, file)如果要下載檔案大的圖片，可參考下個段落「下載大檔案」。shutil.copyfileobj(fsrc, fdst[, length])：將 file-like 物件 fsrc 的內容複製到 file-like 物件 fdst。length 參數 (int) 是 buffer 的大小。如果 length 為負數則代表是複製資料，而不以 chunk 的形式循環原始資料；預設是資料以 chunk 的形式讀取，以避免不受控制的記憶體消耗。請注意，如果 fsrc 物件的當前檔案位置不為 0，則只複製從當前檔案位置到檔案末端的內容。參考至 shutil - High-level file operations - Python 3.7.3 documentation 官方文件。參考來源：python - How to download image using requests - Stack Overflow下載大檔案以迭代的方式取得，預設會以每 128 byte 為一個 chunk 來讀取資料 (參考至 Requests 原始碼)：1234567import requestsresponse = requests.get(url, stream=True)file_name = url.split('/')[-1]with open(file_name, 'wb') as file: for chunk in response: file.write(chunk)若要自訂 chunk 大小，可使用 Response.iter_content() 方法自訂：12345678910import requestsfile_name = url.split('/')[-1]with requests.get(url, stream=True) as response: response.raise_for_status() with open(file_name, 'wb') as file: for chunk in response.iter_content(chunk_size=8192): if chunk: # filter out keep-alive new chunks file.write(chunk) # file.flush()參考來源：Download large file in python with requests - Stack Overflow若想要以一次一行的方式迭代 response 資料，可使用 Response.iter_lines() 方法，此方法預設一個 chunk 的大小為 512 byte，若要設定分隔符號，可加上 delimiter 參數：12345678import jsonimport requestsr = requests.get(url, stream=True)for line in r.iter_lines(): # filter out keep-alive new lines if line: print(json.loads(line))參考來源：Python Requests 庫：HTTP for Humans - 再見紫羅蘭 - 博客園","categories":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"},{"name":"Crawler","slug":"python/crawler","permalink":"https://titangene.github.io/categories/python/crawler/"}],"tags":[{"name":"Python Requests","slug":"python-requests","permalink":"https://titangene.github.io/tags/python-requests/"}],"author":"Titangene"},{"title":"在 Hexo 主題內新增程式碼片段複製功能","slug":"hexo-copy-code-snippet-to-clipboard","date":"2019-02-09T02:40:00.000Z","updated":"2019-04-30T15:38:34.000Z","comments":true,"path":"article/hexo-copy-code-snippet-to-clipboard.html","link":"","permalink":"https://titangene.github.io/article/hexo-copy-code-snippet-to-clipboard.html","excerpt":"為了提高 blog 的使用體驗，本文將說明如何在 Hexo 主題內，提供程式碼片段複製至剪貼簿的功能。","text":"為了提高 blog 的使用體驗，本文將說明如何在 Hexo 主題內，提供程式碼片段複製至剪貼簿的功能。12// copy to clipboardvar clipboard = document.querySelectorAll('pre');載入 clipboard.js在 themes\\material-flow\\layout\\_partial\\scripts.ejs 檔案內的載入 clipboard.js：1&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js\"&gt;&lt;/script&gt;新增程式碼片段複製功能每個程式碼片段內都要新增複製功能按鈕，下面說明新增複製按鈕的處理邏輯：首先要找到所有程式碼區塊：1var snippets = document.querySelectorAll('figure.highlight');準備要新增的按鈕結構：1234var htmlCopyButton = ` &lt;button class=\"codecopy-btn tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard\"&gt; &lt;i class=\"far fa-copy\" aria-hidden=\"true\"&gt;&lt;/i&gt; &lt;/button&gt;`;在原本的程式碼區塊的 &lt;figure&gt; 標籤外多包了一層 &lt;div&gt; 標籤在 &lt;div&gt; 標籤上新增 .code-highlight class 樣式在 &lt;div&gt; 標籤上新增 data-lang 屬性用於記錄此程式碼區塊內的程式碼是哪種程式語言12345678910111213snippets.forEach(snippet =&gt; &#123; var parent = snippet.parentNode; var wrapper = document.createElement('div'); parent.replaceChild(wrapper, snippet); wrapper.appendChild(snippet); wrapper.classList.add('code-highlight'); wrapper.firstChild.insertAdjacentHTML('beforebegin', htmlCopyButton); var lang = (snippet.classList[1] || 'code').toUpperCase(); wrapper.setAttribute('data-lang', lang);&#125;);接著將名為 .codecopy-btn 的 element 上新增複製功能，複製的內容是 &lt;figure&gt; 標籤內的程式碼：12345var clipboard = new ClipboardJS('.codecopy-btn', &#123; target: trigger =&gt; &#123; return trigger.nextSibling; &#125;,&#125;);只要按複製按鈕且複製成功，就會顯示 Copied! 提示已成功複製程式碼片段：1234clipboard.on('success', e =&gt; &#123; e.trigger.setAttribute('aria-label', 'Copied!'); e.clearSelection();&#125;);將每個複製按鈕新增兩個監聽事件，分別是 mouseleave 和 click：mouseleave：滑鼠離開按鈕就將提示文字變成 Copy to clipboardclick：取消事件的預設行為123456789101112var btns = document.querySelectorAll('.codecopy-btn');btns.forEach(btn =&gt; &#123; btn.addEventListener('mouseleave', e =&gt; &#123; e.target.setAttribute('aria-label', 'Copy to clipboard'); e.target.blur(); &#125;); btn.addEventListener('click', e =&gt; &#123; e.preventDefault(); &#125;);&#125;);完整程式碼在 themes\\material-flow\\source\\js 目錄內建立 clipboard-use.js，檔案內容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$(function() &#123; // ref: https://github.com/zenorocha/codecopy/blob/master/src/scripts/main.js var snippets = document.querySelectorAll('figure.highlight'); var htmlCopyButton = ` &lt;button class=\"codecopy-btn tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard\"&gt; &lt;i class=\"far fa-copy\" aria-hidden=\"true\"&gt;&lt;/i&gt; &lt;/button&gt;`; snippets.forEach(snippet =&gt; &#123; var parent = snippet.parentNode; var wrapper = document.createElement('div'); parent.replaceChild(wrapper, snippet); wrapper.appendChild(snippet); wrapper.classList.add('code-highlight'); wrapper.firstChild.insertAdjacentHTML('beforebegin', htmlCopyButton); var lang = (snippet.classList[1] || 'code').toUpperCase(); wrapper.setAttribute('data-lang', lang); &#125;); // Add copy to clipboard functionality and user feedback var clipboard = new ClipboardJS('.codecopy-btn', &#123; target: trigger =&gt; &#123; return trigger.nextSibling; &#125;, &#125;); clipboard.on('success', e =&gt; &#123; e.trigger.setAttribute('aria-label', 'Copied!'); e.clearSelection(); &#125;); // Replace tooltip message when mouse leaves button // and prevent page refresh after click button var btns = document.querySelectorAll('.codecopy-btn'); btns.forEach(btn =&gt; &#123; btn.addEventListener('mouseleave', e =&gt; &#123; e.target.setAttribute('aria-label', 'Copy to clipboard'); e.target.blur(); &#125;); btn.addEventListener('click', e =&gt; &#123; e.preventDefault(); &#125;); &#125;);&#125;);接著在 themes\\material-flow\\layout\\_partial\\scripts.ejs 檔案內的載入 clipboard-use.js：1&lt;%- js('js/clipboard-use.js') %&gt;CSS 樣式提示文字樣式在 themes\\material-flow\\source\\less 目錄內建立 _tooltipped.less，檔案內容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ref: https://github.com/primer/primer/blob/master/modules/primer-tooltips/lib/tooltips.scss.tooltipped &#123; position: relative;&#125;// This is the tooltip bubble.tooltipped::after &#123; position: absolute; z-index: 1000000; display: none; padding: 0.5em 0.75em; -webkit-font-smoothing: subpixel-antialiased; color: #fff; text-align: center; text-decoration: none; text-shadow: none; text-transform: none; letter-spacing: normal; word-wrap: break-word; white-space: pre; pointer-events: none; content: attr(aria-label); background: #616161; border-radius: 3px; opacity: 0;&#125;// This is the tooltip arrow.tooltipped::before &#123; position: absolute; z-index: 1000001; display: none; width: 0; height: 0; color: #616161; pointer-events: none; content: ''; border: 6px solid transparent; opacity: 0;&#125;// delay animation for tooltip@keyframes tooltip-appear &#123; from &#123; opacity: 0; &#125; to &#123; opacity: 1; &#125;&#125;// This will indicate when we'll activate the tooltip.tooltipped:hover,.tooltipped:active,.tooltipped:focus &#123; &amp;::before, &amp;::after &#123; display: inline-block; text-decoration: none; animation-name: tooltip-appear; animation-duration: 0.1s; animation-fill-mode: forwards; animation-timing-function: ease-in; &#125;&#125;// Tooltipped south.tooltipped-s,.tooltipped-sw &#123; &amp;::after &#123; top: 100%; right: 50%; margin-top: 6px; &#125; &amp;::before &#123; top: auto; right: 50%; bottom: -7px; margin-right: -6px; border-bottom-color: #616161; &#125;&#125;.tooltipped-sw::after &#123; margin-right: -16px;&#125;// Move the tooltip body to the center of the object..tooltipped-s::after &#123; transform: translateX(50%);&#125;接著在 themes\\material-flow\\source\\style.less 檔案內的載入 _tooltipped.less：1@import 'less/_tooltipped.less';其他樣式可參考本站的完整樣式：原始碼123456789101112131415161718192021222324252627282930313233343536373839404142figure &#123; &amp;.highlight &#123; position: relative; margin: 1rem 0; padding-top: 22px; &#125;&#125;.code-highlight &#123; position: relative; &amp;::before &#123; content: attr(data-lang); font-family: 'Roboto Mono', Consolas, monospace, sans-serif; font-size: 0.6em; color: #b1b1b1; line-height: 18px; position: absolute; top: 4px; right: 7px; z-index: 1; &#125;&#125;.codecopy-btn &#123; width: 24px; height: 26px; position: absolute; top: 0; right: -24px; border: none; box-shadow: none; background: none; z-index: 1; font-size: 12px; color: #fff; transition: color 0.2s; &amp;:hover &#123; color: #7bf; &#125;&#125;Demo下面是原本的 HTML：123456789101112&lt;figure class=\"highlight javascript\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=\"gutter\"&gt; &lt;pre&gt;&lt;span class=\"line\"&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt; &lt;/td&gt; &lt;td class=\"code\"&gt; &lt;pre&gt;&lt;code class=\"hljs javascript\"&gt;...&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/figure&gt;使用後的 HTML：1234567891011121314151617&lt;div class=\"code-highlight\" data-lang=\"JAVASCRIPT\"&gt; &lt;button class=\"codecopy-btn tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard\"&gt; &lt;i class=\"far fa-copy\" aria-hidden=\"true\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;figure class=\"highlight javascript\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=\"gutter\"&gt; &lt;pre&gt;&lt;span class=\"line\"&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt; &lt;/td&gt; &lt;td class=\"code\"&gt; &lt;pre&gt;&lt;code class=\"hljs javascript\"&gt;...&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/figure&gt;&lt;/div&gt;畫面：參考連結clipboard.js — Copy to clipboard without FlashGitHub’s Primer Tooltipszenorocha/codecopy: A browser extension that adds copy to clipboard buttons on every code block","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://titangene.github.io/tags/hexo/"},{"name":"Code Snippet","slug":"code-snippet","permalink":"https://titangene.github.io/tags/code-snippet/"},{"name":"Clipboard","slug":"clipboard","permalink":"https://titangene.github.io/tags/clipboard/"}],"author":"Titangene"},{"title":"在 Docker 下建立並使用 MSSQL Server for Linux","slug":"docker-mssql-server-for-linux","date":"2019-01-30T15:30:00.000Z","updated":"2019-04-30T15:57:59.000Z","comments":true,"path":"article/docker-mssql-server-for-linux.html","link":"","permalink":"https://titangene.github.io/article/docker-mssql-server-for-linux.html","excerpt":"在 SQL Server 2017 時，微軟推出了 Linux 版，同時也在 Docker Hub 上提供了 microsoft/mssql-server-linux 的 Docker image。本篇會介紹如何在 Docker 下，透過此 image 來建立並使用 MSSQL Server for Linux。","text":"在 SQL Server 2017 時，微軟推出了 Linux 版，同時也在 Docker Hub 上提供了 microsoft/mssql-server-linux 的 Docker image。本篇會介紹如何在 Docker 下，透過此 image 來建立並使用 MSSQL Server for Linux。MSSQL Server for Linux 要求必須 Docker Engine 1.8+，支援任何平台 (Windows/Mac/Linux)硬碟空間至少 2 GBRAM 至少 2 GBimage 必要的環境變數：ACCEPT_EULA=Y：確認同意授權合約MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;：設定 SA 密碼A strong system administrator (SA) 密碼必須符合以下規則：至少 8 個字元必需包含英文大寫、英文小寫、數字、非字母數字符號四者中的其中三種即可詳情可參考官方的 SQL Server on Liunx 的系統需求 文件。建立 ContainerDocker Hub：microsoft/mssql-server-linux1234567# 從 Docker Hub 提取 SQL Server 2017 Linux container image$ docker pull microsoft/mssql-server-linux:2017-latest# 建立並執行 Docker container$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1401:1433 --name sql1 \\ -d microsoft/mssql-server-linux:2017-latest-e 'ACCEPT_EULA=Y'：確認同意授權合約-e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;'：必需是強密碼並至少 8 個字元。強密碼英文大寫、英文小寫、數字、非字母數字符號四者中的其中三種即可。-p hostPort:containerPort：host 對外開 1401 port，container 內開 1433 port--name：指定 container 名稱-d：背景執行microsoft/mssql-server-linux:2017-latest：使用 SQL Server 2017 Linux image 建立 container如果列表 NAMES 顯示 sql1 並且 STATUS 顯示 UP 就代表 SQL Server 已在背景執行：1234# 查看 container 的狀態$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES08e2f151d579 microsoft/mssql-server-linux:2017-latest \"/bin/sh -c /opt/mss…\" 31 minutes ago Up 31 minutes 0.0.0.0:1401-&gt;1433/tcp sql1連接至 SQL Server使用 SQL Server 命令列工具 sqlcmd，連接到 SQL Server container：123456789# 在外部向執行中的 container 內部下指令，啟動 Container 內部的互動式 bash shell，來執行你下的指令$ docker exec -it sql1 bash# 使用 SQL Server 命令列工具 `sqlcmd`，並登入帳號密碼連接到 SQL Server$ /opt/mssql-tools/bin/sqlcmd -S localhost -U SAPassword:# 出現 \"1&gt;\" 就代表已成功登入並已進入 sqlcmd1&gt;變更 SA 的密碼SA 帳號是在安裝期間建立的 SQL Server 實例上的系統管理員。建立 SQL Server container 之後，在 container 中執行 echo $MSSQL_SA_PASSWORD，即可查看 SA 的密碼：123$ docker exec -it sql1 bashroot@xxx:/# echo $MSSQL_SA_PASSWORDYourStrong!Passw0rd執行下面指令可以變更 SA 的密碼，而 opt/mssql-tools/bin/sqlcmd 是 sqlcmd 所在的路徑：123$ docker exec -it sql1 /opt/mssql-tools/bin/sqlcmd \\ -S localhost -U SA -P '&lt;YourStrong!Passw0rd&gt;' \\ -Q 'ALTER LOGIN SA WITH PASSWORD=\"&lt;YourNewStrong!Passw0rd&gt;\"'參數說明：-S：server-U：user name-P：password-Q：query，執行 SQL 指令後結束 sqlcmd建立資料庫及查詢資料123456789101112131415161718192021# 查詢 server 上所有 DB 名稱1&gt; SELECT Name from sys.Databases# 在 sqlcmd 指令模式下，要輸入 GO 指令才會執行2&gt; GOName------------mastertempdbmodelmsdb(4 rows affected)# 建立資料庫1&gt; CREATE DATABASE TestDB2&gt; GO# 出現下面畫面 \"1&gt;\" 就代表已成功建立資料庫1&gt;# 離開 sqlcmd1&gt; quit使用 Azure Data Studio 連接 SQL ServerAzure Data Studio (以前稱為 SQL Operations Studio) 是一個輕量且免費的跨平台 SQL Server 開源管理工具，支援 Windows、macOS、Linux。安裝 Azure Data Studiofor Windows下載並解壓縮，接著執行 \\azuredatastudio-windows\\sqlops.exe 即可開始使用。for Linux下載並解壓縮，接著將 Azure Data Studio 執行檔加入 PATH 環境變數，以後即可在終端機輸入 azuredatastudio 開啟 Azure Data Studio：123456$ cd ~$ cp ~/Downloads/azuredatastudio-linux-&lt;version string&gt;.tar.gz ~$ tar -xvf ~/azuredatastudio-linux-&lt;version string&gt;.tar.gz$ echo 'export PATH=\"$PATH:~/azuredatastudio-linux-x64\"' &gt;&gt; ~/.bashrc$ source ~/.bashrc$ azuredatastudiofor macOS下載並解壓縮，然後將 Azure Data Studio 加入 Launchpad，將 Studio.app 拖曳到應用程式目錄 (Applications folder) 即可。安裝詳情可參考官方的 下載並安裝 - Azure Data Studio | Microsoft Docs 文件。登入 SQL ServerServer name 的格式： IP, PortIP：Linux：使用 ifconfig 指令查詢 IPWindows：使用 ipconfig 指令查詢 IPPort：要看前面建立的 container 是設定多少 Port此範例 (也就是下面的指令) 是設定使用 1401 port，所以只要輸入 YourIP, 1401 就能與 SQL Server 連接。123$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1401:1433 --name sql1 \\ -d microsoft/mssql-server-linux:2017-latest建立資料表和資料，並查詢資料執行下面指令，建立資料表和資料，並查詢資料：12345678-- 切換至 TestDB 資料庫use TestDB;-- 建立資料表CREATE TABLE People(Name nvarchar(50), Age int);-- 新增資料INSERT INTO People VALUES ('Titan', 18), ('John', 6), ('Alex', 40);-- 查詢年齡小於 20 歲的人SELECT * FROM People WHERE Age &lt; 20;執行完的結果如下圖，看到此查詢結果就代表已成功新增資料：刪除 Container指定刪除名為 sql1 的 container：12345678# 查詢目前的正在執行的 container$ docker ps# container 停止執行$ docker stop sql# 刪除 container$ docker rm sql1或是可以在未停止執行 container 的情況下，直接強制刪除 container：12# 強制刪除 container$ docker rm -f sql1透過 Volume 將資料庫的資料儲存至主機在 docker run 指令上加 -v 參數可以建立實體資料夾與 container 資料夾的對應關係，將主機上的指定目錄綁定到 container 的指定目錄，也就是可以存資料庫的資料至主機，參數語法為 -v &lt;host directory&gt;:/var/opt/mssql：12345# 執行 Docker container image$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1402:1433 --name sql2 \\ -v `pwd`/mssql:/var/opt/mssql \\ -d microsoft/mssql-server-linux:2017-latest備份與還原資料庫範例前置準備：建立資料庫、資料表和資料下面的 SQL 指令是用來立資料庫、資料表和資料，因為此 container 是剛剛另外新建的，之前的 container 已經刪除了 (因為沒有利用 Volume 儲存資料庫的資料)，所以需要重新建立資料：123456789-- 建立 資料庫CREATE DATABASE TestDB;GO-- 切換至 TestDB 資料庫use TestDB;-- 建立資料表CREATE TABLE People(Name nvarchar(50), Age int);-- 新增資料INSERT INTO People VALUES ('Titan', 18), ('John', 6), ('Alex', 40);備份資料庫使用 sqlcmd 連接到 SQL Server，並完整備份 TestDB 資料庫，備份檔存至 ./data/testdb.bak：12$ docker exec -it sql2 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA \\ -Q \"BACKUP DATABASE TestDB TO DISK = N'/var/opt/mssql/data/testdb.bak' WITH NOFORMAT, NOINIT, NAME = 'demodb-full', SKIP, NOREWIND, NOUNLOAD, STATS = 10\"當執行此指令時，SQL Server 將會提示需輸入密碼。輸入密碼後，很快就會備份完成，如果備份成功畫面就會顯示「BACKUP DATABASE successfully …」：1234567891011121314Password: 10 percent processed.20 percent processed.30 percent processed.40 percent processed.50 percent processed.60 percent processed.70 percent processed.80 percent processed.90 percent processed.Processed 312 pages for database 'TestDB', file 'TestDB' on file 1.100 percent processed.Processed 6 pages for database 'TestDB', file 'TestDB_log' on file 1.BACKUP DATABASE successfully processed 318 pages in 0.348 seconds (7.139 MB/sec).範例前置處理：刪除 container 和資料庫資料下面是要模擬把 container 刪除後，要如何將剛剛備份的資料庫資料 (也就是 ./data/testdb.bak ) 還原，因此也要刪除透過 Volume 儲存的資料庫資料，如以下步驟：刪除 container1234# 查詢目前的正在執行的 container$ docker ps# 強制刪除 container$ docker rm -f sql2刪除透過 Volume 儲存的資料庫資料1234567891011121314151617181920212223242526272829# 查看剛剛刪除的 container 保存下來的 DB 資料檔 (TestDB_log.ldf 和 TestDB.mdf)$ cd mssql/data$ pwd/home/titan/project/mssql/data$ tree├── master.mdf├── mastlog.ldf├── modellog.ldf├── model.mdf├── msdbdata.mdf├── msdblog.ldf├── tempdb.mdf├── templog.ldf├── testdb.bak├── TestDB_log.ldf &lt;---└── TestDB.mdf &lt;---# 刪除 TestDB.mdf 和 TestDB_log.ldf$ sudo rm TestDB*$ tree├── master.mdf├── mastlog.ldf├── modellog.ldf├── model.mdf├── msdbdata.mdf├── msdblog.ldf├── tempdb.mdf├── templog.ldf└── testdb.bak在建立一個新的 container (用來做還原資料庫用的)先回到專案的根目錄：12345$ pwd/home/titan/project/mssql/data$ cd ../..$ pwd/home/titan/project接著建立一個新的 container，名稱叫做 sql3：1234$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1403:1433 --name sql3 \\ -v `pwd`/mssql:/var/opt/mssql \\ -d microsoft/mssql-server-linux:2017-latest還原資料庫使用 sqlcmd 連接到 SQL Server，並還原 TestDB 資料庫 (要還原的備份檔存至 ./data/testdb.bak )：12$ docker exec -it sql3 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA \\ -Q \"RESTORE DATABASE TestDB FROM DISK = N'/var/opt/mssql/data/testdb.bak' WITH FILE = 1, NOUNLOAD, REPLACE, STATS = 5\"當執行此指令時，SQL Server 將會提示需輸入密碼。輸入密碼後，很快就會還原完成，如果還原成功畫面就會顯示「RESTORE DATABASE successfully …」：123456789101112131415161718192021222324Password: 6 percent processed.11 percent processed.15 percent processed.20 percent processed.25 percent processed.31 percent processed.36 percent processed.41 percent processed.45 percent processed.50 percent processed.57 percent processed.61 percent processed.66 percent processed.70 percent processed.75 percent processed.82 percent processed.86 percent processed.91 percent processed.95 percent processed.100 percent processed.Processed 344 pages for database 'TestDB', file 'TestDB' on file 1.Processed 7 pages for database 'TestDB', file 'TestDB_log' on file 1.RESTORE DATABASE successfully processed 351 pages in 0.321 seconds (8.530 MB/sec).檢查一下剛剛刪除的 TestDB.mdf 和 TestDB_log.ldf 都正確的還原了：12345678910111213$ cd mssql/data$ tree├── master.mdf├── mastlog.ldf├── modellog.ldf├── model.mdf├── msdbdata.mdf├── msdblog.ldf├── tempdb.mdf├── templog.ldf├── testdb.bak├── TestDB_log.ldf &lt;---└── TestDB.mdf &lt;---使用 select SQL 指令可以看到資料確實已還原：使用 Azure Data Studio 備份或還原資料庫如果覺得打指令很麻煩，其實 Azure Data Studio、SQL Server Management Studio (SSMS)、SQL Server Data Tools (SSDT) 或 Visual Studio Code (VS Code) 的 mssql 擴充功能 都有提供 GUI 的介面，可以直接備份或還原資料庫。下圖是 Azure Data Studio 備份或還原資料庫的畫面：詳情可參考官方的 備份與還原的資料庫 - Azure Data Studio | Microsoft Docs 文件。參考連結開始使用 Docker （Linux 上執行 SQL Server） 上的 SQL Server 容器 - SQL Server | Microsoft Docs在 Docker 上的 SQL Server 組態選項 - SQL Server | Microsoft Docs在 Docker 中的 SQL Server 資料庫還原 - SQL Server | Microsoft DocsGithub repo: Microsoft/mssql-docker","categories":[{"name":"SQL Server","slug":"sql-server","permalink":"https://titangene.github.io/categories/sql-server/"},{"name":"Linux","slug":"sql-server/linux","permalink":"https://titangene.github.io/categories/sql-server/linux/"},{"name":"Database","slug":"sql-server/linux/database","permalink":"https://titangene.github.io/categories/sql-server/linux/database/"},{"name":"DevOps","slug":"sql-server/linux/database/devops","permalink":"https://titangene.github.io/categories/sql-server/linux/database/devops/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://titangene.github.io/tags/docker/"},{"name":"Container","slug":"container","permalink":"https://titangene.github.io/tags/container/"}],"author":"Titangene"},{"title":"將 Hexo 的 Markdown 渲染引擎換成 markdown-it","slug":"hexo-markdown-it","date":"2019-01-29T14:51:00.000Z","updated":"2020-01-22T09:41:52.000Z","comments":true,"path":"article/hexo-markdown-it.html","link":"","permalink":"https://titangene.github.io/article/hexo-markdown-it.html","excerpt":"個人很常用 HackMD 紀錄筆記，希望 blog 也可以支援 HackMD 的 Markdown 格式，因此本篇的目標就是要將 Hexo 原本的 Markdown 渲染引擎 marked，換成 HackMD 的 Markdown 渲染引擎：markdown-it。","text":"個人很常用 HackMD 紀錄筆記，希望 blog 也可以支援 HackMD 的 Markdown 格式，因此本篇的目標就是要將 Hexo 原本的 Markdown 渲染引擎 marked，換成 HackMD 的 Markdown 渲染引擎：markdown-it。更換渲染引擎Hexo 預設的 markdown 渲染引擎是 marked，並使用 hexo-renderer-marked 此 Hexo 外掛來將 Markdown 轉換成靜態檔案 HTML，但因前面提到的需求，所以要刪除原本的渲染引擎1$ npm uninstall hexo-renderer-marked --save安裝我們要改用的 Markdown 渲染引擎：markdown-it，而使用此渲染引擎的 Hexo 外掛就是 hexo-renderer-markdown-it，所以要在 hexo 的專案中安裝此外掛：1$ npm install git+https://github.com/hexojs/hexo-renderer-markdown-it.git --save為何安裝 NPM 套件時要指定 github 的 repo 呢？因為 hexo-renderer-markdown-it 此 NPM 套件的程式沒有更新成 Github 上面的程式版本，請確定剛剛安裝套件中，node_modules\\hexo-renderer-markdown-it\\lib\\renderer.js 這個檔案內的下面這段程式碼是否相同：123456789if (opt.plugins) &#123; parser = opt.plugins.reduce(function(parser, pugs) &#123; if (pugs instanceof Object &amp;&amp; pugs.name) &#123; return parser.use(require(pugs.name), pugs.options); &#125; else &#123; return parser.use(require(pugs)); &#125; &#125;, parser);&#125;若是從 NPM 下載的套件版本 (也就是直接使用 npm install hexo-renderer-markdown-it --save 此指令)，會少幾句程式，少了可在載入 markdown-it 的外掛時為該外掛設定所需的 options：12345if (opt.plugins) &#123; parser = opt.plugins.reduce(function(parser, pugs) &#123; return parser.use(require(pugs)); &#125;, parser);&#125;安裝渲染引擎外掛套件我們可以參考 HackMD 的相依套件，只要是名為 markdown-it-xxx 的套件就是渲染引擎 markdown-it 的外掛：1234567891011121314151617181920&#123; \"dependencies\": &#123; // ... \"markdown-it\": \"^8.2.2\", \"markdown-it-abbr\": \"^1.0.4\", \"markdown-it-container\": \"^2.0.0\", \"markdown-it-deflist\": \"^2.0.1\", \"markdown-it-emoji\": \"^1.3.0\", \"markdown-it-footnote\": \"^3.0.1\", \"markdown-it-imsize\": \"^2.0.1\", \"markdown-it-ins\": \"^2.0.0\", \"markdown-it-mark\": \"^2.0.0\", \"markdown-it-mathjax\": \"^2.0.0\", \"markdown-it-regexp\": \"^0.4.0\", \"markdown-it-sub\": \"^1.0.0\", \"markdown-it-sup\": \"^1.0.0\", \"markdown-it-task-checkbox\": \"^1.0.6\", // ... &#125;&#125;而下列是我選擇要安裝的外掛：markdown-it-abbrmarkdown-it-containermarkdown-it-deflistmarkdown-it-emojimarkdown-it-footnotemarkdown-it-imsizemarkdown-it-insmarkdown-it-markmarkdown-it-regexpmarkdown-it-submarkdown-it-supmarkdown-it-task-checkbox123456789101112$ npm i markdown-it-abbr \\ markdown-it-task-checkbox \\ markdown-it-container \\ markdown-it-deflist \\ markdown-it-emoji \\ markdown-it-footnote \\ markdown-it-imsize \\ markdown-it-ins \\ markdown-it-mark \\ markdown-it-regexp \\ markdown-it-sub \\ markdown-it-sup --savemarkdown-it-mathjax為何我未安裝 markdown-it-mathjax 這個外掛？這是因為…我之後再單獨寫一篇文章來介紹如何在 Markdown 加上數學式 MathJax。markdown-it-task-checkbox為何我會比 HackMD 多安裝 markdown-it-task-checkbox 這個外掛？有使用過 HackMD 的朋友都知道，只要在 HackMD 輸入下列 Markdown 語法：12- [ ] task 1- [x] task 2就會被轉換成 HTML 的 checkbox：12345678&lt;ul&gt; &lt;li class=\"task-list-item\"&gt; &lt;input type=\"checkbox\" class=\"task-list-item-checkbox \" /&gt;&lt;label&gt;&lt;/label&gt;task 1 &lt;/li&gt; &lt;li class=\"task-list-item\"&gt; &lt;input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"\" /&gt;&lt;label&gt;&lt;/label&gt;task 2 &lt;/li&gt;&lt;/ul&gt;畫面會看到一個未被勾選以及一個已被勾選的 checkbox：不過 HackMD 不是靠著 Markdown 渲染引擎 markdown-it 的外掛來轉換成 HTML 的，而是直接利用正規表示法 (Regular Expression) 找到 [ ] 或 [x] 的文字，再將這些文字直接轉換成 HTML 的 checkbox。我擷取了 HackMD 的這段程式邏輯，若想看詳細的原始碼可至 HackMD 的原始碼內的 public/js/extra.js 檔案中的第 263 行左右：12345678910111213141516if (/^\\s*\\[[x ]\\]\\s*/.test(html)) &#123; li.innerHTML = html .replace( /^\\s*\\[ \\]\\s*/, `&lt;input type=\"checkbox\" class=\"task-list-item-checkbox\" $&#123;disabled&#125;&gt;&lt;label&gt;&lt;/label&gt;`, ) .replace( /^\\s*\\[x\\]\\s*/, `&lt;input type=\"checkbox\" class=\"task-list-item-checkbox\" checked $&#123;disabled&#125;&gt;&lt;label&gt;&lt;/label&gt;`, ); if (li.tagName.toLowerCase() !== 'li') &#123; li.parentElement.setAttribute('class', 'task-list-item'); &#125; else &#123; li.setAttribute('class', 'task-list-item'); &#125;&#125;設定 _config.yml將下面這些設定在根目錄的 _config.yml 設定檔中：123456789101112131415161718192021222324252627282930313233343536373839# Markdown-it config# Docs: https://github.com/hexojs/hexo-renderer-markdown-it/wikimarkdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-deflist - markdown-it-imsize - markdown-it-mark - markdown-it-regexp - markdown-it-task-checkbox - name: markdown-it-container options: success - name: markdown-it-container options: info - name: markdown-it-container options: warning - name: markdown-it-container options: danger - markdown-it-deflist - name: markdown-it-emoji options: shortcuts: &#123;&#125; anchors: level: 1 collisionSuffix: 'v' permalink: true permalinkClass: header-anchor permalinkSymbol: ''想了解設定詳情可參考 Advanced Configuration | hexojs/hexo-renderer-markdown-it Wiki 官方文件。","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://titangene.github.io/tags/hexo/"},{"name":"Markdown","slug":"markdown","permalink":"https://titangene.github.io/tags/markdown/"}],"author":"Titangene"},{"title":"Flutter 載入圖片","slug":"flutter-loading-images","date":"2018-12-31T13:10:00.000Z","updated":"2019-04-30T15:57:23.000Z","comments":true,"path":"article/flutter-loading-images.html","link":"","permalink":"https://titangene.github.io/article/flutter-loading-images.html","excerpt":"要如何在 Flutter 內載入圖片？這篇做個小記錄。","text":"要如何在 Flutter 內載入圖片？這篇做個小記錄。指定資源Flutter 是在根目錄內的 pubspec.yaml 檔案來設定應用程式所需的資源，設定的資源沒有順序關係。若要指定某些資源，資源的路徑是相對於 pubspec.yaml 檔案的相對路徑：1234flutter: assets: - assets/images/avatar.jpg - assets/images/background.jpg也可以指定某個目錄，代表可以存取到這個目錄下的所有資源，但記得要在目錄的最後加上 / 這個符號：123flutter: assets: - assets/若要存取子目錄內的資源，請記得要另外為子目錄設定，例如：1234flutter: assets: - assets/ - assets/images/載入圖片可使用 Image.asset() 來載入圖片，裡面的參數就是圖片的路徑：12345Widget build(BuildContext context) &#123; // ... return Image.asset('assets/images/background.jpg'); // ...&#125;或是在 Image() 內的 image 參數使用 AssetImage()：1234567Widget build(BuildContext context) &#123; // ... return Image( image: AssetImage('assets/images/background.jpg'), ); // ...&#125;最後顯示的結果會一樣：參考連結Adding assets and images - Flutter","categories":[{"name":"Flutter","slug":"flutter","permalink":"https://titangene.github.io/categories/flutter/"},{"name":"Mobile App","slug":"flutter/mobile-app","permalink":"https://titangene.github.io/categories/flutter/mobile-app/"}],"tags":[{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"}],"author":"Titangene"},{"title":"Python - 日誌 (logging) 模組","slug":"python-logging","date":"2018-12-13T10:32:46.000Z","updated":"2019-04-30T15:55:01.000Z","comments":true,"path":"article/python-logging.html","link":"","permalink":"https://titangene.github.io/article/python-logging.html","excerpt":"開發 Python 時，很常使用 print() 來輸出變數以方便 debug，但要部署時，不需要這些訊息，需要自己手動去註解或刪除那些放在各處的 print()。而 Python 內建提供了 logging 模組可以用來取代 print()，logging 除了可以輸出訊息，也可以將訊息儲存至日誌檔保存。下面紀錄如何使用 logging 模組。","text":"開發 Python 時，很常使用 print() 來輸出變數以方便 debug，但要部署時，不需要這些訊息，需要自己手動去註解或刪除那些放在各處的 print()。而 Python 內建提供了 logging 模組可以用來取代 print()，logging 除了可以輸出訊息，也可以將訊息儲存至日誌檔保存。下面紀錄如何使用 logging 模組。載入 logging 模組1import logginglogging 等級logging 模組預先定義了 6 種等級以及對應的 log 輸出函數 (除了 logging.NOTSET 沒有對應的輸出函數)：等級等級數值輸出函數說明NOTSET0無對應的輸出函數未設定DEBUG10logging.debug()除錯INFO20logging.info()訊息WARNING30logging.warning()警告ERROR40logging.error()錯誤CRITICAL50logging.critical()嚴重錯誤若要查詢各等級的數值，可直接呼叫該等級：12345678import loggingprint(logging.NOTSET) # 0print(logging.DEBUG) # 10print(logging.INFO) # 20print(logging.WARNING) # 30print(logging.ERROR) # 40print(logging.CRITICAL) # 50若要用等級數值來查詢是哪個等級的訊息，可使用 logging.getLevelName(level)：12345678import loggingprint(logging.getLevelName(0)) # NOTSETprint(logging.getLevelName(10)) # DEBUGprint(logging.getLevelName(20)) # INFOprint(logging.getLevelName(30)) # WARNINGprint(logging.getLevelName(40)) # ERRORprint(logging.getLevelName(50)) # CRITICAL輸出 logginglogging 模組預設等級為 WARNING，大於或等於 WARNING 等級的訊息才會被記錄：1234567import logginglogging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是輸出結果，可以看到比 WARNING 等級還要低的訊息有 DEBUG 和 INFO 就不會被輸出：123WARNING:root:warning messageERROR:root:error messageCRITICAL:root:critical message若將等級設為 DEBUG，就會將所有等級的訊息都輸出：123456789import logginglogging.basicConfig(level=logging.DEBUG)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是輸出結果，預設的訊息輸出格式是 %(levelname)s:%(name)s:%(message)s (後面會介紹如何自訂輸出格式)：12345DEBUG:root:debug messageINFO:root:info messageWARNING:root:warning messageERROR:root:error messageCRITICAL:root:critical message紀錄堆疊追蹤資訊logging 模組也提供可以紀錄完整的堆疊追蹤 (stack traces)，若在 logging.error() 加上 exc_info 參數，並將該參數設為 True，就可以紀錄 Exception，如下：123456import loggingtry: x = 5 / 0except: logging.error(\"Catch an exception.\", exc_info=True)下面是輸出結果：12345ERROR:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zero若沒有加上 exc_info=True 則無法紀錄 Exception：123456import loggingtry: x = 5 / 0except: logging.error(\"Catch an exception.\")下面是輸出結果：1ERROR:root:Catch an exception.若要在 logging 內紀錄 exception 訊息，可使用 logging.exception()，它會將 exception 添加至訊息中，此方法的等級為 ERROR，也就是說 logging.exception() 就等同於 logging.error(exc_info=True)123456import loggingtry: x = 5 / 0except: logging.exception('Catch an exception.')輸出結果和 logging.error(exc_info=True) 相同：12345ERROR:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zero若不想使用 ERROR 級別紀錄 exception 訊息，可使用 DEBUG、INFO、WARNING、CRITICAL 級別並加上參數 exc_info=True 的設定：1234567891011import logginglogging.basicConfig(level=logging.DEBUG)try: x = 5 / 0except: logging.debug('Catch an exception.', exc_info=True) logging.info('Catch an exception.', exc_info=True) logging.warning('Catch an exception.', exc_info=True) logging.critical('Catch an exception.', exc_info=True)下面是輸出結果：1234567891011121314151617181920DEBUG:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zeroINFO:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zeroWARNING:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zeroCRITICAL:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zero自訂 logging 輸出格式預設的訊息輸出格式只有 levelname、name、message，下面是其他相關的資訊：格式化字串說明%(asctime)s日期時間, 格式為 YYYY-MM-DD HH:mm:SS,ms，例如：2018-12-13 17:20:30,567%(filename)s模組檔名%(funcName)s函數名稱%(levelname)s日誌的等級名稱%(levelno)s日誌的等級數值%(lineno)d呼叫日誌函數所在的行數%(message)s訊息%(module)s模組名稱%(name)slogger 的名稱%(pathname)s檔案的完整路徑 (如果可用)%(process)dprocess ID (如果可用)%(thread)d執行緒 ID (如果可用)%(threradName)s執行緒名稱可將這些資訊加入 logging.basicConfig() 內的 format 參數：12345678910import loggingFORMAT = '%(asctime)s %(levelname)s: %(message)s'logging.basicConfig(level=logging.DEBUG, format=FORMAT)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是自訂訊息的輸出結果：123452018-12-13 17:40:34,604 DEBUG: debug message2018-12-13 17:40:34,604 INFO: info message2018-12-13 17:40:34,604 WARNING: warning message2018-12-13 17:40:34,604 ERROR: error message2018-12-13 17:40:34,608 CRITICAL: critical message自訂輸出的時間格式在 logging.basicConfig() 內的 datefmt 參數可設定所需的時間格式，要使用 time.strftime() 接受的時間格式：參數說明%Y長年份，例如：2019%y短年份，例如：19%m月份：01 ~ 12%B月份完整名稱，例如：February%b月份縮寫名稱，例如：Feb%d日期：01 ~ 31%H小時 (24 小時制)：00 ~ 23%I小時 (12 小時制)：01 ~ 12%w星期：0 ~ 6，0 代表星期日%A星期完整名稱，例如：Friday%a星期縮寫名稱，例如：Fri%PAM 或 PM%M分鐘：00 ~ 59%S秒：00 ~ 61time.strftime() 的時間參數詳情可參考 Python 官方的 time — Time access and conversions — Python 3.7.2 documentation 文件。1234567891011import loggingLOGGING_FORMAT = '%(asctime)s %(levelname)s: %(message)s'DATE_FORMAT = '%Y%m%d %H:%M:%S'logging.basicConfig(level=logging.DEBUG, format=LOGGING_FORMAT, datefmt=DATE_FORMAT)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是自訂訊息的輸出結果：1234520190107 08:57:07 DEBUG: debug message20190107 08:57:07 INFO: info message20190107 08:57:07 WARNING: warning message20190107 08:57:07 ERROR: error message20190107 08:57:07 CRITICAL: critical message儲存 logging只要在 logging.basicConfig() 內的 filename 參數設定要儲存的日誌檔名，就可以將 logging 儲存：12345678910import loggingFORMAT = '%(asctime)s %(levelname)s: %(message)s'logging.basicConfig(level=logging.DEBUG, filename='myLog.log', filemode='w', format=FORMAT)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')預設 filemode 參數是設為 a，代表 append (附加) 的意思，每次執行程式時，Logging 會將新的訊息加在舊的訊息後面，不會覆蓋舊的訊息。若要改成新訊息覆蓋就訊息，那可以將 filemode 參數設為 w，代表 write 的意思。下面是剛剛執行後儲存的 myLog.log 日誌檔：123452018-12-13 17:47:18,686 DEBUG: debug message2018-12-13 17:47:18,687 INFO: info message2018-12-13 17:47:18,687 WARNING: warning message2018-12-13 17:47:18,687 ERROR: error message2018-12-13 17:47:18,687 CRITICAL: critical message詳情可參考官方文件 Logging facility for Python — Python documentation。","categories":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"}],"tags":[{"name":"Logging","slug":"logging","permalink":"https://titangene.github.io/tags/logging/"}],"author":"Titangene"},{"title":"設定 Windows 工作排程定期執行 Python 爬蟲程式","slug":"set-up-windows-task-scheduler-to-periodically-execute-python-crawler","date":"2018-12-01T04:55:00.000Z","updated":"2019-04-30T15:54:19.000Z","comments":true,"path":"article/set-up-windows-task-scheduler-to-periodically-execute-python-crawler.html","link":"","permalink":"https://titangene.github.io/article/set-up-windows-task-scheduler-to-periodically-execute-python-crawler.html","excerpt":"如何將 Python 爬蟲程式定期執行？使用 Windows 的使用者可以選擇「工作排程器」來解決。","text":"如何將 Python 爬蟲程式定期執行？使用 Windows 的使用者可以選擇「工作排程器」來解決。最近有些資料想透過爬蟲來擷取，而且希望可以定期 (例如：每 10 分鐘一次) 自動執行爬蟲程式，因此就有了這篇筆記。下面介紹如何以 Windows 工作排程器來定期執行爬蟲程式。目標每 10 分鐘自動執行 Python 爬蟲程式，將爬蟲抓到的最新降雨量資料存入 CSV 檔內收集。準備WindowsPython 環境：建議安裝 Anaconda，可參考 用 Conda 建立虛擬環境和管理相依套件Python 套件 (這是本篇爬蟲範例所需的相依套件，可依各自需求來選擇)PandasNumpyRequestsPython 爬蟲程式原始碼source code: titangene/cwb-opendata-crawler-demo/crawler.py簡單說明一下程式的執行步驟：利用 Python 的 Requests 套件來建立 HTTP 的 GET 請求，從中央氣象局提供的開放資料 API 中取得資料，回傳的格式是 JSON解析 API 回傳的 JSON 資料，並將 JSON 轉成 Pandas 的 DataFrame 型別的資料格式將 DataFrame 儲存成 CSV 檔保存資料若想了解中央氣象局開放資料的相關內容，詳情可參考 中央氣象局開放資料 - 開發指南。Python 爬蟲程式的批次檔建立一個副檔名為 .bat 的批次檔，批次檔是用來執行 Python 爬蟲程式，因此就能讓 Windows 工作排程器在定期時間自動執行批次檔，以達成自動化執行爬蟲的目的。下面就來說明批次檔每行都做了甚麼：第一行：切到指定目錄第二行：指定 Python 虛擬環境 (可參考 用 Conda 建立虛擬環境和管理相依套件。如果要在全域環境下執行就不需要這行)第三行：執行 Python 爬蟲程式第四行：若想查看 Python 爬蟲程式執行過程中所輸出 (也就是執行 print 方法的部分) 內容，就需要取消這行的註解REM：單行註解pause：用來暫停批次檔的執行1234cd /d D:/Project/Python/cwb-opendata-crawlercall activate devcall python crawler.pyREM pausesource code: titangene/cwb-opendata-crawler-demo/crawler.batWindows 工作排程器 簡介可預先設定工作在特定時間或指定時間時，會自動執行程式或批次檔以達成工作自動化。下圖為 Windows 10 的工作排程器介面：建立工作，設定定期執行爬蟲程式開啟 Windows 的「工作排程器」，點擊右上角的「建立工作」自訂工作名稱，若有權限需求可勾選「以最高權限執行」選項接著新增「觸發程序」設定工作的開始時間，並選擇「僅一次」，以及設定工作要每隔多久就執行一次，並且要持續多久時間然後新增「動作」設定要自動執行的程式，這邊選擇的就是剛剛提到的 批次檔 (原始碼)如果設定好了就可以按確定完成建立工作，此時就會看到在「工作排程器程式庫」內的工作清單中，多了剛剛新增的工作成果可以看到爬蟲程式會在定期自動執行，執行的時候會跳出一個 cmd 視窗。若剛剛提到的 批次檔 內沒有將 REM pause 這行註解，就會看到爬蟲程式執行完成後，不會自動關閉 cmd 視窗，這是為了可以立即看到該次爬蟲執行過程中輸出的訊息。下圖就是自動執行爬蟲所抓到的資料：完整 source code：titangene/cwb-opendata-crawler-demo","categories":[{"name":"Windows","slug":"windows","permalink":"https://titangene.github.io/categories/windows/"},{"name":"Python","slug":"windows/python","permalink":"https://titangene.github.io/categories/windows/python/"},{"name":"Crawler","slug":"windows/python/crawler","permalink":"https://titangene.github.io/categories/windows/python/crawler/"},{"name":"OS","slug":"windows/python/crawler/os","permalink":"https://titangene.github.io/categories/windows/python/crawler/os/"}],"tags":[{"name":"Python Requests","slug":"python-requests","permalink":"https://titangene.github.io/tags/python-requests/"},{"name":"Windows 工作排程","slug":"windows-工作排程","permalink":"https://titangene.github.io/tags/windows-%E5%B7%A5%E4%BD%9C%E6%8E%92%E7%A8%8B/"}],"author":"Titangene"},{"title":"用 Conda 建立虛擬環境和管理相依套件","slug":"create-a-virtual-environment-and-manage-dependencies-with-conda","date":"2018-11-19T09:10:00.000Z","updated":"2019-05-12T07:21:26.000Z","comments":true,"path":"article/create-a-virtual-environment-and-manage-dependencies-with-conda.html","link":"","permalink":"https://titangene.github.io/article/create-a-virtual-environment-and-manage-dependencies-with-conda.html","excerpt":"學習如何利用 Conda 來建立不同需求所需的 Python 開發環境，並如何管理相依套件。","text":"學習如何利用 Conda 來建立不同需求所需的 Python 開發環境，並如何管理相依套件。AnacondaAnaconda 是最受歡迎的 Python 資料科學 (Data Science) 平台，它特點就是本來就包含了各種數據分析、科學計算的相關套件 (例如：NumPy、SciPy、Matplotlib、SymPy、Pandas … 等)，而 Anaconda 的套件管理工具就是 conda。CondaConda 是一個開源的套件與環境管理的系統，可以在 Windows、macOS 和 Linux 上使用。可利用 Conda 來安裝、執行、更新套件以及其相依的套件，並且還可用來建立不同的開發環境 (例如：不同環境有不同的 Python 版本)。安裝 Anaconda至 Anaconda 官網下載並安裝，建議選擇 Python 3.x 的版本。建立虛擬環境從指定套件列表中建立新的 conda 環境：-n，--name：設定環境名稱1234567$ conda create -n &lt;environment&gt; &lt;package&gt;# 安裝包含 Anaconda 發行版的套件$ conda create -n &lt;environment&gt; anaconda# 指定 Python 版本$ conda create -n &lt;environment&gt; python=3.6-e，--envs：列出已建立的環境123456# 顯示虛擬環境列表，並顯示正在使用的虛擬環境$ conda info -e# conda environments:#base * D:\\Users\\Titan\\Anaconda3hello D:\\Users\\Titan\\Anaconda3\\envs\\hello使用或 activate 至指定環境：12345# Windows$ activate &lt;environment&gt;# Linux and macOS$ source activate &lt;environment&gt;123456# 顯示虛擬環境列表，並顯示正在使用的虛擬環境$ conda info -e# conda environments:#base D:\\Users\\Titan\\Anaconda3hello * D:\\Users\\Titan\\Anaconda3\\envs\\hello* 代表目前正在使用的虛擬環境離開虛擬環境如果要將現在環境改回預設值 base (離開目前環境) 可使用下面指令：12345# Windows$ deactivate# Linux and macOS$ source deactivate利用 conda 安裝套件1234$ conda install &lt;package&gt;# 安裝多個套件$ conda install &lt;package-1&gt; &lt;package-2&gt;查看資訊查看 conda 目前版本12$ conda -Vconda 4.5.11查看目前環境已安裝的套件123456789101112$ conda list# packages in environment at D:\\Users\\Titan\\Anaconda3:## Name Version Build Channel...jupyter 1.0.0 py35_3jupyter_client 5.2.3 py35_0jupyter_console 4.1.1 py35_0jupyter_core 4.4.0 py35h629ba7f_0jupyterlab 0.32.1 &lt;pip&gt;jupyterlab-launcher 0.10.5 &lt;pip&gt;...查看 conda 是否有某套件：12345678$ conda search &lt;package&gt;$ conda search pandasLoading channels: done# Name Version Build Channelpandas 0.9.0 np16py27_0 pkgs/freepandas 0.9.1 np16py27_0 pkgs/free...如果 conda 沒有該套件，可以使用 pip 來安裝套件：12345# 安裝套件$ pip install &lt;package&gt;# 更新套件$ pip install --upgrade &lt;package&gt;刪除套件12345678# 刪除環境內的套件$ conda remove -n &lt;environment&gt; &lt;package&gt;# 刪除目前環境內的套件$ conda remove &lt;package&gt;# 刪除多個套件$ conda remove &lt;package-1&gt; &lt;package-2&gt;更新套件1234567891011# 更新 conda$ conda update conda# 更新 Anaconda$ conda update anaconda# 更新 Python$ conda update python# 更新特定套件$ conda update &lt;package&gt;刪除虛擬環境1$ conda env remove -n &lt;environment&gt;更新 Python更新全域環境若目前 Python 版本是 3.6.1，下面指令只會將 Python 更新至 3.6.x 的最新版本：1$ conda update python若是要更新到其他版本可指定 Python 版本：1$ conda install python=3.6更新 Anaconda更新套件管理器：1$ conda update conda注意：Conda 會更新該版本列表中的最高版本，因此 Python 2.7 更新到 2.x 中的最高版本，而 3.x 系列依此類推。更新 anaconda 此 meta-package，可更新 Anaconda 發行版包含的套件：1$ conda update anaconda如果要更新 Python 的特定版本：1$ conda install python==$pythonversion$參考連結Managing packages | Conda documentationmacos - How do I upgrade to Python 3.6 with conda? - Stack Overflow","categories":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"}],"tags":[{"name":"Anaconda","slug":"anaconda","permalink":"https://titangene.github.io/tags/anaconda/"},{"name":"Conda","slug":"conda","permalink":"https://titangene.github.io/tags/conda/"},{"name":"Virtual Environment","slug":"virtual-environment","permalink":"https://titangene.github.io/tags/virtual-environment/"},{"name":"Package Management","slug":"package-management","permalink":"https://titangene.github.io/tags/package-management/"}],"author":"Titangene"},{"title":"Windows Subsystem for Linux (WSL)","slug":"windows-subsystem-for-linux","date":"2018-11-17T11:00:45.000Z","updated":"2019-04-30T16:01:29.000Z","comments":true,"path":"article/windows-subsystem-for-linux.html","link":"","permalink":"https://titangene.github.io/article/windows-subsystem-for-linux.html","excerpt":"Windows Subsystem for Linux (簡稱 WSL)，由 Microsoft 與 Canonical 公司合作開發，可直接在 Windows 10 中建立一個 Linux 子系統，原生執行 Linux，還可自行選擇你想安裝的 Linux 發行版，例如：Ubuntu、Kali Linux、SUSE。","text":"Windows Subsystem for Linux (簡稱 WSL)，由 Microsoft 與 Canonical 公司合作開發，可直接在 Windows 10 中建立一個 Linux 子系統，原生執行 Linux，還可自行選擇你想安裝的 Linux 發行版，例如：Ubuntu、Kali Linux、SUSE。啟用 Windows Subsystem for Linux使用系統管理者權限開啟 PowerShell，並執行下面命令啟用 Windows Subsystem for Linux 功能：1$ Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux如果顯示下面訊息就代表你沒有使用系統管理員開啟 PowerShell：123456Enable-WindowsOptionalFeature : 要求的作業需要提升的權限。位於 線路:1 字元:1+ Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows- ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Enable-WindowsOptionalFeature], COMException + FullyQualifiedErrorId : Microsoft.Dism.Commands.EnableWindowsOptionalFeatureCommand接著等他跑一下…：接著他會問是否要重啟電腦，因為預設是 Yes，所以可以直接按 Enter：其實上面指令就等於去「控制台 &gt; 程式集 &gt; 開啟或關閉 Windows 功能」開啟「適用於 Linux 的 Windows 子系統」。安裝 Linux 發行版系統組建 (build) 必須要 Windows build 16215 或更新版本。若要想知道系統組建，可至 Windows 的「設定」內的「關於」即可查看。你可以選擇你想安裝的 Linux 發行版：Ubuntu 16.04 LTSUbuntu 18.04 LTSDebian GNU/LinuxOpenSUSE Leap 42SUSE Linux Enterprise Server 12Kali Linux如果在安裝後直接開啟 Ubuntu，就會顯示 Error: 0x8007007e 錯誤就代表你沒有啟用 Windows Subsystem for Linux 功能，詳情請參考上面：1234The WSL optional component is not enabled. Please enable it and try again.See https://aka.ms/wslinstall for details.Error: 0x8007007ePress any key to continue...安裝後啟動 Linux 發行版，此時會開啟一個 console 視窗。因為是第一次開啟，所以會先安裝 WSL，等它安裝完後，就會看到下面畫面，系統要你建立一個新的 Unix 使用者名稱：12345Installing, this may take a few minutes...Installation successful!Please create a default UNIX user account. The username does not need to match your Windows username.For more information visit: https://aka.ms/wslusersEnter new UNIX username:接著是設定此使用者的密碼，這邊的使用者與你的 Windows 使用者名稱和密碼沒有任何關係。詳情可參考官方的 Linux User Account and Permissions | Microsoft Docs 文件。如果顯示 $ 就代表設定完成囉！執行 lsb_release -a 指令就會看到 Linux 的系統版本：在其他終端使用 Bash如果在使用 CMD 、 PowerShell 或其他終端 (例如我常用的 Cmder) 時想用 bash shell，可使用 bash 指令就可以啟動新的 Ubuntu shell：1$ bash存取目錄如果想存取 D:\\project，在此環境下的路徑就是 /mnt/d/project。小結如果有在跨平台開發或維運的朋友，這個功能應該是一直以來的願望吧？讓你在 Windows 上可以直接處理事情，不用再多開 VM 來使用，不只省資源，也省硬碟空間，重點是不用等 VM 開機…參考連結Install the Linux Subsystem on Windows 10 | Microsoft Docs【WSL】Windows Subsystem for Linux 安裝及基本配置！ | 台灣微軟學生大使Bash on Ubuntu on Windows 的簡單使用 | Heresy’s Space","categories":[{"name":"Linux","slug":"linux","permalink":"https://titangene.github.io/categories/linux/"},{"name":"Windows","slug":"linux/windows","permalink":"https://titangene.github.io/categories/linux/windows/"}],"tags":[{"name":"Ubuntu","slug":"ubuntu","permalink":"https://titangene.github.io/tags/ubuntu/"},{"name":"WSL","slug":"wsl","permalink":"https://titangene.github.io/tags/wsl/"}],"author":"Titangene"},{"title":"GitHub 縮網址服務 Git.io","slug":"github-url-shortener","date":"2018-10-31T16:58:19.000Z","updated":"2019-02-07T11:20:54.000Z","comments":true,"path":"article/github-url-shortener.html","link":"","permalink":"https://titangene.github.io/article/github-url-shortener.html","excerpt":"最近發現原來 Github 也有提供縮網址 (URL Shortener) 服務「Git.io」，它只適用於 gist.github.com 及 github.com 兩個 hostname。","text":"最近發現原來 Github 也有提供縮網址 (URL Shortener) 服務「Git.io」，它只適用於 gist.github.com 及 github.com 兩個 hostname。下列網址都可以透過 Git.io 來建立縮網址：Github 個人或組織專業 ( https://github.com/&lt;github-id&gt; )Github repository ( https://github.com/&lt;github-id&gt;/&lt;repo-name&gt; ) 或 repository 內目錄或檔案Gist ( https://gist.github.com/&lt;github-id&gt;/&lt;gist-id&gt; )Git.io 有兩種建立短網址的方法，下面會分別介紹：直接到 Git.io 線上設定使用 curl 指令設定：Git.io: GitHub URL Shortener | GitHub BlogGit.io 線上設定最簡單的方法當然是直接打開 Git.io，接著輸入網址並點擊「shorten」按鈕就會將你剛剛輸入的網址變成短網址，短網址的格式是 git.io/xxx。但缺點是無法自訂短網址名稱，預設是自動隨機英文 + 數字的字串。使用 curl 指令建立短網址-i、--include：顯示 HTTP response headers-F、--form &lt;name=content&gt;：設定表單資料，Content-Type 會被設為 multipart/form-data1$ curl -i https://git.io -F \"url=&lt;想縮短的網址&gt;\" -F \"code=&lt;自訂短網址名稱&gt;\"例如我想將自己的 Github profile URL：github.com/titangene 縮短成 git.io/titan，就要執行下面指令：1234567$ curl -i https://git.io -F \"url=https://github.com/titangene\" -F \"code=titan\"HTTP/1.1 201 Created...Location: https://git.io/titan...$ curl -i https://git.io -F \"url=https://titangene.github.io/\" -F \"code=titan-blog\"只要輸入下面指令就可以確認是否建立成功12345$ curl -i https://git.io/titanHTTP/1.1 302 Found...Location: https://github.com/titangene...[小插曲] 縮網址不小心設定錯誤一開始在 Git.io 測試時，直接用自己的 Github profile URL ( github.com/titangene ) 來產生預設隨機英文 + 數字的短網址，想要修改成 git.io/titan 卻沒辦法！這是因為 Git.io 沒有直接提供修改短網址的功能。後來 Google 一下才發現只能聯繫 Github 客服來幫忙刪除短網址，然後再自行重新設定。過了不到半天客服就回信幫我解決了！真是太感謝 Github 客服了！","categories":[{"name":"Other","slug":"other","permalink":"https://titangene.github.io/categories/other/"}],"tags":[{"name":"Github","slug":"github","permalink":"https://titangene.github.io/tags/github/"},{"name":"URL","slug":"url","permalink":"https://titangene.github.io/tags/url/"},{"name":"URL Shortener","slug":"url-shortener","permalink":"https://titangene.github.io/tags/url-shortener/"}],"author":"Titangene"},{"title":"Flutter 自訂字型","slug":"flutter-custom-fonts","date":"2018-10-29T03:40:00.000Z","updated":"2019-04-30T15:57:38.000Z","comments":true,"path":"article/flutter-custom-fonts.html","link":"","permalink":"https://titangene.github.io/article/flutter-custom-fonts.html","excerpt":"雖然 Android 和 iOS 內建都有字型，但常有自訂字型的需求，所以這篇會教你如何在 Flutter 使用自訂字型。","text":"雖然 Android 和 iOS 內建都有字型，但常有自訂字型的需求，所以這篇會教你如何在 Flutter 使用自訂字型。將字型檔放入專案資料夾內此範例是放在 ./assets/fonts 資料夾內：1234567assets&#x2F; fonts&#x2F; FiraCode-Medium.ttf mononoki-Bold.ttf mononoki-BoldItalic.ttf mononoki-Italic.ttf mononoki-Regular.ttf在 pubspec.yaml 定義字型資訊123456789101112131415flutter: fonts: - family: FiraCode fonts: - asset: assets/fonts/FiraCode-Medium.ttf - family: Mononoki fonts: - asset: assets/fonts/mononoki-Regular.ttf - asset: assets/fonts/mononoki-Bold.ttf weight: 700 - asset: assets/fonts/mononoki-Italic.ttf style: italic - asset: assets/fonts/mononoki-BoldItalic.ttf weight: 700 style: italic設定預設字型12345MaterialApp( title: 'Custom Fonts', theme: ThemeData(fontFamily: 'FiraCode'), home: MyHomePage(title: 'Custom Fonts'),);在特定 Widget 設定字型123456789Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontWeight: FontWeight.w700, fontStyle: FontStyle.italic, ),)完整範例程式碼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Custom Fonts', theme: new ThemeData( primarySwatch: Colors.blue, fontFamily: 'FiraCode', ), home: new MyHomePage(title: 'Custom Fonts'), ); &#125;&#125;class MyHomePage extends StatelessWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(this.title), ), body: Column( children: &lt;Widget&gt;[ new Text( '&lt;-- Custom Fonts -&gt;&gt;', style: TextStyle(fontSize: 30.0), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, ), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontWeight: FontWeight.w700, ), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontStyle: FontStyle.italic, ), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontWeight: FontWeight.w700, fontStyle: FontStyle.italic, ), ), ], ), ); &#125;&#125;詳情可參考 Using custom fonts - Flutter 官方文件","categories":[{"name":"Flutter","slug":"flutter","permalink":"https://titangene.github.io/categories/flutter/"},{"name":"Mobile App","slug":"flutter/mobile-app","permalink":"https://titangene.github.io/categories/flutter/mobile-app/"}],"tags":[{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"},{"name":"Font","slug":"font","permalink":"https://titangene.github.io/tags/font/"}],"author":"Titangene"},{"title":"Flutter 環境建置 (Windows)","slug":"flutter-install-on-windows","date":"2018-10-22T22:58:44.000Z","updated":"2019-04-30T15:57:33.000Z","comments":true,"path":"article/flutter-install-on-windows.html","link":"","permalink":"https://titangene.github.io/article/flutter-install-on-windows.html","excerpt":"最近剛接觸 Flutter，於是就把在 Windows 上建置環境的記錄寫成一篇筆記，裡面包括 Android Studio 和 VS Code 的開發流程。","text":"最近剛接觸 Flutter，於是就把在 Windows 上建置環境的記錄寫成一篇筆記，裡面包括 Android Studio 和 VS Code 的開發流程。詳情可參考官方連結：Get Started: Install on Windows | Flutter系統要求OS：Windows 7 SP1 或以上 (64-bit)硬碟空間：400 MB (不包括 IDE 和工具的空間)工具PowerShell 5.0 或更新版Git for Windows (勾選 Use Git from the Windows Command Prompt 選項，若沒打勾可自行將 Git 安裝目錄內的 bin 資料夾設定為 Path 環境變數，預設目錄為 C:\\Program Files\\Git\\bin )安裝 Flutter SDK下載 Flutter SDK，可下載歷史版本，但建議安裝新版。解壓檔內有一個 flutter 資瞭夾，將此資料夾放在 Flutter SDK 所需的安裝目錄 (e.g D:\\dev\\flutter，請勿將 flutter 資瞭夾放在需要提高權限之類的目錄內，e.g. C:\\Program Files\\ )。將 flutter\\bin 的完整目錄 (e.g. D:\\dev\\flutter\\bin ) 加入 Path 環境變數 (各完整路徑記得用 ; 分號分隔)接著就可以在 Console 內執行 Flutter commands執行 flutter --version 指令確定已成功安裝 Flutter SDK12345$ flutter --versionFlutter 0.7.3 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 3b309bda07 (12 days ago) • 2018-08-28 12:39:24 -0700Engine • revision af42b6dc95Tools • Dart 2.1.0-dev.1.0.flutter-ccb16f7282之後請定期執行 flutter upgrade 指令更新 Flutter (因為目前還在 beta，大約幾週就會有新版)執行 flutter --version 指令後，若看到下面畫面就代表現在有新版可以更新：123456789101112$ flutter --version ╔════════════════════════════════════════════════════════════════════════════╗ ║ A new version of Flutter is available! ║ ║ ║ ║ To update to the latest version, run \"flutter upgrade\". ║ ╚════════════════════════════════════════════════════════════════════════════╝Flutter 0.7.3 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 3b309bda07 (3 weeks ago) • 2018-08-28 12:39:24 -0700Engine • revision af42b6dc95Tools • Dart 2.1.0-dev.1.0.flutter-ccb16f7282執行 flutter upgrade 指令更新 Flutter：123456789101112131415161718$ flutter upgradeUpgrading Flutter from D:\\dev\\flutter......Flutter 0.7.3 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 3b309bda07 (3 weeks ago) • 2018-09-07 12:33:05 -0700Engine • revision 58a1894a1cTools • Dart 2.1.0-dev.1.0.flutter-ccb16f7282Running flutter doctor...Doctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.8.2, on Microsoft Windows [Version 10.0.17134.285], locale zh-TW)[√] Android toolchain - develop for Android devices (Android SDK 28.0.2)[√] Android Studio (version 3.1)[√] VS Code (version 1.27.2)[!] Connected devices ! No devices available! Doctor found issues in 1 category.在執行一次 flutter --version 確認已更新至新的版本：12345$ flutter --versionFlutter 0.8.2 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 5ab9e70727 (13 days ago) • 2018-09-07 12:33:05 -0700Engine • revision 58a1894a1cTools • Dart 2.1.0-dev.3.1.flutter-760a9690c2flutter doctor下面指令是用來查看是否需要安裝任何依賴才能完成設定，因此他會檢查你的環境並顯示檢查報告：1$ flutter doctorDart SDK is bundled with Flutter，不用另外安裝 Dart。從檢查報告的輸出中可以了解需要安裝的其他軟體或執行的其他任務 (以粗體顯示)。例如：123456789101112$ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.7.3, on Microsoft Windows [Version 10.0.17134.228], locale zh-TW)[!] Android toolchain - develop for Android devices (Android SDK 28.0.2) X Android license status unknown.[√] Android Studio (version 3.1) X Flutter plugin not installed; this adds Flutter specific functionality. X Dart plugin not installed; this adds Dart specific functionality.[!] Connected devices ! No devices available! Doctor found issues in 2 categories.下面會介紹如何執行這些任務並完成設定過程。可再次執行 flutter doctor 指令來驗證是否已正確設定所有內容。如果已驗證設定所有內容，就會看到下面輸出結果：12345678$ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.7.3, on Microsoft Windows [Version 10.0.17134.285], locale zh-TW)[√] Android toolchain - develop for Android devices (Android SDK 28.0.2)[√] Android Studio (version 3.1)[√] Connected devices (1 available)• No issues found!加上參數 -v，可以看更詳細的驗證說明：1234567891011121314151617181920212223242526$ flutter doctor -v[√] Flutter (Channel beta, v0.7.3, on Microsoft Windows [Version 10.0.17134.285], locale zh-TW) • Flutter version 0.7.3 at D:\\dev\\flutter • Framework revision 3b309bda07 (3 weeks ago), 2018-08-28 12:39:24 -0700 • Engine revision af42b6dc95 • Dart version 2.1.0-dev.1.0.flutter-ccb16f7282[√] Android toolchain - develop for Android devices (Android SDK 28.0.2) • Android SDK at C:\\Users\\Titan\\AppData\\Local\\Android\\sdk • Android NDK location not configured (optional; useful for native profiling support) • Platform android-28, build-tools 28.0.2 • ANDROID_HOME = C:\\Users\\Titan\\AppData\\Local\\Android\\sdk • Java binary at: C:\\Program Files\\Android\\Android Studio\\jre\\bin\\java • Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1024-b02) • All Android licenses accepted.[√] Android Studio (version 3.1) • Android Studio at C:\\Program Files\\Android\\Android Studio • Flutter plugin version 28.0.1 • Dart plugin version 173.4700 • Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1024-b02)[√] Connected devices (1 available) • SM N950F • 988a98444d********** • android-arm64 • Android 8.0.0 (API 26)• No issues found!Android 設定Flutter 依賴於 Android Studio 以提供 Android 平台的依賴性。但也可以使用其他編輯器來寫 Flutter App。安裝 Java JDK安裝 JDK將 Java JDK 安裝目錄設定為 JAVA_HOME 環境變數 (e.g. C:\\Program Files\\Java\\jdk1.8.0_151 )，並在將 Java JDK 安裝目錄內的 bin 資料夾設定為 Path 環境變數 (e.g. C:\\Program Files\\Java\\jdk1.8.0_151\\bin，也可設定為 %JAVA_HOME%\\bin )安裝 Android Studio安裝 Android Studio，請安裝 Recommended (建議) 版執行 Android Studio，並瀏覽 Android Studio Setup Wizard，安裝最新的 Android SDK、Android SDK Platform-Tools、Android SDK Build-Tools，這些都是 Flutter 在開發 Android 時所必須的。將 Android SDK 目錄設定為 ANDROID_HOME 環境變數 (預設目錄為 C:\\Users\\Titan\\AppData\\Local\\Android\\sdk )定期更新 Android SDK (於 Android Studio &gt; Configure &gt; SDK Manager 安裝)設定你的 Android 裝置想在 Android 裝置上執行和測試 Flutter App，需要 Android 4.1 (API level 16) 或更高版本的 Android 設備。裝置請開啟 開發者模式 內的 USB 偵錯，詳情可參考 Configure on-device developer options | Android Developers 此 Android 官方文件安裝 Google USB Driver (限 Windows)使用 USB 線將裝置連接至電腦，如果你的裝置有出現提示，請授權你的電腦可訪問你的裝置開啟終端機，執行 flutter devices 指令以驗證 Flutter 是否成功連結 Android 裝置12345# 像我連接到 Note 8$ flutter devices1 connected device:SM N950F • 988a98444d********** • android-arm64 • Android 8.0.0 (API 26)Flutter 預設會以 adb 工具基於的 Android SDK 版本來使用，若想用其他版本的 Android SDK，可設定你所需的 Android SDK 目錄為 ANDROID_HOME 環境變數。如果執行 flutter run指令，而且成功將 App 安置手機並執行，就會看到 App 的畫面設定 Android 模擬器 (emulator)想在 Android 模擬器上執行和測試 Flutter App，請依照下面步驟：在主機上啟用 VM acceleration啟動 Android Studio &gt; Tools &gt; AVD Manager 並點選 Create Virtual Device選擇設備定義，然後點擇 Next選擇你所需的 Android 版本的 OS image，然後點選 Next (建議選擇 x86 或 x86_64 image)在 Emulated Performance 欄位請選擇 Hardware - GLES 2.0 以啟用 hardware acceleration驗證 AVD 設定是否正確，若確定請點選 Finish在 Android Virtual Device Manager 中，選擇某台模擬器並點擊 Run有關上述步驟的詳情可參考 Managing AVDs設定編輯器設定 Android Studio安裝 Flutter 和 Dart plugins (外掛)，有兩個 plugin 支援 Flutter：Flutter 外掛：支持 Flutter 開發人員工作流程 (running, debugging, hot reload … 等)Dart 外掛：提供程式碼分析 (輸入時的程式碼驗證、程式碼自動補全)安裝步驟：執行 Android Studio開啟外掛選項 (File &gt; Settings &gt; Plugins)點選 Browse repositories…，接著搜尋 Flutter 並選擇並安裝名為 Flutter 的 plugin (請注意，安裝 Flutter 外掛時會同時安裝 Dart 語言外掛)點擊 Restart Android Studio設定 VS Code安裝 Flutter plugin：安裝 Flutter 此擴充功能，並重啟 VS Code。使用 Flutter Doctor 驗證你的設定環境：按 F1 或 ctrl + shift + p 後，輸入 Flutter 並點選 Flutter: Run Flutter Doctor 即可至 OUTPUT (輸出) 查看驗證結果。使用 Android Studio 開發建立新 app在 Android Studio 中建立 Flutter 專案 ( File &gt; New &gt; New Flutter Project… )接著選擇 Flutter Application，並點選 Next請設定專案名稱、確定 Flutter SDK 目錄、設定專案儲存位置與填寫專案的簡單描述後，點選 Next最後輸入公司網域 (e.g. example.com) 後，點選 Finish 即可建立新的 Flutter 專案執行 app下圖為 Android Studio 的工具列：圖片來源：Get Started: Test Drive | Flutter在 target selector 中，選擇已執行的 Android 裝置，若當前未啟動或未連接任何 Android 裝置，選擇某一模擬器時，Android Studio 就會開啟該選擇的模擬器。如果沒有可用的裝置，可至前面介紹的 設定 Android 模擬器 段落來新建模擬器。點擊 Run 圖示執行 app稍後就會在模擬器或裝置上看到下圖的 app 畫面等待的過程中會初始化 gradlegradle 會 resolve dependencies將專案轉成 apk將 apk 安裝並執行於裝置上1234567891011121314151617181920Launching lib\\main.dart on Android SDK built for x86 64 in debug mode...Initializing gradle...Resolving dependencies...Running 'gradlew assembleDebug'...Built build\\app\\outputs\\apk\\debug\\app-debug.apk.Installing build\\app\\outputs\\apk\\app.apk...D/OpenGLRenderer( 4777): HWUI GL PipelineI/OpenGLRenderer( 4777): Initialized EGL, version 1.4D/OpenGLRenderer( 4777): Swap behavior 1D/ ( 4777): HostConnection::get() New Host Connection established 0x7073cf2e5b00, tid 4831W/OpenGLRenderer( 4777): Failed to choose config with EGL_SWAP_BEHAVIOR_PRESERVED, retrying without...D/OpenGLRenderer( 4777): Swap behavior 0D/EGL_emulation( 4777): eglCreateContext: 0x7073cf2a7600: maj 2 min 0 rcv 2D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf2a7600: ver 2 0 (tinfo 0x7073b4be9300)D/EGL_emulation( 4777): eglCreateContext: 0x7073cf3b10a0: maj 2 min 0 rcv 2D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf3b10a0: ver 2 0 (tinfo 0x7073c2fe87c0)Syncing files to device Android SDK built for x86 64...D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf2a7600: ver 2 0 (tinfo 0x7073b4be9300)D/ ( 4777): HostConnection::get() New Host Connection established 0x7073cf2e65e0, tid 4813D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf3b10a0: ver 2 0 (tinfo 0x7073c560d6c0)嘗試 hot reload修改一些內容並儲存，app 就會自動做 hot reload，就會很快地看到最新的更新。使用 VS Code 開發建立新 app按 F1 或 ctrl + shift + p 後，輸入 Flutter 並點選 Flutter: New Project輸入專案名稱後，按 enter 鍵選擇專案目錄的儲存位置等待專案建立完成，並在畫面顯示 lib/main.dart 檔案執行 app從 VS Code 底部的藍色狀態欄中點選 Device Selector若要使用實體裝置，詳情至 設定你的 Android 裝置 參考。若連結成功會在 VS Code 底部的藍色狀態欄中看到你的裝置名稱如果沒有可用的裝置，請點選 No Devices 並啟動模擬器執行 Debug等待 App 執行，可在偵錯主控台 (Debug Console) 看到執行進度，稍後就會在模擬器或裝置上看到下圖的 app 畫面使用 Terminal + Editor 開發建立新 app使用 flutter create 指令來建立 Flutter 專案，裡面包含 Material Components 的範例 app。app 的程式碼在 lib/main.dart。12$ flutter create &lt;prject-name&gt;$ cd &lt;prject-name&gt;執行 app使用 flutter devices 指令可檢查是否有正在執行的模擬器或裝置。如果沒有可用的裝置，可至前面介紹的 設定 Android 模擬器 段落來新建模擬器。1234$ flutter devices1 connected device:Android SDK built for x86 64 • emulator-5554 • android-x64 • Android 8.0.0 (API 26) (emulator)使用 flutter run 指令可執行 app，並提供以下功能的快速鍵：r：hot reloadR：hot restart (and rebuild state)h：顯示更多幫助訊息q：停止執行123456789101112131415$ flutter runUsing hardware rendering with device Android SDK built for x86 64. If you get graphics artifacts, consider enabling software rendering with \"--enable-software-rendering\".Launching lib/main.dart on Android SDK built for x86 64 in debug mode...Initializing gradle... 1.7sResolving dependencies... 48.1sRunning 'gradlew assembleDebug'... 88.5sBuilt build\\app\\outputs\\apk\\debug\\app-debug.apk.Installing build\\app\\outputs\\apk\\app.apk... 11.4sSyncing files to device Android SDK built for x86 64...D/ ( 5458): HostConnection::get() New Host Connection established 0x7073c31aabe0, tid 5513D/EGL_emulation( 5458): eglMakeCurrent: 0x7073cf3b1280: ver 2 0 (tinfo 0x7073c2ab65c0) 12.3s🔥 To hot reload changes while running, press \"r\". To hot restart (and rebuild state), press \"R\".An Observatory debugger and profiler on Android SDK built for x86 64 is available at: http://127.0.0.1:2158/For a more detailed help message, press \"h\". To quit, press \"q\".","categories":[{"name":"Windows","slug":"windows","permalink":"https://titangene.github.io/categories/windows/"},{"name":"Flutter","slug":"windows/flutter","permalink":"https://titangene.github.io/categories/windows/flutter/"},{"name":"Android","slug":"windows/flutter/android","permalink":"https://titangene.github.io/categories/windows/flutter/android/"},{"name":"Mobile App","slug":"windows/flutter/android/mobile-app","permalink":"https://titangene.github.io/categories/windows/flutter/android/mobile-app/"}],"tags":[{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"},{"name":"VS Code","slug":"vs-code","permalink":"https://titangene.github.io/tags/vs-code/"},{"name":"Android Studio","slug":"android-studio","permalink":"https://titangene.github.io/tags/android-studio/"}],"author":"Titangene"},{"title":"Hexo 加入 Disqus 留言版 (包含留言數)","slug":"hexo-disqus","date":"2018-10-22T14:40:00.000Z","updated":"2019-05-12T07:25:56.000Z","comments":true,"path":"article/hexo-disqus.html","link":"","permalink":"https://titangene.github.io/article/hexo-disqus.html","excerpt":"Blog 最重要的是可以增進技術的交流，而交流就可以透過留言版來達成。大部分的 Blog 在每篇文章下面都會有留言板，而最常見的就是 Disqus 留言板，因此本篇會說明如何將 Disqus 留言板和各文章的留言數加入 Hexo 的主題中。","text":"Blog 最重要的是可以增進技術的交流，而交流就可以透過留言版來達成。大部分的 Blog 在每篇文章下面都會有留言板，而最常見的就是 Disqus 留言板，因此本篇會說明如何將 Disqus 留言板和各文章的留言數加入 Hexo 的主題中。申請網站留言版帳號至 Disqus 首頁註冊帳號後並登入，接著點擊首頁的「GET STARTED」：選擇「I want to install Disqus on my site」選項：需要輸入的欄位：Websit Name：自訂 short name，且是唯一，像我是設定 titangene-blog。short name 會在設定 Hexo 時需要Category：類別，自行選擇Language：語言，自行選擇填寫後點擊「Create Site」：設定 Hexo在 material-flow 主題內的 _config.yml 原有設定是使用 disqus_shortname 參數來設定 Disqus 的 short name：1disqus_shortname: your_disqus_short_name但我想在 blog 加上留言數，所以才將參數設定改成下面內容：enable：設定 true 或 false 來決定是否要啟用 Disqus 的留言版功能shortname：設定你的 Disqus 的 short namecount：設定 true 或 false 來決定是否要顯示文章的留言數12345# Commentsdisqus: enable: true shortname: your_disqus_short_name count: true那接著就是將 Disqus 的留言版功能加入主題中，主要分成幾個步驟：加入 Disqus script新增 Disqus 留言版新增 Disqus 留言數如果在剛剛上面的 count 參數設定為 false 則可以跳過第三個步驟 新增 Disqus 留言數。下面提供的程式碼可適用於 Hexo 的 material-flow 主題，HTML 結構可依各自使用的版型或需求來修改。若想直接看我設定的原始碼，可至此 Blog 的 GitHub Repo「titangene/hexo-blog」查看。加入 Disqus script在 themes\\material-flow\\layout\\_partial\\script\\disqus.ejs 檔案內加入以下程式碼，當頁面載入時，會以非同步的方式將 Disqus 的 script 加入 &lt;head&gt; 或 &lt;body&gt; 標籤中：1234567891011121314151617181920212223&lt;% if (config.disqus.enable) &#123; %&gt; &lt;% if (page.comments) &#123; %&gt;&lt;script&gt; var disqus_shortname = '&lt;%= config.disqus.shortname %&gt;'; var disqus_config = function() &#123; this.page.url = '&lt;%= page.permalink %&gt;'; this.page.identifier = '&lt;%= page.path %&gt;'; this.page.title = '&lt;%= page.title %&gt;'; &#125;; (function() &#123; var dsq = document.createElement('script'); dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; dsq.setAttribute('data-timestamp', '' + new Date()); (document.head || document.body).appendChild(dsq); &#125;)();&lt;/script&gt;&lt;% &#125; %&gt; &lt;% if (config.disqus.count) &#123; %&gt;&lt;script id=\"dsq-count-scr\" src=\"https://&lt;%= config.disqus.shortname %&gt;.disqus.com/count.js\" async&gt;&lt;/script&gt;&lt;% &#125; %&gt; &lt;% &#125; %&gt;接著在 themes\\material-flow\\layout\\layout.ejs 檔案內的 &lt;body&gt; 標籤中將剛剛新增的 disqus.ejs 載入：1&lt;%- partial('script/disqus') %&gt;新增 Disqus 留言版在 themes\\material-flow\\layout\\_partial\\article.ejs 檔案內找到適當的位置加入以下程式碼，就可以在文章內新增 Disqus 留言版：1234567891011&lt;% if (post.comments &amp;&amp; config.disqus.enable) &#123; %&gt;&lt;section class=\"comments\" id=\"comments\"&gt; &lt;h2&gt;留言版&lt;/h2&gt; &lt;div id=\"disqus_thread\"&gt; &lt;noscript &gt;Please enable JavaScript to view the &lt;a href=\"https://disqus.com/?ref_noscript\"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript &gt; &lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt;上面程式碼中最重要的是 &lt;div id=&quot;disqus_thread&quot;&gt; 這句，因為當頁面載入並將 Disqus 的 script 載入後，就會將此標籤內的內容取代成 Disqus 留言版，而 Disqus 留言版是使用 &lt;iframe&gt; 標籤的方式嵌入在頁面中：新增 Disqus 留言數在 themes\\material-flow\\layout\\_partial\\article.ejs 檔案內找到適當的位置加入以下程式碼，就可以在文章內新增 Disqus 留言數：1234567891011121314&lt;% if (post.comments &amp;&amp; config.disqus.enable &amp;&amp; config.disqus.count) &#123; %&gt;&lt;span class=\"comments-count\"&gt; &lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fas fa-comment\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;a href=\"&lt;%- post.permalink %&gt;#disqus_thread\" class=\"article-comment-count\" data-disqus-identifier=\"&lt;%= post.path %&gt;\" itemprop=\"discussionUrl\" &gt; &lt;/a&gt;&lt;/span&gt;&lt;% &#125; %&gt;也可以在 themes\\material-flow\\layout\\_partial\\post.ejs 檔案內新增 Disqus 留言數，這樣就可以在首頁看到各文章的留言數。上面程式碼中最重要的是 &lt;a href=&quot;&lt;%- post.permalink %&gt;#disqus_thread&quot;...&gt; 這句，因為在連結的最後加上 #disqus_thread，就代表要告訴 Disqus 要找哪個連結的留言數，並將留言數設為連結名稱 (例如：1 留言)。而 data-disqus-identifier 屬性需設為此頁面的識別名稱：可參考 Disqus 的 JavaScript configuration variables | Disqus 文件。若要設定顯示在頁面上的留言數文字，可至 Disqus 的「Setting &gt; Community &gt; Comment Count Link」內設定，可分別設定三種情況：0 則留言1 則留言多則留言：{num} 是作為留言數的變數Demo設定後就可以看到每篇文章下面都可以留言囉！可在每篇文章看到留言數：參考來源Install instructions for Universal Code | DisqusAdding comment count links to your home page | Disqus","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://titangene.github.io/tags/hexo/"},{"name":"Comment","slug":"comment","permalink":"https://titangene.github.io/tags/comment/"}],"author":"Titangene"}],"categories":[{"name":"Tools","slug":"tools","permalink":"https://titangene.github.io/categories/tools/"},{"name":"Testing","slug":"testing","permalink":"https://titangene.github.io/categories/testing/"},{"name":"Web Dev","slug":"web-dev","permalink":"https://titangene.github.io/categories/web-dev/"},{"name":"Git","slug":"git","permalink":"https://titangene.github.io/categories/git/"},{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"},{"name":"HTML","slug":"css/html","permalink":"https://titangene.github.io/categories/css/html/"},{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"},{"name":"CSS","slug":"blog/css","permalink":"https://titangene.github.io/categories/blog/css/"},{"name":"DevOps","slug":"devops","permalink":"https://titangene.github.io/categories/devops/"},{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"},{"name":"Windows Server","slug":"windows-server","permalink":"https://titangene.github.io/categories/windows-server/"},{"name":"Cloud","slug":"windows-server/cloud","permalink":"https://titangene.github.io/categories/windows-server/cloud/"},{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"},{"name":"Crawler","slug":"python/crawler","permalink":"https://titangene.github.io/categories/python/crawler/"},{"name":"SQL Server","slug":"sql-server","permalink":"https://titangene.github.io/categories/sql-server/"},{"name":"Linux","slug":"sql-server/linux","permalink":"https://titangene.github.io/categories/sql-server/linux/"},{"name":"Database","slug":"sql-server/linux/database","permalink":"https://titangene.github.io/categories/sql-server/linux/database/"},{"name":"DevOps","slug":"sql-server/linux/database/devops","permalink":"https://titangene.github.io/categories/sql-server/linux/database/devops/"},{"name":"Flutter","slug":"flutter","permalink":"https://titangene.github.io/categories/flutter/"},{"name":"Mobile App","slug":"flutter/mobile-app","permalink":"https://titangene.github.io/categories/flutter/mobile-app/"},{"name":"Windows","slug":"windows","permalink":"https://titangene.github.io/categories/windows/"},{"name":"Python","slug":"windows/python","permalink":"https://titangene.github.io/categories/windows/python/"},{"name":"Crawler","slug":"windows/python/crawler","permalink":"https://titangene.github.io/categories/windows/python/crawler/"},{"name":"OS","slug":"windows/python/crawler/os","permalink":"https://titangene.github.io/categories/windows/python/crawler/os/"},{"name":"Linux","slug":"linux","permalink":"https://titangene.github.io/categories/linux/"},{"name":"Windows","slug":"linux/windows","permalink":"https://titangene.github.io/categories/linux/windows/"},{"name":"Other","slug":"other","permalink":"https://titangene.github.io/categories/other/"},{"name":"Flutter","slug":"windows/flutter","permalink":"https://titangene.github.io/categories/windows/flutter/"},{"name":"Android","slug":"windows/flutter/android","permalink":"https://titangene.github.io/categories/windows/flutter/android/"},{"name":"Mobile App","slug":"windows/flutter/android/mobile-app","permalink":"https://titangene.github.io/categories/windows/flutter/android/mobile-app/"}],"tags":[{"name":"w3HexSchool","slug":"w3hexschool","permalink":"https://titangene.github.io/tags/w3hexschool/"},{"name":"Chrome","slug":"chrome","permalink":"https://titangene.github.io/tags/chrome/"},{"name":"Chrome Extension","slug":"chrome-extension","permalink":"https://titangene.github.io/tags/chrome-extension/"},{"name":"Markdown","slug":"markdown","permalink":"https://titangene.github.io/tags/markdown/"},{"name":"Theme","slug":"theme","permalink":"https://titangene.github.io/tags/theme/"},{"name":"Jest","slug":"jest","permalink":"https://titangene.github.io/tags/jest/"},{"name":"JavaScript","slug":"javascript","permalink":"https://titangene.github.io/tags/javascript/"},{"name":"Unit Testing","slug":"unit-testing","permalink":"https://titangene.github.io/tags/unit-testing/"},{"name":"mock","slug":"mock","permalink":"https://titangene.github.io/tags/mock/"},{"name":"DOM","slug":"dom","permalink":"https://titangene.github.io/tags/dom/"},{"name":"jQuery","slug":"jquery","permalink":"https://titangene.github.io/tags/jquery/"},{"name":"timer","slug":"timer","permalink":"https://titangene.github.io/tags/timer/"},{"name":"snapshot","slug":"snapshot","permalink":"https://titangene.github.io/tags/snapshot/"},{"name":"async","slug":"async","permalink":"https://titangene.github.io/tags/async/"},{"name":"promise","slug":"promise","permalink":"https://titangene.github.io/tags/promise/"},{"name":"callback","slug":"callback","permalink":"https://titangene.github.io/tags/callback/"},{"name":"Node.js","slug":"node-js","permalink":"https://titangene.github.io/tags/node-js/"},{"name":"TypeScript","slug":"typescript","permalink":"https://titangene.github.io/tags/typescript/"},{"name":"Babel","slug":"babel","permalink":"https://titangene.github.io/tags/babel/"},{"name":"Sass","slug":"sass","permalink":"https://titangene.github.io/tags/sass/"},{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/tags/css/"},{"name":"Dart Sass","slug":"dart-sass","permalink":"https://titangene.github.io/tags/dart-sass/"},{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"},{"name":"CLI","slug":"cli","permalink":"https://titangene.github.io/tags/cli/"},{"name":"version manager","slug":"version-manager","permalink":"https://titangene.github.io/tags/version-manager/"},{"name":"npm","slug":"npm","permalink":"https://titangene.github.io/tags/npm/"},{"name":"Yarn","slug":"yarn","permalink":"https://titangene.github.io/tags/yarn/"},{"name":"深入 Git","slug":"深入-git","permalink":"https://titangene.github.io/tags/%E6%B7%B1%E5%85%A5-git/"},{"name":"GitHub","slug":"github","permalink":"https://titangene.github.io/tags/github/"},{"name":"GitLab","slug":"gitlab","permalink":"https://titangene.github.io/tags/gitlab/"},{"name":"Branch","slug":"branch","permalink":"https://titangene.github.io/tags/branch/"},{"name":"Remote","slug":"remote","permalink":"https://titangene.github.io/tags/remote/"},{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Dark Theme","slug":"dark-theme","permalink":"https://titangene.github.io/tags/dark-theme/"},{"name":"Docker","slug":"docker","permalink":"https://titangene.github.io/tags/docker/"},{"name":"Container","slug":"container","permalink":"https://titangene.github.io/tags/container/"},{"name":"Docker Compose","slug":"docker-compose","permalink":"https://titangene.github.io/tags/docker-compose/"},{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"HTTP","slug":"http","permalink":"https://titangene.github.io/tags/http/"},{"name":"Load Balancer","slug":"load-balancer","permalink":"https://titangene.github.io/tags/load-balancer/"},{"name":"Kubernetes","slug":"kubernetes","permalink":"https://titangene.github.io/tags/kubernetes/"},{"name":"VM","slug":"vm","permalink":"https://titangene.github.io/tags/vm/"},{"name":"NIGNX","slug":"nignx","permalink":"https://titangene.github.io/tags/nignx/"},{"name":"Web Server","slug":"web-server","permalink":"https://titangene.github.io/tags/web-server/"},{"name":"Python Requests","slug":"python-requests","permalink":"https://titangene.github.io/tags/python-requests/"},{"name":"Hexo","slug":"hexo","permalink":"https://titangene.github.io/tags/hexo/"},{"name":"Code Snippet","slug":"code-snippet","permalink":"https://titangene.github.io/tags/code-snippet/"},{"name":"Clipboard","slug":"clipboard","permalink":"https://titangene.github.io/tags/clipboard/"},{"name":"Logging","slug":"logging","permalink":"https://titangene.github.io/tags/logging/"},{"name":"Windows 工作排程","slug":"windows-工作排程","permalink":"https://titangene.github.io/tags/windows-%E5%B7%A5%E4%BD%9C%E6%8E%92%E7%A8%8B/"},{"name":"Anaconda","slug":"anaconda","permalink":"https://titangene.github.io/tags/anaconda/"},{"name":"Conda","slug":"conda","permalink":"https://titangene.github.io/tags/conda/"},{"name":"Virtual Environment","slug":"virtual-environment","permalink":"https://titangene.github.io/tags/virtual-environment/"},{"name":"Package Management","slug":"package-management","permalink":"https://titangene.github.io/tags/package-management/"},{"name":"Ubuntu","slug":"ubuntu","permalink":"https://titangene.github.io/tags/ubuntu/"},{"name":"WSL","slug":"wsl","permalink":"https://titangene.github.io/tags/wsl/"},{"name":"Github","slug":"github","permalink":"https://titangene.github.io/tags/github/"},{"name":"URL","slug":"url","permalink":"https://titangene.github.io/tags/url/"},{"name":"URL Shortener","slug":"url-shortener","permalink":"https://titangene.github.io/tags/url-shortener/"},{"name":"Font","slug":"font","permalink":"https://titangene.github.io/tags/font/"},{"name":"VS Code","slug":"vs-code","permalink":"https://titangene.github.io/tags/vs-code/"},{"name":"Android Studio","slug":"android-studio","permalink":"https://titangene.github.io/tags/android-studio/"},{"name":"Comment","slug":"comment","permalink":"https://titangene.github.io/tags/comment/"}]}