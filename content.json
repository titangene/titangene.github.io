{"meta":{"title":"Titangene Blog","subtitle":null,"description":"利用 blog 紀錄學習歷程","author":"Titangene","url":"https://titangene.github.io"},"pages":[{"title":"Categories","date":"2018-10-22T14:40:00.000Z","updated":"2018-10-22T18:20:46.635Z","comments":false,"path":"categories/index.html","permalink":"https://titangene.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2018-10-22T14:40:00.000Z","updated":"2018-10-22T18:21:46.626Z","comments":false,"path":"error/index.html","permalink":"https://titangene.github.io/error/index.html","excerpt":"","text":"This page does not exist, click here to go back to home page.頁面不存在，點此回到首頁。"},{"title":"Tags","date":"2018-10-22T14:40:00.000Z","updated":"2018-10-22T18:22:54.477Z","comments":false,"path":"tags/index.html","permalink":"https://titangene.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"重新認識 CSS - CSS Selector (4)","slug":"css-selector-4","date":"2019-09-20T08:20:52.000Z","updated":"2019-09-21T00:27:26.967Z","comments":true,"path":"article/css-selector-4.html","link":"","permalink":"https://titangene.github.io/article/css-selector-4.html","excerpt":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 structural pseudo-class (偽類)，包括 :root、nth-child、nth-of-type …等 selector。","text":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 structural pseudo-class (偽類)，包括 :root、nth-child、nth-of-type …等 selector。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - CSS Selector (4)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogStructural pseudo-classes當使用 structural pseudo-class 時，它會計算各 sibling 元素的位置：不計算 standalone (獨立) text 和其他非元素節點index 編號從 1 開始只適用於 document tree 中的元素，不會 match 到 pseudo-element:root pseudo-class:root pseudo-class 代表文件的 root 元素在 DOM 文件中，:root pseudo-class 與 Document 物件的 root 元素會 match在 HTML 中，root 元素就是 &lt;html&gt; 元素Child-indexed Pseudo-classes此 pseudo-class 會根據 inclusive sibling 之間的 index 來選擇元素。選擇 index 為多少的 sibling (兄弟，同層) 元素，元素的第一個子元素的 index 是 1。只有開頭為 nth 的 Child-indexed Pseudo-classes 和 Typed Child-indexed Pseudo-classes 都可以在 () 括號裡面可以使用下面這幾種值：an + b：n 可以是任何​​正整數或 0 的數值a 和 b 的值必須是整數 (正數、負數或 0)當 a 和 b 都大於 0 時，可以更好的將 sibling 元素劃分為元素群組 (groups of a elements)，並選擇每個群組的第 b 個元素， 例如：3n + 1 可以 match 到第 1、4、7…等子元素0n + 5 等同於 5當 a 為負值，且 n &gt;= 0 時，只有 an + b 為正值才可以代表 document tree 中的元素odd：奇數的所有 sibling 元素，等同於 2n + 1even偶數的所有 sibling 元素，等同於 2n語法詳情可參閱 Selectors Level 3 的「6.6.5.2. :nth-child() pseudo-class」章節部份。Child-indexed Pseudo-classes 有下面這些 selector：:nth-child(an+b)：選擇指定 index 的所有 sibling 元素，從第一個 sibling 元素開始數:nth-last-child(an+b)：選擇指定 index 的所有 sibling 元素，從最後一個 sibling 元素開始數:first-child()：選擇 sibling 列表中的第一個元素等同於 :nth-child(1):last-child()：選擇 sibling 列表中的最後一個元素等同於 :nth-last-child(1):only-child()：選擇沒有 sibling 的元素等同於 :first-child:last-child 或 :nth-child(1):nth-last-child(1)，但 specificity 較低Typed Child-indexed Pseudo-classes此 pseudo-class 類似於 Child Index Pseudo-classes，但此 pseudo-class 是基於 sibling 列表中相同 type (tag 名稱) 的元素之間的元素 index 來解析。Typed Child-indexed Pseudo-classes 有下面這些 selector：:nth-of-type(an+b)：選擇指定 index 的所有相同 type 的 sibling 元素，從第一個 sibling 元素開始數:nth-last-of-type(an+b)選擇指定 index 的所有相同 type 的 sibling 元素，從最後一個 sibling 元素開始數:first-of-type()選擇 sibling 列表中的第一個相同 type 的元素等同於 :nth-of-type(1):last-of-type()選擇 sibling 列表中的最後一個相同 type 的元素等同於 :nth-last-of-type(1):only-of-type()選擇沒有相同 type 的 sibling 元素等同於 :first-of-type:last-of-type 或 :nth-of-type(1):nth-last-of-type(1)，但 specificity 較低:nth-of-type() 與 :nth-child() 的差異下面是 :nth-of-type() 和 :nth-child() 的範例：123456789101112131415161718192021222324&lt;ul&gt; &lt;li&gt;1 (1 li)&lt;/li&gt; &lt;li&gt;2 (2 li)&lt;/li&gt; &lt;div&gt;3 (div)&lt;/div&gt; &lt;li&gt;4 (3 li) &lt;ul class=\"nested-list\"&gt; &lt;li&gt;4-1&lt;/li&gt; &lt;li&gt;4-2&lt;/li&gt; &lt;li&gt;4-3&lt;/li&gt; &lt;li&gt;4-4&lt;/li&gt; &lt;li&gt;4-5&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;5 (4 li)&lt;/li&gt; &lt;li&gt;6 (5 li)&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;1 (1 li)&lt;/li&gt; &lt;li&gt;2 (2 li)&lt;/li&gt; &lt;div&gt;3 (div)&lt;/div&gt; &lt;li&gt;4 (3 li)&lt;/li&gt; &lt;li&gt;5 (4 li)&lt;/li&gt; &lt;li&gt;6 (5 li)&lt;/li&gt;&lt;/ul&gt;12345678910div &#123; color: olive; &#125;li:nth-of-type(odd) &#123; margin: 2px; outline: 2px solid red;&#125;li:nth-child(odd) &#123; border: 2px solid blue;&#125;這個範例有兩個 ul 元素，裡面各有五個 li 元素，而且在與第二個 li 元素同層的後面加上一個 div 元素，這是用來驗證 :nth-of-type() 和 :nth-child() 的差異用的。另外，在第一個 ul 元素裡面還有一個巢狀 &lt;ul class=&quot;nested-list&quot;&gt; 元素，它放在第四個 li 元素裡面，這是用來巢狀的元素也可以被 selector 選到。每個元素的前面都有一個編號，代表在 sibling 元素之間的 index。而後面的括號是用來告訴你它是 li 元素還是 div 元素，如果是 li 元素就會註記是第幾個 li 元素。例如：4 (3 li) 就代表是第四個 sibling 元素，並且是第三個 li 元素。可以看到那些有紅色 outline 的元素都有 match 到 li:nth-of-type(odd)，因為此 pseudo-class 是以 of-type 為結尾，所以此 selector 只會找相同 type 的 sibling 元素 (OS：就很像是忽略了 div 元素的存在)。只要是奇數的 sibling 元素都會被選起來，套用紅色的 outline 樣式。而那些有藍色 border 的元素都有 match 到 li:nth-child(odd)，因為此 pseudo-class 是以 child 為結尾，所以此 selector 會直接找是 li 的 sibling 元素，並且要是奇數的 sibling 元素。不過，第三個 sibling 元素是 div 元素，不是 li 元素，因此 li:nth-child(odd) 就不會 match 到此 div 元素而巢狀 &lt;ul class=&quot;nested-list&quot;&gt; 元素裡面只有五個 li 元素，沒有其他 type 的元素，所以都會選到奇數的 sibling 元素 (因為沒有亂路的元素)。See the Pen :nth-child &amp; :nth-of-type by Titangene (@titangene) on CodePen.The negation pseudo-class:not(X) 是一個函數符號，可將一個 simple selector (不包括 :not(X) 本身) 作為參數。:not(X) 代表不選擇 match 到 X simple selector 的元素。註：以下這些都是 simple selector：type selector：例如 divuniversal selector：例如 *attribute selector：例如 div[foo]class selector：例如 .myclassID selector：例如 #myidpseudo-class：例如 a:hover不能巢狀使用，所以 :not(:not(...)) 是無效的。另外請注意，因為 pseudo-element 不是 simple selector，所以 pseudo-element 不是 :not() 的有效參數。例如：match HTML 文件中所有未被禁用的 button 元素：1button:not([disable])註：[disable] 是 attribute selector，詳情請參閱我前幾天寫的「重新認識 CSS - CSS Selector (2)」。match 除了 #titan 元素之外的所有元素：1*:not(#titan)註：#titan 是 ID selector，詳情請參閱我前幾天寫的「重新認識 CSS - CSS Selector (1)」。最後今天介紹一些 structural pseudo-class，接下來幾天會接續介紹其他 selector。資料來源：CSS 2.2 Specification - SelectorsSelectors Level 3Selectors Level 4","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-鐵人賽/"}]},{"title":"重新認識 CSS - CSS Selector (3)","slug":"css-selector-3","date":"2019-09-19T08:20:52.000Z","updated":"2019-09-19T13:42:52.353Z","comments":true,"path":"article/css-selector-3.html","link":"","permalink":"https://titangene.github.io/article/css-selector-3.html","excerpt":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 pseudo-class (偽類)。","text":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 pseudo-class (偽類)。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - CSS Selector (3)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogPseudo-classespseudo-class 是以 : 為開頭，後面接著 pseudo-class 的名稱，有些會在後面加上括號 ()，並在括號之間加上值。例如：:nth-child(2)。注意：pseudo-class 和 pseudo-element 不相同pseudo-class 是以 : 為開頭pseudo-element 是以 :: 為開頭，但也可以以 : 為開頭，因為在舊版的 W3C Spec 中沒有將 pseudo-class 和 pseudo-element 區分成 : 和 ::。如果你寫 pseudo-element 是用 :，大部份瀏覽器也還是會支援這種語法。Dynamic pseudo-classesDynamic pseudo-classes 不會出現在 document source 或 document tree 中。Dynamic pseudo-classes 又分為：link pseudo-classes：:link 和 :visiteduser action pseudo-classes：:hover、:active 和 :focusThe link pseudo-classes：:link 和 :visitedUA (User agent，對 HTML 來說就是瀏覽器) 以不同的方式來顯示連結是否已訪問：:link：未訪問過的連結:visited：已訪問過的連結不過，過了一段時間之後，UA 可以將已訪問的連結從 :visited 變回 :link 的狀態。12&lt;h3&gt;&lt;a href=\"https://titangene.github.io\"&gt;Titangene Blog&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=\"https://titangene.github.io/article/css-selector-3.html\"&gt;重新認識 CSS - CSS Selector (3)&lt;/a&gt;&lt;/h3&gt;12a:visited &#123; color: red; &#125;a:link &#123; color: green; &#125;Demo：Codepen 連結See the Pen link pseudo-class: :visited &amp; :link by Titangene (@titangene) on CodePen.The user action pseudo-classes：:hover、:active 和 :focus用於 response 使用者的操作：:hover：當 cursor (滑鼠指標) hover 在元素上時，visual UA 就可以應用此 pseudo-class不支援 互動式 media 的 UA 不用支援此 pseudo-class:active：在使用者按下滑鼠按鈕並放開它之間的時間會應用此 pseudo-class如果滑鼠上有多個按鈕時，:active 只適用於主要或主要 actived 的按鈕 (通常為滑鼠左鍵) …等:focus：當元素有焦點時會應用此 pseudo-class，例如：按鍵盤的 Tab 鍵所選到的元素12&lt;h3&gt;&lt;a href=\"https://titangene.github.io\"&gt;Titangene Blog&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=\"https://titangene.github.io/article/css-selector-3.html\"&gt;重新認識 CSS - CSS Selector (3)&lt;/a&gt;&lt;/h3&gt;1234a &#123; color: black; &#125;a:hover &#123; color: red; &#125;a:focus &#123; color: gray; &#125;a:active &#123; color: purple; &#125;Demo：Codepen 連結See the Pen user action pseudo-class by Titangene (@titangene) on CodePen.也可以一次使用多個 dynamic pseudo-class，如下範例：同時有 :focus 和 :hover 的狀態同時有 :link 和 :active 的狀態12a:focus:hover &#123; color: teal; &#125;a:link:active &#123; color: fuchsia; &#125;The target pseudo-classes：:target有些 URI 的最後會以 # (number sign) 為結尾，後面會接著 anchor identifier (也稱為 fragment identifier)，代表該 URI 是指向資源中的某個位置。通常帶有 fragment identifier 的 URL 會 link 到文件中的某些元素，該元素被稱為 target 元素。例如：在下面的 HTML 文件中有名為 hello 的 anchor (錨點) (也就是 &lt;a href=&quot;#hello&quot;&gt;Hello&lt;/a&gt; 這個連結)：1234&lt;h1&gt;&lt;a href=\"#hello\"&gt;Hello&lt;/a&gt;&lt;/h1&gt;&lt;div id=\"hello\"&gt; &lt;h2&gt;Target&lt;/h2&gt;&lt;/div&gt;1#hello:target &#123; color: red; &#125;Demo：Codepen 連結如果此 HTML 的 URL 為：1https://s.codepen.io/titangene/debug/jONegME/vWkRwRNmBvOM在還沒點擊 #hello 錨點時，畫面如下：只要點擊 #hello 錨點後，下面的 “Target” 文字就會變成紅色 (也就是會應用 #hello:target 的樣式)，畫面如下：並且 URL 的最後會加上 #hello，而 #hello 就是 fragment identifier。剛剛點擊的錨點會 link 到 target 元素，而 target 元素就是 &lt;div id=&quot;hello&quot;&gt;，所以 selector 才會 match 到 #hello:target。See the Pen target pseudo-classes :target by Titangene (@titangene) on CodePen.在 MDN 有一個範例也蠻有趣的，可以用 :target pseudo-class 來實作 lightbox：運作原理是用 display: none 和 display: block 來控制 lightbox 是否開啟，觸發的機制就是用剛剛介紹的 :target pseudo-class 來做的。這個範例很有趣，以前用 JavaScript 才能做到的事情，沒想到也能用純 CSS 來實作出來。UI element states pseudo-classes分為：:enabled：處於啟用狀態的 UI 元素:disabled：處於禁用狀態的 UI 元素:checked：選取 radio 或勾選 checkbox 元素時會應用:enabled &amp; :disabled pseudo-class直接看範例：123456789101112131415&lt;form&gt; &lt;label for=\"enabledField\"&gt;enabled field:&lt;/label&gt; &lt;input type=\"text\" id=\"enabledField\" value=\"Lorem\"&gt; &lt;br&gt;&lt;br&gt; &lt;label for=\"disabledField\"&gt;disabled field:&lt;/label&gt; &lt;input type=\"text\" id=\"disabledField\" value=\"Lorem\" disabled&gt; &lt;br&gt;&lt;br&gt; &lt;label for=\"enabledCheckbox\"&gt;enabled checkbox:&lt;/label&gt; &lt;input type=\"checkbox\" id=\"enabledCheckbox\"&gt; &lt;br&gt;&lt;br&gt; &lt;label for=\"disabledCheckbox\"&gt;disabled checkbox:&lt;/label&gt; &lt;input type=\"checkbox\" id=\"disabledCheckbox\" disabled&gt; &lt;br&gt;&lt;br&gt; &lt;input type=\"button\" value=\"Submit\"&gt;&lt;/form&gt;12input:enabled &#123; outline: 3px solid red; &#125;input:disabled &#123; outline: 3px solid blue; &#125;Demo：Codepen 連結只要被加上 disabled 屬性的 input 元素都代表該元素處於禁用狀態，所以這些元素就會套用 input:disabled 此 selector 的樣式。其餘的元素則會套用 input:enabled 此 selector 的樣式。不過要注意的事元素有無啟用，跟一些會影響使用者互動 UI 元素的 CSS 屬性沒關係，這些都不會影響 selector 是否 match 到 :enabled 或 :disabled。例如：display 和 visibility 屬性都會讓元素在畫面上消失，但是都不會影響到啟用或禁用的狀態。display: none 不會讓元素出現在 formatting structure 中，很像不在畫面上，會完全消失visibility: hidden 生成的 box 是看不見的，完全透明，不會 draw 任何內容，但會影響佈局，也就是會在畫面上佔用空間，但會看不到元素的樣子See the Pen :enabled and :disabled pseudo-classes by Titangene (@titangene) on CodePen.:checked pseudo-class直接看範例：123456789&lt;input type=\"checkbox\" id=\"firstCheckbox\" checked&gt;&lt;label for=\"firstCheckbox\"&gt;First checkbox&lt;/label&gt;&lt;input type=\"checkbox\" id=\"secondCheckbox\"&gt;&lt;label for=\"secondCheckbox\"&gt;Second checkbox&lt;/label&gt;&lt;br&gt;&lt;input type=\"radio\" id=\"firstRadio\" checked&gt;&lt;label for=\"firstRadio\"&gt;First radio&lt;/label&gt;&lt;input type=\"radio\" id=\"secondRadio\"&gt;&lt;label for=\"secondRadio\"&gt;Second radio&lt;/label&gt;12input + label &#123; color: red; &#125;input:checked + label &#123; color: blue; &#125;Demo：Codepen 連結See the Pen :checked pseudo-class by Titangene (@titangene) on CodePen.最後今天介紹一些 pseudo-class，接下來幾天會接續介紹其他 selector。資料來源：CSS 2.2 Specification - SelectorsSelectors Level 3Selectors Level 4:target - CSS | MDNAbout MDN by Mozilla Contributors is licensed under CC-BY-SA 2.5","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-鐵人賽/"}]},{"title":"重新認識 CSS - CSS Selector (2)","slug":"css-selector-2","date":"2019-09-18T08:20:52.000Z","updated":"2019-09-18T09:02:52.683Z","comments":true,"path":"article/css-selector-2.html","link":"","permalink":"https://titangene.github.io/article/css-selector-2.html","excerpt":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 attribute selector (屬性選擇器)。","text":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。本篇會介紹 attribute selector (屬性選擇器)。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - CSS Selector (2)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogAttribute selectorSelector 允許表示元素的屬性。當 selector 作為 expression (表達式) 來 match 元素時，如果該元素具有與 attribute selector (屬性選擇器) 表示的屬性 match 的屬性，則必須將 attribute selector 視為與元素 match。Attribute presence and value selectorCSS2 引入了四個 attribute selector：[att]：代表具有 att 屬性的元素，無論屬性的值為何[att=val]：代表具有 att 屬性的元素，且該屬性值為 val[att~=val]：代表具有 att 屬性的元素，該屬性的值是以空格分隔的單詞列表，其中一個正好是 val如果 val 包含空格，就不代表任何內容 (因為單字之間是用空格來分隔)如果 val 是空字串，就不代表任何內容[att|=val]：代表具有 att 屬性的元素，且該屬性值為 val 或以 val 為開頭，後面接著 - (也就是以 val- 為開頭)直接看範例：1234567891011121314151617181920&lt;h1&gt;Titan&lt;/h1&gt;&lt;h1 title=\"hello\"&gt;Hello&lt;/h1&gt;&lt;h1 title=\"titan\"&gt;Titan&lt;/h1&gt;&lt;h2 title=\"hello\"&gt;Hello&lt;/h2&gt;&lt;h2 title=\"titan\"&gt;Titan&lt;/h2&gt;&lt;h1 class=\"highlight\"&gt;highlight Titan&lt;/h1&gt;&lt;h1 title=\"titan\" class=\"highlight\"&gt;highlight Titan&lt;/h1&gt;&lt;h1 class=\"text text-primary text-bold\"&gt;Text&lt;/h1&gt;&lt;h1 class=\"text-primary text\"&gt;Text&lt;/h1&gt;&lt;h2 class=\"text\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"textPrimary\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"text-primary\"&gt;Text&lt;/h2&gt;&lt;h1 class=\"alert\"&gt;Text&lt;/h1&gt;&lt;h1 class=\"alert-primary\"&gt;Text&lt;/h1&gt;123456h1[title] &#123; color: red; &#125;h2[title=\"titan\"] &#123; color: green; &#125;h1[title=\"titan\"][class=\"highlight\"] &#123; color: blue; &#125;h1[class~=\"text\"] &#123; color: purple; &#125;h2[class|=\"text\"] &#123; color: olive; &#125;h1[class=\"alert\"], h1[class=\"alert-primary\"] &#123; color: gray; &#125;h1[title]：帶有 title 屬性的 h1 元素h2[title=&quot;titan&quot;]：帶有 title 屬性的 h2 元素，並且該屬性值為 titanh1[title=&quot;titan&quot;][class=&quot;highlight&quot;]：帶有 title 和 class 屬性的 h1 元素，並且 title 的屬性值為 titan 以及 class 屬性值為 highlighth1[class~=&quot;text&quot;]：帶有 class 屬性的 h1 元素，並且該屬性值需包含 texth2[class|=&quot;text&quot;]：帶有 class 屬性的 h2 元素，並且該屬性值為需為 text 或以 text- 為開頭h1[class=&quot;alert&quot;], h1[class=&quot;alert-primary&quot;]：帶有 class 屬性的 h1 元素，並且該屬性值為 alert，以及帶有 class 屬性的 h1 元素，並且該屬性值為 alert-primary註：[title=&quot;titan&quot;] 中的 title 是屬性名稱，titan 是名為 title 的屬性值。Demo：Codepen 連結See the Pen Attribute presence and value selectors by Titangene (@titangene) on CodePen.Substring matching attribute selector在 Selectors Level 3 提供了三個額外的 attribute selector，用於 match 屬性值中的子字串：[att^=val]：代表具有 att 屬性的元素，該屬性值以 val 為開頭。如果 val 是空字串，則 selector 不代表任何內容[att$=val]：代表具有 att 屬性的元素，該屬性值以 val 為結尾。如果 val 是空字串，則 selector 不代表任何內容[att*=val]：代表具有 att 屬性的元素，該屬性值至少包含 val 這個子字串。如果 val 是空字串，則 selector 不代表任何內容直接看範例：12345678910&lt;h2 class=\"text\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"textPrimary\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"text-primary\"&gt;Text&lt;/h2&gt;&lt;h2&gt;&lt;a href=\"https://titangene.github.io/article/css-selector-2.html\"&gt;重新認識 CSS - CSS Selector (2)&lt;/a&gt;&lt;/h2&gt;&lt;h2&gt;&lt;a href=\"https://titangene.github.io\"&gt;Titangene Blog&lt;/a&gt;&lt;/h2&gt;&lt;h2 class=\"my-alert\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"myAlertPrimary\"&gt;Text&lt;/h2&gt;&lt;h2 class=\"my-alert-primary\"&gt;Text&lt;/h2&gt;123h2[class^=\"text\"] &#123; color: red; &#125;a[href$=\".html\"] &#123; color: gray; &#125;h2[class*=\"alert\"] &#123; color: green; &#125;h2[class^=&quot;text&quot;]：代表具有 class 屬性的元素，該屬性值以 text 為開頭a[href$=&quot;.html&quot;]：代表具有 href 屬性的元素，該屬性值以 .html 為結尾 (也就是該頁面為 .html 檔)h2[class*=&quot;alert&quot;]：代表具有 class 屬性的元素，該屬性值至少包含 alert 這個子字串Demo：Codepen 連結See the Pen Substring matching attribute selectors by Titangene (@titangene) on CodePen.最後今天介紹一些 attribute selector，接下來幾天會接續介紹其他 selector。資料來源：CSS 2.2 Specification - SelectorsSelectors Level 3Selectors Level 4","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-鐵人賽/"}]},{"title":"重新認識 CSS - CSS Selector (1)","slug":"css-selector-1","date":"2019-09-17T10:20:52.000Z","updated":"2019-09-18T07:17:17.853Z","comments":true,"path":"article/css-selector-1.html","link":"","permalink":"https://titangene.github.io/article/css-selector-1.html","excerpt":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。","text":"Selector (選擇器) 可用來選擇 HTML 和 XML 文件中的節點，並將樣式屬性綁定到文件 (HTML 和 XML) 中的元素上。當選擇器與某元素 match 的時候，就可以對選到的元素進行 CSS 樣式設定。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。本文同步發表於 iT 邦幫忙：重新認識 CSS - CSS Selector (1)「重新認識 CSS」系列文章發文於：iT 邦幫忙Titangene BlogSelector 語法Selector 是由一個或多個 simple selector (簡單選擇器) 序列組合，並用 combinator 分隔的一串東西。simple selector 序列：由多個 simple selector 組成，沒有被 combinator 分隔以 type selector 或 universal selector 為開頭以下這些都是 simple selector：type selector：例如 Euniversal selector：例如 *attribute selector：例如 E[foo]class selector：例如 .myclassID selector：例如 #myidpseudo-class：例如 E:hovercombinator 是 (空白字元)、&gt;、+、~，例如：1234E F &#123; color: red; &#125;E &gt; F &#123; color: red; &#125;E + F &#123; color: red; &#125;E ~ F &#123; color: red; &#125;simple selector 與 combinator 之間可以加上空白，不加空白也可以。例如：下面兩個選擇器是相同的：12E &gt; FE&gt;F不過，通常在之間都會加空白，因為可讀性較佳。Groups of selector當多個選擇器共享相同的宣告時，它們可以用逗號來分隔每個選擇器，每個選擇器都會選到 match 的所有元素，例如：123&lt;h1&gt;header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h3&gt;header 3&lt;/h3&gt;123h1 &#123; color: red; &#125;h2 &#123; color: red; &#125;h3 &#123; color: red; &#125;等同於：1h1, h2, h3 &#123; color: red; &#125;Demo：Codepen 連結See the Pen Groups of selector by Titangene (@titangene) on CodePen.不要要注意的是，上面兩個範例會有一樣的結果是因為所有選擇器都是有效的選擇器 (valid selector)。如果其中一個選擇器為無效時，就會讓整個選擇器群組都無效。不過，若將三個選擇器分開宣告時，就只有那一個會失效。例如：123&lt;h1&gt;header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h3&gt;header 3&lt;/h3&gt;123h1 &#123; color: red; &#125;h2..foo &#123; color: red; &#125;h3 &#123; color: red; &#125;不等於：1h1, h2..foo, h3 &#123; color: red; &#125;Demo：Codepen 連結如下圖，因為上面其中的 h2..foo 是無效選擇器 (invalid selector)，所以會造成 h1, h2..foo, h3 完全無效，並且會刪除這個樣式規則：如果是分開宣告，就只會刪除 h2..foo 這個樣式規則，如下圖：See the Pen Groups of selector: valid selector by Titangene (@titangene) on CodePen.Simple selector以下這些都是 simple selector：type selectoruniversal selectorattribute selectorclass selectorID selectorpseudo-classType selector選到 HTML tag 名稱的元素，例如：match 所有 h1 元素：1&lt;h1&gt;header 1&lt;/h1&gt;1h1 &#123; color: red; &#125;Demo：Codepen 連結See the Pen type selector by Titangene (@titangene) on CodePen.Universal SelectorUniversal selector 是使用 * 來 match 任何元素。例如：下面範例可以選到所有元素：1234&lt;h1&gt;header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h3&gt;header 3&lt;/h3&gt;&lt;a href=\"https://titangene.github.io/\"&gt;Titangene Blog&lt;/a&gt;1* &#123; color: red; &#125;Demo：Codepen 連結See the Pen Universal Selector by Titangene (@titangene) on CodePen.Class selector如果要對多個元素需要相同的樣式時，就可以用 class 這個屬性來標識它們。在 CSS 是使用 . 來代表 class 屬性，也等同於 ~= 表示法 (notation)，屬性值必須在 . 之後。例如：12&lt;h1&gt;header 1&lt;/h1&gt;&lt;h1 class=\"highlight\"&gt;highlight header 1&lt;/h1&gt;1h1.highlight &#123; color: red; &#125;等同於：1h1[class~=highlight] &#123; color: red; &#125;Demo：Codepen 連結第一個 h1 元素的字體顏色不會變成紅色，只有第二個 h1 元素才會變紅色：See the Pen class selector by Titangene (@titangene) on CodePen.如果只單獨使用 class selector (也就是 . )，也等同於在前面加上 universal selector (也就是 * )。例如：1234&lt;h1&gt;header 1&lt;/h1&gt;&lt;h1 class=\"highlight\"&gt;highlight header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h2 class=\"highlight\"&gt;highlight header 2&lt;/h2&gt;1*.highlight &#123; color: red; &#125;1.highlight &#123; color: red; &#125;Demo：Codepen 連結第一個 h1 和 h2 元素的字體顏色不會變成紅色，只有第二個 h1 和 h2 元素才會變紅色：See the Pen class selector &amp; universal selector by Titangene (@titangene) on CodePen.如果需要同時指定某元素上的兩個 class，可以寫成這樣：1234&lt;h1&gt;header 1&lt;/h1&gt;&lt;h1 class=\"text-primary highlight\"&gt;highlight header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h2 class=\"highlight\"&gt;highlight header 2&lt;/h2&gt;1.text-primary.highlight &#123; color: red; &#125;註：在 HTML 要對某元素上同時設定多個 class，是使用空白字元來分隔多個 class。以上面範例來說，第二個 h1 上有兩個 class，分別是 text-primary 和 highlight。Demo：Codepen 連結See the Pen multi class selector by Titangene (@titangene) on CodePen.ID selector如果要對某個元素作唯一的標示，就可以用 id 這個屬性來標識它們。在 CSS 是使用 # 來代表 id 屬性，屬性值必須在 # 之後。例如：1234&lt;h1&gt;header 1&lt;/h1&gt;&lt;h1 id=\"titan\"&gt;header 1&lt;/h1&gt;&lt;h2&gt;header 2&lt;/h2&gt;&lt;h2 id=\"titan\"&gt;header 2&lt;/h2&gt;1#titan &#123; color: red; &#125;Demo：Codepen 連結See the Pen id selector by Titangene (@titangene) on CodePen.如果只想選擇帶有 titan 這個 id 的 h2 元素，可以寫成這樣：1h2#titan &#123; color: red; &#125;Demo：Codepen 連結See the Pen id selector: specific element by Titangene (@titangene) on CodePen.最後今天介紹一些 simple selector，接下來幾天會接續介紹其他 selector。資料來源：CSS 2.2 Specification - SelectorsSelectors Level 3Selectors Level 4","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-鐵人賽/"}]},{"title":"重新認識 CSS - CSS 簡介","slug":"css-introduction","date":"2019-09-16T10:10:11.000Z","updated":"2019-09-16T13:58:19.006Z","comments":true,"path":"article/css-introduction.html","link":"","permalink":"https://titangene.github.io/article/css-introduction.html","excerpt":"CSS 是 Cascading Style Sheets 的縮寫，是一種 style sheet (樣式表) 語言，可將自訂的樣式 (例如：字體、顏色) 附加在 HTML 文件上。這篇會先簡介 CSS，以及如何在 HTML 設定 CSS。","text":"CSS 是 Cascading Style Sheets 的縮寫，是一種 style sheet (樣式表) 語言，可將自訂的樣式 (例如：字體、顏色) 附加在 HTML 文件上。這篇會先簡介 CSS，以及如何在 HTML 設定 CSS。前言「重新認識 CSS」這個系列名稱的由來就如其名，我想要重新認識它。雖然以前就有學過 CSS，但這次想從 CSS Spec 中學到最原始的定義和內容，更加了解 CSS 的原理，讓我在切版的時候可以更加確定自己在做什麼，我踩到的雷只是因為我不夠了解它才會炸開。在這 30 天的內容中，會將 Spec 內看到的資料整理成這個系列，也希望正在學 CSS 的各位可以更加了解它。另外我也會同時將文章發至我的 Blog，如果想直接看文內的程式碼 Demo 畫面，可以到我的 Blog 來看 😃。CSS 規則是由 selector 和宣告 (declaration) 組成，以下面程式碼的 CSS 規則為例，h1 就是 selector，color: red 就是宣告。在 HTML 中，元素名稱不分大小寫，例如：H1 和 h1 相同，但通常會寫小寫。宣告又由屬性名稱和屬性值組成，以下面程式碼為例，color 就是屬性名稱，red 就是屬性值。123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;1h1 &#123; color: red; &#125;在 HTML 設定 CSS要在 HTML 內設定 CSS 有三種方法：Inline CSS：元素上的 style 屬性Internal CSS：style 元素External CSS：link 元素引入外部 CSSInline CSS：元素上的 style 屬性在指定的元素上透過 style 屬性來設定 CSS 樣式相同的樣式無法共用，如果要在不同元素設定相同的樣式，就需要在每個元素上設定 style 屬性CSS 樣式與 HTML 結構寫在一起，可讀性差，不建議這樣寫12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 style=\"color: red;\"&gt;Title&lt;/h1&gt; &lt;h2 style=\"color: red;\"&gt;Title&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt;Demo：See the Pen Inline CSS by Titangene (@titangene) on CodePen.Internal CSS：style 元素直接在 HTML 原始碼內利用 style 元素來設定 CSS只能在單獨的 HTML 內使用 style 元素裡的樣式123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h1 &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;Demo：External CSS：link 元素引入外部 CSS使用 link 元素引入外部 CSS 檔案內的樣式可將 HTML 與 CSS 的原始碼分開管理若要更改樣式，只要更換成其他 CSS 檔案或修改外部 CSS 檔案內的樣式同一份 CSS 樣式可套用至多個 HTML 文件使用常見會使用 CDN (Content Delivery Network)link 元素 上的設定：用 rel 屬性 (relationships) 設定連結類型：stylesheet用 href 屬性 (hyperlink reference) 指定的 CSS 路徑12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;下面內容為 style.css：1h1 &#123; color: red; &#125;Demo：Multiple Style Sheets如果以不同的方式來對同一個元素設定樣式，則會使用最後設定的樣式。例如：同時使用 internal CSS 和 external CSS 的方式設定 CSS：12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\" type=\"text/css\"&gt; &lt;style&gt; h1 &#123; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;下面內容為 style.css：1h1 &#123; color: red; &#125;那 h1 的顏色會是綠色：如果更換 style 和 link 元素的順序，h1 的顏色則會是紅色：12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h1 &#123; color: green; &#125; &lt;/style&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\" type=\"text/css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;資料來源：Style Sheets in HTML documentsHTML Standard - 4.2.4 The link element","categories":[{"name":"CSS","slug":"css","permalink":"https://titangene.github.io/categories/css/"},{"name":"HTML","slug":"css/html","permalink":"https://titangene.github.io/categories/css/html/"}],"tags":[{"name":"IT 鐵人賽","slug":"it-鐵人賽","permalink":"https://titangene.github.io/tags/it-鐵人賽/"}]},{"title":"套用自訂 HackMD 暗主題","slug":"hackmd-dark-theme","date":"2019-05-18T12:16:35.000Z","updated":"2019-05-19T16:02:51.484Z","comments":true,"path":"article/hackmd-dark-theme.html","link":"","permalink":"https://titangene.github.io/article/hackmd-dark-theme.html","excerpt":"HackMD 是我常用的寫作平台，因官方沒有提供暗主題的瀏覽模式，所以我就刻了自訂的暗主題，也將自訂主題開源在 GitHub，歡迎大家發 PR 給我，並記得幫我按個 ⭐️ 星。","text":"HackMD 是我常用的寫作平台，因官方沒有提供暗主題的瀏覽模式，所以我就刻了自訂的暗主題，也將自訂主題開源在 GitHub，歡迎大家發 PR 給我，並記得幫我按個 ⭐️ 星。應該有很多人在瀏覽器安裝 Dark reader 這個擴充功能吧？通常使用的原因大多是想把畫面變成深色瀏覽模式，比較保護眼睛。但是有些網站使用這個擴充功能之後，有些顏色不是你習慣或喜歡的，尤其是在個人常用的網站上會感覺沒那麼習慣。而 HackMD 是我常用來寫技術筆記的寫作平台，尤其是程式碼的 highlight，我個人偏好 VS Code 預設的暗主題 (Dark+ 這個主題)，所以我就在網頁上加上自己自訂的 CSS 去改成我想要的主題。那如何將自定的 CSS 加在指定的網站上呢？原本我是用 Stylish 來管理自訂的網頁樣式，但後來因為一些原因這個擴充功能多了在背景上傳資訊的功能 (雖然官方說不會上傳個資)，於是我就改用 Stylus 來管理樣式。Stylus 是 Stylish 的分支，刪除了任何與分析、回傳資料的功能。如何使用主題在瀏覽器安裝 Stylus 擴充功能，Stylus 目前提供這幾種瀏覽器版本的擴充功能：ChromeFirefoxOpera下載我自定的 HackMD dark theme 至 Stylus下載樣式後會自動套用，開啟 HackMD 就會看到介面變成暗主題囉！如果是之前就開啟的 HackMD 頁面，有時會需要重新整理頁面才會套用暗主題。就是這麼簡單 😄。這邊要另外說明一下，雖然剛剛提到因為 Stylish 有收集資料的問題，所以我改用 Stylus 來管理自定樣式，但是要將自定的樣是分享給別人使用，還是要註冊 Stylish 官方平台的帳號，將要分享的樣式上傳至這個平台，讓其他人可以下載使用。不過如果只是下載別人的主題是不需要註冊帳號，所以不用擔因。原始碼這就是我自定 HackMD 樣式的原始碼：titangene/hackmd-dark-theme如果發現需修正的地方，歡迎發 pull request 給我 😎。如果喜歡，記得幫我按個 ⭐️ 星，Thanks。畫面截圖OverviewRecentView modeBook modeSlide modeEmoji &amp; Todo list &amp; Code block highlightGithub GistLaTeX &amp; UMLTableToC (Table of Contents)HistoryPermissionComment小結其實這個 side project 我在 2017 年 8 月就開始做了，期間做了一些不定期的更新，這次的更新算是所有我發現想改的部分 (洞) 都填好了 (有可能我眼殘沒發現的部分也需要改 XD，歡迎大家發 PR 給我)，包括最近 HackMD 官方推出的可分享文件給指定帳號的功能，我也把介面變成暗主題了。套用暗主題的其他秘訣在 HackMD 擔任 Developer 的 黃鈺凱 在我發文的 Facebook 社團 Markdown 台灣，跟大家分享另一種可以套用暗主題的小秘訣，而且這個方法可以將你自定的樣式，套用至你分享的筆記，或是跟夥伴參與的共筆，讓大家都能共享同樣的暗主題。這個祕訣就是在筆記內，加上 HackMD 的內嵌筆記語法，例如：1&#123;%hackmd BJrTq20hE %&#125;以 https://hackmd.io/IpJEFpXkQg2yvdsY9IbTVg?both (這個連結是由 黃鈺凱 大大提供) 這個筆記為例，在這個筆記內可以看到 HackMD 的內嵌筆記語法，而且可以看到我沒有在 Stylus 開啟我自定的 HackMD dark theme，竟然還可以保有暗主題的樣式：原因就發生在這個 HackMD 的內嵌筆記語法，因為這個語法背後幫你多加了暗主題的樣式。那是怎麼做到的呢？於是我就從 BJrTq20hE 這個看似奇怪亂碼的東西下手。馬上就直覺想到，其實 BJrTq20hE 是另一篇筆記的編號，這個筆記的完整連結像是下面這樣，網址其中的 s 是 HackMD 的發表模式 (應該是叫這樣吧？)：1https://hackmd.io/s/BJrTq20hE進入這個連結後，可以看到整個筆記畫面沒有任何文字內容，但是一樣在沒有套用自訂暗主題的情況下，還能有暗主題的樣式。接著我進入這個筆記的編輯模式就發現答案已揭曉，原來這個看似沒內文的筆記中，有我寫的暗主題樣式，這些樣式直接被寫在這篇 HackMD 的筆記裡面，並且放在 &lt;style&gt; 的 HTML element 內：也就是說如果未來想在其他筆記也套用相同的主題樣式，只要建立專門放樣式的筆記，然後將這個筆記透過 HackMD 的內嵌筆記語法套用至其他筆記上，這樣那些筆記都會共享相同的樣式囉！好神奇啊！感謝 HackMD Developer 大大的分享！","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"},{"name":"CSS","slug":"blog/css","permalink":"https://titangene.github.io/categories/blog/css/"}],"tags":[{"name":"Markdown","slug":"markdown","permalink":"https://titangene.github.io/tags/markdown/"},{"name":"Dark Theme","slug":"dark-theme","permalink":"https://titangene.github.io/tags/dark-theme/"}]},{"title":"透過 Docker Compose 設定 network","slug":"networking-in-docker-compose","date":"2019-05-15T13:03:15.000Z","updated":"2019-05-15T13:02:26.117Z","comments":true,"path":"article/networking-in-docker-compose.html","link":"","permalink":"https://titangene.github.io/article/networking-in-docker-compose.html","excerpt":"Docker Compose 預設會建立 default network，這篇會告訴你如何自訂 network、如何使用現有的 network，以及如何自訂 network 名稱。","text":"Docker Compose 預設會建立 default network，這篇會告訴你如何自訂 network、如何使用現有的 network，以及如何自訂 network 名稱。Docker Compose 預設會幫你的應用程式設定一個 network，service 的每個容器都會加入 default network，並且該 network 上的其他容器都可以連接 (reachable) 以及發現 (discoverable) 與容器名稱相同的 hostname。預設的 network 名稱是基於 “專案目錄名稱”，並加上 _default。例如：你的應用程式放在名為 myapp 的專案目錄中，而 docker-compose.yml 的內容如下：1234567891011version: '3'services: web: build: . ports: - '8000:8000' db: image: postgres ports: - '8001:5432'當你執行 docker-compose up 指令時，會發生以下情況：建立一個名為 myapp_default 的 network使用 web 的設定建立容器，並以 web 這個名稱加入名為 myapp_default 的 network使用 db 的設定建立容器，並以 db 這個名稱加入名為 myapp_default 的 network當然你也可以使用 --project-name (可簡寫成 -p ) 參數 或使用 COMPOSE_PROJECT_NAME 這個 環境變數 來複寫專案名稱。現在，每個容器都可以找到名為 web 或 db 的 hostname，並獲得對應容器的 IP 位址。例如：web 的應用程式的程式碼可以連接到 postgres://db:5432 的 URL，並開始使用 Postgres 資料庫。不過要注意 HOST_PORT 和 CONTAINER_PORT 之間的差別。以上面範例中的 db 來說，HOST_PORT 是 8001，CONTAINER_PORT 是 5432 (postgres 的預設 port)。Networked service-to-service 通訊使用 CONTAINER_PORT。定義 HOST_PORT 之後，service 也可以在 swarm 外部存取。在 web 的容器中，如果要連接到 db 的連接字串會看起來像是 postgres://db:5432 這樣，而從 host machine 來看，連接字串看起來像是 postgres://{DOCKER_IP}:8001。更新容器如果有變更 service 的設定，請執行 docker-compose up 指令來更新 service，它會刪除舊的容器，而新容器會以不同的 IP 位址加入相同名稱的 network。執行中的容器可以找到該名稱並連接到新的 IP 位址，而舊的 IP 位址就無法使用。如果任何容器對舊容器開放連線，那這些容器就會被關閉連線。容器有責任檢測這個情況，再次找到名稱並重新連接。Linkslink 到另一個 service 中的容器。透過 link 可以指定 service 名稱和 link 別名 ( SERVICE:ALIAS ），或僅指定 service 名稱。透過該別名可以從其他 service 存取到 service。link 不需要啟用 service 進行通訊 - 預設情況下，任何 service 都可以通過該 service 的名稱存取任何其他 service。鏈接 (linked) service 的容器可在別名相同的 hostname 上存取，如果未指定別名，則可以存取 service 名稱。在下面範例中，可以從 web 的 hostname db 和 database 存取到 db：123456789version: '3'services: web: build: . links: - 'db:database' db: image: postgreslink 和 depends_on 都是以相同的方式表達 service 之間的依賴關係，因此可以使用它們來決定 service 啟動的順序。如果同時定義 links 和 networks，則它們之間具有 links 的 service 必須共享至少一個共同的網絡才能進行通訊。建議使用 network在 swarm 模式下使用 Compose 檔案 (v3) 部署 stack 時，會忽略 links 這個 option--link 參數為 legacy 功能，可能會被刪除。不建議使用 --link，建議使用 user-defined networks (使用者定義的網路) 來促成兩個容器之間的溝通。user-defined networks 不支援你用 --link 參數在容器之間共享環境變數。但是，你可以使用其他機制 (例如：volume)，以更可控的方式在容器之間共享環境變數。詳情可參考官方的 Compose file version 3 reference | Docker Documentation 文件。Multi-host networking注意：本節中的說明只適用於 legacy Docker Swarm 的相關操作，並且只有目標為 legacy Swarm 叢集才有用。有關將 compose 專案部署至較新的整合 swarm mode，請參考Docker Stacks 文件。將 Compose 應用程式部署至 Swarm 叢集 時，可以使用內建的 overlay driver 在容器之間啟用 multi-host 通訊，而無需更改 Compose 檔案或應用程式的程式碼。想了解如何設定 Swarm 叢集可參考官方的 Multi-host networking 這篇。叢集預設是使用 overlay driver，不過也可以參考下一節指定其他 driver。指定自定 network若不想使用預設的 app network，可以使用 top-level networks key 來指定自己的 network，讓你可以建立更複雜的拓撲，並指定 custom network driver 和 option。還可以使用它，將 service 連接到不由 Compose 管理，而是由外部建立的 network。每個 service 都可以使用 service-level networks key 指定要連接的 network，該 key 是引用至 top-level networks key 下的名稱。以下面定義的兩個自定 network 的 Compose 檔案為例，proxy service 與 db service 隔離，因為它們不共享共同的 network，只有 app 可以與兩者溝通：123456789101112131415161718192021222324252627version: '3'services: proxy: build: ./proxy networks: - frontend app: build: ./app networks: - frontend - backend db: image: postgres networks: - backendnetworks: frontend: # Use a custom driver driver: custom-driver-1 backend: # Use a custom driver which takes special options driver: custom-driver-2 driver_opts: foo: '1' bar: '2'通過為每個連接 (attached) 的 network 設定 ipv4_address 和/或 ipv6_address，可以為 network 設定靜態 IP 位址。設定 default network透過在 top-level networks key 內，名為 default network 下定義 entry，來更改應用程序範圍 (app-wide) 的 default network 的設定：1234567891011121314version: '3'services: web: build: . ports: - '8000:8000' db: image: postgresnetworks: default: # Use a custom driver driver: custom-driver-1使用 pre-existing network如果希望容器加入預先定義好的 network，就可以使用 external option。如果 external 設為 true，就會指定已在 Compose 之外先建立的那個 network，所以 docker-compose up 不會嘗試建立此 network。如果此 network 不存在，會因為找不到參考的目標 network 而發生錯誤。錯誤如下：12$ docker-compose upERROR: Network my_network declared as external, but could be found. Please create the network manually using `docker network create my_network` and try again.如果找不到此 network，可以執行 docker network create [network_name] 來建立 network。在 Compose v3.3 以及更舊版的檔案格式下，external 不能跟其他 network configuration keys 一起使用，包括：driver、driver_opts、ipam 和 internal 。Compose v3.4 以及更新版的格式就沒有這個限制。下面範例的 Compose 會找到名為 my-network-name 的已存在的 network，並將應用程式的容器連接到該 network，這樣就不會嘗試建立一個名為 [projectname]_default 的 network：123456789101112version: \"3.7\"services: app: image: whatever networks: - my-networknetworks: my-network: external: name: my-network-name在下面範例中，proxy 是通往外部世界的 gateway，所以不需要建立一個名為 [projectname]_outside 的 network。Compose 會找到一個名為 outside 的已存在的 network，並將 proxy service 的容器連接到 outside network。12345678910111213141516version: \"3.7\"services: proxy: build: ./proxy networks: - outside - default app: build: ./app networks: - defaultnetworks: outside: external: true下面範例的 Compose 不會嘗試建立一個名為 [projectname]_default 的 network，Compose 會找到名為 my-pre-existing-network 的 network，並將應用程式的容器連接到該 network。123456version: \"3.7\"networks: default: external: name: my-pre-existing-networkexternal.name 在 Compose v3.5 檔案格式 中已被棄用，請改用同版本新增的 name，下一節會說明。自訂 network 名稱network 也可以自訂名稱，name 屬性可引用包含特殊字元的 network。下面以這個 Compose 為例，介紹如何自訂 network 名稱：1234567891011version: '3.5'services: app: image: whatever networks: - my-networknetworks: my-network: name: my-app-network在 top-level networks key先把 Compose 裡面的 version 改成 3.5 以上，因為在 v3.5 版才開始提供自訂 network 名稱 (也就是增加 name 屬性)在 service-level networks key 裡面 (也就是自訂的 service 內的 networks )，加入自訂的 network 名稱 (此範例為 my-network )network 的詳細定義是寫在 top-level networks key (也就是通常寫在檔案最後面的 networks ) 裡面。這裡的 network 名稱要和 service-level networks key 裡面自訂的名稱對應 (也就是 my-network 這個 network 名稱要和上面 services 內的一樣)，在 my-network 下面就可以使用 name 屬性來自定 network 名稱 ( my-app-network 就是你真正自訂的 network 名稱 )詳情可參考官方的 Compose file version 3 reference | Docker Documentation 文件。也可以與 external 屬性一起使用：123456version: \"3.7\"networks: network1: external: true name: my-app-network參考來源Networking in Compose | Docker DocumentationCompose file version 3 reference | Docker Documentation","categories":[{"name":"DevOps","slug":"devops","permalink":"https://titangene.github.io/categories/devops/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://titangene.github.io/tags/docker/"},{"name":"Container","slug":"container","permalink":"https://titangene.github.io/tags/container/"},{"name":"Docker Compose","slug":"docker-compose","permalink":"https://titangene.github.io/tags/docker-compose/"}]},{"title":"在 GCP 建立 Network Load Balancer 和 HTTP Load Balancer","slug":"gcp-network-and-http-load-balancer","date":"2019-04-24T14:22:43.000Z","updated":"2019-04-24T14:21:10.799Z","comments":true,"path":"article/gcp-network-and-http-load-balancer.html","link":"","permalink":"https://titangene.github.io/article/gcp-network-and-http-load-balancer.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Set Up Network and HTTP Load Balancers」這個 quest 所學到的內容，包括如何建立多個 web server instance，以及如何建立 network load balancer 和 HTTP load balancer。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Set Up Network and HTTP Load Balancers」這個 quest 所學到的內容，包括如何建立多個 web server instance，以及如何建立 network load balancer 和 HTTP load balancer。在此 lab 中，你將了解 network load balancer 和 HTTP load balancer 之間的差異，以及如何為 Google Compute Engine (GCE) VM 上執行的應用程式設定 load balancer。你可通過多種方式在 GCP 內進行負載平衡 (load balance)。此 lab 將教你完成以下 load balancer 的設定：L3 (Network Layer) Network Load BalancerL7 (Application Layer) HTTP(s) Load Balancer本篇將會做什麼？設定 network load balancer設定 HTTP load balancer透過實作，了解 network load balancer 和 HTTP load balancer 之間的差異準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)：勾選同意服務條款：之後就可以開始使用 GCP Console 囉：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：gcloud 是 GCP 的 command-line 工具，他已預先安裝在 Cloud Shell 上，並且支援 tab 自動補齊 (tab-completion)。使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]詳情可參考官方的 Google Cloud gcloud Overview 文件。為所有資源設定預設的 region 和 zone在 Cloud Shell 中，執行以下指令設定預設 zone 為 us-central1-a：12$ gcloud config set compute/zone us-central1-aUpdated property [compute/zone].在 Cloud Shell 中，執行以下指令設定預設 region 為 us-central1：12$ gcloud config set compute/region us-central1Updated property [compute/region].詳情可參考官方的 Regions &amp; Zones 文件。注意：在自己的機器上執行 gcloud 時，config 設定在 session 中保持不變 (persist across)。在 Cloud Shell 中，你需要為每個新的 session 或重新連接設定此項。建立多個 web server instance為了模擬來至一個叢集主機的服務，請使用 Instance Templates 和 Managed Instance Groups 建立一個簡單的 Nginx web server 叢集來提供靜態內容。Instance Templates 定義叢集中每個 VM 的規格 (硬碟、CPU、記憶體…等)，Managed Instance Groups 使用 Instance Templates 實例化 (instantiate) 多個 VM instance。要建立一個 Nginx web server 叢集，請建立以下內容：一個用來在每個 VM instance 啟動時設定 Nginx server 的 startup script一個要使用 startup script 的 instance template一個 target pool一個使用 instance template 的 managed instance group建立 startup script在 Cloud Shell 執行下面指令，建立要讓每個 VM instance 使用的 startup script。此 script 會在啟動時設定 Nginx server：1234567cat &lt;&lt; EOF &gt; startup.sh#! /bin/bashapt-get updateapt-get install -y nginxservice nginx startsed -i -- 's/nginx/Google Cloud Platform - '\"\\$HOSTNAME\"'/' /var/www/html/index.nginx-debian.htmlEOF建立 instance template建立一個使用 startup script 的 instance template：nginx-template：instance template 的名稱--metadata-from-file startup-script=startup.sh：--metadata-from-file 參數會從 local 檔案中找到指定的 startup script12$ gcloud compute instance-templates create nginx-template \\ --metadata-from-file startup-script=startup.sh輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/instanceTemplates/nginx-template].NAME MACHINE_TYPE PREEMPTIBLE CREATION_TIMESTAMPnginx-template n1-standard-1 2019-04-22T04:53:53.045-07:00如果上面指令沒有提供明確的 template 設定，gcloud compute 會使用以下預設值建立 template：機型：n1-standard-1image：最新版的 Debian image開機磁碟：以 instance 命名的新標準開機磁碟網路：default VPC 網路IP 位址：臨時的外部 IP 位址詳情可參考官方的 gcloud compute instance-templates 文件。若想了解更多建立 instance template 的方法，詳情可參考官方的 Creating Instance Templates 文件。建立 target pooltarget pool 資源定義了一組可以從 forwarding rules 接收收到流量的 instance。當 forwarding rules 將流量導向到 target pool 時，Google Cloud Load Balancing 會根據 source IP 和 port 以及目標 IP 和 port 的 hash 值，從這些 target pool 中選擇一個 instance。建立 target pool，target pool 允許單個存取點到群組中的所有 instance，而且對於之後步驟的負載平衡來說是必需的：1$ gcloud compute target-pools create nginx-pool輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../regions/us-central1/targetPools/nginx-pool].NAME REGION SESSION_AFFINITY BACKUP HEALTH_CHECKSnginx-pool us-central1 NONE詳情可參考官方文件：建立 target pool 指令：gcloud compute target-pools createNetwork Load Balancing ConceptsUsing Target Pools建立 managed instance group使用 instance template 建立 managed instance group：nginx-group：instance group 的名稱--base-instance-name nginx：其中的 nginx 是指在此 managed instance group 中建立的 instance 使用的名稱。由於這些 instance 都一樣，系統會用隨機字串來作為 instance 名稱的一部分，例如：如果 base 名稱是 nginx，instance 的名稱就可能會是 nginx-cl3t、nginx-sqgw … 等--size 2：instance group 的大小--template nginx-template：用於此群組的 instance template 的名稱--target-pool nginx-pool：要新增此 instance group 的 target pool 的名稱 (可多個 target pool)12345$ gcloud compute instance-groups managed create nginx-group \\ --base-instance-name nginx \\ --size 2 \\ --template nginx-template \\ --target-pool nginx-pool輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../zones/us-central1-a/instanceGroupManagers/nginx-group].NAME LOCATION SCOPE BASE_INSTANCE_NAME SIZE TARGET_SIZE INSTANCE_TEMPLATE AUTOSCALEDnginx-group us-central1-a zone nginx 0 2 nginx-template no詳情可參考官方的 Creating groups of managed instances 文件。執行上面的指令後，會建立兩個 VM instance，名稱會以 nginx- 為前綴，可能需要等幾分鐘。接著查看已建立的所有 compute engine instance：1$ gcloud compute instances list輸出：123NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSnginx-cl3t us-central1-a n1-standard-1 10.128.0.3 35.193.149.246 RUNNINGnginx-sqgw us-central1-a n1-standard-1 10.128.0.2 130.211.208.12 RUNNING設定防火牆設定防火牆後，就可以透過 EXTERNAL_IP 位址和 80 port 來連接機器：1$ gcloud compute firewall-rules create www-firewall --allow tcp:80輸出：1234Creating firewall...⠛Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/firewalls/www-firewall].Creating firewall...done.NAME NETWORK DIRECTION PRIORITY ALLOW DENY DISABLEDwww-firewall default INGRESS 1000 tcp:80 False執行上面的指令後，應該就能透過外部 IP 位址 (也就是 http://EXTERNAL_IP/ ) 來連接剛剛建立的兩個 instance，可以在各別的頁面中，看到各個 instance 的名稱：建立 Network Load BalancerNetwork load balancing 允許你依據收到的 IP 協定資料 (例如：位址、port 和協定類型) 來平衡系統的負載。你還可以取得 HTTP(S) load balancing 沒有提供的一些選項。例如：可以對其他基於 TCP/UDP 的協定 (例如：SMTP 流量) 進行負載平衡。如果你的應用程式對 TCP 連接相關的特性感興趣，network load balancing 也允許你的應用程式去檢查封包，而 HTTP(S) load balancing 則沒有提供。詳情可參考官方的 Setting Up Network Load Balancing 文件。針對你的 instance group 來建立 L3 network load balancer：1234$ gcloud compute forwarding-rules create nginx-lb \\ --region us-central1 \\ --ports=80 \\ --target-pool nginx-pool輸出：1Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../regions/us-central1/forwardingRules/nginx-lb].Forwarding rule 要與 target pool 一起使用，以支援 load balancing 功能，要使用 load balancing 就必須建立 forwarding rule，這樣才會將流量導向到特定的 target pool (用於 load balancing)，而下面指令中的 --ports=80 代表指向 target pool 的外部 port 範圍。列出專案中所有 Google Compute Engine (GCE) 的 Forwarding rule：1$ gcloud compute forwarding-rules list輸出：12NAME REGION IP_ADDRESS IP_PROTOCOL TARGETnginx-lb us-central1 35.202.173.185 TCP us-central1/targetPools/nginx-pool接著透過 http://IP_ADDRESS/ 來存取 load balancer，IP_ADDRESS 是上面執行的指令中所輸出的 IP 位址。建立 HTTP(S) Load BalancerHTTP(S) Load Balancing 提供全球性的 load balancing，能將 HTTP 請求送往你的 instance。你可以設定 URL 規則，將一些 URL 路由 (route) 到一組 instance，並將其他 URL 路由到其他 instance。請求都會路由到最接近使用者的 instance group，前提是該 group 具有足夠的資源，並且適合請求。如果最近的 group 沒有足夠的資源，那請求將會送至具有足夠資源，並且是最接近使用者的 group。詳情可參考官方的 HTTP(S) Load Balancer 文件。首先，建立 health check。health check 可以確認 instance 是否有回應 HTTP 或 HTTPS 流量，其他的 http-basic-check 是 legacy health check 的名稱。在專案中，每個 legacy health check 的名稱不能重複：1$ gcloud compute http-health-checks create http-basic-check輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/httpHealthChecks/http-basic-check].NAME HOST PORT REQUEST_PATHhttp-basic-check 80 /定義 HTTP service，並將 port 號 map 到 instance group 的相關 port。現在 load balancing service 可以將流量 forward 到指定的 port 號：123$ gcloud compute instance-groups managed \\ set-named-ports nginx-group \\ --named-ports http:80輸出：1Updated [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../zones/us-central1-a/instanceGroups/nginx-group].詳情可參考官方的 Creating groups of managed instances 文件。建立 後端服務 (backend service)：1234$ gcloud compute backend-services create nginx-backend \\ --protocol HTTP \\ --http-health-checks http-basic-check \\ --global輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/backendServices/nginx-backend].NAME BACKENDS PROTOCOLnginx-backend HTTP將 instance group 加到後端服務中：1234$ gcloud compute backend-services add-backend nginx-backend \\ --instance-group nginx-group \\ --instance-group-zone us-central1-a \\ --global輸出：1Updated [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/backendServices/nginx-backend].建立一個預設的 URL map，將所有收到的請求導向你的所有 instance：12$ gcloud compute url-maps create web-map \\ --default-service nginx-backend輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/urlMaps/web-map].NAME DEFAULT_SERVICEweb-map backendServices/nginx-backend若要根據請求的 URL 將流量導向不同的 instance，詳情可參考官方的 content-based routing 文件。建立 target HTTP proxy，將請求路由到 URL map：12$ gcloud compute target-http-proxies create http-lb-proxy \\ --url-map web-map輸出：123Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/targetHttpProxies/http-lb-proxy].NAME URL_MAPhttp-lb-proxy web-map建立 global forwarding rule，以處理和路由收到的請求。forwarding rule 會根據指定的 IP 位址、IP 協定和 port，將流量送至特定的 target HTTP 或 HTTPS proxy。global forwarding rule 不支援多 port。1234$ gcloud compute forwarding-rules create http-content-rule \\ --global \\ --target-http-proxy http-lb-proxy \\ --ports 80輸出：1Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-.../global/forwardingRules/http-content-rule].建立 global forwarding rule 後，設定可能需要幾分鐘才能傳播 (propagate)：1$ gcloud compute forwarding-rules list輸出：123NAME REGION IP_ADDRESS IP_PROTOCOL TARGEThttp-content-rule 34.96.77.47 TCP http-lb-proxynginx-lb us-central1 35.202.173.185 TCP us-central1/targetPools/nginx-pool複製 forwarding rule 內的 http-content-rule 中的 IP_ADDRESS。你可能需要幾分鐘才能透過瀏覽器連接到 http://IP_ADDRESS/。如果無法連接 (就像下圖這樣)，請稍等一下，再重新整理瀏覽器：下面兩張圖就是多次連接 http://IP_ADDRESS/ 的時候，常會看到畫面在這兩個之前建立的 VM instance 間切換：參考來源Set Up Network and HTTP Load Balancers","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"HTTP","slug":"http","permalink":"https://titangene.github.io/tags/http/"},{"name":"Load Balancer","slug":"load-balancer","permalink":"https://titangene.github.io/tags/load-balancer/"}]},{"title":"Google Kubernetes Engine (GKE) 入門","slug":"getting-started-with-google-k8s-engine","date":"2019-04-19T09:30:24.000Z","updated":"2019-04-30T16:00:09.450Z","comments":true,"path":"article/getting-started-with-google-k8s-engine.html","link":"","permalink":"https://titangene.github.io/article/getting-started-with-google-k8s-engine.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Kubernetes Engine: Qwik Start」這個 quest 所學到的內容，包括如何透過 GKE 建立容器和部署容器化應用程式。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Kubernetes Engine: Qwik Start」這個 quest 所學到的內容，包括如何透過 GKE 建立容器和部署容器化應用程式。Google Kubernetes Engine (GKE) 提供了一個代管環境，可以使用 Google 基礎架構來部署、管理和擴展容器化應用程式。GKE 提供的環境是由多台機器 (特別是 Google Compute Engine instance) 組成，組成一個容器叢集。在此 lab 中，你將透過 GKE 來實際練習如何建立容器和部署應用程式。GKE 的叢集編排管理 (orchestration)GKE 叢集是由 Kubernetes 開源叢集管理系統提供技術支援。你可以透過 Kubernetes 提供的機制與容器叢集互動。可以使用 Kubernetes 指令和資源來部署以及管理應用程式、執行管理任務、制訂政策，以及監控已部署工作負載 (workload) 的健康狀態。Kubernetes 採用相同的設計原則來執行常用的 Google 服務，並提供相同的優勢：應用程序容器的自動管理、監控與有效性探測 (liveness probe)、自動擴展，滾動升級…等。當您在容器叢集上執行應用程序時，你所使用的技術是由 Google 在容器中執行 production 工作負載的十餘年經驗的技術。GCP 上的 Kubernetes執行 GKE 叢集時，你也可以獲得 GCP 所提供的進階叢集管理功能優點，其中包括：Google Compute Engine (GCE) instances 提供的負載平衡節點池 (Node Pools) 可以指定叢集中的子集節點，以獲得額外的靈活性自動擴展 (Automatic scaling) 叢集的節點 instance 數量自動升級叢集的節點軟體自動修復節點：可維護節點的健康狀態和可用性使用 Stackdriver 來記錄 (logging) 和監控，用於查看叢集的狀態準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)：勾選同意服務條款：之後就可以開始使用 GCP Console 囉：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：gcloud 是 GCP 的 command-line 工具，他已預先安裝在 Cloud Shell 上，並且支援 tab 自動補齊 (tab-completion)。使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]詳情可參考官方的 Google Cloud gcloud Overview 文件。設定預設的 compute zonecompute zone 是你的叢集及其資源所在的大概區域位置，例如：us-central1-a 是 us-central1 region 中的一個 zone。在 Cloud Shell 中啟用新的 session 並執行以下指令，將預設 compute zone 設為 us-central1-a：12$ gcloud config set compute/zone us-central1-aUpdated property [compute/zone].詳情可參考官方的 Managing clusters 文件。建立 GKE 叢集一個叢集包含至少一個叢集主要 (master) 機器和多個稱為 node 的工作 (worker) 機器組成。node 是 Google Compute Engine (GCE) 的 VM instance，執行 Kubernetes 的必要程序 (process)，使它們成為叢集的一部分。若要建立叢集，請執行以下指令，並將 [CLUSTER-NAME] 替換為自訂的叢集名稱 (例如：my-cluster )。叢集名稱必須以字母開頭，結尾必須是字母或數字，且不能超過 40 個字元。1$ gcloud container clusters create [CLUSTER-NAME]你可以無視下面這些輸出內的任何警告：1234567WARNING: In June 2019, node auto-upgrade will be enabled by default for newly created clusters and node pools. To disable it, use the `--no-enable-autoupgrade`flag.WARNING: Starting in 1.12, new clusters will have basic authentication disabled by default. Basic authentication can be enabled (or disabled) manually using the `--[no-]enable-basic-auth` flag.WARNING: Starting in 1.12, new clusters will not have a client certificate issued. You can manually enable (or disable) the issuance of the client certificate using the `--[no-]issue-client-certificate` flag.WARNING: Currently VPC-native is not the default mode during cluster creation. In the future, this will become the default mode and can be disabled using `--no-enable-ip-alias` flag. Use `--[no-]enable-ip-alias` flag to suppress this warning.WARNING: Starting in 1.12, default node pools in new clusters will have their legacy Compute Engine instance metadata endpoints disabled by default. To create a cluster with legacy instance metadata endpoints disabled in the default node pool, run `clusters create` with the flag `--metadata disable-legacy-endpoints=true`.This will enable the autorepair feature for nodes. Please see https://cloud.google.com/kubernetes-engine/docs/node-auto-repair for more information on node autorepairs.WARNING: Starting in Kubernetes v1.10, new clusters will no longer get compute-rw and storage-ro scopes added to what is specified in --scopes (though the latter will remain included in the default --scopes). To use these scopes, add them explicitly to --scopes. To use the new behavior, set container/new_scopes_behavior property (gcloud config set container/new_scopes_behavior true).建立叢集可能需要一些時間，很快應該會看到類似下面的輸出：12NAME LOCATION MASTER_VERSION MASTER_IP MACHINE_TYPE NODE_VERSION NUM_NODES STATUSmy-cluster us-central1-a 1.11.7-gke.12 104.154.18.48 n1-standard-1 1.11.7-gke.12 3 RUNNING詳情可參考官方的 Creating a cluster 文件。取得叢集的驗證憑證建立叢集後，需要取得驗證憑證 (authentication credentials) 才能操作叢集。執行下面指定來對叢集進行驗證，將 [CLUSTER-NAME] 替換成叢集名成：1$ gcloud container clusters get-credentials [CLUSTER-NAME]輸出如下：12Fetching cluster endpoint and auth data.kubeconfig entry generated for my-cluster.詳情可參考官方的 Cluster access for kubectl 文件。將應用部署至叢集現在你已經建立了一個叢集，可以將容器化應用程式部署到該叢集。在此 lab 中，你將在叢集中執行 hello-app。GKE 使用 Kubernetes 物件來建立和管理叢集的資源。Kubernetes 提供 Deployment 物件來部署 stateless 的應用，例如：web server。Service 物件定義了從網際網路上存取應用程式的規則和負載平衡。在 Cloud Shell 中執行下面的 kubectl run 指令，從 hello-app 容器 image 建立新的名為 hello-server 的 Deployment：12$ kubectl run hello-server --image=gcr.io/google-samples/hello-app:1.0 --port 8080deployment.apps \"hello-server\" created我在 Github 上面找到 hello-app image 的專案原始碼：GoogleCloudPlatform/kubernetes-engine-samples如果想在自己的專案上使用自己建置的容器 image，並將此 image 的應用部署至 GKE，可參考官方的 Deploying a containerized web application 文件。此 Kubernetes 指令建立一個代表 hello-app 的 Deployment 物件。在此指令中：--image：指定要部署的容器 image。在這種情況下，該指令從 Google Container Registry bucket 中 pull 範例 image。gcr.io/google-samples/hello-app:1.0 代表這個指令要 pull 的特定 image 版本。如果未指定版本，會使用最新版--port：指定容器要公開的 port將應用公開發佈到網際網路根據預設，在 GKE 上執行的容器無法從網際網路存取，因為這些容器沒有外部 IP 位址。所以你必須執行 kubectl expose 這個指令：12$ kubectl expose deployment hello-server --type=\"LoadBalancer\"service/hello-server exposed此指令會建立一個 Kubernetes Service，它是一個 Kubernetes 資源。GKE 會為應用程式建立外部 IP，明確地將應用程序公開給來自網際網路的流量 (外部流量)。加上 type=&quot;LoadBalancer&quot; 參數會為容器建立一個 GCE 的 Load Balancer (在自己的專案上使用需要計費)。GKE 會將外部 IP 位址指派給 Service 資源，而不是指派給 Deployment。如果你想要找出 GKE 為應用程式佈建 (provisioned) 的外部 IP，可執行 kubectl get service 來檢查 hello-server Service：1$ kubectl get service hello-server產生外部 IP 位址可能需要一分鐘。如果 EXTERNAL-IP 欄位顯示為 pending 狀態時 (如下)，請等待一段時間後，再次執行上面的指令：12NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEhello-server LoadBalancer 10.39.249.21 &lt;pending&gt; 8080:31693/TCP 51s確認應用程式的外部 IP 位址後 ( EXTERNAL-IP 欄位提供的 IP)，請複製此 IP 位址，以下面的輸出範例來說，要複製的 Service 外部 IP 位址就是 35.222.35.96：12NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEhello-server LoadBalancer 10.39.249.21 35.222.35.96 8080:31693/TCP 1m接著將剛剛複製的外部 IP 位址，加上公開的 port，網址格式就會像下面這樣：1http://[EXTERNAL-IP]:8080使用瀏覽器開啟此網址，查看應用程式是否能存取。看到的頁面應該會像下圖這樣：清除執行下面的指令來刪除 Service，此步驟將取消分配為你的 Service 所建立的 Cloud Load Balancer：1$ kubectl delete service hello-server執行下面的指令來刪除容器叢集，此步驟會一併刪除容器叢集的組成資源，例如：運算執行個體、磁碟和網路資源：12345$ gcloud container clusters delete [CLUSTER-NAME]The following clusters will be deleted. - [my-cluster] in [us-central1-a]Do you want to continue (Y/n)?當出現提示時，輸入 Y 進行確認。刪除叢集可能需要一些時間。刪除叢集後的輸出會像下面這樣：1234567The following clusters will be deleted. - [my-cluster] in [us-central1-a]Do you want to continue (Y/n)? yDeleting cluster my-cluster...done.Deleted [https://container.googleapis.com/v1/projects/qwiklabs-gcp-deb218c6553ee39c/zones/us-central1-a/clusters/my-cluster].詳情可查看官方的 Deleting a cluster | Google Kubernetes Engine 文件。參考來源Kubernetes Engine: Qwik Start | Qwiklabs","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"Container","slug":"container","permalink":"https://titangene.github.io/tags/container/"},{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"Load Balancer","slug":"load-balancer","permalink":"https://titangene.github.io/tags/load-balancer/"},{"name":"Kubernetes","slug":"kubernetes","permalink":"https://titangene.github.io/tags/kubernetes/"}]},{"title":"Google Cloud Shell 入門：gcloud & gsutil","slug":"getting-started-with-cloud-shell-gcloud-and-gsutil","date":"2019-04-17T08:56:38.000Z","updated":"2019-04-17T08:56:02.565Z","comments":true,"path":"article/getting-started-with-cloud-shell-gcloud-and-gsutil.html","link":"","permalink":"https://titangene.github.io/article/getting-started-with-cloud-shell-gcloud-and-gsutil.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Getting Started with Cloud Shell &amp; gcloud」這個 quest 所學到的內容，包括如何使用 gcloud 指令，以及如何使用 gsutil 工具來管理 Cloud Storage 資源，將檔案上傳至指定的 bucket。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Getting Started with Cloud Shell &amp; gcloud」這個 quest 所學到的內容，包括如何使用 gcloud 指令，以及如何使用 gsutil 工具來管理 Cloud Storage 資源，將檔案上傳至指定的 bucket。Google Cloud Shell 為你提供 gcloud command-line 存取 GCP 上託管的運算資源。Cloud Shell 是基於 Debian 的 VM，具有 5 GB persistent disk 的 home 目錄，讓你可以輕鬆管理 GCP 專案和資源。你需要的 Cloud SDK gcloud 和其他工具都已預裝在 Cloud Shell 中，讓你可以快速啟動和執行。若想了解如何 在 GCP 上建立 VM 架設 NIGNX Web server 可參考此篇。若想了解如何 在 GCP 上建立 VM 架設 Windows Server 可參考此篇。準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)：勾選同意服務條款：之後就可以開始使用 GCP Console 囉：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：gcloud 是 GCP 的 command-line 工具，他已預先安裝在 Cloud Shell 上，並且支援 tab 自動補齊 (tab-completion)。使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]理解 Regions 和 ZonesCompute Engine 資源位於不同的 regions (地區) 或 zones (區域)。region 是你可以執行資源的所在特定地理位置。每個 region 都有一個或多個 zones。例如，us-central1 region 代表美國中部地區，其中包含的 Zones 有 us-central1-a、us-central1-b、us-central1-c 與 us-central1-f。圖片來源：Creating a Virtual Machine | Qwiklabs位於 zone 中的資源都稱為 zonel (區域) 資源，VM instance (實例) 和 persistent disk (永久磁碟) 都位於 zone 中，如果要將 persistent disk 附加到 VM instance，這兩個資源都必須位於同一個 zone 中。同樣，如果要將靜態 IP 位址分配到 instance，此 instance 就必須與靜態 IP 位於同一個 region 中。詳情可參考 GCP 官方的 Regions &amp; Zones 文件。使用 command line在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕開啟新的 Cloud Shell session：啟用 Cloud Shell 後，你可以使用 command line invoke Cloud SDK gcloud 指令或 VM instance 上可用的其他工具，還可以在不同專案和 Cloud Shell session 之間，將要存取的檔案儲存在 persistent disk storage 的 $HOME 目錄內。$HOME 目錄是私有的，其他使用者無法存取。可以在任何 gcloud 指令的末端加上 -h 參數來查看使用指南：1$ gcloud -h加上 --help 參數或執行 gcloud help 可以查看更詳細的 help 內容：1$ gcloud config --help透過按 Enter 或空白建來捲動瀏覽 help 內容，按 q 按鍵會退出內容。下面兩個指令是一樣的意思，都是用來查看詳細的 help 內容：12$ gcloud config --help$ gcloud help config使用你的 home 目錄現在讓我們試試你的 HOME 目錄。就算去終止和重啟 VM，Cloud Shell HOME 錄的內容都會在所有 Cloud Shell session 之間的專案中保留。變更目前的工作目錄：1$ cd $HOME使用 vi 打開 .bashrc 設定檔：1$ vi ./.bashrc使用 gcloud 指令檢視環境內的設定列表：1$ gcloud config list如果要檢查其他屬性的設定，請在指令後面加上 --all 參數：1$ gcloud config list --all管理 Cloud Storage 資料可以使用 Cloud Shell 中的 gsutil 工具來管理 Cloud Storage 資源，包括建立和刪除 bucket 和物件、複製和移動儲存資料以及管理 bucket 和物件 ACLs (Access Control List)。gsutil 還能將資料傳入和傳出 Cloud Shell instance。bucket 是用於儲存資料的基本容器，儲存在 Cloud Storage 的所有資料都必須放在 bucket 中。你可以用 bucket 來整理資料、控制資料的存取權，但 bucket 不能像目錄和資料夾可以巢狀儲存。由於建立和刪除 bucket 有一些限制，所以你設計的儲存應用程式應儘量執行密集的物件作業和相對較少的 bucket 作業。詳情可參考官方的 Buckets、Creating Storage Buckets 和 Access Control List (ACL) 文件。嘗試建立 Cloud Storage bucket，bucket 名稱不能重複，因此請將 unique-name 替換為其他名稱，或者 append 名稱讓它不重複。1$ gsutil mb gs://unique-name像我是使用名為 unique-name-titan 的 bucket，剛好沒有重複，所以成功建立了 bucket：12$ gsutil mb gs://unique-name-titanCreating gs://unique-name-titan/...如果使用重複的 bucket 名稱就會出現類似下面的訊息：123$ gsutil mb gs://unique-nameCreating gs://unique-name/...ServiceException: 409 Bucket unique-name already exists.現在來建立一些資料，上傳到你的 bucket。首先，建立一個測試檔案：1$ vi test.dat加一些資料進去：1Welcome to gcloud!存儲檔案：1:wq現在，上傳一些檔案到你建立的 bucket，請將 unique-name 取代成你的 storage bucket：1$ gsutil cp test.dat gs://unique-name剛剛我是使用 unique-name-titan 的 bucket，所以上傳指令如下，可以看到我已成功上傳：1234$ gsutil cp test.dat gs://unique-name-titanCopying file://test.dat [Content-Type=application/octet-stream]...- [1 files][ 19.0 B/ 19.0 B]Operation completed over 1 objects/19.0 B.如果是使用重複的 bucket 名稱上傳，就會出現類似下面的訊息：123$ gsutil cp test.dat gs://unique-nameCopying file://test.dat [Content-Type=application/octet-stream]...BadRequestException: 400 Project does not exist: 666160882299若要查看你的 bucket 和檔案，請開啟導航選單，然後選擇「Storage &gt; Browser」：然後點擊你的 bucket：你應該會看到 test.dat 這個檔案：參考來源Getting Started with Cloud Shell &amp; gcloud | Qwiklabs (本篇大多數的圖片來源)","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"VM","slug":"vm","permalink":"https://titangene.github.io/tags/vm/"}]},{"title":"在 GCP 上建立 VM 架設 Windows Server","slug":"gcp-vm-windows-server","date":"2019-04-16T13:17:46.000Z","updated":"2019-04-30T15:56:57.523Z","comments":true,"path":"article/gcp-vm-windows-server.html","link":"","permalink":"https://titangene.github.io/article/gcp-vm-windows-server.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Compute Engine: Qwik Start - Windows」這個 quest 所學到的內容，包括如何透過 GCP Console 在 GCP 建立 instance 架設 Windows Server，以及如何使用 Chrome RDP for GCP 擴充功能直接從瀏覽器進行 RDP 連接至 Windows Server。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Compute Engine: Qwik Start - Windows」這個 quest 所學到的內容，包括如何透過 GCP Console 在 GCP 建立 instance 架設 Windows Server，以及如何使用 Chrome RDP for GCP 擴充功能直接從瀏覽器進行 RDP 連接至 Windows Server。Google Compute Engine 可讓你在 Google 基礎架構上建立和執行 VM。 Compute Engine 提供擴展、效能和價值，讓你可以輕鬆地在 Google 基礎架構上啟動大型運算群集。你可以在 Google Compute Engine 上執行 Windows 應用程式，並利用 VM instance 可用的許多優勢，例如：可靠的儲存選項、Google 網路的速度和自動擴展 (Autoscaling)。在此 lab 中，你將學習如何在 Google Compute Engine 中啟動 Windows Server instance，並使用遠端桌面協定連接到該 instance。若想了解如何 在 GCP 上建立 VM 架設 NIGNX Web server 可參考此篇。如果你未在 local 主機上使用 Windows，請安裝第三方的 RDP client，例如：FusionLabs 的 Chrome RDP。準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)勾選同意服務條款：之後就可以開始使用 GCP Console 囉：建立 VM instance在 GCP Console 的左上角，點選「Navigation menu &gt; Compute Engine &gt; VM Instances」：接著點擊「Create」按鈕建立新的 instance：在「Boot disk」部分中，點擊「Change」按鈕以開始配置 boot disk：選擇「Windows Server 2012 R2 Datacenter」，然後點擊「Select」按鈕：將所有其他設定都保留為預設值。設定好之後，點擊「Create」按鈕建立 instance：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]詳情可參考官方的 Google Cloud gcloud Overview 文件。測試 Windows Startup 的狀態在「VM Instances」頁面上看到帶有綠色狀態的 icon 就代表該 instance 已建立完成，如下圖：但是，它可能尚未準備好接受 RDP 連接，因為所有 OS 元件初始化都需要一段時間。要查看 server 是否已準備好進行 RDP 連接，請在 Cloud Shell terminal command-line 中執行以下指令，其中的 instance-1 是剛剛建立的 instance 名稱：1$ gcloud compute instances get-serial-port-output instance-1 --zone us-central1-a重複這個指令，直到指令輸出以下內容為止。這個指令的輸出會告訴你 OS 元件已初始化，並且 Windows Server 已準備好接受 RDP 連接 (嘗試下一步)。1Finished running startup scripts.這個指令完整的輸出訊息會類似下面這樣：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566$ gcloud compute instances get-serial-port-output instance-1 --zone us-central1-aSeaBIOS (version 1.8.2-20190322_093631-google)Total RAM Size = 0x00000000f0000000 = 3840 MiBCPUs found: 1 Max CPUs supported: 1found virtio-scsi at 0:3virtio-scsi vendor='Google' product='PersistentDisk' rev='1' type=0 removable=0virtio-scsi blksize=512 sectors=104857600 = 51200 MiBdrive 0x000f29f0: PCHS=0/0/0 translation=lba LCHS=1024/255/63 s=104857600Booting from Hard Disk 0...2019/04/15 15:39:21 GCEWindowsAgent: GCE Agent Started (version 4.6.0@1)2019/04/15 15:39:56 GCEInstanceSetup: Starting sysprep specialize phase.2019/04/15 15:39:57 GCEInstanceSetup: All networks set to DHCP.2019/04/15 15:39:57 GCEInstanceSetup: Running 'netsh' with arguments 'interface ipv4 set interface Ethernet mtu=1460'2019/04/15 15:39:57 GCEInstanceSetup: --&gt; Ok.2019/04/15 15:39:58 GCEInstanceSetup: MTU set to 1460.2019/04/15 15:39:58 GCEInstanceSetup: Running 'route' with arguments '/p add 169.254.169.254 mask 255.255.255.255 0.0.0.0 if 12 metric 1'2019/04/15 15:39:58 GCEInstanceSetup: --&gt; OK!2019/04/15 15:39:58 GCEInstanceSetup: Added persistent route to metadata netblock via first netkvm adapter.2019/04/15 15:39:58 GCEInstanceSetup: Getting hostname from metadata server.2019/04/15 15:39:58 GCEInstanceSetup: Changing hostname from WIN-MQ2QFF14J03 to instance-1.2019/04/15 15:39:58 GCEInstanceSetup: Renamed from WIN-MQ2QFF14J03 to instance-1.2019/04/15 15:39:58 GCEMetadataScripts: Starting specialize scripts (version 4.2.1@1).2019/04/15 15:39:58 GCEMetadataScripts: No specialize scripts to run.2019/04/15 15:39:58 GCEMetadataScripts: Finished running specialize scripts.2019/04/15 15:39:58 GCEInstanceSetup: Finished with sysprep specialize phase, restarting...2019/04/15 15:39:59 GCEWindowsAgent: GCE Agent StoppedSeaBIOS (version 1.8.2-20190322_093631-google)Total RAM Size = 0x00000000f0000000 = 3840 MiBCPUs found: 1 Max CPUs supported: 1found virtio-scsi at 0:3virtio-scsi vendor='Google' product='PersistentDisk' rev='1' type=0 removable=0virtio-scsi blksize=512 sectors=104857600 = 51200 MiBdrive 0x000f29f0: PCHS=0/0/0 translation=lba LCHS=1024/255/63 s=104857600Booting from Hard Disk 0...2019/04/15 15:40:36 GCEWindowsAgent: GCE Agent Started (version 4.6.0@1)2019/04/15 15:40:43 GCEInstanceSetup: Disabled Ctrl + Alt + Del.2019/04/15 15:40:43 GCEInstanceSetup: Enable RDP firewall rules.2019/04/15 15:40:43 GCEInstanceSetup: Running 'netsh' with arguments 'advfirewall firewall set rule group=remote desktop new enable=Yes'2019/04/15 15:40:43 GCEInstanceSetup: --&gt; Updated 3 rule(s).2019/04/15 15:40:43 GCEInstanceSetup: --&gt; Ok.2019/04/15 15:40:43 GCEInstanceSetup: Restarting Terminal Service services, to enable RDP.2019/04/15 15:40:44 GCEInstanceSetup: Enabled Remote Desktop.2019/04/15 15:40:44 GCEInstanceSetup: Configuring WinRM...2019/04/15 15:40:47 GCEInstanceSetup: Running 'netsh' with arguments 'advfirewall firewall add rule profile=any name=Windows Remote Management (HTTPS-In) dir=in localport=5986 protocol=TCP action=allow'2019/04/15 15:40:47 GCEInstanceSetup: --&gt; Ok.2019/04/15 15:40:48 GCEInstanceSetup: Setup of WinRM complete.2019/04/15 15:40:48 GCEInstanceSetup: Running startup scripts from metadata server.2019/04/15 15:40:48 GCEInstanceSetup: Running 'schtasks' with arguments '/run /tn GCEStartup'2019/04/15 15:40:48 GCEInstanceSetup: --&gt; SUCCESS: Attempted to run the scheduled task \"GCEStartup\".2019/04/15 15:40:48 GCEInstanceSetup: ------------------------------------------------------------2019/04/15 15:40:48 GCEInstanceSetup: Instance setup finished. instance-1 is ready to use.2019/04/15 15:40:48 GCEInstanceSetup: ------------------------------------------------------------2019/04/15 15:40:51 GCEInstanceSetup: Checking instance license activation status.2019/04/15 15:40:51 GCEInstanceSetup: instance-1 needs to be activated by a KMS Server.2019/04/15 15:40:51 GCEInstanceSetup: Key Management Service machine name set to kms.windows.googlecloud.com successfully.2019/04/15 15:40:51 GCEInstanceSetup: Installed product key W3GGN-FT8W3-Y4M27-J84CP-Q3VJ9 successfully.2019/04/15 15:40:51 GCEInstanceSetup: Activating instance...2019/04/15 15:40:52 GCEInstanceSetup: Activating Windows(R), ServerDatacenter edition (00091344-1ea4-4f37-b789-01750ba6988c) ...2019/04/15 15:40:52 GCEInstanceSetup: Product activated successfully.2019/04/15 15:40:52 GCEInstanceSetup: Activation successful.2019/04/15 15:40:53 GCEMetadataScripts: Starting startup scripts (version 4.2.1@1).2019/04/15 15:40:53 GCEMetadataScripts: No startup scripts to run.2019/04/15 15:40:53 GCEMetadataScripts: Finished running startup scripts.Specify --start=4643 in the next get-serial-port-output invocation to get only the new output starting from here.連接 instance點擊 VM 的名稱：在「Remote Access」部分點擊「Set Windows Password」按鈕：輸入 username 後，點擊「Set」按鈕來產生此 Windows instance 的密碼。如果沒有此 username 的 Windows 帳號，就會建立該帳號並使用新密碼，如果已有此帳號，密碼則會被重設：複製密碼並儲存，稍後登入 instance 時會用到：使用遠端桌面 (RDP) 進入 Windows Server可以使用 Chrome RDP for Google Cloud Platform 擴充功能直接從瀏覽器進行 RDP 連接，點擊「RDP」按鈕進行連接：如果剛剛是用 Chrome 的無痕模式登入帳號，就會發生點擊「RDP」按鈕沒有反應的狀況，換成原本的模式就可以正常使用。它會提示你安裝 RDP 擴充功能。安裝完成後，GCP 會打開像下圖的登入畫面，請使用 Windows 使用者和密碼登入 (貼上之前儲存的密碼)：點擊「Continue」按鈕以確認你要連接：打開 Server Manager 時，就會連接到 Windows Server 上的 VM instance。使用 RDP client 複製和貼上登入到 instance 後，可以按 Ctrl + V 貼上資料 (如果是 Mac 的使用者，按 Cmd + V 會無法貼上）。如果要貼至 PuTTY 和 Powershell，請按滑鼠右鍵就可以貼上。如果在 Powershell 視窗中，請確保已點擊該視窗，否則會無法貼上。參考來源Compute Engine: Qwik Start - Windows (本篇大多數的圖片來源)","categories":[{"name":"Windows Server","slug":"windows-server","permalink":"https://titangene.github.io/categories/windows-server/"},{"name":"Cloud","slug":"windows-server/cloud","permalink":"https://titangene.github.io/categories/windows-server/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"VM","slug":"vm","permalink":"https://titangene.github.io/tags/vm/"}]},{"title":"GCP (Google Cloud Platform) 入門","slug":"getting-started-with-gcp","date":"2019-04-15T14:20:20.000Z","updated":"2019-04-16T12:05:50.221Z","comments":true,"path":"article/getting-started-with-gcp.html","link":"","permalink":"https://titangene.github.io/article/getting-started-with-gcp.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「A Tour of Qwiklabs and the Google Cloud Platform」這個 quest 所學到的內容，包括如何使用以及認識 Qwiklab 和 GCP。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「A Tour of Qwiklabs and the Google Cloud Platform」這個 quest 所學到的內容，包括如何使用以及認識 Qwiklab 和 GCP。Google Cloud Platform (GCP) 是託管在 Google 基礎架構上的一套雲端服務，從計算和儲存，到資料分析、機器學習、網路、GCP 提供各種服務和 API，可以與任何雲端計算應用程式或專案整合 - 無論是個人還是企業。在這個入門等級的 lab 中，可透過使用 GCP console (瀏覽器內的 UI，可讓您存取和管理 Google Cloud 服務) 來練習使用 GCP，了解 GCP 的主要功能，必了解 Qwiklabs 的環境。你會學到什麼了解如何使用特定憑證存取 GCP console認識 GCP 專案了解如何使用 GCP 的導航選單來識別 GCP 服務的類型了解 primitive roles 並使用 Cloud IAM 服務檢查特定使用者的可用操作了解 Cloud Shell 並使用 gcloud toolkit 來執行指令了解 API library 並查看其主要功能若想了解如何 在 GCP 上建立 VM 架設 NIGNX Web server 可參考此篇。若想了解如何 在 GCP 上建立 VM 架設 Windows Server 可參考此篇。其他關於 Qwiklab 的介紹，可至原文 A Tour of Qwiklabs and the Google Cloud Platform 查看。存取 GCP Console如果已經點擊右上角的「Start Lab」開始，應該會看到左側的「Open Google Console」按鈕變成可以被點擊，而且可以看到有帳號、密碼以及 GCP 專案 ID：GCP 專案 IDGCP 專案是你的 Google 雲端資源的組織實體，包含資源和服務，例如：可以包含一個 VM 的 pool，一組資料庫以及將它們彼此連接的網路，專案還包含設定和權限，這些設定和權限可以指定安全規則以及設定誰有權存取哪些資源。而 GCP Project ID 不會重複，用於將 GCP 資源和 API 連接到你的特定專案。帳號和密碼帳號和密碼是表示在 GCP 身份和存取管理 (Identity and Access Management，IAM) 服務中，具有存取權限身份 (一個或多個角色) 的憑證，允許你在已分配的專案中使用 GCP 資源。這些憑證是臨時的，只能在 lab 限制的存取時間內使用，所以只要計時器倒數到 0 之後，你就無法再使用這些憑證存取這個的 GCP 專案。登入 GCPLab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)勾選同意服務條款：之後就可以開始使用 GCP Console 囉：GCP Console 中的專案GCP Console 的左上角，會看到一個名為 Project info 的面板，畫面如下：一個專案會有名稱、ID、編號，在使用 GCP 服務時會經常使用這些東西。不過你可以存取多個 GCP 專案。在某些 lab 中，可能會使用多個專案來完成分配的任務。如果點擊帶有專案名稱的下拉式選單並選擇「ALL」，就會看到「Qwiklabs Resources」專案也可見：目前不要切換到 Qwiklabs 資源專案！但是，你可以稍後在其他 lab 中使用它。GCP 的大型企業或有經驗的使用者擁有數十到數千個 GCP 專案的情況還蠻常見的，組織會以不同的方式使用 GCP，因此專案分離在雲端運算服務 (以團隊或產品為例) 是個好方法。“Qwiklabs Resources” 是一個包含某些 lab 的檔案，資料集和機器 image 的專案，可以從每個 GCP lab 環境存取。要注意是 “Qwiklabs Resources” 與所有 Qwiklabs 使用者共享資源 (read only)，也就代表你無法刪除或修改它。你正在使用名為類似於 qwiklabs-gcp-xxx 的 GCP 專案是臨時的，也就代表專案及其包含的所有內容會在 lab 結束後刪除。每次使用的 lab 都可以存取一個或多個新的 GCP 專案，並且在那裡 (不是 “Qwiklabs Resources” ) 執行所有 lab 的步驟。導航選單和服務在畫面的左上角有一個類似「三」的 icon：點擊此按鈕會顯示 (或隱藏) GCP 核心服務的導航選單，如果選單沒有打開，請點擊此 icon 並捲動查看所有提供的服務類型：在導航選單可以快速存取平台的服務，可看到共有 7 類 GCP 的服務：Compute：包含支援任何類型的工作負載的各種機型。通過不同的運算選項，可以決定你希望如何參與 operational details 和基礎架構等Storage：結構化或非結構化、關係資料或非關係資料的資料儲存和資料庫選項Networking：平衡應用程式流量和提供安全規則的服務Stackdriver：一套跨雲端日誌記錄 (cross-cloud logging)、監控、追蹤和其他服務的可靠性工具Tools：管理部署和應用程式建置 pipeline 的開發人員的服務Big Data：用於處理和分析大量資料集的服務Artificial Intelligence (AI)：可在 GCP 上執行特定的 AI 和機器學習 (ML，machine learning) 任務的一套 API詳情可查看官方的 About the GCP Services | Google Cloud 文件。角色和權限除了雲端運算服務之外，GCP 還包含一組權限和角色，用於定義誰可以存取哪些資源，我們就可以使用雲端身份和存取管理 (Cloud Identity and Access Management，IAM) 服務來檢查和修改角色和權限。請打開導航選單，然後點擊「IAM &amp; admin」，畫面會跳至包含使用者列表的頁面，該頁面指定給予特定帳號的權限和角色。嘗試篩選這些並找到你登入的 “@qwiklabs” 此使用者名稱：類似下圖：member 欄位被設為 google23396_student@qwiklabs.net（與你登入的帳號一樣），name 欄位被設為 google23396_student@qwiklabs.net student。會看到 Role 欄位被設為 Editor，這是 GCP 提供的三種 primitive roles 的其中之一。除非另有指定，否則 primitive roles 是設定專案等級的權限，它們控制對所有 GCP 服務的存取和管理。下表是從角色文件中提取的定義，其中提供了 viewer、editor 和 owner 角色權限的 overview：角色名稱權限roles/viewer不影響狀態的 read-only 操作的權限，例如：查看 (但不能修改) 現有的資源或資料roles/editor所有 viewer 的權限，以及修改狀態的操作的權限，例如：修改現有資源roles/owner所有 editor 權限和以下操作的權限：- 管理專案的角色和權限以及專案中的所有資源- 設定專案的計費方式因此 editor 能夠建立、修改和刪除 GCP 資源。但是無法在 GCP 專案中新增或刪除 member。API 和服務Google Cloud API 是 GCP 中重要的部分。與服務類似，從企業管理到機器學習等領域的 200 多個 API 都可以輕鬆地與 GCP 專案和應用程式整合。API 是 “Application Programming Interfaces”，可以直接或通過 Google Cloud client library 呼叫 (call) 它們。 Cloud API 使用官方的 Google API Design Guide 中描述的資源導向的設計原則。當 Qwiklabs 為 lab instance 提供新的 GCP 專案時，它可以在背後啟用大多數的 API，以便你可以立即處理 lab 的任務。但要注意的事，當你在 Qwiklabs 之外建立自己的 GCP 專案時，必須自己啟用某些 API。大多數雲端 API 會為你提供有關專案使用該 API 的詳細資訊 (包括流量、錯誤率、延遲時間)，幫助你快速找到使用 Google服務的應用程序問題。你可以通過打開導航選單並點擊「APIs &amp; Services &gt; Library」來查看此資訊：在 API 搜尋欄中，輸入 “Dialogflow” 並選擇 Dialogflow API 後，就會看到下圖的頁面：Dialogflow API 可讓你建置對話式 (conversational) 應用程式 (例如，for Google Assistant)，而無需擔心底層機器學習和自然語言理解 (Natural Language Understanding) schema。點擊「ENABLE」按鈕後會跳至新頁面，接著點擊瀏覽器的返回按鈕就可看到「API enabled」：點擊「Try this API」按鈕會以新分頁的方式開啟 Dialogflow API 的文件，並且可以指定可用的 API 方法。詳情可查看 Google Cloud 中名為 APIs Explorer 的 hands-on 工具。Cloud ShellCloud Shell 是在瀏覽器內的指令提示 (command prompt) 執行環境，允許你在終端提示 (terminal prompt) 下輸入指令來管理 GCP 專案中的資源和服務。Cloud Shell 能讓你在不離開 console 的情況下執行所有 shell 指令，並有預裝的 command-line 工具。在 console 的右上角點擊「Activate Cloud Shell」按鈕，然後在出現提示時點擊「START CLOUD SHELL」按鈕：接著會在 console 底部出現一個新的黑色視窗，視窗內會出現類似以下內容的訊息和提示，這代表你已啟動並執行 Cloud Shell session：1234Welcome to Cloud Shell! Type \"help\" to get started.Your Cloud Platform project in this session is set to qwiklabs-gcp-76ad0f1342e20013.Use \"gcloud config set project [PROJECT_ID]\" to change to a different project.gcpstaging23396_student@cloudshell:~ (qwiklabs-gcp-76ad0f1342e20013)$接著將下面指令複製並貼 (或輸入) 至 Cloud Shell 上，然後按 Enter 鍵執行，應該會看到類似下面的輸出：123456$ gcloud auth listCredentialed AccountsACTIVE ACCOUNT* gcpstaging23396_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`其中 ACTIVE ACCOUNT 是設為你的 GCP IAM 身份 (也就是 googlexxxxxx_student@qwiklabs.net )，gcloudauth list 指令會列出 GCP 專案中有憑證的帳號。此帳號名稱與之前登入到 console 的 Qwiklabs 帳號相同。：如之前所說的，Cloud Shell 預裝了特定的 command-line 工具，主要的 GCP toolkit 是 gcloud，是用於平台上的許多任務，例如：資源管理和使用者身份驗證。除了預裝的 toolkit，Cloud Shell 還附帶標準的 unix CLI 工具和 nano 等文字編輯器，在 Cloud Shell 中可以利用它們來建立和編輯檔案。參考來源A Tour of Qwiklabs and the Google Cloud Platform (本篇大多數的圖片來源)","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"}]},{"title":"在 GCP 上建立 VM 架設 NIGNX Web server","slug":"gcp-vm-nignx-web-server","date":"2019-04-14T02:17:46.000Z","updated":"2019-04-30T15:57:08.765Z","comments":true,"path":"article/gcp-vm-nignx-web-server.html","link":"","permalink":"https://titangene.github.io/article/gcp-vm-nignx-web-server.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Creating a Virtual Machine」這個 quest 所學到的內容，包括如何透過 GCP Console 和 command-line 工具 gcloud 在 GCP 建立 instance，如何使用 gcloud 透過 SSH 連接到你的 instance，以及如何在 VM 上部署 NIGNX web server。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Creating a Virtual Machine」這個 quest 所學到的內容，包括如何透過 GCP Console 和 command-line 工具 gcloud 在 GCP 建立 instance，如何使用 gcloud 透過 SSH 連接到你的 instance，以及如何在 VM 上部署 NIGNX web server。透過 Google Compute Engine，可在 Google 基礎架構上，建立執行不同作業系統的 VM (virtual machine，虛擬機)，包括多種 Linux (Debian、Ubuntu、Suse、Red Hat、CoreOS) 和 Windows Server。可以學到如何使用 Google Cloud Platform (GCP) Console 和 gcloud command-line 建立各種機器類型的虛擬機 instance (實例)，還能學習如何將 NGINX web server 連接到 VM。若想了解如何 在 GCP 上建立 VM 架設 Windows Server 可參考此篇。本篇將會做什麼？使用 GCP Console 建立 VM使用 gcloud command-line 建立 VM在 VM 上部署 web server準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)勾選同意服務條款：之後就可以開始使用 GCP Console 囉：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：gcloud 是 GCP 的 command-line 工具，他已預先安裝在 Cloud Shell 上，並且支援 tab 自動補齊 (tab-completion)。未來可使用 gcloud 的下面指令並透過 PROJECT_ID 來更換成其他專案：1$ gcloud config set project [PROJECT_ID]使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]理解 Regions 和 ZonesCompute Engine 資源位於不同的 regions (地區) 或 zones (區域)。region 是你可以執行資源的所在特定地理位置。每個 region 都有一個或多個 zones。例如，us-central1 region 代表美國中部地區，其中包含的 Zones 有 us-central1-a、us-central1-b、us-central1-c 與 us-central1-f。圖片來源：Creating a Virtual Machine | Qwiklabs位於 zone 中的資源都稱為 zonel (區域) 資源，VM instance (實例) 和 persistent disk (永久磁碟) 都位於 zone 中，如果要將 persistent disk 附加到 VM instance，這兩個資源都必須位於同一個 zone 中。同樣，如果要將靜態 IP 位址分配到 instance，此 instance 就必須與靜態 IP 位於同一個 region 中。詳情可參考 GCP 官方的 Regions &amp; Zones 文件。從 Cloud Console 建立新的 instance在 GCP Console 的右上角，點選「Navigation menu &gt; Compute Engine &gt; VM Instances」：接著點擊「Create」建立新的 instance：建立新的 instance 時可以設定很多參數。在此 lab 中會使用以下設定：欄位值額外資訊namegcelabregionus-central1 (Iowa)或asia-south1 (Mumbai)更多關於 regions 的資訊zoneus-central1-c或asia-south1-c注意：記住你選擇的 zone，之後會用到更多關於 zones 的資訊Machine Type2 vCPU這是一個 ( n1-standard-2 )2-CPU, 7.5 GB RAM instance有很多機型可以選擇，從 micro instance 類型的到 32-core/208 GB RAM 的都有，詳情可參考機型種類文件注意：新專案具有預設的資源配額，可能會限制 CPU 核心數。可在此 lab 之外的專案上申請到更高的規格Boot DiskNew 10 GB standard persistent diskOS Image: Debian GNU/Linux 9 (Stretch)有很多 images 可以選擇，包括：Debian、Ubuntu、CoreOS，以及 premium images，像是 RedHat Enterprise Linux 和 Windows Server，詳情可參考 OS 文件Firewall勾選 Allow HTTP traffic，勾選此選項才能存取之後安裝的 web server注意：這會自動建立防火牆規則，允許 80 port 的 HTTP 流量設定好之後，點擊「Create」：等待 instance 建立：看到下面畫面就代表 instance 已建立完成，接著點擊右邊的「SSH」按鈕，會開啟新的瀏覽器頁面：此頁面是直接從瀏覽器啟動 SSH client 連接到 VM：詳情可參考官方的 Connect to an instance using ssh 文件。安裝 NGINX web server透過 SSH 連接 VM 之後，請使用 sudo 取得 root 的存取權限：1$ sudo su -更新 OS：12345$ apt-get updateGet:1 http://security.debian.org stretch/updates InRelease [94.3 kB]Ign:2 http://deb.debian.org/debian stretch InRelease Get:3 http://deb.debian.org/debian stretch-updates InRelease [91.0 kB] ...安裝 NGINX：1$ apt-get install nginx -y檢查 NGINX 是否正在執行：12345$ ps auwx | grep nginxroot 2339 0.0 0.0 159532 1628 ? Ss 06:37 0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;www-data 2340 0.0 0.0 159864 3200 ? S 06:37 0:00 nginx: worker processwww-data 2341 0.0 0.0 159864 3200 ? S 06:37 0:00 nginx: worker processroot 2350 0.0 0.0 12780 952 pts/0 S+ 06:37 0:00 grep nginx註：如果關掉 NGINX 就不會出現關於 NGINX 的 process：1234$ service nginx stop$ ps auwx | grep nginxroot 2359 0.0 0.0 12780 1012 pts/0 S+ 14:23 0:00 grep nginx使用下面指令可以啟動 NGINX：1$ service nginx start回到 Cloud Console，並點擊 VM instance 的 External IP 連結：就會開啟新分頁，可以看到 NGINX web server 的預設網頁：使用 gcloud 建立新的 instance前面介紹的是利用 GCP Console 來建立 VM instance，這邊要介紹的是可以使用預裝在 Google Cloud Shell 中的 command-line 工具 gcloud 來完成一樣的事。Cloud Shell 是基於 Debian 的 VM，預載你所需的所有開發工具 (gcloud、git … 等其他)，並提供 5 GB persistent disk 的 home 目錄。詳情可參考 gcloud command line tool guide。在 Cloud Shell 使用 command-line 工具 gcloud 建立一台新的 VM instance，將 [YOUR_ZONE] 替換成前面使用的 zone：1$ gcloud compute instances create gcelab2 --machine-type n1-standard-2 --zone [your_zone]像我前面的 zone 是用 asia-south1-c，所以指令如下：1234$ gcloud compute instances create gcelab2 --machine-type n1-standard-2 --zone asia-south1-cCreated [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-f9d61ede8167e6b0/zones/asia-south1-c/instances/gcelab2].NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSgcelab2 asia-south1-c n1-standard-2 10.160.0.3 35.244.6.170 RUNNING建立的 instance 具有以下預設值：最新的 Debian 9 (stretch) image預設機型 (machine type) 為 n1-standard-2，在此 lab 中，你也可以使用 n1-highmem-4 或 n1-highcpu-4 其他機型。在 lab 之外的專案可以指定自訂的機型root persistent disk 預設與 instance 的名稱一樣，disk 會自動附加到 instance執行下面指令可以查看所有預設值：1$ gcloud compute instances create --helpNote：如果你總是使用同一個 region/zone，並且不希望每次都使用 --zone 參數，就可以使用下面指令，將指定的 region 和 zones 設為預設：12$ gcloud config set compute/zone ...$ gcloud config set compute/region ...詳情可參考官方的 gcloud compute | Compute Engine Documentation 文件。若要查看剛剛建立的 instance 是否成功建立，就要回到「Navigation menu &gt; Compute Engine &gt; VM Instances」頁面，如果還是沒有看到，就可以點擊「REFRESH」按鈕重新整理此頁面，應該就會看到剛剛建立名為 gcelab2 的 instance：接著你也可以使用 gcloud 透過 SSH 連接到你的 instance，連線時，請確認指令後面 --zone 參數的 [YOUR_ZONE] 是否和當初建立的一樣，或是如果你已在全域設定預設 (上面 Note 提到的部分)，就可以省略 --zone 參數：1$ gcloud compute ssh gcelab2 --zone [YOUR_ZONE]像我沒有在全域設定預設，所以需要在指令後面加上 --zone 參數，[YOUR_ZONE] 則是當初建立的 asia-south1-c，指令如下：12345678910$ gcloud compute ssh gcelab2 --zone asia-south1-cWARNING: The public SSH key file for gcloud does not exist.WARNING: The private SSH key file for gcloud does not exist.WARNING: You do not have an SSH key for gcloud.WARNING: SSH keygen will be executed to generate a key.This tool needs to create the directory[/home/google3043863_student/.ssh] before being able to generate SSHkeys.Do you want to continue (Y/n)?接著會出現下面畫面，請輸入 Y 繼續：1Do you want to continue (Y/n)? y此時會產生一對公鑰 (public key) 和私鑰 (private key)，接著按 Enter 鍵，不輸入也不設定 passphrase (如果是在真正的專案就建議輸入 passphrase，因為當別人拿走你的私鑰時，就無法直接登入主機，還要輸入 passphrase，安全性會比較高)：1234567891011121314151617181920212223242526272829Generating public/private rsa key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/google3043863_student/.ssh/google_compute_engine.Your public key has been saved in /home/google3043863_student/.ssh/google_compute_engine.pub.The key fingerprint is:SHA256:LJMylIaZY1aNf2v0uP/a83TSVw506GazmtvrTyPCxqU google3043863_student@cs-6000-devshell-vm-8e6e4e18-0f7e-4771-ac48-22ab57ceb161The key&apos;s randomart image is:+---[RSA 2048]----+| .o || =... . || B +. o .|| o + .oo o . || o +oS+ .* .|| o o+ + oo *.|| . . E .+.*|| . ..o=.+o|| .oo*==o.|+----[SHA256]-----+Warning: Permanently added &apos;compute.3226821850929314737&apos; (ECDSA) to the list of known hosts.Linux gcelab2 4.9.0-8-amd64 #1 SMP Debian 4.9.144-3.1 (2019-02-19) x86_64The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Creating directory &apos;/home/google3043863_student&apos;.使用 gcloud 設定防火牆如果我已經跟著之前的步驟安裝完 NGINX 了，就會發現剛剛建立的 instance 沒有做防火牆設定，也就是不允許 80 port 的 HTTP 流量，所以就可以是用下面指令來設定：1$ gcloud compute firewall-rules create nginx --allow tcp:80執行指令後會看到下面訊息，訊息內容是無法建立防火牆，這是因為請求的身分權限不足：123Creating firewall...failed.ERROR: (gcloud.compute.firewall-rules.create) Could not fetch resource: - Insufficient Permission: Request had insufficient authentication scopes.那如何知道目前的有效帳號名稱？可以使用下面指令來查看，可以看到目前的帳號不是之前 lab 暫時給我們用的帳號：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* 721269751803-compute@developer.gserviceaccount.comTo set the active account, run: $ gcloud config set account `ACCOUNT`所以必須登入之前的帳號，可以使用下面指令：123456789101112131415$ gcloud auth loginYou are running on a Google Compute Engine virtual machine.It is recommended that you use service accounts for authentication.You can run: $ gcloud config set account `ACCOUNT`to switch accounts if necessary.Your credentials may be visible to others with access to thisvirtual machine. Are you sure you want to authenticate withyour personal account?Do you want to continue (Y/n)?接著會出現下面畫面，請輸入 Y 繼續：1Do you want to continue (Y/n)?接著會出現一長串的連結，點擊這個連結：12345678Do you want to continue (Y/n)? yGo to the following link in your browser: https://accounts.google.com/o/oauth2/auth?redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob&amp;prompt=select_account&amp;response_type=code&amp;client_id=32555940559.apps.googleusercontent.com&amp;scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloud-platform+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fappengine.admin+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcompute+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Faccounts.reauth&amp;access_type=offlineEnter verification code:該連結就是要你用 lab 提供的帳號登入：接著要同意 Google Cloud SDK 存取此帳號：接著複製此授權碼，將授權碼貼至剛剛的 shell：12345678Enter verification code: 4/KwEnGIyzJ0P_ZvFeKt5264lP_3CdzZhUb-ZXoEJ0TbVFQVUQyYSBF58WARNING: `gcloud auth login` no longer writes application default credentials.If you need to use ADC, see: gcloud auth application-default --helpYou are now logged in as [google3043863_student@qwiklabs.net].Your current project is [qwiklabs-gcp-f9d61ede8167e6b0]. You can change this setting by running: $ gcloud config set project PROJECT_ID登入成功後，可以再次執行下面指令看一下目前有效帳號的名稱，變成 lab 暫時給我們用的帳號囉：12345678$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT 721269751803-compute@developer.gserviceaccount.com* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`接著再次執行下面指令，就可以成功設定防火牆：12345$ gcloud compute firewall-rules create nginx --allow tcp:80Creating firewall...⠶Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-f9d61ede8167e6b0/global/firewalls/nginx].Creating firewall...done.NAME NETWORK DIRECTION PRIORITY ALLOW DENY DISABLEDnginx default INGRESS 1000 tcp:80 False雖然 GCP Console 介面上 VM instance 的 External IP 沒有變成可以點擊的連結，但可以將 External IP 複製到新的瀏覽器分頁：就能成功看到 NGINX web server 的預設網頁：下圖就是我成功完成此 quest 的畫面：參考來源Creating a Virtual Machine | QwiklabsA Tour of Qwiklabs and the Google Cloud Platform | Qwiklabs在 GCP 上開立一台虛擬機 | Ray’s Coding Journey","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"VM","slug":"vm","permalink":"https://titangene.github.io/tags/vm/"},{"name":"NIGNX","slug":"nignx","permalink":"https://titangene.github.io/tags/nignx/"},{"name":"Web Server","slug":"web-server","permalink":"https://titangene.github.io/tags/web-server/"}]},{"title":"Python 爬蟲常用技巧 (持續更新)","slug":"python-crawler-note","date":"2019-02-28T09:33:51.000Z","updated":"2019-04-30T15:55:09.896Z","comments":true,"path":"article/python-crawler-note.html","link":"","permalink":"https://titangene.github.io/article/python-crawler-note.html","excerpt":"紀錄個人常用的 Python 爬蟲技巧，未來還會持續更新其他技巧。","text":"紀錄個人常用的 Python 爬蟲技巧，未來還會持續更新其他技巧。載入常用套件12345678910import jsonimport shutilimport xml.etree.ElementTree as ETfrom urllib.parse import urlparse, parse_qs, urlunparseimport requestsfrom bs4 import BeautifulSoupfrom user_agent import generate_user_agentimport numpy as npimport pandas as pd解析 HTML123456import requestsfrom bs4 import BeautifulSoupresponse = requests.get(url)soup = BeautifulSoup(response.text, 'lxml')html = soup.find(id='some_id')解析網址12345from urllib.parse import urlparse, parse_qs, urlunparseurl = 'http://xxx.com/api/data?id=123&amp;sub_code=06A1297'link_parse = urlparse(url)print(link_parse)輸出：1ParseResult(scheme=&apos;http&apos;, netloc=&apos;xxx.com&apos;, path=&apos;/api/data&apos;, params=&apos;&apos;, query=&apos;id=123&amp;sub_code=06A1297&apos;, fragment=&apos;&apos;)將 ParseResult 物件轉成網址字串12url = urlunparse(link_parse)print(url)輸出：1&apos;http://xxx.com/api/data?id=123&amp;sub_code=06A1297&apos;解析網址 query123456link_query = parse_qs(link_parse.query)print(link_query)id = link_query['id'][0]sub_code = link_query['sub_code'][0]print(id, sub_code)輸出：12&#123;&apos;id&apos;: [&apos;123&apos;], &apos;sub_code&apos;: [&apos;06A1297&apos;]&#125;123 06A1297隨機生成 user-agentfake_useragent 套件123456789import requestsfrom fake_useragent import UserAgentdef set_header_user_agent(): user_agent = UserAgent() return user_agent.randomuser_agent = set_header_user_agent()response = requests.get(url, headers=&#123; 'user-agent': user_agent &#125;)user_agent 套件12345import requestsfrom user_agent import generate_user_agentuser_agent = generate_user_agent()response = requests.get(url, headers=&#123; 'user-agent': user_agent &#125;)讀取表格資料123456789import requestsfrom bs4 import BeautifulSoupimport numpy as npimport pandas as pdresponse = requests.get(url)soup = BeautifulSoup(response.text, 'lxml')html = soup.find(id='table_id')df = pd.read_html(str(html), header=0)[0]讀取/解析 JSON123456789import json# 讀取with open('data.json', encoding='utf-8') as file: datas = json.load(file)# 解析with open('data.json', 'w', encoding='utf-8') as file: json.dump(datas, file, ensure_ascii=False)讀取/解析 XML讀取 XML 檔1234import xml.etree.ElementTree as ETtree = ET.parse('data.xml')root = tree.getroot()讀取 XML 字串123import xml.etree.ElementTree as ETroot = ET.fromstring(some_xml_strings)以下面的 XML 為範例：123456789101112131415161718&lt;?xml version=\"1.0\"?&gt;&lt;bookstore&gt; &lt;book ISBN=\"10-000000-001\"&gt; &lt;title&gt;Book 1&lt;/title&gt; &lt;price&gt;300&lt;/price&gt; &lt;comments&gt; &lt;userComment rating=\"4\"&gt;xxx...&lt;/userComment&gt; &lt;userComment rating=\"2\"&gt;yyy...&lt;/userComment&gt; &lt;/comments&gt; &lt;/book&gt; &lt;book ISBN=\"10-000000-999\"&gt; &lt;title&gt;Book 2&lt;/title&gt; &lt;price&gt;500&lt;/price&gt; &lt;comments&gt; &lt;userComment rating=\"3\"&gt;zzz...&lt;/userComment&gt; &lt;/comments&gt; &lt;/book&gt;&lt;/bookstore&gt;迴圈取得子元素12for child in root: print(child.tag, child.attrib)輸出：12book &#123;&apos;ISBN&apos;: &apos;10-000000-001&apos;&#125;book &#123;&apos;ISBN&apos;: &apos;10-000000-999&apos;&#125;用 index 取得某元素123root[0][1].tagroot[0][1].textroot[0].attrib輸出：123&apos;price&apos;&apos;300&apos;&#123;&apos;ISBN&apos;: &apos;10-000000-001&apos;&#125;搜尋指定元素使用 root.iter()：123for comment in root.iter('userComment'): print(comment.attrib) print('comment: &#123;&#125;'.format(comment.text))輸出：123456&#123;&apos;rating&apos;: &apos;4&apos;&#125;comment: xxx...&#123;&apos;rating&apos;: &apos;2&apos;&#125;comment: yyy...&#123;&apos;rating&apos;: &apos;3&apos;&#125;comment: zzz...使用 root.findall()：1234for book in root.findall('book'): ISBN = book.get('ISBN') title = book.find('title').text print(ISBN, title)1210-000000-001 Book 110-000000-999 Book 2下載圖片response.raw 是 file-like 物件，預設不會解壓縮 response (使用 gzip 或 deflate，參考至 Requests 原始碼)，可以透過在 requests.get() 方法中，新增參數 stream=True 來強制解壓縮，並且可以避免立即將大的 response 內容讀入記憶體內，接著使用 shutil.copyfileobj() 讓 Python 將 串流資料轉成檔案物件。12345678import requestsimport shutilurl = \"http://www.xxx.com/xxx.png\"response = requests.get(url, stream=True)file_name = url.split('/')[-1]with open(file_name, 'wb') as file: shutil.copyfileobj(response.raw, file)如果要下載檔案大的圖片，可參考下個段落「下載大檔案」。shutil.copyfileobj(fsrc, fdst[, length])：將 file-like 物件 fsrc 的內容複製到 file-like 物件 fdst。length 參數 (int) 是 buffer 的大小。如果 length 為負數則代表是複製資料，而不以 chunk 的形式循環原始資料；預設是資料以 chunk 的形式讀取，以避免不受控制的記憶體消耗。請注意，如果 fsrc 物件的當前檔案位置不為 0，則只複製從當前檔案位置到檔案末端的內容。參考至 shutil - High-level file operations - Python 3.7.3 documentation 官方文件。:::參考來源：python - How to download image using requests - Stack Overflow下載大檔案以迭代的方式取得，預設會以每 128 byte 為一個 chunk 來讀取資料 (參考至 Requests 原始碼)：1234567import requestsresponse = requests.get(url, stream=True)file_name = url.split('/')[-1]with open(file_name, 'wb') as file: for chunk in response: file.write(chunk)若要自訂 chunk 大小，可使用 Response.iter_content() 方法自訂：12345678910import requestsfile_name = url.split('/')[-1]with requests.get(url, stream=True) as response: response.raise_for_status() with open(file_name, 'wb') as file: for chunk in response.iter_content(chunk_size=8192): if chunk: # filter out keep-alive new chunks file.write(chunk) # file.flush()參考來源：Download large file in python with requests - Stack Overflow若想要以一次一行的方式迭代 response 資料，可使用 Response.iter_lines() 方法，此方法預設一個 chunk 的大小為 512 byte，若要設定分隔符號，可加上 delimiter 參數：12345678import jsonimport requestsr = requests.get(url, stream=True)for line in r.iter_lines(): # filter out keep-alive new lines if line: print(json.loads(line))參考來源：Python Requests 庫：HTTP for Humans - 再見紫羅蘭 - 博客園","categories":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"},{"name":"Crawler","slug":"python/crawler","permalink":"https://titangene.github.io/categories/python/crawler/"}],"tags":[{"name":"Python Requests","slug":"python-requests","permalink":"https://titangene.github.io/tags/python-requests/"}]},{"title":"在 Hexo 主題內新增程式碼片段複製功能","slug":"hexo-copy-code-snippet-to-clipboard","date":"2019-02-09T02:40:00.000Z","updated":"2019-04-30T15:38:34.184Z","comments":true,"path":"article/hexo-copy-code-snippet-to-clipboard.html","link":"","permalink":"https://titangene.github.io/article/hexo-copy-code-snippet-to-clipboard.html","excerpt":"為了提高 blog 的使用體驗，本文將說明如何在 Hexo 主題內，提供程式碼片段複製至剪貼簿的功能。","text":"為了提高 blog 的使用體驗，本文將說明如何在 Hexo 主題內，提供程式碼片段複製至剪貼簿的功能。12// copy to clipboardvar clipboard = document.querySelectorAll('pre');載入 clipboard.js在 themes\\material-flow\\layout\\_partial\\scripts.ejs 檔案內的載入 clipboard.js：1&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js\"&gt;&lt;/script&gt;新增程式碼片段複製功能每個程式碼片段內都要新增複製功能按鈕，下面說明新增複製按鈕的處理邏輯：首先要找到所有程式碼區塊：1var snippets = document.querySelectorAll('figure.highlight');準備要新增的按鈕結構：1234var htmlCopyButton = ` &lt;button class=\"codecopy-btn tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard\"&gt; &lt;i class=\"far fa-copy\" aria-hidden=\"true\"&gt;&lt;/i&gt; &lt;/button&gt;`;在原本的程式碼區塊的 &lt;figure&gt; 標籤外多包了一層 &lt;div&gt; 標籤在 &lt;div&gt; 標籤上新增 .code-highlight class 樣式在 &lt;div&gt; 標籤上新增 data-lang 屬性用於記錄此程式碼區塊內的程式碼是哪種程式語言12345678910111213snippets.forEach(snippet =&gt; &#123; var parent = snippet.parentNode; var wrapper = document.createElement('div'); parent.replaceChild(wrapper, snippet); wrapper.appendChild(snippet); wrapper.classList.add('code-highlight'); wrapper.firstChild.insertAdjacentHTML('beforebegin', htmlCopyButton); var lang = (snippet.classList[1] || 'code').toUpperCase(); wrapper.setAttribute('data-lang', lang);&#125;);接著將名為 .codecopy-btn 的 element 上新增複製功能，複製的內容是 &lt;figure&gt; 標籤內的程式碼：12345var clipboard = new ClipboardJS('.codecopy-btn', &#123; target: trigger =&gt; &#123; return trigger.nextSibling; &#125;,&#125;);只要按複製按鈕且複製成功，就會顯示 Copied! 提示已成功複製程式碼片段：1234clipboard.on('success', e =&gt; &#123; e.trigger.setAttribute('aria-label', 'Copied!'); e.clearSelection();&#125;);將每個複製按鈕新增兩個監聽事件，分別是 mouseleave 和 click：mouseleave：滑鼠離開按鈕就將提示文字變成 Copy to clipboardclick：取消事件的預設行為123456789101112var btns = document.querySelectorAll('.codecopy-btn');btns.forEach(btn =&gt; &#123; btn.addEventListener('mouseleave', e =&gt; &#123; e.target.setAttribute('aria-label', 'Copy to clipboard'); e.target.blur(); &#125;); btn.addEventListener('click', e =&gt; &#123; e.preventDefault(); &#125;);&#125;);完整程式碼在 themes\\material-flow\\source\\js 目錄內建立 clipboard-use.js，檔案內容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$(function() &#123; // ref: https://github.com/zenorocha/codecopy/blob/master/src/scripts/main.js var snippets = document.querySelectorAll('figure.highlight'); var htmlCopyButton = ` &lt;button class=\"codecopy-btn tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard\"&gt; &lt;i class=\"far fa-copy\" aria-hidden=\"true\"&gt;&lt;/i&gt; &lt;/button&gt;`; snippets.forEach(snippet =&gt; &#123; var parent = snippet.parentNode; var wrapper = document.createElement('div'); parent.replaceChild(wrapper, snippet); wrapper.appendChild(snippet); wrapper.classList.add('code-highlight'); wrapper.firstChild.insertAdjacentHTML('beforebegin', htmlCopyButton); var lang = (snippet.classList[1] || 'code').toUpperCase(); wrapper.setAttribute('data-lang', lang); &#125;); // Add copy to clipboard functionality and user feedback var clipboard = new ClipboardJS('.codecopy-btn', &#123; target: trigger =&gt; &#123; return trigger.nextSibling; &#125;, &#125;); clipboard.on('success', e =&gt; &#123; e.trigger.setAttribute('aria-label', 'Copied!'); e.clearSelection(); &#125;); // Replace tooltip message when mouse leaves button // and prevent page refresh after click button var btns = document.querySelectorAll('.codecopy-btn'); btns.forEach(btn =&gt; &#123; btn.addEventListener('mouseleave', e =&gt; &#123; e.target.setAttribute('aria-label', 'Copy to clipboard'); e.target.blur(); &#125;); btn.addEventListener('click', e =&gt; &#123; e.preventDefault(); &#125;); &#125;);&#125;);接著在 themes\\material-flow\\layout\\_partial\\scripts.ejs 檔案內的載入 clipboard-use.js：1&lt;%- js('js/clipboard-use.js') %&gt;CSS 樣式提示文字樣式在 themes\\material-flow\\source\\less 目錄內建立 _tooltipped.less，檔案內容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ref: https://github.com/primer/primer/blob/master/modules/primer-tooltips/lib/tooltips.scss.tooltipped &#123; position: relative;&#125;// This is the tooltip bubble.tooltipped::after &#123; position: absolute; z-index: 1000000; display: none; padding: 0.5em 0.75em; -webkit-font-smoothing: subpixel-antialiased; color: #fff; text-align: center; text-decoration: none; text-shadow: none; text-transform: none; letter-spacing: normal; word-wrap: break-word; white-space: pre; pointer-events: none; content: attr(aria-label); background: #616161; border-radius: 3px; opacity: 0;&#125;// This is the tooltip arrow.tooltipped::before &#123; position: absolute; z-index: 1000001; display: none; width: 0; height: 0; color: #616161; pointer-events: none; content: ''; border: 6px solid transparent; opacity: 0;&#125;// delay animation for tooltip@keyframes tooltip-appear &#123; from &#123; opacity: 0; &#125; to &#123; opacity: 1; &#125;&#125;// This will indicate when we'll activate the tooltip.tooltipped:hover,.tooltipped:active,.tooltipped:focus &#123; &amp;::before, &amp;::after &#123; display: inline-block; text-decoration: none; animation-name: tooltip-appear; animation-duration: 0.1s; animation-fill-mode: forwards; animation-timing-function: ease-in; &#125;&#125;// Tooltipped south.tooltipped-s,.tooltipped-sw &#123; &amp;::after &#123; top: 100%; right: 50%; margin-top: 6px; &#125; &amp;::before &#123; top: auto; right: 50%; bottom: -7px; margin-right: -6px; border-bottom-color: #616161; &#125;&#125;.tooltipped-sw::after &#123; margin-right: -16px;&#125;// Move the tooltip body to the center of the object..tooltipped-s::after &#123; transform: translateX(50%);&#125;接著在 themes\\material-flow\\source\\style.less 檔案內的載入 _tooltipped.less：1@import 'less/_tooltipped.less';其他樣式可參考本站的完整樣式：原始碼123456789101112131415161718192021222324252627282930313233343536373839404142figure &#123; &amp;.highlight &#123; position: relative; margin: 1rem 0; padding-top: 22px; &#125;&#125;.code-highlight &#123; position: relative; &amp;::before &#123; content: attr(data-lang); font-family: 'Roboto Mono', Consolas, monospace, sans-serif; font-size: 0.6em; color: #b1b1b1; line-height: 18px; position: absolute; top: 4px; right: 7px; z-index: 1; &#125;&#125;.codecopy-btn &#123; width: 24px; height: 26px; position: absolute; top: 0; right: -24px; border: none; box-shadow: none; background: none; z-index: 1; font-size: 12px; color: #fff; transition: color 0.2s; &amp;:hover &#123; color: #7bf; &#125;&#125;Demo下面是原本的 HTML：123456789101112&lt;figure class=\"highlight javascript\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=\"gutter\"&gt; &lt;pre&gt;&lt;span class=\"line\"&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt; &lt;/td&gt; &lt;td class=\"code\"&gt; &lt;pre&gt;&lt;code class=\"hljs javascript\"&gt;...&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/figure&gt;使用後的 HTML：1234567891011121314151617&lt;div class=\"code-highlight\" data-lang=\"JAVASCRIPT\"&gt; &lt;button class=\"codecopy-btn tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard\"&gt; &lt;i class=\"far fa-copy\" aria-hidden=\"true\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;figure class=\"highlight javascript\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=\"gutter\"&gt; &lt;pre&gt;&lt;span class=\"line\"&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt; &lt;/td&gt; &lt;td class=\"code\"&gt; &lt;pre&gt;&lt;code class=\"hljs javascript\"&gt;...&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/figure&gt;&lt;/div&gt;畫面：參考連結clipboard.js — Copy to clipboard without FlashGitHub’s Primer Tooltipszenorocha/codecopy: A browser extension that adds copy to clipboard buttons on every code block","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://titangene.github.io/tags/hexo/"},{"name":"Code Snippet","slug":"code-snippet","permalink":"https://titangene.github.io/tags/code-snippet/"},{"name":"Clipboard","slug":"clipboard","permalink":"https://titangene.github.io/tags/clipboard/"}]},{"title":"在 Docker 下建立並使用 MSSQL Server for Linux","slug":"docker-mssql-server-for-linux","date":"2019-01-30T15:30:00.000Z","updated":"2019-04-30T15:57:59.868Z","comments":true,"path":"article/docker-mssql-server-for-linux.html","link":"","permalink":"https://titangene.github.io/article/docker-mssql-server-for-linux.html","excerpt":"在 SQL Server 2017 時，微軟推出了 Linux 版，同時也在 Docker Hub 上提供了 microsoft/mssql-server-linux 的 Docker image。本篇會介紹如何在 Docker 下，透過此 image 來建立並使用 MSSQL Server for Linux。","text":"在 SQL Server 2017 時，微軟推出了 Linux 版，同時也在 Docker Hub 上提供了 microsoft/mssql-server-linux 的 Docker image。本篇會介紹如何在 Docker 下，透過此 image 來建立並使用 MSSQL Server for Linux。MSSQL Server for Linux 要求必須 Docker Engine 1.8+，支援任何平台 (Windows/Mac/Linux)硬碟空間至少 2 GBRAM 至少 2 GBimage 必要的環境變數：ACCEPT_EULA=Y：確認同意授權合約MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;：設定 SA 密碼A strong system administrator (SA) 密碼必須符合以下規則：至少 8 個字元必需包含英文大寫、英文小寫、數字、非字母數字符號四者中的其中三種即可詳情可參考官方的 SQL Server on Liunx 的系統需求 文件。建立 ContainerDocker Hub：microsoft/mssql-server-linux1234567# 從 Docker Hub 提取 SQL Server 2017 Linux container image$ docker pull microsoft/mssql-server-linux:2017-latest# 建立並執行 Docker container$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1401:1433 --name sql1 \\ -d microsoft/mssql-server-linux:2017-latest-e 'ACCEPT_EULA=Y'：確認同意授權合約-e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;'：必需是強密碼並至少 8 個字元。強密碼英文大寫、英文小寫、數字、非字母數字符號四者中的其中三種即可。-p hostPort:containerPort：host 對外開 1401 port，container 內開 1433 port--name：指定 container 名稱-d：背景執行microsoft/mssql-server-linux:2017-latest：使用 SQL Server 2017 Linux image 建立 container如果列表 NAMES 顯示 sql1 並且 STATUS 顯示 UP 就代表 SQL Server 已在背景執行：1234# 查看 container 的狀態$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES08e2f151d579 microsoft/mssql-server-linux:2017-latest \"/bin/sh -c /opt/mss…\" 31 minutes ago Up 31 minutes 0.0.0.0:1401-&gt;1433/tcp sql1連接至 SQL Server使用 SQL Server 命令列工具 sqlcmd，連接到 SQL Server container：123456789# 在外部向執行中的 container 內部下指令，啟動 Container 內部的互動式 bash shell，來執行你下的指令$ docker exec -it sql1 bash# 使用 SQL Server 命令列工具 `sqlcmd`，並登入帳號密碼連接到 SQL Server$ /opt/mssql-tools/bin/sqlcmd -S localhost -U SAPassword:# 出現 \"1&gt;\" 就代表已成功登入並已進入 sqlcmd1&gt;變更 SA 的密碼SA 帳號是在安裝期間建立的 SQL Server 實例上的系統管理員。建立 SQL Server container 之後，在 container 中執行 echo $MSSQL_SA_PASSWORD，即可查看 SA 的密碼：123$ docker exec -it sql1 bashroot@xxx:/# echo $MSSQL_SA_PASSWORDYourStrong!Passw0rd執行下面指令可以變更 SA 的密碼，而 opt/mssql-tools/bin/sqlcmd 是 sqlcmd 所在的路徑：123$ docker exec -it sql1 /opt/mssql-tools/bin/sqlcmd \\ -S localhost -U SA -P '&lt;YourStrong!Passw0rd&gt;' \\ -Q 'ALTER LOGIN SA WITH PASSWORD=\"&lt;YourNewStrong!Passw0rd&gt;\"'參數說明：-S：server-U：user name-P：password-Q：query，執行 SQL 指令後結束 sqlcmd建立資料庫及查詢資料123456789101112131415161718192021# 查詢 server 上所有 DB 名稱1&gt; SELECT Name from sys.Databases# 在 sqlcmd 指令模式下，要輸入 GO 指令才會執行2&gt; GOName------------mastertempdbmodelmsdb(4 rows affected)# 建立資料庫1&gt; CREATE DATABASE TestDB2&gt; GO# 出現下面畫面 \"1&gt;\" 就代表已成功建立資料庫1&gt;# 離開 sqlcmd1&gt; quit使用 Azure Data Studio 連接 SQL ServerAzure Data Studio (以前稱為 SQL Operations Studio) 是一個輕量且免費的跨平台 SQL Server 開源管理工具，支援 Windows、macOS、Linux。安裝 Azure Data Studiofor Windows下載並解壓縮，接著執行 \\azuredatastudio-windows\\sqlops.exe 即可開始使用。for Linux下載並解壓縮，接著將 Azure Data Studio 執行檔加入 PATH 環境變數，以後即可在終端機輸入 azuredatastudio 開啟 Azure Data Studio：123456$ cd ~$ cp ~/Downloads/azuredatastudio-linux-&lt;version string&gt;.tar.gz ~$ tar -xvf ~/azuredatastudio-linux-&lt;version string&gt;.tar.gz$ echo 'export PATH=\"$PATH:~/azuredatastudio-linux-x64\"' &gt;&gt; ~/.bashrc$ source ~/.bashrc$ azuredatastudiofor macOS下載並解壓縮，然後將 Azure Data Studio 加入 Launchpad，將 Studio.app 拖曳到應用程式目錄 (Applications folder) 即可。安裝詳情可參考官方的 下載並安裝 - Azure Data Studio | Microsoft Docs 文件。登入 SQL ServerServer name 的格式： IP, PortIP：Linux：使用 ifconfig 指令查詢 IPWindows：使用 ipconfig 指令查詢 IPPort：要看前面建立的 container 是設定多少 Port此範例 (也就是下面的指令) 是設定使用 1401 port，所以只要輸入 YourIP, 1401 就能與 SQL Server 連接。123$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1401:1433 --name sql1 \\ -d microsoft/mssql-server-linux:2017-latest建立資料表和資料，並查詢資料執行下面指令，建立資料表和資料，並查詢資料：12345678-- 切換至 TestDB 資料庫use TestDB;-- 建立資料表CREATE TABLE People(Name nvarchar(50), Age int);-- 新增資料INSERT INTO People VALUES ('Titan', 18), ('John', 6), ('Alex', 40);-- 查詢年齡小於 20 歲的人SELECT * FROM People WHERE Age &lt; 20;執行完的結果如下圖，看到此查詢結果就代表已成功新增資料：刪除 Container指定刪除名為 sql1 的 container：12345678# 查詢目前的正在執行的 container$ docker ps# container 停止執行$ docker stop sql# 刪除 container$ docker rm sql1或是可以在未停止執行 container 的情況下，直接強制刪除 container：12# 強制刪除 container$ docker rm -f sql1透過 Volume 將資料庫的資料儲存至主機在 docker run 指令上加 -v 參數可以建立實體資料夾與 container 資料夾的對應關係，將主機上的指定目錄綁定到 container 的指定目錄，也就是可以存資料庫的資料至主機，參數語法為 -v &lt;host directory&gt;:/var/opt/mssql：12345# 執行 Docker container image$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1402:1433 --name sql2 \\ -v `pwd`/mssql:/var/opt/mssql \\ -d microsoft/mssql-server-linux:2017-latest備份與還原資料庫範例前置準備：建立資料庫、資料表和資料下面的 SQL 指令是用來立資料庫、資料表和資料，因為此 container 是剛剛另外新建的，之前的 container 已經刪除了 (因為沒有利用 Volume 儲存資料庫的資料)，所以需要重新建立資料：123456789-- 建立 資料庫CREATE DATABASE TestDB;GO-- 切換至 TestDB 資料庫use TestDB;-- 建立資料表CREATE TABLE People(Name nvarchar(50), Age int);-- 新增資料INSERT INTO People VALUES ('Titan', 18), ('John', 6), ('Alex', 40);備份資料庫使用 sqlcmd 連接到 SQL Server，並完整備份 TestDB 資料庫，備份檔存至 ./data/testdb.bak：12$ docker exec -it sql2 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA \\ -Q \"BACKUP DATABASE TestDB TO DISK = N'/var/opt/mssql/data/testdb.bak' WITH NOFORMAT, NOINIT, NAME = 'demodb-full', SKIP, NOREWIND, NOUNLOAD, STATS = 10\"當執行此指令時，SQL Server 將會提示需輸入密碼。輸入密碼後，很快就會備份完成，如果備份成功畫面就會顯示「BACKUP DATABASE successfully …」：1234567891011121314Password: 10 percent processed.20 percent processed.30 percent processed.40 percent processed.50 percent processed.60 percent processed.70 percent processed.80 percent processed.90 percent processed.Processed 312 pages for database 'TestDB', file 'TestDB' on file 1.100 percent processed.Processed 6 pages for database 'TestDB', file 'TestDB_log' on file 1.BACKUP DATABASE successfully processed 318 pages in 0.348 seconds (7.139 MB/sec).範例前置處理：刪除 container 和資料庫資料下面是要模擬把 container 刪除後，要如何將剛剛備份的資料庫資料 (也就是 ./data/testdb.bak ) 還原，因此也要刪除透過 Volume 儲存的資料庫資料，如以下步驟：刪除 container1234# 查詢目前的正在執行的 container$ docker ps# 強制刪除 container$ docker rm -f sql2刪除透過 Volume 儲存的資料庫資料1234567891011121314151617181920212223242526272829# 查看剛剛刪除的 container 保存下來的 DB 資料檔 (TestDB_log.ldf 和 TestDB.mdf)$ cd mssql/data$ pwd/home/titan/project/mssql/data$ tree├── master.mdf├── mastlog.ldf├── modellog.ldf├── model.mdf├── msdbdata.mdf├── msdblog.ldf├── tempdb.mdf├── templog.ldf├── testdb.bak├── TestDB_log.ldf &lt;---└── TestDB.mdf &lt;---# 刪除 TestDB.mdf 和 TestDB_log.ldf$ sudo rm TestDB*$ tree├── master.mdf├── mastlog.ldf├── modellog.ldf├── model.mdf├── msdbdata.mdf├── msdblog.ldf├── tempdb.mdf├── templog.ldf└── testdb.bak在建立一個新的 container (用來做還原資料庫用的)先回到專案的根目錄：12345$ pwd/home/titan/project/mssql/data$ cd ../..$ pwd/home/titan/project接著建立一個新的 container，名稱叫做 sql3：1234$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1403:1433 --name sql3 \\ -v `pwd`/mssql:/var/opt/mssql \\ -d microsoft/mssql-server-linux:2017-latest還原資料庫使用 sqlcmd 連接到 SQL Server，並還原 TestDB 資料庫 (要還原的備份檔存至 ./data/testdb.bak )：12$ docker exec -it sql3 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA \\ -Q \"RESTORE DATABASE TestDB FROM DISK = N'/var/opt/mssql/data/testdb.bak' WITH FILE = 1, NOUNLOAD, REPLACE, STATS = 5\"當執行此指令時，SQL Server 將會提示需輸入密碼。輸入密碼後，很快就會還原完成，如果還原成功畫面就會顯示「RESTORE DATABASE successfully …」：123456789101112131415161718192021222324Password: 6 percent processed.11 percent processed.15 percent processed.20 percent processed.25 percent processed.31 percent processed.36 percent processed.41 percent processed.45 percent processed.50 percent processed.57 percent processed.61 percent processed.66 percent processed.70 percent processed.75 percent processed.82 percent processed.86 percent processed.91 percent processed.95 percent processed.100 percent processed.Processed 344 pages for database 'TestDB', file 'TestDB' on file 1.Processed 7 pages for database 'TestDB', file 'TestDB_log' on file 1.RESTORE DATABASE successfully processed 351 pages in 0.321 seconds (8.530 MB/sec).檢查一下剛剛刪除的 TestDB.mdf 和 TestDB_log.ldf 都正確的還原了：12345678910111213$ cd mssql/data$ tree├── master.mdf├── mastlog.ldf├── modellog.ldf├── model.mdf├── msdbdata.mdf├── msdblog.ldf├── tempdb.mdf├── templog.ldf├── testdb.bak├── TestDB_log.ldf &lt;---└── TestDB.mdf &lt;---使用 select SQL 指令可以看到資料確實已還原：使用 Azure Data Studio 備份或還原資料庫如果覺得打指令很麻煩，其實 Azure Data Studio、SQL Server Management Studio (SSMS)、SQL Server Data Tools (SSDT) 或 Visual Studio Code (VS Code) 的 mssql 擴充功能 都有提供 GUI 的介面，可以直接備份或還原資料庫。下圖是 Azure Data Studio 備份或還原資料庫的畫面：詳情可參考官方的 備份與還原的資料庫 - Azure Data Studio | Microsoft Docs 文件。參考連結開始使用 Docker （Linux 上執行 SQL Server） 上的 SQL Server 容器 - SQL Server | Microsoft Docs在 Docker 上的 SQL Server 組態選項 - SQL Server | Microsoft Docs在 Docker 中的 SQL Server 資料庫還原 - SQL Server | Microsoft DocsGithub repo: Microsoft/mssql-docker","categories":[{"name":"SQL Server","slug":"sql-server","permalink":"https://titangene.github.io/categories/sql-server/"},{"name":"Linux","slug":"sql-server/linux","permalink":"https://titangene.github.io/categories/sql-server/linux/"},{"name":"Database","slug":"sql-server/linux/database","permalink":"https://titangene.github.io/categories/sql-server/linux/database/"},{"name":"DevOps","slug":"sql-server/linux/database/devops","permalink":"https://titangene.github.io/categories/sql-server/linux/database/devops/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://titangene.github.io/tags/docker/"},{"name":"Container","slug":"container","permalink":"https://titangene.github.io/tags/container/"}]},{"title":"將 Hexo 的 Markdown 渲染引擎換成 markdown-it","slug":"hexo-markdown-it","date":"2019-01-29T14:51:00.000Z","updated":"2019-09-08T16:34:17.393Z","comments":true,"path":"article/hexo-markdown-it.html","link":"","permalink":"https://titangene.github.io/article/hexo-markdown-it.html","excerpt":"個人很常用 HackMD 紀錄筆記，希望 blog 也可以支援 HackMD 的 Markdown 格式，因此本篇的目標就是要將 Hexo 原本的 Markdown 渲染引擎 marked，換成 HackMD 的 Markdown 渲染引擎：markdown-it。","text":"個人很常用 HackMD 紀錄筆記，希望 blog 也可以支援 HackMD 的 Markdown 格式，因此本篇的目標就是要將 Hexo 原本的 Markdown 渲染引擎 marked，換成 HackMD 的 Markdown 渲染引擎：markdown-it。更換渲染引擎Hexo 預設的 markdown 渲染引擎是 marked，並使用 hexo-renderer-marked 此 Hexo 外掛來將 Markdown 轉換成靜態檔案 HTML，但因前面提到的需求，所以要刪除原本的渲染引擎1$ npm uninstall hexo-renderer-marked --save安裝我們要改用的 Markdown 渲染引擎：markdown-it，而使用此渲染引擎的 Hexo 外掛就是 hexo-renderer-markdown-it，所以要在 hexo 的專案中安裝此外掛：1$ npm install git+https://github.com/hexojs/hexo-renderer-markdown-it.git --save為何安裝 NPM 套件時要指定 github 的 repo 呢？因為 hexo-renderer-markdown-it 此 NPM 套件的程式沒有更新成 Github 上面的程式版本，請確定剛剛安裝套件中，node_modules\\hexo-renderer-markdown-it\\lib\\renderer.js 這個檔案內的下面這段程式碼是否相同：123456789if (opt.plugins) &#123; parser = opt.plugins.reduce(function(parser, pugs) &#123; if (pugs instanceof Object &amp;&amp; pugs.name) &#123; return parser.use(require(pugs.name), pugs.options); &#125; else &#123; return parser.use(require(pugs)); &#125; &#125;, parser);&#125;若是從 NPM 下載的套件版本 (也就是直接使用 npm install hexo-renderer-markdown-it --save 此指令)，會少幾句程式，少了可在載入 markdown-it 的外掛時為該外掛設定所需的 options：12345if (opt.plugins) &#123; parser = opt.plugins.reduce(function(parser, pugs) &#123; return parser.use(require(pugs)); &#125;, parser);&#125;安裝渲染引擎外掛套件我們可以參考 HackMD 的相依套件，只要是名為 markdown-it-xxx 的套件就是渲染引擎 markdown-it 的外掛：12345678910111213141516171819&#123; \"dependencies\": &#123; // ... \"markdown-it\": \"^8.2.2\", \"markdown-it-abbr\": \"^1.0.4\", \"markdown-it-container\": \"^2.0.0\", \"markdown-it-deflist\": \"^2.0.1\", \"markdown-it-emoji\": \"^1.3.0\", \"markdown-it-footnote\": \"^3.0.1\", \"markdown-it-imsize\": \"^2.0.1\", \"markdown-it-ins\": \"^2.0.0\", \"markdown-it-mark\": \"^2.0.0\", \"markdown-it-mathjax\": \"^2.0.0\", \"markdown-it-regexp\": \"^0.4.0\", \"markdown-it-sub\": \"^1.0.0\", \"markdown-it-sup\": \"^1.0.0\" // ... &#125;&#125;而下列是我選擇要安裝的外掛：markdown-it-abbrmarkdown-it-containermarkdown-it-deflistmarkdown-it-emojimarkdown-it-footnotemarkdown-it-imsizemarkdown-it-insmarkdown-it-markmarkdown-it-regexpmarkdown-it-submarkdown-it-supmarkdown-it-task-checkbox1$ npm i markdown-it-abbr markdown-it-checkbox markdown-it-container markdown-it-deflist markdown-it-emoji markdown-it-footnote markdown-it-imsize markdown-it-ins markdown-it-mark markdown-it-regexp markdown-it-sub markdown-it-sup --savemarkdown-it-mathjax為何我未安裝 markdown-it-mathjax 這個外掛？這是因為…我之後再單獨寫一篇文章來介紹如何在 Markdown 加上數學式 MathJax。markdown-it-task-checkbox為何我會比 HackMD 多安裝 markdown-it-task-checkbox 這個外掛？有使用過 HackMD 的朋友都知道，只要在 HackMD 輸入下列 Markdown 語法：12- [ ] task 1- [x] task 2就會被轉換成 HTML 的 checkbox：12345678&lt;ul&gt; &lt;li class=\"task-list-item\"&gt; &lt;input type=\"checkbox\" class=\"task-list-item-checkbox \" /&gt;&lt;label&gt;&lt;/label&gt;task 1 &lt;/li&gt; &lt;li class=\"task-list-item\"&gt; &lt;input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"\" /&gt;&lt;label&gt;&lt;/label&gt;task 2 &lt;/li&gt;&lt;/ul&gt;畫面會看到一個未被勾選以及一個已被勾選的 checkbox：不過 HackMD 不是靠著 Markdown 渲染引擎 markdown-it 的外掛來轉換成 HTML 的，而是直接利用正規表示法 (Regular Expression) 找到 [ ] 或 [x] 的文字，再將這些文字直接轉換成 HTML 的 checkbox。我擷取了 HackMD 的這段程式邏輯，若想看詳細的原始碼可至 HackMD 的原始碼內的 public/js/extra.js 檔案中的第 263 行左右：12345678910111213141516if (/^\\s*\\[[x ]\\]\\s*/.test(html)) &#123; li.innerHTML = html .replace( /^\\s*\\[ \\]\\s*/, `&lt;input type=\"checkbox\" class=\"task-list-item-checkbox\" $&#123;disabled&#125;&gt;&lt;label&gt;&lt;/label&gt;`, ) .replace( /^\\s*\\[x\\]\\s*/, `&lt;input type=\"checkbox\" class=\"task-list-item-checkbox\" checked $&#123;disabled&#125;&gt;&lt;label&gt;&lt;/label&gt;`, ); if (li.tagName.toLowerCase() !== 'li') &#123; li.parentElement.setAttribute('class', 'task-list-item'); &#125; else &#123; li.setAttribute('class', 'task-list-item'); &#125;&#125;設定 _config.yml將下面這些設定在根目錄的 _config.yml 設定檔中：123456789101112131415161718192021222324252627282930313233343536373839# Markdown-it config# Docs: https://github.com/hexojs/hexo-renderer-markdown-it/wikimarkdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-deflist - markdown-it-imsize - markdown-it-mark - markdown-it-regexp - markdown-it-task-checkbox - name: markdown-it-container options: success - name: markdown-it-container options: info - name: markdown-it-container options: warning - name: markdown-it-container options: danger - markdown-it-deflist - name: markdown-it-emoji options: shortcuts: &#123;&#125; anchors: level: 1 collisionSuffix: 'v' permalink: true permalinkClass: header-anchor permalinkSymbol: ''想了解設定詳情可參考 Advanced Configuration | hexojs/hexo-renderer-markdown-it Wiki 官方文件。","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"}],"tags":[{"name":"Markdown","slug":"markdown","permalink":"https://titangene.github.io/tags/markdown/"},{"name":"Hexo","slug":"hexo","permalink":"https://titangene.github.io/tags/hexo/"}]},{"title":"Flutter 載入圖片","slug":"flutter-loading-images","date":"2018-12-31T13:10:00.000Z","updated":"2019-04-30T15:57:23.428Z","comments":true,"path":"article/flutter-loading-images.html","link":"","permalink":"https://titangene.github.io/article/flutter-loading-images.html","excerpt":"要如何在 Flutter 內載入圖片？這篇做個小記錄。","text":"要如何在 Flutter 內載入圖片？這篇做個小記錄。指定資源Flutter 是在根目錄內的 pubspec.yaml 檔案來設定應用程式所需的資源，設定的資源沒有順序關係。若要指定某些資源，資源的路徑是相對於 pubspec.yaml 檔案的相對路徑：1234flutter: assets: - assets/images/avatar.jpg - assets/images/background.jpg也可以指定某個目錄，代表可以存取到這個目錄下的所有資源，但記得要在目錄的最後加上 / 這個符號：123flutter: assets: - assets/若要存取子目錄內的資源，請記得要另外為子目錄設定，例如：1234flutter: assets: - assets/ - assets/images/載入圖片可使用 Image.asset() 來載入圖片，裡面的參數就是圖片的路徑：12345Widget build(BuildContext context) &#123; // ... return Image.asset('assets/images/background.jpg'); // ...&#125;或是在 Image() 內的 image 參數使用 AssetImage()：1234567Widget build(BuildContext context) &#123; // ... return Image( image: AssetImage('assets/images/background.jpg'), ); // ...&#125;最後顯示的結果會一樣：參考連結Adding assets and images - Flutter","categories":[{"name":"Flutter","slug":"flutter","permalink":"https://titangene.github.io/categories/flutter/"},{"name":"Mobile App","slug":"flutter/mobile-app","permalink":"https://titangene.github.io/categories/flutter/mobile-app/"}],"tags":[{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"}]},{"title":"Python - 日誌 (logging) 模組","slug":"python-logging","date":"2018-12-13T10:32:46.000Z","updated":"2019-04-30T15:55:01.854Z","comments":true,"path":"article/python-logging.html","link":"","permalink":"https://titangene.github.io/article/python-logging.html","excerpt":"開發 Python 時，很常使用 print() 來輸出變數以方便 debug，但要部署時，不需要這些訊息，需要自己手動去註解或刪除那些放在各處的 print()。而 Python 內建提供了 logging 模組可以用來取代 print()，logging 除了可以輸出訊息，也可以將訊息儲存至日誌檔保存。下面紀錄如何使用 logging 模組。","text":"開發 Python 時，很常使用 print() 來輸出變數以方便 debug，但要部署時，不需要這些訊息，需要自己手動去註解或刪除那些放在各處的 print()。而 Python 內建提供了 logging 模組可以用來取代 print()，logging 除了可以輸出訊息，也可以將訊息儲存至日誌檔保存。下面紀錄如何使用 logging 模組。載入 logging 模組1import logginglogging 等級logging 模組預先定義了 6 種等級以及對應的 log 輸出函數 (除了 logging.NOTSET 沒有對應的輸出函數)：等級等級數值輸出函數說明NOTSET0無對應的輸出函數未設定DEBUG10logging.debug()除錯INFO20logging.info()訊息WARNING30logging.warning()警告ERROR40logging.error()錯誤CRITICAL50logging.critical()嚴重錯誤若要查詢各等級的數值，可直接呼叫該等級：12345678import loggingprint(logging.NOTSET) # 0print(logging.DEBUG) # 10print(logging.INFO) # 20print(logging.WARNING) # 30print(logging.ERROR) # 40print(logging.CRITICAL) # 50若要用等級數值來查詢是哪個等級的訊息，可使用 logging.getLevelName(level)：12345678import loggingprint(logging.getLevelName(0)) # NOTSETprint(logging.getLevelName(10)) # DEBUGprint(logging.getLevelName(20)) # INFOprint(logging.getLevelName(30)) # WARNINGprint(logging.getLevelName(40)) # ERRORprint(logging.getLevelName(50)) # CRITICAL輸出 logginglogging 模組預設等級為 WARNING，大於或等於 WARNING 等級的訊息才會被記錄：1234567import logginglogging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是輸出結果，可以看到比 WARNING 等級還要低的訊息有 DEBUG 和 INFO 就不會被輸出：123WARNING:root:warning messageERROR:root:error messageCRITICAL:root:critical message若將等級設為 DEBUG，就會將所有等級的訊息都輸出：123456789import logginglogging.basicConfig(level=logging.DEBUG)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是輸出結果，預設的訊息輸出格式是 %(levelname)s:%(name)s:%(message)s (後面會介紹如何自訂輸出格式)：12345DEBUG:root:debug messageINFO:root:info messageWARNING:root:warning messageERROR:root:error messageCRITICAL:root:critical message紀錄堆疊追蹤資訊logging 模組也提供可以紀錄完整的堆疊追蹤 (stack traces)，若在 logging.error() 加上 exc_info 參數，並將該參數設為 True，就可以紀錄 Exception，如下：123456import loggingtry: x = 5 / 0except: logging.error(\"Catch an exception.\", exc_info=True)下面是輸出結果：12345ERROR:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zero若沒有加上 exc_info=True 則無法紀錄 Exception：123456import loggingtry: x = 5 / 0except: logging.error(\"Catch an exception.\")下面是輸出結果：1ERROR:root:Catch an exception.若要在 logging 內紀錄 exception 訊息，可使用 logging.exception()，它會將 exception 添加至訊息中，此方法的等級為 ERROR，也就是說 logging.exception() 就等同於 logging.error(exc_info=True)123456import loggingtry: x = 5 / 0except: logging.exception('Catch an exception.')輸出結果和 logging.error(exc_info=True) 相同：12345ERROR:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zero若不想使用 ERROR 級別紀錄 exception 訊息，可使用 DEBUG、INFO、WARNING、CRITICAL 級別並加上參數 exc_info=True 的設定：1234567891011import logginglogging.basicConfig(level=logging.DEBUG)try: x = 5 / 0except: logging.debug('Catch an exception.', exc_info=True) logging.info('Catch an exception.', exc_info=True) logging.warning('Catch an exception.', exc_info=True) logging.critical('Catch an exception.', exc_info=True)下面是輸出結果：1234567891011121314151617181920DEBUG:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zeroINFO:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zeroWARNING:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zeroCRITICAL:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zero自訂 logging 輸出格式預設的訊息輸出格式只有 levelname、name、message，下面是其他相關的資訊：格式化字串說明%(asctime)s日期時間, 格式為 YYYY-MM-DD HH:mm:SS,ms，例如：2018-12-13 17:20:30,567%(filename)s模組檔名%(funcName)s函數名稱%(levelname)s日誌的等級名稱%(levelno)s日誌的等級數值%(lineno)d呼叫日誌函數所在的行數%(message)s訊息%(module)s模組名稱%(name)slogger 的名稱%(pathname)s檔案的完整路徑 (如果可用)%(process)dprocess ID (如果可用)%(thread)d執行緒 ID (如果可用)%(threradName)s執行緒名稱可將這些資訊加入 logging.basicConfig() 內的 format 參數：12345678910import loggingFORMAT = '%(asctime)s %(levelname)s: %(message)s'logging.basicConfig(level=logging.DEBUG, format=FORMAT)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是自訂訊息的輸出結果：123452018-12-13 17:40:34,604 DEBUG: debug message2018-12-13 17:40:34,604 INFO: info message2018-12-13 17:40:34,604 WARNING: warning message2018-12-13 17:40:34,604 ERROR: error message2018-12-13 17:40:34,608 CRITICAL: critical message自訂輸出的時間格式在 logging.basicConfig() 內的 datefmt 參數可設定所需的時間格式，要使用 time.strftime() 接受的時間格式：參數說明%Y長年份，例如：2019%y短年份，例如：19%m月份：01 ~ 12%B月份完整名稱，例如：February%b月份縮寫名稱，例如：Feb%d日期：01 ~ 31%H小時 (24 小時制)：00 ~ 23%I小時 (12 小時制)：01 ~ 12%w星期：0 ~ 6，0 代表星期日%A星期完整名稱，例如：Friday%a星期縮寫名稱，例如：Fri%PAM 或 PM%M分鐘：00 ~ 59%S秒：00 ~ 61time.strftime() 的時間參數詳情可參考 Python 官方的 time — Time access and conversions — Python 3.7.2 documentation 文件。1234567891011import loggingLOGGING_FORMAT = '%(asctime)s %(levelname)s: %(message)s'DATE_FORMAT = '%Y%m%d %H:%M:%S'logging.basicConfig(level=logging.DEBUG, format=LOGGING_FORMAT, datefmt=DATE_FORMAT)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是自訂訊息的輸出結果：1234520190107 08:57:07 DEBUG: debug message20190107 08:57:07 INFO: info message20190107 08:57:07 WARNING: warning message20190107 08:57:07 ERROR: error message20190107 08:57:07 CRITICAL: critical message儲存 logging只要在 logging.basicConfig() 內的 filename 參數設定要儲存的日誌檔名，就可以將 logging 儲存：12345678910import loggingFORMAT = '%(asctime)s %(levelname)s: %(message)s'logging.basicConfig(level=logging.DEBUG, filename='myLog.log', filemode='w', format=FORMAT)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')預設 filemode 參數是設為 a，代表 append (附加) 的意思，每次執行程式時，Logging 會將新的訊息加在舊的訊息後面，不會覆蓋舊的訊息。若要改成新訊息覆蓋就訊息，那可以將 filemode 參數設為 w，代表 write 的意思。下面是剛剛執行後儲存的 myLog.log 日誌檔：123452018-12-13 17:47:18,686 DEBUG: debug message2018-12-13 17:47:18,687 INFO: info message2018-12-13 17:47:18,687 WARNING: warning message2018-12-13 17:47:18,687 ERROR: error message2018-12-13 17:47:18,687 CRITICAL: critical message詳情可參考官方文件 Logging facility for Python — Python documentation。","categories":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"}],"tags":[{"name":"Logging","slug":"logging","permalink":"https://titangene.github.io/tags/logging/"}]},{"title":"設定 Windows 工作排程定期執行 Python 爬蟲程式","slug":"set-up-windows-task-scheduler-to-periodically-execute-python-crawler","date":"2018-12-01T04:55:00.000Z","updated":"2019-04-30T15:54:19.642Z","comments":true,"path":"article/set-up-windows-task-scheduler-to-periodically-execute-python-crawler.html","link":"","permalink":"https://titangene.github.io/article/set-up-windows-task-scheduler-to-periodically-execute-python-crawler.html","excerpt":"如何將 Python 爬蟲程式定期執行？使用 Windows 的使用者可以選擇「工作排程器」來解決。","text":"如何將 Python 爬蟲程式定期執行？使用 Windows 的使用者可以選擇「工作排程器」來解決。最近有些資料想透過爬蟲來擷取，而且希望可以定期 (例如：每 10 分鐘一次) 自動執行爬蟲程式，因此就有了這篇筆記。下面介紹如何以 Windows 工作排程器來定期執行爬蟲程式。目標每 10 分鐘自動執行 Python 爬蟲程式，將爬蟲抓到的最新降雨量資料存入 CSV 檔內收集。準備WindowsPython 環境：建議安裝 Anaconda，可參考 用 Conda 建立虛擬環境和管理相依套件Python 套件 (這是本篇爬蟲範例所需的相依套件，可依各自需求來選擇)PandasNumpyRequestsPython 爬蟲程式原始碼source code: titangene/cwb-opendata-crawler-demo/crawler.py簡單說明一下程式的執行步驟：利用 Python 的 Requests 套件來建立 HTTP 的 GET 請求，從中央氣象局提供的開放資料 API 中取得資料，回傳的格式是 JSON解析 API 回傳的 JSON 資料，並將 JSON 轉成 Pandas 的 DataFrame 型別的資料格式將 DataFrame 儲存成 CSV 檔保存資料若想了解中央氣象局開放資料的相關內容，詳情可參考 中央氣象局開放資料 - 開發指南。Python 爬蟲程式的批次檔建立一個副檔名為 .bat 的批次檔，批次檔是用來執行 Python 爬蟲程式，因此就能讓 Windows 工作排程器在定期時間自動執行批次檔，以達成自動化執行爬蟲的目的。下面就來說明批次檔每行都做了甚麼：第一行：切到指定目錄第二行：指定 Python 虛擬環境 (可參考 用 Conda 建立虛擬環境和管理相依套件。如果要在全域環境下執行就不需要這行)第三行：執行 Python 爬蟲程式第四行：若想查看 Python 爬蟲程式執行過程中所輸出 (也就是執行 print 方法的部分) 內容，就需要取消這行的註解REM：單行註解pause：用來暫停批次檔的執行1234cd /d D:/Project/Python/cwb-opendata-crawlercall activate devcall python crawler.pyREM pausesource code: titangene/cwb-opendata-crawler-demo/crawler.batWindows 工作排程器 簡介可預先設定工作在特定時間或指定時間時，會自動執行程式或批次檔以達成工作自動化。下圖為 Windows 10 的工作排程器介面：建立工作，設定定期執行爬蟲程式開啟 Windows 的「工作排程器」，點擊右上角的「建立工作」自訂工作名稱，若有權限需求可勾選「以最高權限執行」選項接著新增「觸發程序」設定工作的開始時間，並選擇「僅一次」，以及設定工作要每隔多久就執行一次，並且要持續多久時間然後新增「動作」設定要自動執行的程式，這邊選擇的就是剛剛提到的 批次檔 (原始碼)如果設定好了就可以按確定完成建立工作，此時就會看到在「工作排程器程式庫」內的工作清單中，多了剛剛新增的工作成果可以看到爬蟲程式會在定期自動執行，執行的時候會跳出一個 cmd 視窗。若剛剛提到的 批次檔 內沒有將 REM pause 這行註解，就會看到爬蟲程式執行完成後，不會自動關閉 cmd 視窗，這是為了可以立即看到該次爬蟲執行過程中輸出的訊息。下圖就是自動執行爬蟲所抓到的資料：完整 source code：titangene/cwb-opendata-crawler-demo","categories":[{"name":"Windows","slug":"windows","permalink":"https://titangene.github.io/categories/windows/"},{"name":"Python","slug":"windows/python","permalink":"https://titangene.github.io/categories/windows/python/"},{"name":"Crawler","slug":"windows/python/crawler","permalink":"https://titangene.github.io/categories/windows/python/crawler/"},{"name":"OS","slug":"windows/python/crawler/os","permalink":"https://titangene.github.io/categories/windows/python/crawler/os/"}],"tags":[{"name":"Python Requests","slug":"python-requests","permalink":"https://titangene.github.io/tags/python-requests/"},{"name":"Windows 工作排程","slug":"windows-工作排程","permalink":"https://titangene.github.io/tags/windows-工作排程/"}]},{"title":"用 Conda 建立虛擬環境和管理相依套件","slug":"create-a-virtual-environment-and-manage-dependencies-with-conda","date":"2018-11-19T09:10:00.000Z","updated":"2019-05-12T07:21:26.188Z","comments":true,"path":"article/create-a-virtual-environment-and-manage-dependencies-with-conda.html","link":"","permalink":"https://titangene.github.io/article/create-a-virtual-environment-and-manage-dependencies-with-conda.html","excerpt":"學習如何利用 Conda 來建立不同需求所需的 Python 開發環境，並如何管理相依套件。","text":"學習如何利用 Conda 來建立不同需求所需的 Python 開發環境，並如何管理相依套件。AnacondaAnaconda 是最受歡迎的 Python 資料科學 (Data Science) 平台，它特點就是本來就包含了各種數據分析、科學計算的相關套件 (例如：NumPy、SciPy、Matplotlib、SymPy、Pandas … 等)，而 Anaconda 的套件管理工具就是 conda。CondaConda 是一個開源的套件與環境管理的系統，可以在 Windows、macOS 和 Linux 上使用。可利用 Conda 來安裝、執行、更新套件以及其相依的套件，並且還可用來建立不同的開發環境 (例如：不同環境有不同的 Python 版本)。安裝 Anaconda至 Anaconda 官網下載並安裝，建議選擇 Python 3.x 的版本。建立虛擬環境從指定套件列表中建立新的 conda 環境：-n，--name：設定環境名稱1234567$ conda create -n &lt;environment&gt; &lt;package&gt;# 安裝包含 Anaconda 發行版的套件$ conda create -n &lt;environment&gt; anaconda# 指定 Python 版本$ conda create -n &lt;environment&gt; python=3.6-e，--envs：列出已建立的環境123456# 顯示虛擬環境列表，並顯示正在使用的虛擬環境$ conda info -e# conda environments:#base * D:\\Users\\Titan\\Anaconda3hello D:\\Users\\Titan\\Anaconda3\\envs\\hello使用或 activate 至指定環境：12345# Windows$ activate &lt;environment&gt;# Linux and macOS$ source activate &lt;environment&gt;123456# 顯示虛擬環境列表，並顯示正在使用的虛擬環境$ conda info -e# conda environments:#base D:\\Users\\Titan\\Anaconda3hello * D:\\Users\\Titan\\Anaconda3\\envs\\hello* 代表目前正在使用的虛擬環境離開虛擬環境如果要將現在環境改回預設值 base (離開目前環境) 可使用下面指令：12345# Windows$ deactivate# Linux and macOS$ source deactivate利用 conda 安裝套件1234$ conda install &lt;package&gt;# 安裝多個套件$ conda install &lt;package-1&gt; &lt;package-2&gt;查看資訊查看 conda 目前版本12$ conda -Vconda 4.5.11查看目前環境已安裝的套件123456789101112$ conda list# packages in environment at D:\\Users\\Titan\\Anaconda3:## Name Version Build Channel...jupyter 1.0.0 py35_3jupyter_client 5.2.3 py35_0jupyter_console 4.1.1 py35_0jupyter_core 4.4.0 py35h629ba7f_0jupyterlab 0.32.1 &lt;pip&gt;jupyterlab-launcher 0.10.5 &lt;pip&gt;...查看 conda 是否有某套件：12345678$ conda search &lt;package&gt;$ conda search pandasLoading channels: done# Name Version Build Channelpandas 0.9.0 np16py27_0 pkgs/freepandas 0.9.1 np16py27_0 pkgs/free...如果 conda 沒有該套件，可以使用 pip 來安裝套件：12345# 安裝套件$ pip install &lt;package&gt;# 更新套件$ pip install --upgrade &lt;package&gt;刪除套件12345678# 刪除環境內的套件$ conda remove -n &lt;environment&gt; &lt;package&gt;# 刪除目前環境內的套件$ conda remove &lt;package&gt;# 刪除多個套件$ conda remove &lt;package-1&gt; &lt;package-2&gt;更新套件1234567891011# 更新 conda$ conda update conda# 更新 Anaconda$ conda update anaconda# 更新 Python$ conda update python# 更新特定套件$ conda update &lt;package&gt;刪除虛擬環境1$ conda env remove -n &lt;environment&gt;更新 Python更新全域環境若目前 Python 版本是 3.6.1，下面指令只會將 Python 更新至 3.6.x 的最新版本：1$ conda update python若是要更新到其他版本可指定 Python 版本：1$ conda install python=3.6更新 Anaconda更新套件管理器：1$ conda update conda注意：Conda 會更新該版本列表中的最高版本，因此 Python 2.7 更新到 2.x 中的最高版本，而 3.x 系列依此類推。更新 anaconda 此 meta-package，可更新 Anaconda 發行版包含的套件：1$ conda update anaconda如果要更新 Python 的特定版本：1$ conda install python==$pythonversion$參考連結Managing packages | Conda documentationmacos - How do I upgrade to Python 3.6 with conda? - Stack Overflow","categories":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"}],"tags":[{"name":"Anaconda","slug":"anaconda","permalink":"https://titangene.github.io/tags/anaconda/"},{"name":"Conda","slug":"conda","permalink":"https://titangene.github.io/tags/conda/"},{"name":"Virtual Environment","slug":"virtual-environment","permalink":"https://titangene.github.io/tags/virtual-environment/"},{"name":"Package Management","slug":"package-management","permalink":"https://titangene.github.io/tags/package-management/"}]},{"title":"Windows Subsystem for Linux (WSL)","slug":"windows-subsystem-for-linux","date":"2018-11-17T11:00:45.000Z","updated":"2019-04-30T16:01:29.511Z","comments":true,"path":"article/windows-subsystem-for-linux.html","link":"","permalink":"https://titangene.github.io/article/windows-subsystem-for-linux.html","excerpt":"Windows Subsystem for Linux (簡稱 WSL)，由 Microsoft 與 Canonical 公司合作開發，可直接在 Windows 10 中建立一個 Linux 子系統，原生執行 Linux，還可自行選擇你想安裝的 Linux 發行版，例如：Ubuntu、Kali Linux、SUSE。","text":"Windows Subsystem for Linux (簡稱 WSL)，由 Microsoft 與 Canonical 公司合作開發，可直接在 Windows 10 中建立一個 Linux 子系統，原生執行 Linux，還可自行選擇你想安裝的 Linux 發行版，例如：Ubuntu、Kali Linux、SUSE。啟用 Windows Subsystem for Linux使用系統管理者權限開啟 PowerShell，並執行下面命令啟用 Windows Subsystem for Linux 功能：1$ Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux如果顯示下面訊息就代表你沒有使用系統管理員開啟 PowerShell：123456Enable-WindowsOptionalFeature : 要求的作業需要提升的權限。位於 線路:1 字元:1+ Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows- ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Enable-WindowsOptionalFeature], COMException + FullyQualifiedErrorId : Microsoft.Dism.Commands.EnableWindowsOptionalFeatureCommand接著等他跑一下…：接著他會問是否要重啟電腦，因為預設是 Yes，所以可以直接按 Enter：其實上面指令就等於去「控制台 &gt; 程式集 &gt; 開啟或關閉 Windows 功能」開啟「適用於 Linux 的 Windows 子系統」。安裝 Linux 發行版系統組建 (build) 必須要 Windows build 16215 或更新版本。若要想知道系統組建，可至 Windows 的「設定」內的「關於」即可查看。你可以選擇你想安裝的 Linux 發行版：Ubuntu 16.04 LTSUbuntu 18.04 LTSDebian GNU/LinuxOpenSUSE Leap 42SUSE Linux Enterprise Server 12Kali Linux如果在安裝後直接開啟 Ubuntu，就會顯示 Error: 0x8007007e 錯誤就代表你沒有啟用 Windows Subsystem for Linux 功能，詳情請參考上面：1234The WSL optional component is not enabled. Please enable it and try again.See https://aka.ms/wslinstall for details.Error: 0x8007007ePress any key to continue...安裝後啟動 Linux 發行版，此時會開啟一個 console 視窗。因為是第一次開啟，所以會先安裝 WSL，等它安裝完後，就會看到下面畫面，系統要你建立一個新的 Unix 使用者名稱：12345Installing, this may take a few minutes...Installation successful!Please create a default UNIX user account. The username does not need to match your Windows username.For more information visit: https://aka.ms/wslusersEnter new UNIX username:接著是設定此使用者的密碼，這邊的使用者與你的 Windows 使用者名稱和密碼沒有任何關係。詳情可參考官方的 Linux User Account and Permissions | Microsoft Docs 文件。如果顯示 $ 就代表設定完成囉！執行 lsb_release -a 指令就會看到 Linux 的系統版本：在其他終端使用 Bash如果在使用 CMD 、 PowerShell 或其他終端 (例如我常用的 Cmder) 時想用 bash shell，可使用 bash 指令就可以啟動新的 Ubuntu shell：1$ bash存取目錄如果想存取 D:\\project，在此環境下的路徑就是 /mnt/d/project。小結如果有在跨平台開發或維運的朋友，這個功能應該是一直以來的願望吧？讓你在 Windows 上可以直接處理事情，不用再多開 VM 來使用，不只省資源，也省硬碟空間，重點是不用等 VM 開機…參考連結Install the Linux Subsystem on Windows 10 | Microsoft Docs【WSL】Windows Subsystem for Linux 安裝及基本配置！ | 台灣微軟學生大使Bash on Ubuntu on Windows 的簡單使用 | Heresy’s Space","categories":[{"name":"Linux","slug":"linux","permalink":"https://titangene.github.io/categories/linux/"},{"name":"Windows","slug":"linux/windows","permalink":"https://titangene.github.io/categories/linux/windows/"}],"tags":[{"name":"Ubuntu","slug":"ubuntu","permalink":"https://titangene.github.io/tags/ubuntu/"},{"name":"WSL","slug":"wsl","permalink":"https://titangene.github.io/tags/wsl/"}]},{"title":"GitHub 縮網址服務 Git.io","slug":"github-url-shortener","date":"2018-10-31T16:58:19.000Z","updated":"2019-02-07T11:20:54.891Z","comments":true,"path":"article/github-url-shortener.html","link":"","permalink":"https://titangene.github.io/article/github-url-shortener.html","excerpt":"最近發現原來 Github 也有提供縮網址 (URL Shortener) 服務「Git.io」，它只適用於 gist.github.com 及 github.com 兩個 hostname。","text":"最近發現原來 Github 也有提供縮網址 (URL Shortener) 服務「Git.io」，它只適用於 gist.github.com 及 github.com 兩個 hostname。下列網址都可以透過 Git.io 來建立縮網址：Github 個人或組織專業 ( https://github.com/&lt;github-id&gt; )Github repository ( https://github.com/&lt;github-id&gt;/&lt;repo-name&gt; ) 或 repository 內目錄或檔案Gist ( https://gist.github.com/&lt;github-id&gt;/&lt;gist-id&gt; )Git.io 有兩種建立短網址的方法，下面會分別介紹：直接到 Git.io 線上設定使用 curl 指令設定：Git.io: GitHub URL Shortener | GitHub BlogGit.io 線上設定最簡單的方法當然是直接打開 Git.io，接著輸入網址並點擊「shorten」按鈕就會將你剛剛輸入的網址變成短網址，短網址的格式是 git.io/xxx。但缺點是無法自訂短網址名稱，預設是自動隨機英文 + 數字的字串。使用 curl 指令建立短網址-i、--include：顯示 HTTP response headers-F、--form &lt;name=content&gt;：設定表單資料，Content-Type 會被設為 multipart/form-data1$ curl -i https://git.io -F \"url=&lt;想縮短的網址&gt;\" -F \"code=&lt;自訂短網址名稱&gt;\"例如我想將自己的 Github profile URL：github.com/titangene 縮短成 git.io/titan，就要執行下面指令：1234567$ curl -i https://git.io -F \"url=https://github.com/titangene\" -F \"code=titan\"HTTP/1.1 201 Created...Location: https://git.io/titan...$ curl -i https://git.io -F \"url=https://titangene.github.io/\" -F \"code=titan-blog\"只要輸入下面指令就可以確認是否建立成功12345$ curl -i https://git.io/titanHTTP/1.1 302 Found...Location: https://github.com/titangene...[小插曲] 縮網址不小心設定錯誤一開始在 Git.io 測試時，直接用自己的 Github profile URL ( github.com/titangene ) 來產生預設隨機英文 + 數字的短網址，想要修改成 git.io/titan 卻沒辦法！這是因為 Git.io 沒有直接提供修改短網址的功能。後來 Google 一下才發現只能聯繫 Github 客服來幫忙刪除短網址，然後再自行重新設定。過了不到半天客服就回信幫我解決了！真是太感謝 Github 客服了！","categories":[{"name":"Other","slug":"other","permalink":"https://titangene.github.io/categories/other/"}],"tags":[{"name":"Github","slug":"github","permalink":"https://titangene.github.io/tags/github/"},{"name":"URL","slug":"url","permalink":"https://titangene.github.io/tags/url/"},{"name":"URL Shortener","slug":"url-shortener","permalink":"https://titangene.github.io/tags/url-shortener/"}]},{"title":"Flutter 自訂字型","slug":"flutter-custom-fonts","date":"2018-10-29T03:40:00.000Z","updated":"2019-04-30T15:57:38.523Z","comments":true,"path":"article/flutter-custom-fonts.html","link":"","permalink":"https://titangene.github.io/article/flutter-custom-fonts.html","excerpt":"雖然 Android 和 iOS 內建都有字型，但常有自訂字型的需求，所以這篇會教你如何在 Flutter 使用自訂字型。","text":"雖然 Android 和 iOS 內建都有字型，但常有自訂字型的需求，所以這篇會教你如何在 Flutter 使用自訂字型。將字型檔放入專案資料夾內此範例是放在 ./assets/fonts 資料夾內：1234567assets/ fonts/ FiraCode-Medium.ttf mononoki-Bold.ttf mononoki-BoldItalic.ttf mononoki-Italic.ttf mononoki-Regular.ttf在 pubspec.yaml 定義字型資訊123456789101112131415flutter: fonts: - family: FiraCode fonts: - asset: assets/fonts/FiraCode-Medium.ttf - family: Mononoki fonts: - asset: assets/fonts/mononoki-Regular.ttf - asset: assets/fonts/mononoki-Bold.ttf weight: 700 - asset: assets/fonts/mononoki-Italic.ttf style: italic - asset: assets/fonts/mononoki-BoldItalic.ttf weight: 700 style: italic設定預設字型12345MaterialApp( title: 'Custom Fonts', theme: ThemeData(fontFamily: 'FiraCode'), home: MyHomePage(title: 'Custom Fonts'),);在特定 Widget 設定字型123456789Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontWeight: FontWeight.w700, fontStyle: FontStyle.italic, ),)完整範例程式碼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Custom Fonts', theme: new ThemeData( primarySwatch: Colors.blue, fontFamily: 'FiraCode', ), home: new MyHomePage(title: 'Custom Fonts'), ); &#125;&#125;class MyHomePage extends StatelessWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(this.title), ), body: Column( children: &lt;Widget&gt;[ new Text( '&lt;-- Custom Fonts -&gt;&gt;', style: TextStyle(fontSize: 30.0), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, ), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontWeight: FontWeight.w700, ), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontStyle: FontStyle.italic, ), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontWeight: FontWeight.w700, fontStyle: FontStyle.italic, ), ), ], ), ); &#125;&#125;詳情可參考 Using custom fonts - Flutter 官方文件","categories":[{"name":"Flutter","slug":"flutter","permalink":"https://titangene.github.io/categories/flutter/"},{"name":"Mobile App","slug":"flutter/mobile-app","permalink":"https://titangene.github.io/categories/flutter/mobile-app/"}],"tags":[{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"},{"name":"Font","slug":"font","permalink":"https://titangene.github.io/tags/font/"}]},{"title":"Flutter 環境建置 (Windows)","slug":"flutter-install-on-windows","date":"2018-10-22T22:58:44.000Z","updated":"2019-04-30T15:57:33.487Z","comments":true,"path":"article/flutter-install-on-windows.html","link":"","permalink":"https://titangene.github.io/article/flutter-install-on-windows.html","excerpt":"最近剛接觸 Flutter，於是就把在 Windows 上建置環境的記錄寫成一篇筆記，裡面包括 Android Studio 和 VS Code 的開發流程。","text":"最近剛接觸 Flutter，於是就把在 Windows 上建置環境的記錄寫成一篇筆記，裡面包括 Android Studio 和 VS Code 的開發流程。詳情可參考官方連結：Get Started: Install on Windows | Flutter系統要求OS：Windows 7 SP1 或以上 (64-bit)硬碟空間：400 MB (不包括 IDE 和工具的空間)工具PowerShell 5.0 或更新版Git for Windows (勾選 Use Git from the Windows Command Prompt 選項，若沒打勾可自行將 Git 安裝目錄內的 bin 資料夾設定為 Path 環境變數，預設目錄為 C:\\Program Files\\Git\\bin )安裝 Flutter SDK下載 Flutter SDK，可下載歷史版本，但建議安裝新版。解壓檔內有一個 flutter 資瞭夾，將此資料夾放在 Flutter SDK 所需的安裝目錄 (e.g D:\\dev\\flutter，請勿將 flutter 資瞭夾放在需要提高權限之類的目錄內，e.g. C:\\Program Files\\ )。將 flutter\\bin 的完整目錄 (e.g. D:\\dev\\flutter\\bin ) 加入 Path 環境變數 (各完整路徑記得用 ; 分號分隔)接著就可以在 Console 內執行 Flutter commands執行 flutter --version 指令確定已成功安裝 Flutter SDK12345$ flutter --versionFlutter 0.7.3 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 3b309bda07 (12 days ago) • 2018-08-28 12:39:24 -0700Engine • revision af42b6dc95Tools • Dart 2.1.0-dev.1.0.flutter-ccb16f7282之後請定期執行 flutter upgrade 指令更新 Flutter (因為目前還在 beta，大約幾週就會有新版)執行 flutter --version 指令後，若看到下面畫面就代表現在有新版可以更新：123456789101112$ flutter --version ╔════════════════════════════════════════════════════════════════════════════╗ ║ A new version of Flutter is available! ║ ║ ║ ║ To update to the latest version, run \"flutter upgrade\". ║ ╚════════════════════════════════════════════════════════════════════════════╝Flutter 0.7.3 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 3b309bda07 (3 weeks ago) • 2018-08-28 12:39:24 -0700Engine • revision af42b6dc95Tools • Dart 2.1.0-dev.1.0.flutter-ccb16f7282執行 flutter upgrade 指令更新 Flutter：123456789101112131415161718$ flutter upgradeUpgrading Flutter from D:\\dev\\flutter......Flutter 0.7.3 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 3b309bda07 (3 weeks ago) • 2018-09-07 12:33:05 -0700Engine • revision 58a1894a1cTools • Dart 2.1.0-dev.1.0.flutter-ccb16f7282Running flutter doctor...Doctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.8.2, on Microsoft Windows [Version 10.0.17134.285], locale zh-TW)[√] Android toolchain - develop for Android devices (Android SDK 28.0.2)[√] Android Studio (version 3.1)[√] VS Code (version 1.27.2)[!] Connected devices ! No devices available! Doctor found issues in 1 category.在執行一次 flutter --version 確認已更新至新的版本：12345$ flutter --versionFlutter 0.8.2 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 5ab9e70727 (13 days ago) • 2018-09-07 12:33:05 -0700Engine • revision 58a1894a1cTools • Dart 2.1.0-dev.3.1.flutter-760a9690c2flutter doctor下面指令是用來查看是否需要安裝任何依賴才能完成設定，因此他會檢查你的環境並顯示檢查報告：1$ flutter doctorDart SDK is bundled with Flutter，不用另外安裝 Dart。從檢查報告的輸出中可以了解需要安裝的其他軟體或執行的其他任務 (以粗體顯示)。例如：123456789101112$ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.7.3, on Microsoft Windows [Version 10.0.17134.228], locale zh-TW)[!] Android toolchain - develop for Android devices (Android SDK 28.0.2) X Android license status unknown.[√] Android Studio (version 3.1) X Flutter plugin not installed; this adds Flutter specific functionality. X Dart plugin not installed; this adds Dart specific functionality.[!] Connected devices ! No devices available! Doctor found issues in 2 categories.下面會介紹如何執行這些任務並完成設定過程。可再次執行 flutter doctor 指令來驗證是否已正確設定所有內容。如果已驗證設定所有內容，就會看到下面輸出結果：12345678$ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.7.3, on Microsoft Windows [Version 10.0.17134.285], locale zh-TW)[√] Android toolchain - develop for Android devices (Android SDK 28.0.2)[√] Android Studio (version 3.1)[√] Connected devices (1 available)• No issues found!加上參數 -v，可以看更詳細的驗證說明：1234567891011121314151617181920212223242526$ flutter doctor -v[√] Flutter (Channel beta, v0.7.3, on Microsoft Windows [Version 10.0.17134.285], locale zh-TW) • Flutter version 0.7.3 at D:\\dev\\flutter • Framework revision 3b309bda07 (3 weeks ago), 2018-08-28 12:39:24 -0700 • Engine revision af42b6dc95 • Dart version 2.1.0-dev.1.0.flutter-ccb16f7282[√] Android toolchain - develop for Android devices (Android SDK 28.0.2) • Android SDK at C:\\Users\\Titan\\AppData\\Local\\Android\\sdk • Android NDK location not configured (optional; useful for native profiling support) • Platform android-28, build-tools 28.0.2 • ANDROID_HOME = C:\\Users\\Titan\\AppData\\Local\\Android\\sdk • Java binary at: C:\\Program Files\\Android\\Android Studio\\jre\\bin\\java • Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1024-b02) • All Android licenses accepted.[√] Android Studio (version 3.1) • Android Studio at C:\\Program Files\\Android\\Android Studio • Flutter plugin version 28.0.1 • Dart plugin version 173.4700 • Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1024-b02)[√] Connected devices (1 available) • SM N950F • 988a98444d********** • android-arm64 • Android 8.0.0 (API 26)• No issues found!Android 設定Flutter 依賴於 Android Studio 以提供 Android 平台的依賴性。但也可以使用其他編輯器來寫 Flutter App。安裝 Java JDK安裝 JDK將 Java JDK 安裝目錄設定為 JAVA_HOME 環境變數 (e.g. C:\\Program Files\\Java\\jdk1.8.0_151 )，並在將 Java JDK 安裝目錄內的 bin 資料夾設定為 Path 環境變數 (e.g. C:\\Program Files\\Java\\jdk1.8.0_151\\bin，也可設定為 %JAVA_HOME%\\bin )安裝 Android Studio安裝 Android Studio，請安裝 Recommended (建議) 版執行 Android Studio，並瀏覽 Android Studio Setup Wizard，安裝最新的 Android SDK、Android SDK Platform-Tools、Android SDK Build-Tools，這些都是 Flutter 在開發 Android 時所必須的。將 Android SDK 目錄設定為 ANDROID_HOME 環境變數 (預設目錄為 C:\\Users\\Titan\\AppData\\Local\\Android\\sdk )定期更新 Android SDK (於 Android Studio &gt; Configure &gt; SDK Manager 安裝)設定你的 Android 裝置想在 Android 裝置上執行和測試 Flutter App，需要 Android 4.1 (API level 16) 或更高版本的 Android 設備。裝置請開啟 開發者模式 內的 USB 偵錯，詳情可參考 Configure on-device developer options | Android Developers 此 Android 官方文件安裝 Google USB Driver (限 Windows)使用 USB 線將裝置連接至電腦，如果你的裝置有出現提示，請授權你的電腦可訪問你的裝置開啟終端機，執行 flutter devices 指令以驗證 Flutter 是否成功連結 Android 裝置12345# 像我連接到 Note 8$ flutter devices1 connected device:SM N950F • 988a98444d********** • android-arm64 • Android 8.0.0 (API 26)Flutter 預設會以 adb 工具基於的 Android SDK 版本來使用，若想用其他版本的 Android SDK，可設定你所需的 Android SDK 目錄為 ANDROID_HOME 環境變數。如果執行 flutter run指令，而且成功將 App 安置手機並執行，就會看到 App 的畫面設定 Android 模擬器 (emulator)想在 Android 模擬器上執行和測試 Flutter App，請依照下面步驟：在主機上啟用 VM acceleration啟動 Android Studio &gt; Tools &gt; AVD Manager 並點選 Create Virtual Device選擇設備定義，然後點擇 Next選擇你所需的 Android 版本的 OS image，然後點選 Next (建議選擇 x86 或 x86_64 image)在 Emulated Performance 欄位請選擇 Hardware - GLES 2.0 以啟用 hardware acceleration驗證 AVD 設定是否正確，若確定請點選 Finish在 Android Virtual Device Manager 中，選擇某台模擬器並點擊 Run有關上述步驟的詳情可參考 Managing AVDs設定編輯器設定 Android Studio安裝 Flutter 和 Dart plugins (外掛)，有兩個 plugin 支援 Flutter：Flutter 外掛：支持 Flutter 開發人員工作流程 (running, debugging, hot reload … 等)Dart 外掛：提供程式碼分析 (輸入時的程式碼驗證、程式碼自動補全)安裝步驟：執行 Android Studio開啟外掛選項 (File &gt; Settings &gt; Plugins)點選 Browse repositories…，接著搜尋 Flutter 並選擇並安裝名為 Flutter 的 plugin (請注意，安裝 Flutter 外掛時會同時安裝 Dart 語言外掛)點擊 Restart Android Studio設定 VS Code安裝 Flutter plugin：安裝 Flutter 此擴充功能，並重啟 VS Code。使用 Flutter Doctor 驗證你的設定環境：按 F1 或 ctrl + shift + p 後，輸入 Flutter 並點選 Flutter: Run Flutter Doctor 即可至 OUTPUT (輸出) 查看驗證結果。使用 Android Studio 開發建立新 app在 Android Studio 中建立 Flutter 專案 ( File &gt; New &gt; New Flutter Project… )接著選擇 Flutter Application，並點選 Next請設定專案名稱、確定 Flutter SDK 目錄、設定專案儲存位置與填寫專案的簡單描述後，點選 Next最後輸入公司網域 (e.g. example.com) 後，點選 Finish 即可建立新的 Flutter 專案執行 app下圖為 Android Studio 的工具列：圖片來源：Get Started: Test Drive | Flutter在 target selector 中，選擇已執行的 Android 裝置，若當前未啟動或未連接任何 Android 裝置，選擇某一模擬器時，Android Studio 就會開啟該選擇的模擬器。如果沒有可用的裝置，可至前面介紹的 設定 Android 模擬器 段落來新建模擬器。點擊 Run 圖示執行 app稍後就會在模擬器或裝置上看到下圖的 app 畫面等待的過程中會初始化 gradlegradle 會 resolve dependencies將專案轉成 apk將 apk 安裝並執行於裝置上1234567891011121314151617181920Launching lib\\main.dart on Android SDK built for x86 64 in debug mode...Initializing gradle...Resolving dependencies...Running 'gradlew assembleDebug'...Built build\\app\\outputs\\apk\\debug\\app-debug.apk.Installing build\\app\\outputs\\apk\\app.apk...D/OpenGLRenderer( 4777): HWUI GL PipelineI/OpenGLRenderer( 4777): Initialized EGL, version 1.4D/OpenGLRenderer( 4777): Swap behavior 1D/ ( 4777): HostConnection::get() New Host Connection established 0x7073cf2e5b00, tid 4831W/OpenGLRenderer( 4777): Failed to choose config with EGL_SWAP_BEHAVIOR_PRESERVED, retrying without...D/OpenGLRenderer( 4777): Swap behavior 0D/EGL_emulation( 4777): eglCreateContext: 0x7073cf2a7600: maj 2 min 0 rcv 2D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf2a7600: ver 2 0 (tinfo 0x7073b4be9300)D/EGL_emulation( 4777): eglCreateContext: 0x7073cf3b10a0: maj 2 min 0 rcv 2D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf3b10a0: ver 2 0 (tinfo 0x7073c2fe87c0)Syncing files to device Android SDK built for x86 64...D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf2a7600: ver 2 0 (tinfo 0x7073b4be9300)D/ ( 4777): HostConnection::get() New Host Connection established 0x7073cf2e65e0, tid 4813D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf3b10a0: ver 2 0 (tinfo 0x7073c560d6c0)嘗試 hot reload修改一些內容並儲存，app 就會自動做 hot reload，就會很快地看到最新的更新。使用 VS Code 開發建立新 app按 F1 或 ctrl + shift + p 後，輸入 Flutter 並點選 Flutter: New Project輸入專案名稱後，按 enter 鍵選擇專案目錄的儲存位置等待專案建立完成，並在畫面顯示 lib/main.dart 檔案執行 app從 VS Code 底部的藍色狀態欄中點選 Device Selector若要使用實體裝置，詳情至 設定你的 Android 裝置 參考。若連結成功會在 VS Code 底部的藍色狀態欄中看到你的裝置名稱如果沒有可用的裝置，請點選 No Devices 並啟動模擬器執行 Debug等待 App 執行，可在偵錯主控台 (Debug Console) 看到執行進度，稍後就會在模擬器或裝置上看到下圖的 app 畫面使用 Terminal + Editor 開發建立新 app使用 flutter create 指令來建立 Flutter 專案，裡面包含 Material Components 的範例 app。app 的程式碼在 lib/main.dart。12$ flutter create &lt;prject-name&gt;$ cd &lt;prject-name&gt;執行 app使用 flutter devices 指令可檢查是否有正在執行的模擬器或裝置。如果沒有可用的裝置，可至前面介紹的 設定 Android 模擬器 段落來新建模擬器。1234$ flutter devices1 connected device:Android SDK built for x86 64 • emulator-5554 • android-x64 • Android 8.0.0 (API 26) (emulator)使用 flutter run 指令可執行 app，並提供以下功能的快速鍵：r：hot reloadR：hot restart (and rebuild state)h：顯示更多幫助訊息q：停止執行123456789101112131415$ flutter runUsing hardware rendering with device Android SDK built for x86 64. If you get graphics artifacts, consider enabling software rendering with \"--enable-software-rendering\".Launching lib/main.dart on Android SDK built for x86 64 in debug mode...Initializing gradle... 1.7sResolving dependencies... 48.1sRunning 'gradlew assembleDebug'... 88.5sBuilt build\\app\\outputs\\apk\\debug\\app-debug.apk.Installing build\\app\\outputs\\apk\\app.apk... 11.4sSyncing files to device Android SDK built for x86 64...D/ ( 5458): HostConnection::get() New Host Connection established 0x7073c31aabe0, tid 5513D/EGL_emulation( 5458): eglMakeCurrent: 0x7073cf3b1280: ver 2 0 (tinfo 0x7073c2ab65c0) 12.3s🔥 To hot reload changes while running, press \"r\". To hot restart (and rebuild state), press \"R\".An Observatory debugger and profiler on Android SDK built for x86 64 is available at: http://127.0.0.1:2158/For a more detailed help message, press \"h\". To quit, press \"q\".","categories":[{"name":"Windows","slug":"windows","permalink":"https://titangene.github.io/categories/windows/"},{"name":"Flutter","slug":"windows/flutter","permalink":"https://titangene.github.io/categories/windows/flutter/"},{"name":"Android","slug":"windows/flutter/android","permalink":"https://titangene.github.io/categories/windows/flutter/android/"},{"name":"Mobile App","slug":"windows/flutter/android/mobile-app","permalink":"https://titangene.github.io/categories/windows/flutter/android/mobile-app/"}],"tags":[{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"},{"name":"VS Code","slug":"vs-code","permalink":"https://titangene.github.io/tags/vs-code/"},{"name":"Android Studio","slug":"android-studio","permalink":"https://titangene.github.io/tags/android-studio/"}]},{"title":"Hexo 加入 Disqus 留言版 (包含留言數)","slug":"hexo-disqus","date":"2018-10-22T14:40:00.000Z","updated":"2019-05-12T07:25:56.244Z","comments":true,"path":"article/hexo-disqus.html","link":"","permalink":"https://titangene.github.io/article/hexo-disqus.html","excerpt":"Blog 最重要的是可以增進技術的交流，而交流就可以透過留言版來達成。大部分的 Blog 在每篇文章下面都會有留言板，而最常見的就是 Disqus 留言板，因此本篇會說明如何將 Disqus 留言板和各文章的留言數加入 Hexo 的主題中。","text":"Blog 最重要的是可以增進技術的交流，而交流就可以透過留言版來達成。大部分的 Blog 在每篇文章下面都會有留言板，而最常見的就是 Disqus 留言板，因此本篇會說明如何將 Disqus 留言板和各文章的留言數加入 Hexo 的主題中。申請網站留言版帳號至 Disqus 首頁註冊帳號後並登入，接著點擊首頁的「GET STARTED」：選擇「I want to install Disqus on my site」選項：需要輸入的欄位：Websit Name：自訂 short name，且是唯一，像我是設定 titangene-blog。short name 會在設定 Hexo 時需要Category：類別，自行選擇Language：語言，自行選擇填寫後點擊「Create Site」：設定 Hexo在 material-flow 主題內的 _config.yml 原有設定是使用 disqus_shortname 參數來設定 Disqus 的 short name：1disqus_shortname: your_disqus_short_name但我想在 blog 加上留言數，所以才將參數設定改成下面內容：enable：設定 true 或 false 來決定是否要啟用 Disqus 的留言版功能shortname：設定你的 Disqus 的 short namecount：設定 true 或 false 來決定是否要顯示文章的留言數12345# Commentsdisqus: enable: true shortname: your_disqus_short_name count: true那接著就是將 Disqus 的留言版功能加入主題中，主要分成幾個步驟：加入 Disqus script新增 Disqus 留言版新增 Disqus 留言數如果在剛剛上面的 count 參數設定為 false 則可以跳過第三個步驟 新增 Disqus 留言數。下面提供的程式碼可適用於 Hexo 的 material-flow 主題，HTML 結構可依各自使用的版型或需求來修改。若想直接看我設定的原始碼，可至此 Blog 的 GitHub Repo「titangene/hexo-blog」查看。加入 Disqus script在 themes\\material-flow\\layout\\_partial\\script\\disqus.ejs 檔案內加入以下程式碼，當頁面載入時，會以非同步的方式將 Disqus 的 script 加入 &lt;head&gt; 或 &lt;body&gt; 標籤中：1234567891011121314151617181920212223&lt;% if (config.disqus.enable) &#123; %&gt; &lt;% if (page.comments) &#123; %&gt;&lt;script&gt; var disqus_shortname = '&lt;%= config.disqus.shortname %&gt;'; var disqus_config = function() &#123; this.page.url = '&lt;%= page.permalink %&gt;'; this.page.identifier = '&lt;%= page.path %&gt;'; this.page.title = '&lt;%= page.title %&gt;'; &#125;; (function() &#123; var dsq = document.createElement('script'); dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; dsq.setAttribute('data-timestamp', '' + new Date()); (document.head || document.body).appendChild(dsq); &#125;)();&lt;/script&gt;&lt;% &#125; %&gt; &lt;% if (config.disqus.count) &#123; %&gt;&lt;script id=\"dsq-count-scr\" src=\"https://&lt;%= config.disqus.shortname %&gt;.disqus.com/count.js\" async&gt;&lt;/script&gt;&lt;% &#125; %&gt; &lt;% &#125; %&gt;接著在 themes\\material-flow\\layout\\layout.ejs 檔案內的 &lt;body&gt; 標籤中將剛剛新增的 disqus.ejs 載入：1&lt;%- partial('script/disqus') %&gt;新增 Disqus 留言版在 themes\\material-flow\\layout\\_partial\\article.ejs 檔案內找到適當的位置加入以下程式碼，就可以在文章內新增 Disqus 留言版：1234567891011&lt;% if (post.comments &amp;&amp; config.disqus.enable) &#123; %&gt;&lt;section class=\"comments\" id=\"comments\"&gt; &lt;h2&gt;留言版&lt;/h2&gt; &lt;div id=\"disqus_thread\"&gt; &lt;noscript &gt;Please enable JavaScript to view the &lt;a href=\"https://disqus.com/?ref_noscript\"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript &gt; &lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt;上面程式碼中最重要的是 &lt;div id=&quot;disqus_thread&quot;&gt; 這句，因為當頁面載入並將 Disqus 的 script 載入後，就會將此標籤內的內容取代成 Disqus 留言版，而 Disqus 留言版是使用 &lt;iframe&gt; 標籤的方式嵌入在頁面中：新增 Disqus 留言數在 themes\\material-flow\\layout\\_partial\\article.ejs 檔案內找到適當的位置加入以下程式碼，就可以在文章內新增 Disqus 留言數：1234567891011121314&lt;% if (post.comments &amp;&amp; config.disqus.enable &amp;&amp; config.disqus.count) &#123; %&gt;&lt;span class=\"comments-count\"&gt; &lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fas fa-comment\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;a href=\"&lt;%- post.permalink %&gt;#disqus_thread\" class=\"article-comment-count\" data-disqus-identifier=\"&lt;%= post.path %&gt;\" itemprop=\"discussionUrl\" &gt; &lt;/a&gt;&lt;/span&gt;&lt;% &#125; %&gt;也可以在 themes\\material-flow\\layout\\_partial\\post.ejs 檔案內新增 Disqus 留言數，這樣就可以在首頁看到各文章的留言數。上面程式碼中最重要的是 &lt;a href=&quot;&lt;%- post.permalink %&gt;#disqus_thread&quot;...&gt; 這句，因為在連結的最後加上 #disqus_thread，就代表要告訴 Disqus 要找哪個連結的留言數，並將留言數設為連結名稱 (例如：1 留言)。而 data-disqus-identifier 屬性需設為此頁面的識別名稱：可參考 Disqus 的 JavaScript configuration variables | Disqus 文件。若要設定顯示在頁面上的留言數文字，可至 Disqus 的「Setting &gt; Community &gt; Comment Count Link」內設定，可分別設定三種情況：0 則留言1 則留言多則留言：{num} 是作為留言數的變數Demo設定後就可以看到每篇文章下面都可以留言囉！可在每篇文章看到留言數：參考來源Install instructions for Universal Code | DisqusAdding comment count links to your home page | Disqus","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://titangene.github.io/tags/hexo/"},{"name":"Comment","slug":"comment","permalink":"https://titangene.github.io/tags/comment/"}]}]}