{"meta":{"title":"Titangene Blog","subtitle":null,"description":"利用 blog 紀錄學習歷程","author":"Titangene","url":"https://titangene.github.io"},"pages":[{"title":"Categories","date":"2018-10-22T14:40:00.000Z","updated":"2018-10-22T18:20:46.635Z","comments":false,"path":"categories/index.html","permalink":"https://titangene.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2018-10-22T14:40:00.000Z","updated":"2018-10-22T18:21:46.626Z","comments":false,"path":"error/index.html","permalink":"https://titangene.github.io/error/index.html","excerpt":"","text":"This page does not exist, click here to go back to home page.頁面不存在，點此回到首頁。"},{"title":"Tags","date":"2018-10-22T14:40:00.000Z","updated":"2018-10-22T18:22:54.477Z","comments":false,"path":"tags/index.html","permalink":"https://titangene.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Google Cloud Shell 入門：gcloud & gsutil","slug":"getting-started-with-cloud-shell-gcloud-and-gsutil","date":"2019-04-17T08:56:38.000Z","updated":"2019-04-17T08:56:02.565Z","comments":true,"path":"article/getting-started-with-cloud-shell-gcloud-and-gsutil.html","link":"","permalink":"https://titangene.github.io/article/getting-started-with-cloud-shell-gcloud-and-gsutil.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Getting Started with Cloud Shell &amp; gcloud」這個 quest 所學到的內容，包括如何使用 gcloud 指令，以及如何使用 gsutil 工具來管理 Cloud Storage 資源，將檔案上傳至指定的 bucket。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Getting Started with Cloud Shell &amp; gcloud」這個 quest 所學到的內容，包括如何使用 gcloud 指令，以及如何使用 gsutil 工具來管理 Cloud Storage 資源，將檔案上傳至指定的 bucket。Google Cloud Shell 為你提供 gcloud command-line 存取 GCP 上託管的運算資源。Cloud Shell 是基於 Debian 的 VM，具有 5 GB persistent disk 的 home 目錄，讓你可以輕鬆管理 GCP 專案和資源。你需要的 Cloud SDK gcloud 和其他工具都已預裝在 Cloud Shell 中，讓你可以快速啟動和執行。若想了解如何 在 GCP 上建立 VM 架設 NIGNX Web server 可參考此篇。若想了解如何 在 GCP 上建立 VM 架設 Windows Server 可參考此篇。準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)：勾選同意服務條款：之後就可以開始使用 GCP Console 囉：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：gcloud 是 GCP 的 command-line 工具，他已預先安裝在 Cloud Shell 上，並且支援 tab 自動補齊 (tab-completion)。使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]理解 Regions 和 ZonesCompute Engine 資源位於不同的 regions (地區) 或 zones (區域)。region 是你可以執行資源的所在特定地理位置。每個 region 都有一個或多個 zones。例如，us-central1 region 代表美國中部地區，其中包含的 Zones 有 us-central1-a、us-central1-b、us-central1-c 與 us-central1-f。圖片來源：Creating a Virtual Machine | Qwiklabs位於 zone 中的資源都稱為 zonel (區域) 資源，VM instance (實例) 和 persistent disk (永久磁碟) 都位於 zone 中，如果要將 persistent disk 附加到 VM instance，這兩個資源都必須位於同一個 zone 中。同樣，如果要將靜態 IP 位址分配到 instance，此 instance 就必須與靜態 IP 位於同一個 region 中。詳情可參考 GCP 官方的 Regions &amp; Zones 文件。使用 command line在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕開啟新的 Cloud Shell session：啟用 Cloud Shell 後，你可以使用 command line invoke Cloud SDK gcloud 指令或 VM instance 上可用的其他工具，還可以在不同專案和 Cloud Shell session 之間，將要存取的檔案儲存在 persistent disk storage 的 $HOME 目錄內。$HOME 目錄是私有的，其他使用者無法存取。可以在任何 gcloud 指令的末端加上 -h 參數來查看使用指南：1$ gcloud -h加上 --help 參數或執行 gcloud help 可以查看更詳細的 help 內容：1$ gcloud config --help透過按 Enter 或空白建來捲動瀏覽 help 內容，按 q 按鍵會退出內容。下面兩個指令是一樣的意思，都是用來查看詳細的 help 內容：12$ gcloud config --help$ gcloud help config使用你的 home 目錄現在讓我們試試你的 HOME 目錄。就算去終止和重啟 VM，Cloud Shell HOME 錄的內容都會在所有 Cloud Shell session 之間的專案中保留。變更目前的工作目錄：1$ cd $HOME使用 vi 打開 .bashrc 設定檔：1$ vi ./.bashrc使用 gcloud 指令檢視環境內的設定列表：1$ gcloud config list如果要檢查其他屬性的設定，請在指令後面加上 --all 參數：1$ gcloud config list --all管理 Cloud Storage 資料可以使用 Cloud Shell 中的 gsutil 工具來管理 Cloud Storage 資源，包括建立和刪除 bucket 和物件、複製和移動儲存資料以及管理 bucket 和物件 ACLs (Access Control List)。gsutil 還能將資料傳入和傳出 Cloud Shell instance。bucket 是用於儲存資料的基本容器，儲存在 Cloud Storage 的所有資料都必須放在 bucket 中。你可以用 bucket 來整理資料、控制資料的存取權，但 bucket 不能像目錄和資料夾可以巢狀儲存。由於建立和刪除 bucket 有一些限制，所以你設計的儲存應用程式應儘量執行密集的物件作業和相對較少的 bucket 作業。詳情可參考官方的 Buckets、Creating Storage Buckets 和 Access Control List (ACL) 文件。嘗試建立 Cloud Storage bucket，bucket 名稱不能重複，因此請將 unique-name 替換為其他名稱，或者 append 名稱讓它不重複。1$ gsutil mb gs://unique-name像我是使用名為 unique-name-titan 的 bucket，剛好沒有重複，所以成功建立了 bucket：12$ gsutil mb gs://unique-name-titanCreating gs://unique-name-titan/...如果使用重複的 bucket 名稱就會出現類似下面的訊息：123$ gsutil mb gs://unique-nameCreating gs://unique-name/...ServiceException: 409 Bucket unique-name already exists.現在來建立一些資料，上傳到你的 bucket。首先，建立一個測試檔案：1$ vi test.dat加一些資料進去：1Welcome to gcloud!存儲檔案：1:wq現在，上傳一些檔案到你建立的 bucket，請將 unique-name 取代成你的 storage bucket：1$ gsutil cp test.dat gs://unique-name剛剛我是使用 unique-name-titan 的 bucket，所以上傳指令如下，可以看到我已成功上傳：1234$ gsutil cp test.dat gs://unique-name-titanCopying file://test.dat [Content-Type=application/octet-stream]...- [1 files][ 19.0 B/ 19.0 B]Operation completed over 1 objects/19.0 B.如果是使用重複的 bucket 名稱上傳，就會出現類似下面的訊息：123$ gsutil cp test.dat gs://unique-nameCopying file://test.dat [Content-Type=application/octet-stream]...BadRequestException: 400 Project does not exist: 666160882299若要查看你的 bucket 和檔案，請開啟導航選單，然後選擇「Storage &gt; Browser」：然後點擊你的 bucket：你應該會看到 test.dat 這個檔案：參考來源Getting Started with Cloud Shell &amp; gcloud | Qwiklabs (本篇大多數的圖片來源)","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"VM","slug":"vm","permalink":"https://titangene.github.io/tags/vm/"}]},{"title":"在 GCP 上建立 VM 架設 Windows Server","slug":"gcp-vm-windows-server","date":"2019-04-16T13:17:46.000Z","updated":"2019-04-16T12:16:24.204Z","comments":true,"path":"article/gcp-vm-windows-server.html","link":"","permalink":"https://titangene.github.io/article/gcp-vm-windows-server.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Compute Engine: Qwik Start - Windows」這個 quest 所學到的內容，包括如何透過 GCP Console 在 GCP 建立 instance 架設 Windows Server，以及如何使用 Chrome RDP for GCP 擴充功能直接從瀏覽器進行 RDP 連接至 Windows Server。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Compute Engine: Qwik Start - Windows」這個 quest 所學到的內容，包括如何透過 GCP Console 在 GCP 建立 instance 架設 Windows Server，以及如何使用 Chrome RDP for GCP 擴充功能直接從瀏覽器進行 RDP 連接至 Windows Server。Google Compute Engine 可讓你在 Google 基礎架構上建立和執行 VM。 Compute Engine 提供擴展、效能和價值，讓你可以輕鬆地在 Google 基礎架構上啟動大型運算群集。你可以在 Google Compute Engine 上執行 Windows 應用程式，並利用 VM instance 可用的許多優勢，例如：可靠的儲存選項、Google 網路的速度和自動擴展 (Autoscaling)。在此 lab 中，你將學習如何在 Google Compute Engine 中啟動 Windows Server instance，並使用遠端桌面協定連接到該 instance。若想了解如何 在 GCP 上建立 VM 架設 NIGNX Web server 可參考此篇。如果你未在 local 主機上使用 Windows，請安裝第三方的 RDP client，例如：FusionLabs 的 Chrome RDP。準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)勾選同意服務條款：之後就可以開始使用 GCP Console 囉：建立 VM instance在 GCP Console 的左上角，點選「Navigation menu &gt; Compute Engine &gt; VM Instances」：接著點擊「Create」按鈕建立新的 instance：在「Boot disk」部分中，點擊「Change」按鈕以開始配置 boot disk：選擇「Windows Server 2012 R2 Datacenter」，然後點擊「Select」按鈕：將所有其他設定都保留為預設值。設定好之後，點擊「Create」按鈕建立 instance：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]詳情可參考官方的 Google Cloud gcloud Overview 文件。測試 Windows Startup 的狀態在「VM Instances」頁面上看到帶有綠色狀態的 icon 就代表該 instance 已建立完成，如下圖：但是，它可能尚未準備好接受 RDP 連接，因為所有 OS 元件初始化都需要一段時間。要查看 server 是否已準備好進行 RDP 連接，請在 Cloud Shell terminal command-line 中執行以下指令，其中的 instance-1 是剛剛建立的 instance 名稱：1$ gcloud compute instances get-serial-port-output instance-1 --zone us-central1-a重複這個指令，直到指令輸出以下內容為止。這個指令的輸出會告訴你 OS 元件已初始化，並且 Windows Server 已準備好接受 RDP 連接 (嘗試下一步)。1Finished running startup scripts.這個指令完整的輸出訊息會類似下面這樣：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566$ gcloud compute instances get-serial-port-output instance-1 --zone us-central1-aSeaBIOS (version 1.8.2-20190322_093631-google)Total RAM Size = 0x00000000f0000000 = 3840 MiBCPUs found: 1 Max CPUs supported: 1found virtio-scsi at 0:3virtio-scsi vendor='Google' product='PersistentDisk' rev='1' type=0 removable=0virtio-scsi blksize=512 sectors=104857600 = 51200 MiBdrive 0x000f29f0: PCHS=0/0/0 translation=lba LCHS=1024/255/63 s=104857600Booting from Hard Disk 0...2019/04/15 15:39:21 GCEWindowsAgent: GCE Agent Started (version 4.6.0@1)2019/04/15 15:39:56 GCEInstanceSetup: Starting sysprep specialize phase.2019/04/15 15:39:57 GCEInstanceSetup: All networks set to DHCP.2019/04/15 15:39:57 GCEInstanceSetup: Running 'netsh' with arguments 'interface ipv4 set interface Ethernet mtu=1460'2019/04/15 15:39:57 GCEInstanceSetup: --&gt; Ok.2019/04/15 15:39:58 GCEInstanceSetup: MTU set to 1460.2019/04/15 15:39:58 GCEInstanceSetup: Running 'route' with arguments '/p add 169.254.169.254 mask 255.255.255.255 0.0.0.0 if 12 metric 1'2019/04/15 15:39:58 GCEInstanceSetup: --&gt; OK!2019/04/15 15:39:58 GCEInstanceSetup: Added persistent route to metadata netblock via first netkvm adapter.2019/04/15 15:39:58 GCEInstanceSetup: Getting hostname from metadata server.2019/04/15 15:39:58 GCEInstanceSetup: Changing hostname from WIN-MQ2QFF14J03 to instance-1.2019/04/15 15:39:58 GCEInstanceSetup: Renamed from WIN-MQ2QFF14J03 to instance-1.2019/04/15 15:39:58 GCEMetadataScripts: Starting specialize scripts (version 4.2.1@1).2019/04/15 15:39:58 GCEMetadataScripts: No specialize scripts to run.2019/04/15 15:39:58 GCEMetadataScripts: Finished running specialize scripts.2019/04/15 15:39:58 GCEInstanceSetup: Finished with sysprep specialize phase, restarting...2019/04/15 15:39:59 GCEWindowsAgent: GCE Agent StoppedSeaBIOS (version 1.8.2-20190322_093631-google)Total RAM Size = 0x00000000f0000000 = 3840 MiBCPUs found: 1 Max CPUs supported: 1found virtio-scsi at 0:3virtio-scsi vendor='Google' product='PersistentDisk' rev='1' type=0 removable=0virtio-scsi blksize=512 sectors=104857600 = 51200 MiBdrive 0x000f29f0: PCHS=0/0/0 translation=lba LCHS=1024/255/63 s=104857600Booting from Hard Disk 0...2019/04/15 15:40:36 GCEWindowsAgent: GCE Agent Started (version 4.6.0@1)2019/04/15 15:40:43 GCEInstanceSetup: Disabled Ctrl + Alt + Del.2019/04/15 15:40:43 GCEInstanceSetup: Enable RDP firewall rules.2019/04/15 15:40:43 GCEInstanceSetup: Running 'netsh' with arguments 'advfirewall firewall set rule group=remote desktop new enable=Yes'2019/04/15 15:40:43 GCEInstanceSetup: --&gt; Updated 3 rule(s).2019/04/15 15:40:43 GCEInstanceSetup: --&gt; Ok.2019/04/15 15:40:43 GCEInstanceSetup: Restarting Terminal Service services, to enable RDP.2019/04/15 15:40:44 GCEInstanceSetup: Enabled Remote Desktop.2019/04/15 15:40:44 GCEInstanceSetup: Configuring WinRM...2019/04/15 15:40:47 GCEInstanceSetup: Running 'netsh' with arguments 'advfirewall firewall add rule profile=any name=Windows Remote Management (HTTPS-In) dir=in localport=5986 protocol=TCP action=allow'2019/04/15 15:40:47 GCEInstanceSetup: --&gt; Ok.2019/04/15 15:40:48 GCEInstanceSetup: Setup of WinRM complete.2019/04/15 15:40:48 GCEInstanceSetup: Running startup scripts from metadata server.2019/04/15 15:40:48 GCEInstanceSetup: Running 'schtasks' with arguments '/run /tn GCEStartup'2019/04/15 15:40:48 GCEInstanceSetup: --&gt; SUCCESS: Attempted to run the scheduled task \"GCEStartup\".2019/04/15 15:40:48 GCEInstanceSetup: ------------------------------------------------------------2019/04/15 15:40:48 GCEInstanceSetup: Instance setup finished. instance-1 is ready to use.2019/04/15 15:40:48 GCEInstanceSetup: ------------------------------------------------------------2019/04/15 15:40:51 GCEInstanceSetup: Checking instance license activation status.2019/04/15 15:40:51 GCEInstanceSetup: instance-1 needs to be activated by a KMS Server.2019/04/15 15:40:51 GCEInstanceSetup: Key Management Service machine name set to kms.windows.googlecloud.com successfully.2019/04/15 15:40:51 GCEInstanceSetup: Installed product key W3GGN-FT8W3-Y4M27-J84CP-Q3VJ9 successfully.2019/04/15 15:40:51 GCEInstanceSetup: Activating instance...2019/04/15 15:40:52 GCEInstanceSetup: Activating Windows(R), ServerDatacenter edition (00091344-1ea4-4f37-b789-01750ba6988c) ...2019/04/15 15:40:52 GCEInstanceSetup: Product activated successfully.2019/04/15 15:40:52 GCEInstanceSetup: Activation successful.2019/04/15 15:40:53 GCEMetadataScripts: Starting startup scripts (version 4.2.1@1).2019/04/15 15:40:53 GCEMetadataScripts: No startup scripts to run.2019/04/15 15:40:53 GCEMetadataScripts: Finished running startup scripts.Specify --start=4643 in the next get-serial-port-output invocation to get only the new output starting from here.連接 instance點擊 VM 的名稱：在「Remote Access」部分點擊「Set Windows Password」按鈕：輸入 username 後，點擊「Set」按鈕來產生此 Windows instance 的密碼。如果沒有此 username 的 Windows 帳號，就會建立該帳號並使用新密碼，如果已有此帳號，密碼則會被重設：複製密碼並儲存，稍後登入 instance 時會用到：使用遠端桌面 (RDP) 進入 Windows Server可以使用 Chrome RDP for Google Cloud Platform 擴充功能直接從瀏覽器進行 RDP 連接，點擊「RDP」按鈕進行連接：如果剛剛是用 Chrome 的無痕模式登入帳號，就會發生點擊「RDP」按鈕沒有反應的狀況，換成原本的模式就可以正常使用。它會提示你安裝 RDP 擴充功能。安裝完成後，GCP 會打開像下圖的登入畫面，請使用 Windows 使用者和密碼登入 (貼上之前儲存的密碼)：點擊「Continue」按鈕以確認你要連接：打開 Server Manager 時，就會連接到 Windows Server 上的 VM instance。使用 RDP client 複製和貼上登入到 instance 後，可以按 Ctrl + V 貼上資料 (如果是 Mac 的使用者，按 Cmd + V 會無法貼上）。如果要貼至 PuTTY 和 Powershell，請按滑鼠右鍵就可以貼上。如果在 Powershell 視窗中，請確保已點擊該視窗，否則會無法貼上。參考來源Compute Engine: Qwik Start - Windows (本篇大多數的圖片來源)","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"},{"name":"Windows","slug":"cloud/windows","permalink":"https://titangene.github.io/categories/cloud/windows/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"VM","slug":"vm","permalink":"https://titangene.github.io/tags/vm/"},{"name":"Windows Server","slug":"windows-server","permalink":"https://titangene.github.io/tags/windows-server/"}]},{"title":"GCP (Google Cloud Platform) 入門","slug":"getting-started-with-gcp","date":"2019-04-15T14:20:20.000Z","updated":"2019-04-16T12:05:50.221Z","comments":true,"path":"article/getting-started-with-gcp.html","link":"","permalink":"https://titangene.github.io/article/getting-started-with-gcp.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「A Tour of Qwiklabs and the Google Cloud Platform」這個 quest 所學到的內容，包括如何使用以及認識 Qwiklab 和 GCP。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「A Tour of Qwiklabs and the Google Cloud Platform」這個 quest 所學到的內容，包括如何使用以及認識 Qwiklab 和 GCP。Google Cloud Platform (GCP) 是託管在 Google 基礎架構上的一套雲端服務，從計算和儲存，到資料分析、機器學習、網路、GCP 提供各種服務和 API，可以與任何雲端計算應用程式或專案整合 - 無論是個人還是企業。在這個入門等級的 lab 中，可透過使用 GCP console (瀏覽器內的 UI，可讓您存取和管理 Google Cloud 服務) 來練習使用 GCP，了解 GCP 的主要功能，必了解 Qwiklabs 的環境。你會學到什麼了解如何使用特定憑證存取 GCP console認識 GCP 專案了解如何使用 GCP 的導航選單來識別 GCP 服務的類型了解 primitive roles 並使用 Cloud IAM 服務檢查特定使用者的可用操作了解 Cloud Shell 並使用 gcloud toolkit 來執行指令了解 API library 並查看其主要功能若想了解如何 在 GCP 上建立 VM 架設 NIGNX Web server 可參考此篇。若想了解如何 在 GCP 上建立 VM 架設 Windows Server 可參考此篇。其他關於 Qwiklab 的介紹，可至原文 A Tour of Qwiklabs and the Google Cloud Platform 查看。存取 GCP Console如果已經點擊右上角的「Start Lab」開始，應該會看到左側的「Open Google Console」按鈕變成可以被點擊，而且可以看到有帳號、密碼以及 GCP 專案 ID：GCP 專案 IDGCP 專案是你的 Google 雲端資源的組織實體，包含資源和服務，例如：可以包含一個 VM 的 pool，一組資料庫以及將它們彼此連接的網路，專案還包含設定和權限，這些設定和權限可以指定安全規則以及設定誰有權存取哪些資源。而 GCP Project ID 不會重複，用於將 GCP 資源和 API 連接到你的特定專案。帳號和密碼帳號和密碼是表示在 GCP 身份和存取管理 (Identity and Access Management，IAM) 服務中，具有存取權限身份 (一個或多個角色) 的憑證，允許你在已分配的專案中使用 GCP 資源。這些憑證是臨時的，只能在 lab 限制的存取時間內使用，所以只要計時器倒數到 0 之後，你就無法再使用這些憑證存取這個的 GCP 專案。登入 GCPLab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)勾選同意服務條款：之後就可以開始使用 GCP Console 囉：GCP Console 中的專案GCP Console 的左上角，會看到一個名為 Project info 的面板，畫面如下：一個專案會有名稱、ID、編號，在使用 GCP 服務時會經常使用這些東西。不過你可以存取多個 GCP 專案。在某些 lab 中，可能會使用多個專案來完成分配的任務。如果點擊帶有專案名稱的下拉式選單並選擇「ALL」，就會看到「Qwiklabs Resources」專案也可見：目前不要切換到 Qwiklabs 資源專案！但是，你可以稍後在其他 lab 中使用它。GCP 的大型企業或有經驗的使用者擁有數十到數千個 GCP 專案的情況還蠻常見的，組織會以不同的方式使用 GCP，因此專案分離在雲端運算服務 (以團隊或產品為例) 是個好方法。“Qwiklabs Resources” 是一個包含某些 lab 的檔案，資料集和機器 image 的專案，可以從每個 GCP lab 環境存取。要注意是 “Qwiklabs Resources” 與所有 Qwiklabs 使用者共享資源 (read only)，也就代表你無法刪除或修改它。你正在使用名為類似於 qwiklabs-gcp-xxx 的 GCP 專案是臨時的，也就代表專案及其包含的所有內容會在 lab 結束後刪除。每次使用的 lab 都可以存取一個或多個新的 GCP 專案，並且在那裡 (不是 “Qwiklabs Resources” ) 執行所有 lab 的步驟。導航選單和服務在畫面的左上角有一個類似「三」的 icon：點擊此按鈕會顯示 (或隱藏) GCP 核心服務的導航選單，如果選單沒有打開，請點擊此 icon 並捲動查看所有提供的服務類型：在導航選單可以快速存取平台的服務，可看到共有 7 類 GCP 的服務：Compute：包含支援任何類型的工作負載的各種機型。通過不同的運算選項，可以決定你希望如何參與 operational details 和基礎架構等Storage：結構化或非結構化、關係資料或非關係資料的資料儲存和資料庫選項Networking：平衡應用程式流量和提供安全規則的服務Stackdriver：一套跨雲端日誌記錄 (cross-cloud logging)、監控、追蹤和其他服務的可靠性工具Tools：管理部署和應用程式建置 pipeline 的開發人員的服務Big Data：用於處理和分析大量資料集的服務Artificial Intelligence (AI)：可在 GCP 上執行特定的 AI 和機器學習 (ML，machine learning) 任務的一套 API詳情可查看官方的 About the GCP Services | Google Cloud 文件。角色和權限除了雲端運算服務之外，GCP 還包含一組權限和角色，用於定義誰可以存取哪些資源，我們就可以使用雲端身份和存取管理 (Cloud Identity and Access Management，IAM) 服務來檢查和修改角色和權限。請打開導航選單，然後點擊「IAM &amp; admin」，畫面會跳至包含使用者列表的頁面，該頁面指定給予特定帳號的權限和角色。嘗試篩選這些並找到你登入的 “@qwiklabs” 此使用者名稱：類似下圖：member 欄位被設為 google23396_student@qwiklabs.net（與你登入的帳號一樣），name 欄位被設為 google23396_student@qwiklabs.net student。會看到 Role 欄位被設為 Editor，這是 GCP 提供的三種 primitive roles 的其中之一。除非另有指定，否則 primitive roles 是設定專案等級的權限，它們控制對所有 GCP 服務的存取和管理。下表是從角色文件中提取的定義，其中提供了 viewer、editor 和 owner 角色權限的 overview：角色名稱權限roles/viewer不影響狀態的 read-only 操作的權限，例如：查看 (但不能修改) 現有的資源或資料roles/editor所有 viewer 的權限，以及修改狀態的操作的權限，例如：修改現有資源roles/owner所有 editor 權限和以下操作的權限：- 管理專案的角色和權限以及專案中的所有資源- 設定專案的計費方式因此 editor 能夠建立、修改和刪除 GCP 資源。但是無法在 GCP 專案中新增或刪除 member。API 和服務Google Cloud API 是 GCP 中重要的部分。與服務類似，從企業管理到機器學習等領域的 200 多個 API 都可以輕鬆地與 GCP 專案和應用程式整合。API 是 “Application Programming Interfaces”，可以直接或通過 Google Cloud client library 呼叫 (call) 它們。 Cloud API 使用官方的 Google API Design Guide 中描述的資源導向的設計原則。當 Qwiklabs 為 lab instance 提供新的 GCP 專案時，它可以在背後啟用大多數的 API，以便你可以立即處理 lab 的任務。但要注意的事，當你在 Qwiklabs 之外建立自己的 GCP 專案時，必須自己啟用某些 API。大多數雲端 API 會為你提供有關專案使用該 API 的詳細資訊 (包括流量、錯誤率、延遲時間)，幫助你快速找到使用 Google服務的應用程序問題。你可以通過打開導航選單並點擊「APIs &amp; Services &gt; Library」來查看此資訊：在 API 搜尋欄中，輸入 “Dialogflow” 並選擇 Dialogflow API 後，就會看到下圖的頁面：Dialogflow API 可讓你建置對話式 (conversational) 應用程式 (例如，for Google Assistant)，而無需擔心底層機器學習和自然語言理解 (Natural Language Understanding) schema。點擊「ENABLE」按鈕後會跳至新頁面，接著點擊瀏覽器的返回按鈕就可看到「API enabled」：點擊「Try this API」按鈕會以新分頁的方式開啟 Dialogflow API 的文件，並且可以指定可用的 API 方法。詳情可查看 Google Cloud 中名為 APIs Explorer 的 hands-on 工具。Cloud ShellCloud Shell 是在瀏覽器內的指令提示 (command prompt) 執行環境，允許你在終端提示 (terminal prompt) 下輸入指令來管理 GCP 專案中的資源和服務。Cloud Shell 能讓你在不離開 console 的情況下執行所有 shell 指令，並有預裝的 command-line 工具。在 console 的右上角點擊「Activate Cloud Shell」按鈕，然後在出現提示時點擊「START CLOUD SHELL」按鈕：接著會在 console 底部出現一個新的黑色視窗，視窗內會出現類似以下內容的訊息和提示，這代表你已啟動並執行 Cloud Shell session：1234Welcome to Cloud Shell! Type \"help\" to get started.Your Cloud Platform project in this session is set to qwiklabs-gcp-76ad0f1342e20013.Use \"gcloud config set project [PROJECT_ID]\" to change to a different project.gcpstaging23396_student@cloudshell:~ (qwiklabs-gcp-76ad0f1342e20013)$接著將下面指令複製並貼 (或輸入) 至 Cloud Shell 上，然後按 Enter 鍵執行，應該會看到類似下面的輸出：123456$ gcloud auth listCredentialed AccountsACTIVE ACCOUNT* gcpstaging23396_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`其中 ACTIVE ACCOUNT 是設為你的 GCP IAM 身份 (也就是 googlexxxxxx_student@qwiklabs.net )，gcloudauth list 指令會列出 GCP 專案中有憑證的帳號。此帳號名稱與之前登入到 console 的 Qwiklabs 帳號相同。：如之前所說的，Cloud Shell 預裝了特定的 command-line 工具，主要的 GCP toolkit 是 gcloud，是用於平台上的許多任務，例如：資源管理和使用者身份驗證。除了預裝的 toolkit，Cloud Shell 還附帶標準的 unix CLI 工具和 nano 等文字編輯器，在 Cloud Shell 中可以利用它們來建立和編輯檔案。參考來源A Tour of Qwiklabs and the Google Cloud Platform (本篇大多數的圖片來源)","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"}]},{"title":"在 GCP 上建立 VM 架設 NIGNX Web server","slug":"gcp-vm-nignx-web-server","date":"2019-04-14T02:17:46.000Z","updated":"2019-04-16T12:02:42.132Z","comments":true,"path":"article/gcp-vm-nignx-web-server.html","link":"","permalink":"https://titangene.github.io/article/gcp-vm-nignx-web-server.html","excerpt":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Creating a Virtual Machine」這個 quest 所學到的內容，包括如何透過 GCP Console 和 command-line 工具 gcloud 在 GCP 建立 instance，如何使用 gcloud 透過 SSH 連接到你的 instance，以及如何在 VM 上部署 NIGNX web server。","text":"本篇是紀錄在 Google 的 Qwiklab 平台內，完成「Creating a Virtual Machine」這個 quest 所學到的內容，包括如何透過 GCP Console 和 command-line 工具 gcloud 在 GCP 建立 instance，如何使用 gcloud 透過 SSH 連接到你的 instance，以及如何在 VM 上部署 NIGNX web server。透過 Google Compute Engine，可在 Google 基礎架構上，建立執行不同作業系統的 VM (virtual machine，虛擬機)，包括多種 Linux (Debian、Ubuntu、Suse、Red Hat、CoreOS) 和 Windows Server。可以學到如何使用 Google Cloud Platform (GCP) Console 和 gcloud command-line 建立各種機器類型的虛擬機 instance (實例)，還能學習如何將 NGINX web server 連接到 VM。若想了解如何 在 GCP 上建立 VM 架設 Windows Server 可參考此篇。本篇將會做什麼？使用 GCP Console 建立 VM使用 gcloud command-line 建立 VM在 VM 上部署 web server準備在點擊「Start Lab」之前，準備好網路瀏覽器 (推薦用 Google Chrome)，並且至少 40 分鐘可以專注的時間，因為 lab 是有時間限制，當你按下「Start Lab」開始學習時，無法暫停倒數計時，你只能在這段時間內使用 lab 提供給你的全新暫時 GCP Console 可用帳號，時間到之後的幾分鐘就會自動登出。注意：如果你有自己的個人 GCP 帳號或專案，請不要在此 lab 使用開始你的 Lab，然後登入 GCP Console如果準備要開始，可以點擊右上角的「Start Lab」開始：接著會出現這個畫面，因為我參加 GDG Tainan 的活動，活動有提供 Qwiklabs 一個月的免費額度，所以我點選下圖左邊的「Use Subscription」：Lab 會提供給你免費暫時的 GCP 帳號，複製帳號和密碼，然後點擊「Open Google Console」開啟 GCP Console：圖片來源：Creating a Virtual Machine | Qwiklabs接著就會開啟登入頁面，建議另外開 Chrome 無痕模式來登入 lab 提供的帳號和密碼，因為 Chrome 會紀錄帳密，現在登入的只是暫時帳號，未來不需要用到：注意：這邊是登入 lab 提供的帳號 (也就是 email 必須為 googlexxxxxx_student@qwiklabs.net )，如果你有自己的 GCP 帳號，請不要用於此 lab，避免產生費用類似於 googlexxxxxx_student@qwiklabs.net 的帳號是一個 Google 帳號，專為 Qwiklabs 學生使用而建立的。它具有特定的域名 (也就是 qwiklabs.net )，並且已分配了 IAM 角色，允許你去存取該 GCP 專案。接受 terms 和 conditions：不要新增 recovery options 或 two-factor authentication (因為這是一個臨時帳號)勾選同意服務條款：之後就可以開始使用 GCP Console 囉：啟動 Google Cloud ShellGoogle Cloud Shell 是載入了開發工具的 VM，它提供 5GB 的 home 目錄，並在 Google Cloud 上執行。可用 Google Cloud Shell 提供的 command-line 來存取 GCP 的資源。在 GCP console 的右上方工具列中，點擊「Activate Cloud Shell」按鈕：在打開的對話框內，點擊「START CLOUD SHELL」：連接和提供環境需要一些時間：連接後，就代表你已經過身份驗證，專案已設置為 PROJECT_ID，以下圖的為例，此專案的 ID 為 qwiklabs-gcp-f9d61ede8167e6b0：gcloud 是 GCP 的 command-line 工具，他已預先安裝在 Cloud Shell 上，並且支援 tab 自動補齊 (tab-completion)。未來可使用 gcloud 的下面指令並透過 PROJECT_ID 來更換成其他專案：1$ gcloud config set project [PROJECT_ID]使用下面指令可列出有效帳號名稱：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`可以使用以下指令列出專案 ID：12345$ gcloud config list project[core]project = qwiklabs-gcp-f9d61ede8167e6b0Your active configuration is: [cloudshell-9292]理解 Regions 和 ZonesCompute Engine 資源位於不同的 regions (地區) 或 zones (區域)。region 是你可以執行資源的所在特定地理位置。每個 region 都有一個或多個 zones。例如，us-central1 region 代表美國中部地區，其中包含的 Zones 有 us-central1-a、us-central1-b、us-central1-c 與 us-central1-f。圖片來源：Creating a Virtual Machine | Qwiklabs位於 zone 中的資源都稱為 zonel (區域) 資源，VM instance (實例) 和 persistent disk (永久磁碟) 都位於 zone 中，如果要將 persistent disk 附加到 VM instance，這兩個資源都必須位於同一個 zone 中。同樣，如果要將靜態 IP 位址分配到 instance，此 instance 就必須與靜態 IP 位於同一個 region 中。詳情可參考 GCP 官方的 Regions &amp; Zones 文件。從 Cloud Console 建立新的 instance在 GCP Console 的右上角，點選「Navigation menu &gt; Compute Engine &gt; VM Instances」：接著點擊「Create」建立新的 instance：建立新的 instance 時可以設定很多參數。在此 lab 中會使用以下設定：欄位值額外資訊namegcelabregionus-central1 (Iowa)或asia-south1 (Mumbai)更多關於 regions 的資訊zoneus-central1-c或asia-south1-c注意：記住你選擇的 zone，之後會用到更多關於 zones 的資訊Machine Type2 vCPU這是一個 ( n1-standard-2 )2-CPU, 7.5 GB RAM instance有很多機型可以選擇，從 micro instance 類型的到 32-core/208 GB RAM 的都有，詳情可參考機型種類文件注意：新專案具有預設的資源配額，可能會限制 CPU 核心數。可在此 lab 之外的專案上申請到更高的規格Boot DiskNew 10 GB standard persistent diskOS Image: Debian GNU/Linux 9 (Stretch)有很多 images 可以選擇，包括：Debian、Ubuntu、CoreOS，以及 premium images，像是 RedHat Enterprise Linux 和 Windows Server，詳情可參考 OS 文件Firewall勾選 Allow HTTP traffic，勾選此選項才能存取之後安裝的 web server注意：這會自動建立防火牆規則，允許 80 port 的 HTTP 流量設定好之後，點擊「Create」：等待 instance 建立：看到下面畫面就代表 instance 已建立完成，接著點擊右邊的「SSH」按鈕，會開啟新的瀏覽器頁面：此頁面是直接從瀏覽器啟動 SSH client 連接到 VM：詳情可參考官方的 Connect to an instance using ssh 文件。安裝 NGINX web server透過 SSH 連接 VM 之後，請使用 sudo 取得 root 的存取權限：1$ sudo su -更新 OS：12345$ apt-get updateGet:1 http://security.debian.org stretch/updates InRelease [94.3 kB]Ign:2 http://deb.debian.org/debian stretch InRelease Get:3 http://deb.debian.org/debian stretch-updates InRelease [91.0 kB] ...安裝 NGINX：1$ apt-get install nginx -y檢查 NGINX 是否正在執行：12345$ ps auwx | grep nginxroot 2339 0.0 0.0 159532 1628 ? Ss 06:37 0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;www-data 2340 0.0 0.0 159864 3200 ? S 06:37 0:00 nginx: worker processwww-data 2341 0.0 0.0 159864 3200 ? S 06:37 0:00 nginx: worker processroot 2350 0.0 0.0 12780 952 pts/0 S+ 06:37 0:00 grep nginx註：如果關掉 NGINX 就不會出現關於 NGINX 的 process：1234$ service nginx stop$ ps auwx | grep nginxroot 2359 0.0 0.0 12780 1012 pts/0 S+ 14:23 0:00 grep nginx使用下面指令可以啟動 NGINX：1$ service nginx start回到 Cloud Console，並點擊 VM instance 的 External IP 連結：就會開啟新分頁，可以看到 NGINX web server 的預設網頁：使用 gcloud 建立新的 instance前面介紹的是利用 GCP Console 來建立 VM instance，這邊要介紹的是可以使用預裝在 Google Cloud Shell 中的 command-line 工具 gcloud 來完成一樣的事。Cloud Shell 是基於 Debian 的 VM，預載你所需的所有開發工具 (gcloud、git … 等其他)，並提供 5 GB persistent disk 的 home 目錄。詳情可參考 gcloud command line tool guide。在 Cloud Shell 使用 command-line 工具 gcloud 建立一台新的 VM instance，將 [YOUR_ZONE] 替換成前面使用的 zone：1$ gcloud compute instances create gcelab2 --machine-type n1-standard-2 --zone [your_zone]像我前面的 zone 是用 asia-south1-c，所以指令如下：1234$ gcloud compute instances create gcelab2 --machine-type n1-standard-2 --zone asia-south1-cCreated [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-f9d61ede8167e6b0/zones/asia-south1-c/instances/gcelab2].NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSgcelab2 asia-south1-c n1-standard-2 10.160.0.3 35.244.6.170 RUNNING建立的 instance 具有以下預設值：最新的 Debian 9 (stretch) image預設機型 (machine type) 為 n1-standard-2，在此 lab 中，你也可以使用 n1-highmem-4 或 n1-highcpu-4 其他機型。在 lab 之外的專案可以指定自訂的機型root persistent disk 預設與 instance 的名稱一樣，disk 會自動附加到 instance執行下面指令可以查看所有預設值：1$ gcloud compute instances create --helpNote：如果你總是使用同一個 region/zone，並且不希望每次都使用 --zone 參數，就可以使用下面指令，將指定的 region 和 zones 設為預設：12$ gcloud config set compute/zone ...$ gcloud config set compute/region ...詳情可參考官方的 gcloud compute | Compute Engine Documentation 文件。若要查看剛剛建立的 instance 是否成功建立，就要回到「Navigation menu &gt; Compute Engine &gt; VM Instances」頁面，如果還是沒有看到，就可以點擊「REFRESH」按鈕重新整理此頁面，應該就會看到剛剛建立名為 gcelab2 的 instance：接著你也可以使用 gcloud 透過 SSH 連接到你的 instance，連線時，請確認指令後面 --zone 參數的 [YOUR_ZONE] 是否和當初建立的一樣，或是如果你已在全域設定預設 (上面 Note 提到的部分)，就可以省略 --zone 參數：1$ gcloud compute ssh gcelab2 --zone [YOUR_ZONE]像我沒有在全域設定預設，所以需要在指令後面加上 --zone 參數，[YOUR_ZONE] 則是當初建立的 asia-south1-c，指令如下：12345678910$ gcloud compute ssh gcelab2 --zone asia-south1-cWARNING: The public SSH key file for gcloud does not exist.WARNING: The private SSH key file for gcloud does not exist.WARNING: You do not have an SSH key for gcloud.WARNING: SSH keygen will be executed to generate a key.This tool needs to create the directory[/home/google3043863_student/.ssh] before being able to generate SSHkeys.Do you want to continue (Y/n)?接著會出現下面畫面，請輸入 Y 繼續：1Do you want to continue (Y/n)? y此時會產生一對公鑰 (public key) 和私鑰 (private key)，接著按 Enter 鍵，不輸入也不設定 passphrase (如果是在真正的專案就建議輸入 passphrase，因為當別人拿走你的私鑰時，就無法直接登入主機，還要輸入 passphrase，安全性會比較高)：1234567891011121314151617181920212223242526272829Generating public/private rsa key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/google3043863_student/.ssh/google_compute_engine.Your public key has been saved in /home/google3043863_student/.ssh/google_compute_engine.pub.The key fingerprint is:SHA256:LJMylIaZY1aNf2v0uP/a83TSVw506GazmtvrTyPCxqU google3043863_student@cs-6000-devshell-vm-8e6e4e18-0f7e-4771-ac48-22ab57ceb161The key&apos;s randomart image is:+---[RSA 2048]----+| .o || =... . || B +. o .|| o + .oo o . || o +oS+ .* .|| o o+ + oo *.|| . . E .+.*|| . ..o=.+o|| .oo*==o.|+----[SHA256]-----+Warning: Permanently added &apos;compute.3226821850929314737&apos; (ECDSA) to the list of known hosts.Linux gcelab2 4.9.0-8-amd64 #1 SMP Debian 4.9.144-3.1 (2019-02-19) x86_64The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Creating directory &apos;/home/google3043863_student&apos;.使用 gcloud 設定防火牆如果我已經跟著之前的步驟安裝完 NGINX 了，就會發現剛剛建立的 instance 沒有做防火牆設定，也就是不允許 80 port 的 HTTP 流量，所以就可以是用下面指令來設定：1$ gcloud compute firewall-rules create nginx --allow tcp:80執行指令後會看到下面訊息，訊息內容是無法建立防火牆，這是因為請求的身分權限不足：123Creating firewall...failed.ERROR: (gcloud.compute.firewall-rules.create) Could not fetch resource: - Insufficient Permission: Request had insufficient authentication scopes.那如何知道目前的有效帳號名稱？可以使用下面指令來查看，可以看到目前的帳號不是之前 lab 暫時給我們用的帳號：1234567$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT* 721269751803-compute@developer.gserviceaccount.comTo set the active account, run: $ gcloud config set account `ACCOUNT`所以必須登入之前的帳號，可以使用下面指令：123456789101112131415$ gcloud auth loginYou are running on a Google Compute Engine virtual machine.It is recommended that you use service accounts for authentication.You can run: $ gcloud config set account `ACCOUNT`to switch accounts if necessary.Your credentials may be visible to others with access to thisvirtual machine. Are you sure you want to authenticate withyour personal account?Do you want to continue (Y/n)?接著會出現下面畫面，請輸入 Y 繼續：1Do you want to continue (Y/n)?接著會出現一長串的連結，點擊這個連結：12345678Do you want to continue (Y/n)? yGo to the following link in your browser: https://accounts.google.com/o/oauth2/auth?redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob&amp;prompt=select_account&amp;response_type=code&amp;client_id=32555940559.apps.googleusercontent.com&amp;scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloud-platform+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fappengine.admin+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcompute+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Faccounts.reauth&amp;access_type=offlineEnter verification code:該連結就是要你用 lab 提供的帳號登入：接著要同意 Google Cloud SDK 存取此帳號：接著複製此授權碼，將授權碼貼至剛剛的 shell：12345678Enter verification code: 4/KwEnGIyzJ0P_ZvFeKt5264lP_3CdzZhUb-ZXoEJ0TbVFQVUQyYSBF58WARNING: `gcloud auth login` no longer writes application default credentials.If you need to use ADC, see: gcloud auth application-default --helpYou are now logged in as [google3043863_student@qwiklabs.net].Your current project is [qwiklabs-gcp-f9d61ede8167e6b0]. You can change this setting by running: $ gcloud config set project PROJECT_ID登入成功後，可以再次執行下面指令看一下目前有效帳號的名稱，變成 lab 暫時給我們用的帳號囉：12345678$ gcloud auth list Credentialed AccountsACTIVE ACCOUNT 721269751803-compute@developer.gserviceaccount.com* google3043863_student@qwiklabs.netTo set the active account, run: $ gcloud config set account `ACCOUNT`接著再次執行下面指令，就可以成功設定防火牆：12345$ gcloud compute firewall-rules create nginx --allow tcp:80Creating firewall...⠶Created [https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-f9d61ede8167e6b0/global/firewalls/nginx].Creating firewall...done.NAME NETWORK DIRECTION PRIORITY ALLOW DENY DISABLEDnginx default INGRESS 1000 tcp:80 False雖然 GCP Console 介面上 VM instance 的 External IP 沒有變成可以點擊的連結，但可以將 External IP 複製到新的瀏覽器分頁：就能成功看到 NGINX web server 的預設網頁：下圖就是我成功完成此 quest 的畫面：參考來源Creating a Virtual Machine | QwiklabsA Tour of Qwiklabs and the Google Cloud Platform | Qwiklabs在 GCP 上開立一台虛擬機 | Ray’s Coding Journey","categories":[{"name":"Cloud","slug":"cloud","permalink":"https://titangene.github.io/categories/cloud/"}],"tags":[{"name":"GCP","slug":"gcp","permalink":"https://titangene.github.io/tags/gcp/"},{"name":"VM","slug":"vm","permalink":"https://titangene.github.io/tags/vm/"},{"name":"NIGNX","slug":"nignx","permalink":"https://titangene.github.io/tags/nignx/"},{"name":"Web Server","slug":"web-server","permalink":"https://titangene.github.io/tags/web-server/"}]},{"title":"Python 爬蟲常用技巧 (持續更新)","slug":"python-crawler-note","date":"2019-02-28T09:33:51.000Z","updated":"2019-04-13T15:35:15.766Z","comments":true,"path":"article/python-crawler-note.html","link":"","permalink":"https://titangene.github.io/article/python-crawler-note.html","excerpt":"紀錄個人常用的 Python 爬蟲技巧，未來還會持續更新其他技巧。","text":"紀錄個人常用的 Python 爬蟲技巧，未來還會持續更新其他技巧。載入常用套件12345678910import jsonimport shutilimport xml.etree.ElementTree as ETfrom urllib.parse import urlparse, parse_qs, urlunparseimport requestsfrom bs4 import BeautifulSoupfrom user_agent import generate_user_agentimport numpy as npimport pandas as pd解析 HTML123456import requestsfrom bs4 import BeautifulSoupresponse = requests.get(url)soup = BeautifulSoup(response.text, 'lxml')html = soup.find(id='some_id')解析網址12345from urllib.parse import urlparse, parse_qs, urlunparseurl = 'http://xxx.com/api/data?id=123&amp;sub_code=06A1297'link_parse = urlparse(url)print(link_parse)輸出：1ParseResult(scheme=&apos;http&apos;, netloc=&apos;xxx.com&apos;, path=&apos;/api/data&apos;, params=&apos;&apos;, query=&apos;id=123&amp;sub_code=06A1297&apos;, fragment=&apos;&apos;)將 ParseResult 物件轉成網址字串12url = urlunparse(link_parse)print(url)輸出：1&apos;http://xxx.com/api/data?id=123&amp;sub_code=06A1297&apos;解析網址 query123456link_query = parse_qs(link_parse.query)print(link_query)id = link_query['id'][0]sub_code = link_query['sub_code'][0]print(id, sub_code)輸出：12&#123;&apos;id&apos;: [&apos;123&apos;], &apos;sub_code&apos;: [&apos;06A1297&apos;]&#125;123 06A1297隨機生成 user-agentfake_useragent 套件123456789import requestsfrom fake_useragent import UserAgentdef set_header_user_agent(): user_agent = UserAgent() return user_agent.randomuser_agent = set_header_user_agent()response = requests.get(url, headers=&#123; 'user-agent': user_agent &#125;)user_agent 套件12345import requestsfrom user_agent import generate_user_agentuser_agent = generate_user_agent()response = requests.get(url, headers=&#123; 'user-agent': user_agent &#125;)讀取表格資料123456789import requestsfrom bs4 import BeautifulSoupimport numpy as npimport pandas as pdresponse = requests.get(url)soup = BeautifulSoup(response.text, 'lxml')html = soup.find(id='table_id')df = pd.read_html(str(html), header=0)[0]讀取/解析 JSON123456789import json# 讀取with open('data.json', encoding='utf-8') as file: datas = json.load(file)# 解析with open('data.json', 'w', encoding='utf-8') as file: json.dump(datas, file, ensure_ascii=False)讀取/解析 XML讀取 XML 檔1234import xml.etree.ElementTree as ETtree = ET.parse('data.xml')root = tree.getroot()讀取 XML 字串123import xml.etree.ElementTree as ETroot = ET.fromstring(some_xml_strings)以下面的 XML 為範例：123456789101112131415161718&lt;?xml version=\"1.0\"?&gt;&lt;bookstore&gt; &lt;book ISBN=\"10-000000-001\"&gt; &lt;title&gt;Book 1&lt;/title&gt; &lt;price&gt;300&lt;/price&gt; &lt;comments&gt; &lt;userComment rating=\"4\"&gt;xxx...&lt;/userComment&gt; &lt;userComment rating=\"2\"&gt;yyy...&lt;/userComment&gt; &lt;/comments&gt; &lt;/book&gt; &lt;book ISBN=\"10-000000-999\"&gt; &lt;title&gt;Book 2&lt;/title&gt; &lt;price&gt;500&lt;/price&gt; &lt;comments&gt; &lt;userComment rating=\"3\"&gt;zzz...&lt;/userComment&gt; &lt;/comments&gt; &lt;/book&gt;&lt;/bookstore&gt;迴圈取得子元素12for child in root: print(child.tag, child.attrib)輸出：12book &#123;&apos;ISBN&apos;: &apos;10-000000-001&apos;&#125;book &#123;&apos;ISBN&apos;: &apos;10-000000-999&apos;&#125;用 index 取得某元素123root[0][1].tagroot[0][1].textroot[0].attrib輸出：123&apos;price&apos;&apos;300&apos;&#123;&apos;ISBN&apos;: &apos;10-000000-001&apos;&#125;搜尋指定元素使用 root.iter()：123for comment in root.iter('userComment'): print(comment.attrib) print('comment: &#123;&#125;'.format(comment.text))輸出：123456&#123;&apos;rating&apos;: &apos;4&apos;&#125;comment: xxx...&#123;&apos;rating&apos;: &apos;2&apos;&#125;comment: yyy...&#123;&apos;rating&apos;: &apos;3&apos;&#125;comment: zzz...使用 root.findall()：1234for book in root.findall('book'): ISBN = book.get('ISBN') title = book.find('title').text print(ISBN, title)1210-000000-001 Book 110-000000-999 Book 2下載圖片response.raw 是 file-like 物件，預設不會解壓縮 response (使用 gzip 或 deflate，參考至 Requests 原始碼)，可以透過在 requests.get() 方法中，新增參數 stream=True 來強制解壓縮，並且可以避免立即將大的 response 內容讀入記憶體內，接著使用 shutil.copyfileobj() 讓 Python 將 串流資料轉成檔案物件。12345678import requestsimport shutilurl = \"http://www.xxx.com/xxx.png\"response = requests.get(url, stream=True)file_name = url.split('/')[-1]with open(file_name, 'wb') as file: shutil.copyfileobj(response.raw, file)如果要下載檔案大的圖片，可參考下個段落「下載大檔案」。shutil.copyfileobj(fsrc, fdst[, length])：將 file-like 物件 fsrc 的內容複製到 file-like 物件 fdst。length 參數 (int) 是 buffer 的大小。如果 length 為負數則代表是複製資料，而不以 chunk 的形式循環原始資料；預設是資料以 chunk 的形式讀取，以避免不受控制的記憶體消耗。請注意，如果 fsrc 物件的當前檔案位置不為 0，則只複製從當前檔案位置到檔案末端的內容。參考至 shutil - High-level file operations - Python 3.7.3 documentation 官方文件。參考來源：python - How to download image using requests - Stack Overflow下載大檔案以迭代的方式取得，預設會以每 128 byte 為一個 chunk 來讀取資料 (參考至 Requests 原始碼)：1234567import requestsresponse = requests.get(url, stream=True)file_name = url.split('/')[-1]with open(file_name, 'wb') as file: for chunk in response: file.write(chunk)若要自訂 chunk 大小，可使用 Response.iter_content() 方法自訂：12345678910import requestsfile_name = url.split('/')[-1]with requests.get(url, stream=True) as response: response.raise_for_status() with open(file_name, 'wb') as file: for chunk in response.iter_content(chunk_size=8192): if chunk: # filter out keep-alive new chunks file.write(chunk) # file.flush()參考來源：Download large file in python with requests - Stack Overflow若想要以一次一行的方式迭代 response 資料，可使用 Response.iter_lines() 方法，此方法預設一個 chunk 的大小為 512 byte，若要設定分隔符號，可加上 delimiter 參數：12345678import jsonimport requestsr = requests.get(url, stream=True)for line in r.iter_lines(): # filter out keep-alive new lines if line: print(json.loads(line))參考來源：Python Requests庫：HTTP for Humans - 再見紫羅蘭 - 博客園","categories":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/tags/python/"},{"name":"Python Requests","slug":"python-requests","permalink":"https://titangene.github.io/tags/python-requests/"},{"name":"Crawler","slug":"crawler","permalink":"https://titangene.github.io/tags/crawler/"}]},{"title":"在 Hexo 主題內新增程式碼片段複製功能","slug":"hexo-copy-code-snippet-to-clipboard","date":"2019-02-09T02:40:00.000Z","updated":"2019-02-09T02:37:16.804Z","comments":true,"path":"article/hexo-copy-code-snippet-to-clipboard.html","link":"","permalink":"https://titangene.github.io/article/hexo-copy-code-snippet-to-clipboard.html","excerpt":"為了提高 blog 的使用體驗，本文將說明如何在 Hexo 主題內，提供程式碼片段複製至剪貼簿的功能。","text":"為了提高 blog 的使用體驗，本文將說明如何在 Hexo 主題內，提供程式碼片段複製至剪貼簿的功能。12// copy to clipboardvar clipboard = document.querySelectorAll('pre');載入 clipboard.js在 themes\\material-flow\\layout\\_partial\\scripts.ejs 檔案內的載入 clipboard.js：1&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js\"&gt;&lt;/script&gt;新增程式碼片段複製功能每個程式碼片段內都要新增複製功能按鈕，下面說明新增複製按鈕的處理邏輯：首先要找到所有程式碼區塊：1var snippets = document.querySelectorAll('figure.highlight');準備要新增的按鈕結構：1234var htmlCopyButton = ` &lt;button class=\"codecopy-btn tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard\"&gt; &lt;i class=\"far fa-copy\" aria-hidden=\"true\"&gt;&lt;/i&gt; &lt;/button&gt;`;在原本的程式碼區塊的 &lt;figure&gt; 標籤外多包了一層 &lt;div&gt; 標籤在 &lt;div&gt; 標籤上新增 .code-highlight class 樣式在 &lt;div&gt; 標籤上新增 data-lang 屬性用於記錄此程式碼區塊內的程式碼是哪種程式語言12345678910111213snippets.forEach((snippet) =&gt; &#123; var parent = snippet.parentNode; var wrapper = document.createElement('div'); parent.replaceChild(wrapper, snippet); wrapper.appendChild(snippet); wrapper.classList.add('code-highlight'); wrapper.firstChild.insertAdjacentHTML('beforebegin', htmlCopyButton); var lang = (snippet.classList[1] || 'code').toUpperCase(); wrapper.setAttribute('data-lang', lang);&#125;);接著將名為 .codecopy-btn 的 element 上新增複製功能，複製的內容是 &lt;figure&gt; 標籤內的程式碼：12345var clipboard = new ClipboardJS('.codecopy-btn', &#123; target: (trigger) =&gt; &#123; return trigger.nextSibling; &#125;&#125;);只要按複製按鈕且複製成功，就會顯示 Copied! 提示已成功複製程式碼片段：1234clipboard.on('success', (e) =&gt; &#123; e.trigger.setAttribute('aria-label', 'Copied!'); e.clearSelection();&#125;);將每個複製按鈕新增兩個監聽事件，分別是 mouseleave 和 click：mouseleave：滑鼠離開按鈕就將提示文字變成 Copy to clipboardclick：取消事件的預設行為123456789101112var btns = document.querySelectorAll('.codecopy-btn');btns.forEach((btn) =&gt; &#123; btn.addEventListener('mouseleave', (e) =&gt; &#123; e.target.setAttribute('aria-label', 'Copy to clipboard'); e.target.blur(); &#125;); btn.addEventListener('click', (e) =&gt; &#123; e.preventDefault() &#125;);&#125;);完整程式碼在 themes\\material-flow\\source\\js 目錄內建立 clipboard-use.js，檔案內容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$(function () &#123; // ref: https://github.com/zenorocha/codecopy/blob/master/src/scripts/main.js var snippets = document.querySelectorAll('figure.highlight'); var htmlCopyButton = ` &lt;button class=\"codecopy-btn tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard\"&gt; &lt;i class=\"far fa-copy\" aria-hidden=\"true\"&gt;&lt;/i&gt; &lt;/button&gt;`; snippets.forEach((snippet) =&gt; &#123; var parent = snippet.parentNode; var wrapper = document.createElement('div'); parent.replaceChild(wrapper, snippet); wrapper.appendChild(snippet); wrapper.classList.add('code-highlight'); wrapper.firstChild.insertAdjacentHTML('beforebegin', htmlCopyButton); var lang = (snippet.classList[1] || 'code').toUpperCase(); wrapper.setAttribute('data-lang', lang); &#125;); // Add copy to clipboard functionality and user feedback var clipboard = new ClipboardJS('.codecopy-btn', &#123; target: (trigger) =&gt; &#123; return trigger.nextSibling; &#125; &#125;); clipboard.on('success', (e) =&gt; &#123; e.trigger.setAttribute('aria-label', 'Copied!'); e.clearSelection(); &#125;); // Replace tooltip message when mouse leaves button // and prevent page refresh after click button var btns = document.querySelectorAll('.codecopy-btn'); btns.forEach((btn) =&gt; &#123; btn.addEventListener('mouseleave', (e) =&gt; &#123; e.target.setAttribute('aria-label', 'Copy to clipboard'); e.target.blur(); &#125;); btn.addEventListener('click', (e) =&gt; &#123; e.preventDefault() &#125;); &#125;);&#125;);接著在 themes\\material-flow\\layout\\_partial\\scripts.ejs 檔案內的載入 clipboard-use.js：1&lt;%- js('js/clipboard-use.js') %&gt;CSS 樣式提示文字樣式在 themes\\material-flow\\source\\less 目錄內建立 _tooltipped.less，檔案內容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ref: https://github.com/primer/primer/blob/master/modules/primer-tooltips/lib/tooltips.scss.tooltipped &#123; position: relative;&#125;// This is the tooltip bubble.tooltipped::after &#123; position: absolute; z-index: 1000000; display: none; padding: .5em .75em; -webkit-font-smoothing: subpixel-antialiased; color: #fff; text-align: center; text-decoration: none; text-shadow: none; text-transform: none; letter-spacing: normal; word-wrap: break-word; white-space: pre; pointer-events: none; content: attr(aria-label); background: #616161; border-radius: 3px; opacity: 0;&#125;// This is the tooltip arrow.tooltipped::before &#123; position: absolute; z-index: 1000001; display: none; width: 0; height: 0; color: #616161; pointer-events: none; content: \"\"; border: 6px solid transparent; opacity: 0;&#125;// delay animation for tooltip@keyframes tooltip-appear &#123; from &#123; opacity: 0; &#125; to &#123; opacity: 1; &#125;&#125;// This will indicate when we'll activate the tooltip.tooltipped:hover,.tooltipped:active,.tooltipped:focus &#123; &amp;::before, &amp;::after &#123; display: inline-block; text-decoration: none; animation-name: tooltip-appear; animation-duration: .1s; animation-fill-mode: forwards; animation-timing-function: ease-in; &#125;&#125;// Tooltipped south.tooltipped-s,.tooltipped-sw &#123; &amp;::after &#123; top: 100%; right: 50%; margin-top: 6px; &#125; &amp;::before &#123; top: auto; right: 50%; bottom: -7px; margin-right: -6px; border-bottom-color: #616161; &#125;&#125;.tooltipped-sw::after &#123; margin-right: -16px;&#125;// Move the tooltip body to the center of the object..tooltipped-s::after &#123; transform: translateX(50%);&#125;接著在 themes\\material-flow\\source\\style.less 檔案內的載入 _tooltipped.less：1@import \"less/_tooltipped.less\";其他樣式可參考本站的完整樣式：原始碼123456789101112131415161718192021222324252627282930313233343536373839404142figure &#123; &amp;.highlight &#123; position: relative; margin: 1rem 0; padding-top: 22px; &#125;&#125;.code-highlight &#123; position: relative; &amp;::before &#123; content: attr(data-lang); font-family: \"Roboto Mono\", Consolas, monospace, sans-serif; font-size: 0.6em; color: #b1b1b1; line-height: 18px; position: absolute; top: 4px; right: 7px; z-index: 1; &#125;&#125;.codecopy-btn &#123; width: 24px; height: 26px; position: absolute; top: 0; right: -24px; border: none; box-shadow: none; background: none; z-index: 1; font-size: 12px; color: #fff; transition: color 0.2s; &amp;:hover &#123; color: #7bf; &#125;&#125;Demo下面是原本的 HTML：123456789101112&lt;figure class=\"highlight javascript\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=\"gutter\"&gt; &lt;pre&gt;&lt;span class=\"line\"&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt; &lt;/td&gt; &lt;td class=\"code\"&gt; &lt;pre&gt;&lt;code class=\"hljs javascript\"&gt;...&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/figure&gt;使用後的 HTML：1234567891011121314151617&lt;div class=\"code-highlight\" data-lang=\"JAVASCRIPT\"&gt; &lt;button class=\"codecopy-btn tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard\"&gt; &lt;i class=\"far fa-copy\" aria-hidden=\"true\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;figure class=\"highlight javascript\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=\"gutter\"&gt; &lt;pre&gt;&lt;span class=\"line\"&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt; &lt;/td&gt; &lt;td class=\"code\"&gt; &lt;pre&gt;&lt;code class=\"hljs javascript\"&gt;...&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/figure&gt;&lt;/div&gt;畫面：參考連結clipboard.js — Copy to clipboard without FlashGitHub’s Primer Tooltipszenorocha/codecopy: A browser extension that adds copy to clipboard buttons on every code block","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://titangene.github.io/tags/hexo/"},{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/tags/blog/"},{"name":"Code Snippet","slug":"code-snippet","permalink":"https://titangene.github.io/tags/code-snippet/"},{"name":"Clipboard","slug":"clipboard","permalink":"https://titangene.github.io/tags/clipboard/"}]},{"title":"在 Docker 下建立並使用 MSSQL Server for Linux","slug":"docker-mssql-server-for-linux","date":"2019-01-30T15:30:00.000Z","updated":"2019-02-07T11:20:51.282Z","comments":true,"path":"article/docker-mssql-server-for-linux.html","link":"","permalink":"https://titangene.github.io/article/docker-mssql-server-for-linux.html","excerpt":"在 SQL Server 2017 時，微軟推出了 Linux 版，同時也在 Docker Hub 上提供了 microsoft/mssql-server-linux 的 Docker image。本篇會介紹如何在 Docker 下，透過此 image 來建立並使用 MSSQL Server for Linux。","text":"在 SQL Server 2017 時，微軟推出了 Linux 版，同時也在 Docker Hub 上提供了 microsoft/mssql-server-linux 的 Docker image。本篇會介紹如何在 Docker 下，透過此 image 來建立並使用 MSSQL Server for Linux。MSSQL Server for Linux 要求必須 Docker Engine 1.8+，支援任何平台 (Windows/Mac/Linux)硬碟空間至少 2 GBRAM 至少 2 GBimage 必要的環境變數：ACCEPT_EULA=Y：確認同意授權合約MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;：設定 SA 密碼A strong system administrator (SA) 密碼必須符合以下規則：至少 8 個字元必需包含英文大寫、英文小寫、數字、非字母數字符號四者中的其中三種即可詳情可參考官方的 SQL Server on Liunx 的系統需求 文件。建立 ContainerDocker Hub：microsoft/mssql-server-linux1234567# 從 Docker Hub 提取 SQL Server 2017 Linux container image$ docker pull microsoft/mssql-server-linux:2017-latest# 建立並執行 Docker container$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1401:1433 --name sql1 \\ -d microsoft/mssql-server-linux:2017-latest-e 'ACCEPT_EULA=Y'：確認同意授權合約-e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;'：必需是強密碼並至少 8 個字元。強密碼英文大寫、英文小寫、數字、非字母數字符號四者中的其中三種即可。-p hostPort:containerPort：host 對外開 1401 port，container 內開 1433 port--name：指定 container 名稱-d：背景執行microsoft/mssql-server-linux:2017-latest：使用 SQL Server 2017 Linux image 建立 container如果列表 NAMES 顯示 sql1 並且 STATUS 顯示 UP 就代表 SQL Server 已在背景執行：1234# 查看 container 的狀態$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES08e2f151d579 microsoft/mssql-server-linux:2017-latest \"/bin/sh -c /opt/mss…\" 31 minutes ago Up 31 minutes 0.0.0.0:1401-&gt;1433/tcp sql1連接至 SQL Server使用 SQL Server 命令列工具 sqlcmd，連接到 SQL Server container：123456789# 在外部向執行中的 container 內部下指令，啟動 Container 內部的互動式 bash shell，來執行你下的指令$ docker exec -it sql1 bash# 使用 SQL Server 命令列工具 `sqlcmd`，並登入帳號密碼連接到 SQL Server$ /opt/mssql-tools/bin/sqlcmd -S localhost -U SAPassword:# 出現 \"1&gt;\" 就代表已成功登入並已進入 sqlcmd1&gt;變更 SA 的密碼SA 帳號是在安裝期間建立的 SQL Server 實例上的系統管理員。建立 SQL Server container 之後，在 container 中執行 echo $MSSQL_SA_PASSWORD，即可查看 SA 的密碼：123$ docker exec -it sql1 bashroot@xxx:/# echo $MSSQL_SA_PASSWORDYourStrong!Passw0rd執行下面指令可以變更 SA 的密碼，而 opt/mssql-tools/bin/sqlcmd 是 sqlcmd 所在的路徑：123$ docker exec -it sql1 /opt/mssql-tools/bin/sqlcmd \\ -S localhost -U SA -P '&lt;YourStrong!Passw0rd&gt;' \\ -Q 'ALTER LOGIN SA WITH PASSWORD=\"&lt;YourNewStrong!Passw0rd&gt;\"'參數說明：-S：server-U：user name-P：password-Q：query，執行 SQL 指令後結束 sqlcmd建立資料庫及查詢資料123456789101112131415161718192021# 查詢 server 上所有 DB 名稱1&gt; SELECT Name from sys.Databases# 在 sqlcmd 指令模式下，要輸入 GO 指令才會執行2&gt; GOName------------mastertempdbmodelmsdb(4 rows affected)# 建立資料庫1&gt; CREATE DATABASE TestDB2&gt; GO# 出現下面畫面 \"1&gt;\" 就代表已成功建立資料庫1&gt;# 離開 sqlcmd1&gt; quit使用 Azure Data Studio 連接 SQL ServerAzure Data Studio (以前稱為 SQL Operations Studio) 是一個輕量且免費的跨平台 SQL Server 開源管理工具，支援 Windows、macOS、Linux。安裝 Azure Data Studiofor Windows下載並解壓縮，接著執行 \\azuredatastudio-windows\\sqlops.exe 即可開始使用。for Linux下載並解壓縮，接著將 Azure Data Studio 執行檔加入 PATH 環境變數，以後即可在終端機輸入 azuredatastudio 開啟 Azure Data Studio：123456$ cd ~$ cp ~/Downloads/azuredatastudio-linux-&lt;version string&gt;.tar.gz ~$ tar -xvf ~/azuredatastudio-linux-&lt;version string&gt;.tar.gz$ echo 'export PATH=\"$PATH:~/azuredatastudio-linux-x64\"' &gt;&gt; ~/.bashrc$ source ~/.bashrc$ azuredatastudiofor macOS下載並解壓縮，然後將 Azure Data Studio 加入 Launchpad，將 Studio.app 拖曳到應用程式目錄 (Applications folder) 即可。安裝詳情可參考官方的 下載並安裝 - Azure Data Studio | Microsoft Docs 文件。登入 SQL ServerServer name 的格式： IP, PortIP：Linux：使用 ifconfig 指令查詢 IPWindows：使用 ipconfig 指令查詢 IPPort：要看前面建立的 container 是設定多少 Port此範例 (也就是下面的指令) 是設定使用 1401 port，所以只要輸入 YourIP, 1401 就能與 SQL Server 連接。123$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1401:1433 --name sql1 \\ -d microsoft/mssql-server-linux:2017-latest建立資料表和資料，並查詢資料執行下面指令，建立資料表和資料，並查詢資料：12345678-- 切換至 TestDB 資料庫use TestDB;-- 建立資料表CREATE TABLE People(Name nvarchar(50), Age int);-- 新增資料INSERT INTO People VALUES ('Titan', 18), ('John', 6), ('Alex', 40);-- 查詢年齡小於 20 歲的人SELECT * FROM People WHERE Age &lt; 20;執行完的結果如下圖，看到此查詢結果就代表已成功新增資料：刪除 Container指定刪除名為 sql1 的 container：12345678# 查詢目前的正在執行的 container$ docker ps# container 停止執行$ docker stop sql# 刪除 container$ docker rm sql1或是可以在未停止執行 container 的情況下，直接強制刪除 container：12# 強制刪除 container$ docker rm -f sql1透過 Volume 將資料庫的資料儲存至主機在 docker run 指令上加 -v 參數可以建立實體資料夾與 container 資料夾的對應關係，將主機上的指定目錄綁定到 container 的指定目錄，也就是可以存資料庫的資料至主機，參數語法為 -v &lt;host directory&gt;:/var/opt/mssql：12345# 執行 Docker container image$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1402:1433 --name sql2 \\ -v `pwd`/mssql:/var/opt/mssql \\ -d microsoft/mssql-server-linux:2017-latest備份與還原資料庫範例前置準備：建立資料庫、資料表和資料下面的 SQL 指令是用來立資料庫、資料表和資料，因為此 container 是剛剛另外新建的，之前的 container 已經刪除了 (因為沒有利用 Volume 儲存資料庫的資料)，所以需要重新建立資料：123456789-- 建立 資料庫CREATE DATABASE TestDB;GO-- 切換至 TestDB 資料庫use TestDB;-- 建立資料表CREATE TABLE People(Name nvarchar(50), Age int);-- 新增資料INSERT INTO People VALUES ('Titan', 18), ('John', 6), ('Alex', 40);備份資料庫使用 sqlcmd 連接到 SQL Server，並完整備份 TestDB 資料庫，備份檔存至 ./data/testdb.bak：12$ docker exec -it sql2 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA \\ -Q \"BACKUP DATABASE TestDB TO DISK = N'/var/opt/mssql/data/testdb.bak' WITH NOFORMAT, NOINIT, NAME = 'demodb-full', SKIP, NOREWIND, NOUNLOAD, STATS = 10\"當執行此指令時，SQL Server 將會提示需輸入密碼。輸入密碼後，很快就會備份完成，如果備份成功畫面就會顯示「BACKUP DATABASE successfully …」：1234567891011121314Password: 10 percent processed.20 percent processed.30 percent processed.40 percent processed.50 percent processed.60 percent processed.70 percent processed.80 percent processed.90 percent processed.Processed 312 pages for database 'TestDB', file 'TestDB' on file 1.100 percent processed.Processed 6 pages for database 'TestDB', file 'TestDB_log' on file 1.BACKUP DATABASE successfully processed 318 pages in 0.348 seconds (7.139 MB/sec).範例前置處理：刪除 container 和資料庫資料下面是要模擬把 container 刪除後，要如何將剛剛備份的資料庫資料 (也就是 ./data/testdb.bak ) 還原，因此也要刪除透過 Volume 儲存的資料庫資料，如以下步驟：刪除 container1234# 查詢目前的正在執行的 container$ docker ps# 強制刪除 container$ docker rm -f sql2刪除透過 Volume 儲存的資料庫資料1234567891011121314151617181920212223242526272829# 查看剛剛刪除的 container 保存下來的 DB 資料檔 (TestDB_log.ldf 和 TestDB.mdf)$ cd mssql/data$ pwd/home/titan/project/mssql/data$ tree├── master.mdf├── mastlog.ldf├── modellog.ldf├── model.mdf├── msdbdata.mdf├── msdblog.ldf├── tempdb.mdf├── templog.ldf├── testdb.bak├── TestDB_log.ldf &lt;---└── TestDB.mdf &lt;---# 刪除 TestDB.mdf 和 TestDB_log.ldf$ sudo rm TestDB*$ tree├── master.mdf├── mastlog.ldf├── modellog.ldf├── model.mdf├── msdbdata.mdf├── msdblog.ldf├── tempdb.mdf├── templog.ldf└── testdb.bak在建立一個新的 container (用來做還原資料庫用的)先回到專案的根目錄：12345$ pwd/home/titan/project/mssql/data$ cd ../..$ pwd/home/titan/project接著建立一個新的 container，名稱叫做 sql3：1234$ docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;' \\ -p 1403:1433 --name sql3 \\ -v `pwd`/mssql:/var/opt/mssql \\ -d microsoft/mssql-server-linux:2017-latest還原資料庫使用 sqlcmd 連接到 SQL Server，並還原 TestDB 資料庫 (要還原的備份檔存至 ./data/testdb.bak )：12$ docker exec -it sql3 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA \\ -Q \"RESTORE DATABASE TestDB FROM DISK = N'/var/opt/mssql/data/testdb.bak' WITH FILE = 1, NOUNLOAD, REPLACE, STATS = 5\"當執行此指令時，SQL Server 將會提示需輸入密碼。輸入密碼後，很快就會還原完成，如果還原成功畫面就會顯示「RESTORE DATABASE successfully …」：123456789101112131415161718192021222324Password: 6 percent processed.11 percent processed.15 percent processed.20 percent processed.25 percent processed.31 percent processed.36 percent processed.41 percent processed.45 percent processed.50 percent processed.57 percent processed.61 percent processed.66 percent processed.70 percent processed.75 percent processed.82 percent processed.86 percent processed.91 percent processed.95 percent processed.100 percent processed.Processed 344 pages for database 'TestDB', file 'TestDB' on file 1.Processed 7 pages for database 'TestDB', file 'TestDB_log' on file 1.RESTORE DATABASE successfully processed 351 pages in 0.321 seconds (8.530 MB/sec).檢查一下剛剛刪除的 TestDB.mdf 和 TestDB_log.ldf 都正確的還原了：12345678910111213$ cd mssql/data$ tree├── master.mdf├── mastlog.ldf├── modellog.ldf├── model.mdf├── msdbdata.mdf├── msdblog.ldf├── tempdb.mdf├── templog.ldf├── testdb.bak├── TestDB_log.ldf &lt;---└── TestDB.mdf &lt;---使用 select SQL 指令可以看到資料確實已還原：使用 Azure Data Studio 備份或還原資料庫如果覺得打指令很麻煩，其實 Azure Data Studio、SQL Server Management Studio (SSMS)、SQL Server Data Tools (SSDT) 或 Visual Studio Code (VS Code) 的 mssql 擴充功能 都有提供 GUI 的介面，可以直接備份或還原資料庫。下圖是 Azure Data Studio 備份或還原資料庫的畫面：詳情可參考官方的 備份與還原的資料庫 - Azure Data Studio | Microsoft Docs 文件。參考連結開始使用 Docker （Linux 上執行 SQL Server） 上的 SQL Server 容器 - SQL Server | Microsoft Docs在 Docker 上的 SQL Server 組態選項 - SQL Server | Microsoft Docs在 Docker 中的 SQL Server 資料庫還原 - SQL Server | Microsoft DocsGithub repo: Microsoft/mssql-docker","categories":[{"name":"DevOps","slug":"devops","permalink":"https://titangene.github.io/categories/devops/"}],"tags":[{"name":"Database","slug":"database","permalink":"https://titangene.github.io/tags/database/"},{"name":"Docker","slug":"docker","permalink":"https://titangene.github.io/tags/docker/"},{"name":"Container","slug":"container","permalink":"https://titangene.github.io/tags/container/"},{"name":"SQL Server","slug":"sql-server","permalink":"https://titangene.github.io/tags/sql-server/"},{"name":"Linux","slug":"linux","permalink":"https://titangene.github.io/tags/linux/"}]},{"title":"將 Hexo 的 Markdown 渲染引擎換成 markdown-it","slug":"hexo-markdown-it","date":"2019-01-29T14:51:00.000Z","updated":"2019-02-08T14:14:56.125Z","comments":true,"path":"article/hexo-markdown-it.html","link":"","permalink":"https://titangene.github.io/article/hexo-markdown-it.html","excerpt":"個人很常用 HackMD 紀錄筆記，希望 blog 也可以支援 HackMD 的 Markdown 格式，因此本篇的目標就是要將 Hexo 原本的 Markdown 渲染引擎 marked，換成 HackMD 的 Markdown 渲染引擎：markdown-it。","text":"個人很常用 HackMD 紀錄筆記，希望 blog 也可以支援 HackMD 的 Markdown 格式，因此本篇的目標就是要將 Hexo 原本的 Markdown 渲染引擎 marked，換成 HackMD 的 Markdown 渲染引擎：markdown-it。更換渲染引擎Hexo 預設的 markdown 渲染引擎是 marked，並使用 hexo-renderer-marked 此 Hexo 外掛來將 Markdown 轉換成靜態檔案 HTML，但因前面提到的需求，所以要刪除原本的渲染引擎1$ npm uninstall hexo-renderer-marked --save安裝我們要改用的 Markdown 渲染引擎：markdown-it，而使用此渲染引擎的 Hexo 外掛就是 hexo-renderer-markdown-it，所以要在 hexo 的專案中安裝此外掛：1$ npm install git+https://github.com/hexojs/hexo-renderer-markdown-it.git --save為何安裝 NPM 套件時要指定 github 的 repo 呢？因為 hexo-renderer-markdown-it 此 NPM 套件的程式沒有更新成 Github 上面的程式版本，請確定剛剛安裝套件中，node_modules\\hexo-renderer-markdown-it\\lib\\renderer.js 這個檔案內的下面這段程式碼是否相同：123456789if (opt.plugins) &#123; parser = opt.plugins.reduce(function (parser, pugs) &#123; if (pugs instanceof Object &amp;&amp; pugs.name) &#123; return parser.use(require(pugs.name), pugs.options); &#125; else &#123; return parser.use(require(pugs)); &#125; &#125;, parser);&#125;若是從 NPM 下載的套件版本 (也就是直接使用 npm install hexo-renderer-markdown-it --save 此指令)，會少幾句程式，少了可在載入 markdown-it 的外掛時為該外掛設定所需的 options：12345if (opt.plugins) &#123; parser = opt.plugins.reduce(function (parser, pugs) &#123; return parser.use(require(pugs)); &#125;, parser);&#125;安裝渲染引擎外掛套件我們可以參考 HackMD 的相依套件，只要是名為 markdown-it-xxx 的套件就是渲染引擎 markdown-it 的外掛：12345678910111213141516171819&#123; \"dependencies\": &#123; // ... \"markdown-it\": \"^8.2.2\", \"markdown-it-abbr\": \"^1.0.4\", \"markdown-it-container\": \"^2.0.0\", \"markdown-it-deflist\": \"^2.0.1\", \"markdown-it-emoji\": \"^1.3.0\", \"markdown-it-footnote\": \"^3.0.1\", \"markdown-it-imsize\": \"^2.0.1\", \"markdown-it-ins\": \"^2.0.0\", \"markdown-it-mark\": \"^2.0.0\", \"markdown-it-mathjax\": \"^2.0.0\", \"markdown-it-regexp\": \"^0.4.0\", \"markdown-it-sub\": \"^1.0.0\", \"markdown-it-sup\": \"^1.0.0\", // ... &#125;&#125;而下列是我選擇要安裝的外掛：markdown-it-abbrmarkdown-it-containermarkdown-it-deflistmarkdown-it-emojimarkdown-it-footnotemarkdown-it-imsizemarkdown-it-insmarkdown-it-markmarkdown-it-regexpmarkdown-it-submarkdown-it-supmarkdown-it-task-checkbox1$ npm i markdown-it-abbr markdown-it-checkbox markdown-it-container markdown-it-deflist markdown-it-emoji markdown-it-footnote markdown-it-imsize markdown-it-ins markdown-it-mark markdown-it-regexp markdown-it-sub markdown-it-sup --savemarkdown-it-mathjax為何我未安裝 markdown-it-mathjax 這個外掛？這是因為…我之後再單獨寫一篇文章來介紹如何在 Markdown 加上數學式 MathJax。markdown-it-task-checkbox為何我會比 HackMD 多安裝 markdown-it-task-checkbox 這個外掛？有使用過 HackMD 的朋友都知道，只要在 HackMD 輸入下列 Markdown 語法：12[ ] task 1[x] task 2就會被轉換成 HTML 的 checkbox：1234&lt;ul&gt; &lt;li class=\"task-list-item\"&gt;&lt;input type=\"checkbox\" class=\"task-list-item-checkbox \"&gt;&lt;label&gt;&lt;/label&gt;task 1&lt;/li&gt; &lt;li class=\"task-list-item\"&gt;&lt;input type=\"checkbox\" class=\"task-list-item-checkbox\" checked=\"\"&gt;&lt;label&gt;&lt;/label&gt;task 2&lt;/li&gt;&lt;/ul&gt;畫面會看到一個未被勾選以及一個已被勾選的 checkbox：不過 HackMD 不是靠著 Markdown 渲染引擎 markdown-it 的外掛來轉換成 HTML 的，而是直接利用正規表示法 (Regular Expression) 找到 [ ] 或 [x] 的文字，再將這些文字直接轉換成 HTML 的 checkbox。我擷取了 HackMD 的這段程式邏輯，若想看詳細的原始碼可至 HackMD 的原始碼內的 public/js/extra.js 檔案中的第 263 行左右：123456789if (/^\\s*\\[[x ]\\]\\s*/.test(html)) &#123; li.innerHTML = html.replace(/^\\s*\\[ \\]\\s*/, `&lt;input type=\"checkbox\" class=\"task-list-item-checkbox\" $&#123;disabled&#125;&gt;&lt;label&gt;&lt;/label&gt;`) .replace(/^\\s*\\[x\\]\\s*/, `&lt;input type=\"checkbox\" class=\"task-list-item-checkbox\" checked $&#123;disabled&#125;&gt;&lt;label&gt;&lt;/label&gt;`) if (li.tagName.toLowerCase() !== 'li') &#123; li.parentElement.setAttribute('class', 'task-list-item') &#125; else &#123; li.setAttribute('class', 'task-list-item') &#125;&#125;設定 _config.yml將下面這些設定在根目錄的 _config.yml 設定檔中：123456789101112131415161718192021222324252627282930313233343536373839# Markdown-it config# Docs: https://github.com/hexojs/hexo-renderer-markdown-it/wikimarkdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-deflist - markdown-it-imsize - markdown-it-mark - markdown-it-regexp - markdown-it-task-checkbox - name: markdown-it-container options: success - name: markdown-it-container options: info - name: markdown-it-container options: warning - name: markdown-it-container options: danger - markdown-it-deflist - name: markdown-it-emoji options: shortcuts: &#123;&#125; anchors: level: 1 collisionSuffix: 'v' permalink: true permalinkClass: header-anchor permalinkSymbol: ''想了解設定詳情可參考 Advanced Configuration | hexojs/hexo-renderer-markdown-it Wiki 官方文件。","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://titangene.github.io/tags/hexo/"},{"name":"Markdown","slug":"markdown","permalink":"https://titangene.github.io/tags/markdown/"},{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/tags/blog/"}]},{"title":"Flutter 載入圖片","slug":"flutter-loading-images","date":"2018-12-31T13:10:00.000Z","updated":"2019-01-29T15:52:00.015Z","comments":true,"path":"article/flutter-loading-images.html","link":"","permalink":"https://titangene.github.io/article/flutter-loading-images.html","excerpt":"要如何在 Flutter 內載入圖片？這篇做個小記錄。","text":"要如何在 Flutter 內載入圖片？這篇做個小記錄。指定資源Flutter 是在根目錄內的 pubspec.yaml 檔案來設定應用程式所需的資源，設定的資源沒有順序關係。若要指定某些資源，資源的路徑是相對於 pubspec.yaml 檔案的相對路徑：1234flutter: assets: - assets/images/avatar.jpg - assets/images/background.jpg也可以指定某個目錄，代表可以存取到這個目錄下的所有資源，但記得要在目錄的最後加上 / 這個符號：123flutter: assets: - assets/若要存取子目錄內的資源，請記得要另外為子目錄設定，例如：1234flutter: assets: - assets/ - assets/images/載入圖片可使用 Image.asset() 來載入圖片，裡面的參數就是圖片的路徑：12345Widget build(BuildContext context) &#123; // ... return Image.asset('assets/images/background.jpg'); // ...&#125;或是在 Image() 內的 image 參數使用 AssetImage()：1234567Widget build(BuildContext context) &#123; // ... return Image( image: AssetImage('assets/images/background.jpg'), ); // ...&#125;最後顯示的結果會一樣：參考連結Adding assets and images - Flutter","categories":[{"name":"Native App","slug":"native-app","permalink":"https://titangene.github.io/categories/native-app/"}],"tags":[{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"},{"name":"Flutter","slug":"flutter","permalink":"https://titangene.github.io/tags/flutter/"},{"name":"Native App","slug":"native-app","permalink":"https://titangene.github.io/tags/native-app/"}]},{"title":"Python - 日誌 (logging) 模組","slug":"python-logging","date":"2018-12-13T10:32:46.000Z","updated":"2019-02-07T11:20:51.642Z","comments":true,"path":"article/python-logging.html","link":"","permalink":"https://titangene.github.io/article/python-logging.html","excerpt":"開發 Python 時，很常使用 print() 來輸出變數以方便 debug，但要部署時，不需要這些訊息，需要自己手動去註解或刪除那些放在各處的 print()。而 Python 內建提供了 logging 模組可以用來取代 print()，logging 除了可以輸出訊息，也可以將訊息儲存至日誌檔保存。下面紀錄如何使用 logging 模組。","text":"開發 Python 時，很常使用 print() 來輸出變數以方便 debug，但要部署時，不需要這些訊息，需要自己手動去註解或刪除那些放在各處的 print()。而 Python 內建提供了 logging 模組可以用來取代 print()，logging 除了可以輸出訊息，也可以將訊息儲存至日誌檔保存。下面紀錄如何使用 logging 模組。載入 logging 模組1import logginglogging 等級logging 模組預先定義了 6 種等級以及對應的 log 輸出函數 (除了 logging.NOTSET 沒有對應的輸出函數)：等級等級數值輸出函數說明NOTSET0無對應的輸出函數未設定DEBUG10logging.debug()除錯INFO20logging.info()訊息WARNING30logging.warning()警告ERROR40logging.error()錯誤CRITICAL50logging.critical()嚴重錯誤若要查詢各等級的數值，可直接呼叫該等級：12345678import loggingprint(logging.NOTSET) # 0print(logging.DEBUG) # 10print(logging.INFO) # 20print(logging.WARNING) # 30print(logging.ERROR) # 40print(logging.CRITICAL) # 50若要用等級數值來查詢是哪個等級的訊息，可使用 logging.getLevelName(level)：12345678import loggingprint(logging.getLevelName(0)) # NOTSETprint(logging.getLevelName(10)) # DEBUGprint(logging.getLevelName(20)) # INFOprint(logging.getLevelName(30)) # WARNINGprint(logging.getLevelName(40)) # ERRORprint(logging.getLevelName(50)) # CRITICAL輸出 logginglogging 模組預設等級為 WARNING，大於或等於 WARNING 等級的訊息才會被記錄：1234567import logginglogging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是輸出結果，可以看到比 WARNING 等級還要低的訊息有 DEBUG 和 INFO 就不會被輸出：123WARNING:root:warning messageERROR:root:error messageCRITICAL:root:critical message若將等級設為 DEBUG，就會將所有等級的訊息都輸出：123456789import logginglogging.basicConfig(level=logging.DEBUG)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是輸出結果，預設的訊息輸出格式是 %(levelname)s:%(name)s:%(message)s (後面會介紹如何自訂輸出格式)：12345DEBUG:root:debug messageINFO:root:info messageWARNING:root:warning messageERROR:root:error messageCRITICAL:root:critical message紀錄堆疊追蹤資訊logging 模組也提供可以紀錄完整的堆疊追蹤 (stack traces)，若在 logging.error() 加上 exc_info 參數，並將該參數設為 True，就可以紀錄 Exception，如下：123456import loggingtry: x = 5 / 0except: logging.error(\"Catch an exception.\", exc_info=True)下面是輸出結果：12345ERROR:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zero若沒有加上 exc_info=True 則無法紀錄 Exception：123456import loggingtry: x = 5 / 0except: logging.error(\"Catch an exception.\")下面是輸出結果：1ERROR:root:Catch an exception.若要在 logging 內紀錄 exception 訊息，可使用 logging.exception()，它會將 exception 添加至訊息中，此方法的等級為 ERROR，也就是說 logging.exception() 就等同於 logging.error(exc_info=True)123456import loggingtry: x = 5 / 0except: logging.exception('Catch an exception.')輸出結果和 logging.error(exc_info=True) 相同：12345ERROR:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zero若不想使用 ERROR 級別紀錄 exception 訊息，可使用 DEBUG、INFO、WARNING、CRITICAL 級別並加上參數 exc_info=True 的設定：1234567891011import logginglogging.basicConfig(level=logging.DEBUG)try: x = 5 / 0except: logging.debug('Catch an exception.', exc_info=True) logging.info('Catch an exception.', exc_info=True) logging.warning('Catch an exception.', exc_info=True) logging.critical('Catch an exception.', exc_info=True)下面是輸出結果：1234567891011121314151617181920DEBUG:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zeroINFO:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zeroWARNING:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zeroCRITICAL:root:Catch an exception.Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; x = 5 / 0ZeroDivisionError: division by zero自訂 logging 輸出格式預設的訊息輸出格式只有 levelname、name、message，下面是其他相關的資訊：格式化字串說明%(asctime)s日期時間, 格式為 YYYY-MM-DD HH:mm:SS,ms，例如：2018-12-13 17:20:30,567%(filename)s模組檔名%(funcName)s函數名稱%(levelname)s日誌的等級名稱%(levelno)s日誌的等級數值%(lineno)d呼叫日誌函數所在的行數%(message)s訊息%(module)s模組名稱%(name)slogger 的名稱%(pathname)s檔案的完整路徑 (如果可用)%(process)dprocess ID (如果可用)%(thread)d執行緒 ID (如果可用)%(threradName)s執行緒名稱可將這些資訊加入 logging.basicConfig() 內的 format 參數：12345678910import loggingFORMAT = '%(asctime)s %(levelname)s: %(message)s'logging.basicConfig(level=logging.DEBUG, format=FORMAT)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是自訂訊息的輸出結果：123452018-12-13 17:40:34,604 DEBUG: debug message2018-12-13 17:40:34,604 INFO: info message2018-12-13 17:40:34,604 WARNING: warning message2018-12-13 17:40:34,604 ERROR: error message2018-12-13 17:40:34,608 CRITICAL: critical message自訂輸出的時間格式在 logging.basicConfig() 內的 datefmt 參數可設定所需的時間格式，要使用 time.strftime() 接受的時間格式：參數說明%Y長年份，例如：2019%y短年份，例如：19%m月份：01 ~ 12%B月份完整名稱，例如：February%b月份縮寫名稱，例如：Feb%d日期：01 ~ 31%H小時 (24 小時制)：00 ~ 23%I小時 (12 小時制)：01 ~ 12%w星期：0 ~ 6，0 代表星期日%A星期完整名稱，例如：Friday%a星期縮寫名稱，例如：Fri%PAM 或 PM%M分鐘：00 ~ 59%S秒：00 ~ 61time.strftime() 的時間參數詳情可參考 Python 官方的 time — Time access and conversions — Python 3.7.2 documentation 文件。1234567891011import loggingLOGGING_FORMAT = '%(asctime)s %(levelname)s: %(message)s'DATE_FORMAT = '%Y%m%d %H:%M:%S'logging.basicConfig(level=logging.DEBUG, format=LOGGING_FORMAT, datefmt=DATE_FORMAT)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')下面是自訂訊息的輸出結果：1234520190107 08:57:07 DEBUG: debug message20190107 08:57:07 INFO: info message20190107 08:57:07 WARNING: warning message20190107 08:57:07 ERROR: error message20190107 08:57:07 CRITICAL: critical message儲存 logging只要在 logging.basicConfig() 內的 filename 參數設定要儲存的日誌檔名，就可以將 logging 儲存：12345678910import loggingFORMAT = '%(asctime)s %(levelname)s: %(message)s'logging.basicConfig(level=logging.DEBUG, filename='myLog.log', filemode='w', format=FORMAT)logging.debug('debug message')logging.info('info message')logging.warning('warning message')logging.error('error message')logging.critical('critical message')預設 filemode 參數是設為 a，代表 append (附加) 的意思，每次執行程式時，Logging 會將新的訊息加在舊的訊息後面，不會覆蓋舊的訊息。若要改成新訊息覆蓋就訊息，那可以將 filemode 參數設為 w，代表 write 的意思。下面是剛剛執行後儲存的 myLog.log 日誌檔：123452018-12-13 17:47:18,686 DEBUG: debug message2018-12-13 17:47:18,687 INFO: info message2018-12-13 17:47:18,687 WARNING: warning message2018-12-13 17:47:18,687 ERROR: error message2018-12-13 17:47:18,687 CRITICAL: critical message詳情可參考官方文件 Logging facility for Python — Python documentation。","categories":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/tags/python/"},{"name":"Logging","slug":"logging","permalink":"https://titangene.github.io/tags/logging/"}]},{"title":"設定 Windows 工作排程定期執行 Python 爬蟲程式","slug":"set-up-windows-task-scheduler-to-periodically-execute-python-crawler","date":"2018-12-01T04:55:00.000Z","updated":"2019-02-01T13:35:53.183Z","comments":true,"path":"article/set-up-windows-task-scheduler-to-periodically-execute-python-crawler.html","link":"","permalink":"https://titangene.github.io/article/set-up-windows-task-scheduler-to-periodically-execute-python-crawler.html","excerpt":"如何將 Python 爬蟲程式定期執行？使用 Windows 的使用者可以選擇「工作排程器」來解決。","text":"如何將 Python 爬蟲程式定期執行？使用 Windows 的使用者可以選擇「工作排程器」來解決。最近有些資料想透過爬蟲來擷取，而且希望可以定期 (例如：每 10 分鐘一次) 自動執行爬蟲程式，因此就有了這篇筆記。下面介紹如何以 Windows 工作排程器來定期執行爬蟲程式。目標每 10 分鐘自動執行 Python 爬蟲程式，將爬蟲抓到的最新降雨量資料存入 CSV 檔內收集。準備WindowsPython 環境：建議安裝 Anaconda，可參考 用 Conda 建立虛擬環境和管理相依套件Python 套件 (這是本篇爬蟲範例所需的相依套件，可依各自需求來選擇)PandasNumpyRequestsPython 爬蟲程式原始碼source code: titangene/cwb-opendata-crawler-demo/crawler.py簡單說明一下程式的執行步驟：利用 Python 的 Requests 套件來建立 HTTP 的 GET 請求，從中央氣象局提供的開放資料 API 中取得資料，回傳的格式是 JSON解析 API 回傳的 JSON 資料，並將 JSON 轉成 Pandas 的 DataFrame 型別的資料格式將 DataFrame 儲存成 CSV 檔保存資料若想了解中央氣象局開放資料的相關內容，詳情可參考 中央氣象局開放資料 - 開發指南。Python 爬蟲程式的批次檔建立一個副檔名為 .bat 的批次檔，批次檔是用來執行 Python 爬蟲程式，因此就能讓 Windows 工作排程器在定期時間自動執行批次檔，以達成自動化執行爬蟲的目的。下面就來說明批次檔每行都做了甚麼：第一行：切到指定目錄第二行：指定 Python 虛擬環境 (可參考 用 Conda 建立虛擬環境和管理相依套件。如果要在全域環境下執行就不需要這行)第三行：執行 Python 爬蟲程式第四行：若想查看 Python 爬蟲程式執行過程中所輸出 (也就是執行 print 方法的部分) 內容，就需要取消這行的註解REM：單行註解pause：用來暫停批次檔的執行1234cd /d D:/Project/Python/cwb-opendata-crawlercall activate devcall python crawler.pyREM pausesource code: titangene/cwb-opendata-crawler-demo/crawler.batWindows 工作排程器 簡介可預先設定工作在特定時間或指定時間時，會自動執行程式或批次檔以達成工作自動化。下圖為 Windows 10 的工作排程器介面：建立工作，設定定期執行爬蟲程式開啟 Windows 的「工作排程器」，點擊右上角的「建立工作」自訂工作名稱，若有權限需求可勾選「以最高權限執行」選項接著新增「觸發程序」設定工作的開始時間，並選擇「僅一次」，以及設定工作要每隔多久就執行一次，並且要持續多久時間然後新增「動作」設定要自動執行的程式，這邊選擇的就是剛剛提到的 批次檔 (原始碼)如果設定好了就可以按確定完成建立工作，此時就會看到在「工作排程器程式庫」內的工作清單中，多了剛剛新增的工作成果可以看到爬蟲程式會在定期自動執行，執行的時候會跳出一個 cmd 視窗。若剛剛提到的 批次檔 內沒有將 REM pause 這行註解，就會看到爬蟲程式執行完成後，不會自動關閉 cmd 視窗，這是為了可以立即看到該次爬蟲執行過程中輸出的訊息。下圖就是自動執行爬蟲所抓到的資料：完整 source code：titangene/cwb-opendata-crawler-demo","categories":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/tags/python/"},{"name":"Python Requests","slug":"python-requests","permalink":"https://titangene.github.io/tags/python-requests/"},{"name":"Crawler","slug":"crawler","permalink":"https://titangene.github.io/tags/crawler/"},{"name":"Windows","slug":"windows","permalink":"https://titangene.github.io/tags/windows/"},{"name":"Windows 工作排程","slug":"windows-工作排程","permalink":"https://titangene.github.io/tags/windows-工作排程/"}]},{"title":"用 Conda 建立虛擬環境和管理相依套件","slug":"create-a-virtual-environment-and-manage-dependencies-with-conda","date":"2018-11-19T09:10:00.000Z","updated":"2019-02-07T11:20:51.916Z","comments":true,"path":"article/create-a-virtual-environment-and-manage-dependencies-with-conda.html","link":"","permalink":"https://titangene.github.io/article/create-a-virtual-environment-and-manage-dependencies-with-conda.html","excerpt":"學習如何利用 Conda 來建立不同需求所需的 Python 開發環境，並如何管理相依套件。","text":"學習如何利用 Conda 來建立不同需求所需的 Python 開發環境，並如何管理相依套件。AnacondaAnaconda 是最受歡迎的 Python 資料科學 (Data Science) 平台，它特點就是本來就包含了各種數據分析、科學計算的相關套件 (例如：NumPy、SciPy、Matplotlib、SymPy、Pandas … 等)，而 Anaconda 的套件管理工具就是 conda。CondaConda 是一個開源的套件與環境管理的系統，可以在 Windows、macOS 和 Linux 上使用。可利用 Conda 來安裝、執行、更新套件以及其相依的套件，並且還可用來建立不同的開發環境 (例如：不同環境有不同的 Python 版本)。安裝 Anaconda至 Anaconda 官網下載並安裝，建議選擇 Python 3.x 的版本。建立虛擬環境從指定套件列表中建立新的 conda 環境：-n，--name：設定環境名稱1234567$ conda create -n &lt;environment&gt; &lt;package&gt;# 安裝包含 Anaconda 發行版的套件$ conda create -n &lt;environment&gt; anaconda# 指定 Python 版本$ conda create -n &lt;environment&gt; python=3.6-e，--envs：列出已建立的環境123456# 顯示虛擬環境列表，並顯示正在使用的虛擬環境$ conda info -e# conda environments:#base * D:\\Users\\Titan\\Anaconda3hello D:\\Users\\Titan\\Anaconda3\\envs\\hello使用或 activate 至指定環境：12345# Windows$ activate &lt;environment&gt;# Linux and macOS$ source activate &lt;environment&gt;123456# 顯示虛擬環境列表，並顯示正在使用的虛擬環境$ conda info -e# conda environments:#base D:\\Users\\Titan\\Anaconda3hello * D:\\Users\\Titan\\Anaconda3\\envs\\hello* 代表目前正在使用的虛擬環境離開虛擬環境如果要將現在環境改回預設值 base (離開目前環境) 可使用下面指令：12345# Windows$ deactivate# Linux and macOS$ source deactivate利用 conda 安裝套件1234$ conda install &lt;package&gt;# 安裝多個套件$ conda install &lt;package-1&gt; &lt;package-2&gt;查看資訊查看 conda 目前版本12$ conda -Vconda 4.5.11查看目前環境已安裝的套件123456789101112$ conda list# packages in environment at D:\\Users\\Titan\\Anaconda3:## Name Version Build Channel...jupyter 1.0.0 py35_3jupyter_client 5.2.3 py35_0jupyter_console 4.1.1 py35_0jupyter_core 4.4.0 py35h629ba7f_0jupyterlab 0.32.1 &lt;pip&gt;jupyterlab-launcher 0.10.5 &lt;pip&gt;...查看 conda 是否有某套件：12345678$ conda search &lt;package&gt;$ conda search pandasLoading channels: done# Name Version Build Channelpandas 0.9.0 np16py27_0 pkgs/freepandas 0.9.1 np16py27_0 pkgs/free...如果 conda 沒有該套件，可以使用 pip 來安裝套件：12345# 安裝套件$ pip install &lt;package&gt;# 更新套件$ pip install --upgrade &lt;package&gt;刪除套件12345678# 刪除環境內的套件$ conda remove -n &lt;environment&gt; &lt;package&gt;# 刪除目前環境內的套件$ conda remove &lt;package&gt;# 刪除多個套件$ conda remove &lt;package-1&gt; &lt;package-2&gt;更新套件1234567891011# 更新 conda$ conda update conda# 更新 Anaconda$ conda update anaconda# 更新 Python$ conda update python# 更新特定套件$ conda update &lt;package&gt;刪除虛擬環境1$ conda env remove -n &lt;environment&gt;更新 Python更新全域環境若目前 Python 版本是 3.6.1，下面指令只會將 Python 更新至 3.6.x 的最新版本：1$ conda update python若是要更新到其他版本可指定 Python 版本：1$ conda install python=3.6更新 Anaconda更新套件管理器：1$ conda update conda注意：Conda 會更新該版本列表中的最高版本，因此 Python 2.7 更新到 2.x 中的最高版本，而 3.x 系列依此類推。更新 anaconda 此 meta-package，可更新 Anaconda 發行版包含的套件：1$ conda update anaconda如果要更新 Python 的特定版本：1$ conda install python==$pythonversion$參考連結Managing packages | Conda documentationmacos - How do I upgrade to Python 3.6 with conda? - Stack Overflow","categories":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/categories/python/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://titangene.github.io/tags/python/"},{"name":"Anaconda","slug":"anaconda","permalink":"https://titangene.github.io/tags/anaconda/"},{"name":"Conda","slug":"conda","permalink":"https://titangene.github.io/tags/conda/"},{"name":"Virtual Environment","slug":"virtual-environment","permalink":"https://titangene.github.io/tags/virtual-environment/"},{"name":"Package Management","slug":"package-management","permalink":"https://titangene.github.io/tags/package-management/"}]},{"title":"Windows Subsystem for Linux (WSL)","slug":"windows-subsystem-for-linux","date":"2018-11-17T11:00:45.000Z","updated":"2019-02-07T11:20:52.820Z","comments":true,"path":"article/windows-subsystem-for-linux.html","link":"","permalink":"https://titangene.github.io/article/windows-subsystem-for-linux.html","excerpt":"Windows Subsystem for Linux (簡稱 WSL)，由 Microsoft 與 Canonical 公司合作開發，可直接在 Windows 10 中建立一個 Linux 子系統，原生執行 Linux，還可自行選擇你想安裝的 Linux 發行版，例如：Ubuntu、Kali Linux、SUSE。","text":"Windows Subsystem for Linux (簡稱 WSL)，由 Microsoft 與 Canonical 公司合作開發，可直接在 Windows 10 中建立一個 Linux 子系統，原生執行 Linux，還可自行選擇你想安裝的 Linux 發行版，例如：Ubuntu、Kali Linux、SUSE。啟用 Windows Subsystem for Linux使用系統管理者權限開啟 PowerShell，並執行下面命令啟用 Windows Subsystem for Linux 功能：1$ Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux如果顯示下面訊息就代表你沒有使用系統管理員開啟 PowerShell：123456Enable-WindowsOptionalFeature : 要求的作業需要提升的權限。位於 線路:1 字元:1+ Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows- ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [Enable-WindowsOptionalFeature], COMException + FullyQualifiedErrorId : Microsoft.Dism.Commands.EnableWindowsOptionalFeatureCommand接著等他跑一下…：接著他會問是否要重啟電腦，因為預設是 Yes，所以可以直接按 Enter：其實上面指令就等於去「控制台 &gt; 程式集 &gt; 開啟或關閉 Windows 功能」開啟「適用於 Linux 的 Windows 子系統」。安裝 Linux 發行版系統組建 (build) 必須要 Windows build 16215 或更新版本。若要想知道系統組建，可至 Windows 的「設定」內的「關於」即可查看。你可以選擇你想安裝的 Linux 發行版：Ubuntu 16.04 LTSUbuntu 18.04 LTSDebian GNU/LinuxOpenSUSE Leap 42SUSE Linux Enterprise Server 12Kali Linux如果在安裝後直接開啟 Ubuntu，就會顯示 Error: 0x8007007e 錯誤就代表你沒有啟用 Windows Subsystem for Linux 功能，詳情請參考上面：1234The WSL optional component is not enabled. Please enable it and try again.See https://aka.ms/wslinstall for details.Error: 0x8007007ePress any key to continue...安裝後啟動 Linux 發行版，此時會開啟一個 console 視窗。因為是第一次開啟，所以會先安裝 WSL，等它安裝完後，就會看到下面畫面，系統要你建立一個新的 Unix 使用者名稱：12345Installing, this may take a few minutes...Installation successful!Please create a default UNIX user account. The username does not need to match your Windows username.For more information visit: https://aka.ms/wslusersEnter new UNIX username:接著是設定此使用者的密碼，這邊的使用者與你的 Windows 使用者名稱和密碼沒有任何關係。詳情可參考官方的 Linux User Account and Permissions | Microsoft Docs 文件。如果顯示 $ 就代表設定完成囉！執行 lsb_release -a 指令就會看到 Linux 的系統版本：在其他終端使用 Bash如果在使用 CMD 、 PowerShell 或其他終端 (例如我常用的 Cmder) 時想用 bash shell，可使用 bash 指令就可以啟動新的 Ubuntu shell：1$ bash存取目錄如果想存取 D:\\project，在此環境下的路徑就是 /mnt/d/project。小結如果有在跨平台開發或維運的朋友，這個功能應該是一直以來的願望吧？讓你在 Windows 上可以直接處理事情，不用再多開 VM 來使用，不只省資源，也省硬碟空間，重點是不用等 VM 開機…參考連結Install the Linux Subsystem on Windows 10 | Microsoft Docs【WSL】Windows Subsystem for Linux 安裝及基本配置！ | 台灣微軟學生大使Bash on Ubuntu on Windows 的簡單使用 | Heresy’s Space","categories":[{"name":"Windows","slug":"windows","permalink":"https://titangene.github.io/categories/windows/"},{"name":"Linux","slug":"windows/linux","permalink":"https://titangene.github.io/categories/windows/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://titangene.github.io/tags/linux/"},{"name":"Ubuntu","slug":"ubuntu","permalink":"https://titangene.github.io/tags/ubuntu/"},{"name":"Windows 10","slug":"windows-10","permalink":"https://titangene.github.io/tags/windows-10/"},{"name":"WSL","slug":"wsl","permalink":"https://titangene.github.io/tags/wsl/"}]},{"title":"GitHub 縮網址服務 Git.io","slug":"github-url-shortener","date":"2018-10-31T16:58:19.000Z","updated":"2019-02-07T11:20:54.891Z","comments":true,"path":"article/github-url-shortener.html","link":"","permalink":"https://titangene.github.io/article/github-url-shortener.html","excerpt":"最近發現原來 Github 也有提供縮網址 (URL Shortener) 服務「Git.io」，它只適用於 gist.github.com 及 github.com 兩個 hostname。","text":"最近發現原來 Github 也有提供縮網址 (URL Shortener) 服務「Git.io」，它只適用於 gist.github.com 及 github.com 兩個 hostname。下列網址都可以透過 Git.io 來建立縮網址：Github 個人或組織專業 ( https://github.com/&lt;github-id&gt; )Github repository ( https://github.com/&lt;github-id&gt;/&lt;repo-name&gt; ) 或 repository 內目錄或檔案Gist ( https://gist.github.com/&lt;github-id&gt;/&lt;gist-id&gt; )Git.io 有兩種建立短網址的方法，下面會分別介紹：直接到 Git.io 線上設定使用 curl 指令設定：Git.io: GitHub URL Shortener | GitHub BlogGit.io 線上設定最簡單的方法當然是直接打開 Git.io，接著輸入網址並點擊「shorten」按鈕就會將你剛剛輸入的網址變成短網址，短網址的格式是 git.io/xxx。但缺點是無法自訂短網址名稱，預設是自動隨機英文 + 數字的字串。使用 curl 指令建立短網址-i、--include：顯示 HTTP response headers-F、--form &lt;name=content&gt;：設定表單資料，Content-Type 會被設為 multipart/form-data1$ curl -i https://git.io -F \"url=&lt;想縮短的網址&gt;\" -F \"code=&lt;自訂短網址名稱&gt;\"例如我想將自己的 Github profile URL：github.com/titangene 縮短成 git.io/titan，就要執行下面指令：1234567$ curl -i https://git.io -F \"url=https://github.com/titangene\" -F \"code=titan\"HTTP/1.1 201 Created...Location: https://git.io/titan...$ curl -i https://git.io -F \"url=https://titangene.github.io/\" -F \"code=titan-blog\"只要輸入下面指令就可以確認是否建立成功12345$ curl -i https://git.io/titanHTTP/1.1 302 Found...Location: https://github.com/titangene...[小插曲] 縮網址不小心設定錯誤一開始在 Git.io 測試時，直接用自己的 Github profile URL ( github.com/titangene ) 來產生預設隨機英文 + 數字的短網址，想要修改成 git.io/titan 卻沒辦法！這是因為 Git.io 沒有直接提供修改短網址的功能。後來 Google 一下才發現只能聯繫 Github 客服來幫忙刪除短網址，然後再自行重新設定。過了不到半天客服就回信幫我解決了！真是太感謝 Github 客服了！","categories":[{"name":"Other","slug":"other","permalink":"https://titangene.github.io/categories/other/"}],"tags":[{"name":"Github","slug":"github","permalink":"https://titangene.github.io/tags/github/"},{"name":"URL","slug":"url","permalink":"https://titangene.github.io/tags/url/"},{"name":"URL Shortener","slug":"url-shortener","permalink":"https://titangene.github.io/tags/url-shortener/"}]},{"title":"Flutter 自訂字型","slug":"flutter-custom-fonts","date":"2018-10-29T03:40:00.000Z","updated":"2019-02-09T03:36:22.688Z","comments":true,"path":"article/flutter-custom-fonts.html","link":"","permalink":"https://titangene.github.io/article/flutter-custom-fonts.html","excerpt":"雖然 Android 和 iOS 內建都有字型，但常有自訂字型的需求，所以這篇會教你如何在 Flutter 使用自訂字型。","text":"雖然 Android 和 iOS 內建都有字型，但常有自訂字型的需求，所以這篇會教你如何在 Flutter 使用自訂字型。將字型檔放入專案資料夾內此範例是放在 ./assets/fonts 資料夾內：1234567assets/ fonts/ FiraCode-Medium.ttf mononoki-Bold.ttf mononoki-BoldItalic.ttf mononoki-Italic.ttf mononoki-Regular.ttf在 pubspec.yaml 定義字型資訊123456789101112131415flutter: fonts: - family: FiraCode fonts: - asset: assets/fonts/FiraCode-Medium.ttf - family: Mononoki fonts: - asset: assets/fonts/mononoki-Regular.ttf - asset: assets/fonts/mononoki-Bold.ttf weight: 700 - asset: assets/fonts/mononoki-Italic.ttf style: italic - asset: assets/fonts/mononoki-BoldItalic.ttf weight: 700 style: italic設定預設字型12345MaterialApp( title: 'Custom Fonts', theme: ThemeData(fontFamily: 'FiraCode'), home: MyHomePage(title: 'Custom Fonts'),);在特定 Widget 設定字型123456789Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontWeight: FontWeight.w700, fontStyle: FontStyle.italic, ),)完整範例程式碼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Custom Fonts', theme: new ThemeData( primarySwatch: Colors.blue, fontFamily: 'FiraCode', ), home: new MyHomePage(title: 'Custom Fonts'), ); &#125;&#125;class MyHomePage extends StatelessWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(this.title), ), body: Column( children: &lt;Widget&gt;[ new Text( '&lt;-- Custom Fonts -&gt;&gt;', style: TextStyle(fontSize: 30.0), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, ), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontWeight: FontWeight.w700, ), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontStyle: FontStyle.italic, ), ), new Text( 'Custom Fonts', style: TextStyle( fontFamily: 'Mononoki', fontSize: 30.0, fontWeight: FontWeight.w700, fontStyle: FontStyle.italic, ), ), ], ), ); &#125;&#125;詳情可參考 Using custom fonts - Flutter 官方文件","categories":[{"name":"Native App","slug":"native-app","permalink":"https://titangene.github.io/categories/native-app/"}],"tags":[{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"},{"name":"Flutter","slug":"flutter","permalink":"https://titangene.github.io/tags/flutter/"},{"name":"Native App","slug":"native-app","permalink":"https://titangene.github.io/tags/native-app/"},{"name":"Font","slug":"font","permalink":"https://titangene.github.io/tags/font/"}]},{"title":"Flutter 環境建置 (Windows)","slug":"flutter-install-on-windows","date":"2018-10-22T22:58:44.000Z","updated":"2019-04-01T08:54:05.998Z","comments":true,"path":"article/flutter-install-on-windows.html","link":"","permalink":"https://titangene.github.io/article/flutter-install-on-windows.html","excerpt":"最近剛接觸 Flutter，於是就把在 Windows 上建置環境的記錄寫成一篇筆記，裡面包括 Android Studio 和 VS Code 的開發流程。","text":"最近剛接觸 Flutter，於是就把在 Windows 上建置環境的記錄寫成一篇筆記，裡面包括 Android Studio 和 VS Code 的開發流程。詳情可參考官方連結：Get Started: Install on Windows | Flutter系統要求OS：Windows 7 SP1 或以上 (64-bit)硬碟空間：400 MB (不包括 IDE 和工具的空間)工具PowerShell 5.0 或更新版Git for Windows (勾選 Use Git from the Windows Command Prompt 選項，若沒打勾可自行將 Git 安裝目錄內的 bin 資料夾設定為 Path 環境變數，預設目錄為 C:\\Program Files\\Git\\bin )安裝 Flutter SDK下載 Flutter SDK，可下載歷史版本，但建議安裝新版。解壓檔內有一個 flutter 資瞭夾，將此資料夾放在 Flutter SDK 所需的安裝目錄 (e.g D:\\dev\\flutter，請勿將 flutter 資瞭夾放在需要提高權限之類的目錄內，e.g. C:\\Program Files\\ )。將 flutter\\bin 的完整目錄 (e.g. D:\\dev\\flutter\\bin ) 加入 Path 環境變數 (各完整路徑記得用 ; 分號分隔)接著就可以在 Console 內執行 Flutter commands執行 flutter --version 指令確定已成功安裝 Flutter SDK12345$ flutter --versionFlutter 0.7.3 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 3b309bda07 (12 days ago) • 2018-08-28 12:39:24 -0700Engine • revision af42b6dc95Tools • Dart 2.1.0-dev.1.0.flutter-ccb16f7282之後請定期執行 flutter upgrade 指令更新 Flutter (因為目前還在 beta，大約幾週就會有新版)執行 flutter --version 指令後，若看到下面畫面就代表現在有新版可以更新：123456789101112$ flutter --version ╔════════════════════════════════════════════════════════════════════════════╗ ║ A new version of Flutter is available! ║ ║ ║ ║ To update to the latest version, run \"flutter upgrade\". ║ ╚════════════════════════════════════════════════════════════════════════════╝Flutter 0.7.3 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 3b309bda07 (3 weeks ago) • 2018-08-28 12:39:24 -0700Engine • revision af42b6dc95Tools • Dart 2.1.0-dev.1.0.flutter-ccb16f7282執行 flutter upgrade 指令更新 Flutter：123456789101112131415161718$ flutter upgradeUpgrading Flutter from D:\\dev\\flutter......Flutter 0.7.3 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 3b309bda07 (3 weeks ago) • 2018-09-07 12:33:05 -0700Engine • revision 58a1894a1cTools • Dart 2.1.0-dev.1.0.flutter-ccb16f7282Running flutter doctor...Doctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.8.2, on Microsoft Windows [Version 10.0.17134.285], locale zh-TW)[√] Android toolchain - develop for Android devices (Android SDK 28.0.2)[√] Android Studio (version 3.1)[√] VS Code (version 1.27.2)[!] Connected devices ! No devices available! Doctor found issues in 1 category.在執行一次 flutter --version 確認已更新至新的版本：12345$ flutter --versionFlutter 0.8.2 • channel beta • https://github.com/flutter/flutter.gitFramework • revision 5ab9e70727 (13 days ago) • 2018-09-07 12:33:05 -0700Engine • revision 58a1894a1cTools • Dart 2.1.0-dev.3.1.flutter-760a9690c2flutter doctor下面指令是用來查看是否需要安裝任何依賴才能完成設定，因此他會檢查你的環境並顯示檢查報告：1$ flutter doctorDart SDK is bundled with Flutter，不用另外安裝 Dart。從檢查報告的輸出中可以了解需要安裝的其他軟體或執行的其他任務 (以粗體顯示)。例如：123456789101112$ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.7.3, on Microsoft Windows [Version 10.0.17134.228], locale zh-TW)[!] Android toolchain - develop for Android devices (Android SDK 28.0.2) X Android license status unknown.[√] Android Studio (version 3.1) X Flutter plugin not installed; this adds Flutter specific functionality. X Dart plugin not installed; this adds Dart specific functionality.[!] Connected devices ! No devices available! Doctor found issues in 2 categories.下面會介紹如何執行這些任務並完成設定過程。可再次執行 flutter doctor 指令來驗證是否已正確設定所有內容。如果已驗證設定所有內容，就會看到下面輸出結果：12345678$ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.7.3, on Microsoft Windows [Version 10.0.17134.285], locale zh-TW)[√] Android toolchain - develop for Android devices (Android SDK 28.0.2)[√] Android Studio (version 3.1)[√] Connected devices (1 available)• No issues found!加上參數 -v，可以看更詳細的驗證說明：1234567891011121314151617181920212223242526$ flutter doctor -v[√] Flutter (Channel beta, v0.7.3, on Microsoft Windows [Version 10.0.17134.285], locale zh-TW) • Flutter version 0.7.3 at D:\\dev\\flutter • Framework revision 3b309bda07 (3 weeks ago), 2018-08-28 12:39:24 -0700 • Engine revision af42b6dc95 • Dart version 2.1.0-dev.1.0.flutter-ccb16f7282[√] Android toolchain - develop for Android devices (Android SDK 28.0.2) • Android SDK at C:\\Users\\Titan\\AppData\\Local\\Android\\sdk • Android NDK location not configured (optional; useful for native profiling support) • Platform android-28, build-tools 28.0.2 • ANDROID_HOME = C:\\Users\\Titan\\AppData\\Local\\Android\\sdk • Java binary at: C:\\Program Files\\Android\\Android Studio\\jre\\bin\\java • Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1024-b02) • All Android licenses accepted.[√] Android Studio (version 3.1) • Android Studio at C:\\Program Files\\Android\\Android Studio • Flutter plugin version 28.0.1 • Dart plugin version 173.4700 • Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1024-b02)[√] Connected devices (1 available) • SM N950F • 988a98444d********** • android-arm64 • Android 8.0.0 (API 26)• No issues found!Android 設定Flutter 依賴於 Android Studio 以提供 Android 平台的依賴性。但也可以使用其他編輯器來寫 Flutter App。安裝 Java JDK安裝 JDK將 Java JDK 安裝目錄設定為 JAVA_HOME 環境變數 (e.g. C:\\Program Files\\Java\\jdk1.8.0_151 )，並在將 Java JDK 安裝目錄內的 bin 資料夾設定為 Path 環境變數 (e.g. C:\\Program Files\\Java\\jdk1.8.0_151\\bin，也可設定為 %JAVA_HOME%\\bin )安裝 Android Studio安裝 Android Studio，請安裝 Recommended (建議) 版執行 Android Studio，並瀏覽 Android Studio Setup Wizard，安裝最新的 Android SDK、Android SDK Platform-Tools、Android SDK Build-Tools，這些都是 Flutter 在開發 Android 時所必須的。將 Android SDK 目錄設定為 ANDROID_HOME 環境變數 (預設目錄為 C:\\Users\\Titan\\AppData\\Local\\Android\\sdk )定期更新 Android SDK (於 Android Studio &gt; Configure &gt; SDK Manager 安裝)設定你的 Android 裝置想在 Android 裝置上執行和測試 Flutter App，需要 Android 4.1 (API level 16) 或更高版本的 Android 設備。裝置請開啟 開發者模式 內的 USB 偵錯，詳情可參考 Configure on-device developer options | Android Developers 此 Android 官方文件安裝 Google USB Driver (限 Windows)使用 USB 線將裝置連接至電腦，如果你的裝置有出現提示，請授權你的電腦可訪問你的裝置開啟終端機，執行 flutter devices 指令以驗證 Flutter 是否成功連結 Android 裝置12345# 像我連接到 Note 8$ flutter devices1 connected device:SM N950F • 988a98444d********** • android-arm64 • Android 8.0.0 (API 26)Flutter 預設會以 adb 工具基於的 Android SDK 版本來使用，若想用其他版本的 Android SDK，可設定你所需的 Android SDK 目錄為 ANDROID_HOME 環境變數。如果執行 flutter run指令，而且成功將 App 安置手機並執行，就會看到 App 的畫面設定 Android 模擬器 (emulator)想在 Android 模擬器上執行和測試 Flutter App，請依照下面步驟：在主機上啟用 VM acceleration啟動 Android Studio &gt; Tools &gt; AVD Manager 並點選 Create Virtual Device選擇設備定義，然後點擇 Next選擇你所需的 Android 版本的 OS image，然後點選 Next (建議選擇 x86 或 x86_64 image)在 Emulated Performance 欄位請選擇 Hardware - GLES 2.0 以啟用 hardware acceleration驗證 AVD 設定是否正確，若確定請點選 Finish在 Android Virtual Device Manager 中，選擇某台模擬器並點擊 Run有關上述步驟的詳情可參考 Managing AVDs設定編輯器設定 Android Studio安裝 Flutter 和 Dart plugins (外掛)，有兩個 plugin 支援 Flutter：Flutter 外掛：支持 Flutter 開發人員工作流程 (running, debugging, hot reload … 等)Dart 外掛：提供程式碼分析 (輸入時的程式碼驗證、程式碼自動補全)安裝步驟：執行 Android Studio開啟外掛選項 (File &gt; Settings &gt; Plugins)點選 Browse repositories…，接著搜尋 Flutter 並選擇並安裝名為 Flutter 的 plugin (請注意，安裝 Flutter 外掛時會同時安裝 Dart 語言外掛)點擊 Restart Android Studio設定 VS Code安裝 Flutter plugin：安裝 Flutter 此擴充功能，並重啟 VS Code。使用 Flutter Doctor 驗證你的設定環境：按 F1 或 ctrl + shift + p 後，輸入 Flutter 並點選 Flutter: Run Flutter Doctor 即可至 OUTPUT (輸出) 查看驗證結果。使用 Android Studio 開發建立新 app在 Android Studio 中建立 Flutter 專案 ( File &gt; New &gt; New Flutter Project… )接著選擇 Flutter Application，並點選 Next請設定專案名稱、確定 Flutter SDK 目錄、設定專案儲存位置與填寫專案的簡單描述後，點選 Next最後輸入公司網域 (e.g. example.com) 後，點選 Finish 即可建立新的 Flutter 專案執行 app下圖為 Android Studio 的工具列：圖片來源：Get Started: Test Drive | Flutter在 target selector 中，選擇已執行的 Android 裝置，若當前未啟動或未連接任何 Android 裝置，選擇某一模擬器時，Android Studio 就會開啟該選擇的模擬器。如果沒有可用的裝置，可至前面介紹的 設定 Android 模擬器 段落來新建模擬器。點擊 Run 圖示執行 app稍後就會在模擬器或裝置上看到下圖的 app 畫面等待的過程中會初始化 gradlegradle 會 resolve dependencies將專案轉成 apk將 apk 安裝並執行於裝置上1234567891011121314151617181920Launching lib\\main.dart on Android SDK built for x86 64 in debug mode...Initializing gradle...Resolving dependencies...Running 'gradlew assembleDebug'...Built build\\app\\outputs\\apk\\debug\\app-debug.apk.Installing build\\app\\outputs\\apk\\app.apk...D/OpenGLRenderer( 4777): HWUI GL PipelineI/OpenGLRenderer( 4777): Initialized EGL, version 1.4D/OpenGLRenderer( 4777): Swap behavior 1D/ ( 4777): HostConnection::get() New Host Connection established 0x7073cf2e5b00, tid 4831W/OpenGLRenderer( 4777): Failed to choose config with EGL_SWAP_BEHAVIOR_PRESERVED, retrying without...D/OpenGLRenderer( 4777): Swap behavior 0D/EGL_emulation( 4777): eglCreateContext: 0x7073cf2a7600: maj 2 min 0 rcv 2D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf2a7600: ver 2 0 (tinfo 0x7073b4be9300)D/EGL_emulation( 4777): eglCreateContext: 0x7073cf3b10a0: maj 2 min 0 rcv 2D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf3b10a0: ver 2 0 (tinfo 0x7073c2fe87c0)Syncing files to device Android SDK built for x86 64...D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf2a7600: ver 2 0 (tinfo 0x7073b4be9300)D/ ( 4777): HostConnection::get() New Host Connection established 0x7073cf2e65e0, tid 4813D/EGL_emulation( 4777): eglMakeCurrent: 0x7073cf3b10a0: ver 2 0 (tinfo 0x7073c560d6c0)嘗試 hot reload修改一些內容並儲存，app 就會自動做 hot reload，就會很快地看到最新的更新。使用 VS Code 開發建立新 app按 F1 或 ctrl + shift + p 後，輸入 Flutter 並點選 Flutter: New Project輸入專案名稱後，按 enter 鍵選擇專案目錄的儲存位置等待專案建立完成，並在畫面顯示 lib/main.dart 檔案執行 app從 VS Code 底部的藍色狀態欄中點選 Device Selector若要使用實體裝置，詳情至 設定你的 Android 裝置 參考。若連結成功會在 VS Code 底部的藍色狀態欄中看到你的裝置名稱如果沒有可用的裝置，請點選 No Devices 並啟動模擬器執行 Debug等待 App 執行，可在偵錯主控台 (Debug Console) 看到執行進度，稍後就會在模擬器或裝置上看到下圖的 app 畫面使用 Terminal + Editor 開發建立新 app使用 flutter create 指令來建立 Flutter 專案，裡面包含 Material Components 的範例 app。app 的程式碼在 lib/main.dart。12$ flutter create &lt;prject-name&gt;$ cd &lt;prject-name&gt;執行 app使用 flutter devices 指令可檢查是否有正在執行的模擬器或裝置。如果沒有可用的裝置，可至前面介紹的 設定 Android 模擬器 段落來新建模擬器。1234$ flutter devices1 connected device:Android SDK built for x86 64 • emulator-5554 • android-x64 • Android 8.0.0 (API 26) (emulator)使用 flutter run 指令可執行 app，並提供以下功能的快速鍵：r：hot reloadR：hot restart (and rebuild state)h：顯示更多幫助訊息q：停止執行123456789101112131415$ flutter runUsing hardware rendering with device Android SDK built for x86 64. If you get graphics artifacts, consider enabling software rendering with \"--enable-software-rendering\".Launching lib/main.dart on Android SDK built for x86 64 in debug mode...Initializing gradle... 1.7sResolving dependencies... 48.1sRunning 'gradlew assembleDebug'... 88.5sBuilt build\\app\\outputs\\apk\\debug\\app-debug.apk.Installing build\\app\\outputs\\apk\\app.apk... 11.4sSyncing files to device Android SDK built for x86 64...D/ ( 5458): HostConnection::get() New Host Connection established 0x7073c31aabe0, tid 5513D/EGL_emulation( 5458): eglMakeCurrent: 0x7073cf3b1280: ver 2 0 (tinfo 0x7073c2ab65c0) 12.3s🔥 To hot reload changes while running, press \"r\". To hot restart (and rebuild state), press \"R\".An Observatory debugger and profiler on Android SDK built for x86 64 is available at: http://127.0.0.1:2158/For a more detailed help message, press \"h\". To quit, press \"q\".","categories":[{"name":"Native App","slug":"native-app","permalink":"https://titangene.github.io/categories/native-app/"}],"tags":[{"name":"Dart","slug":"dart","permalink":"https://titangene.github.io/tags/dart/"},{"name":"Flutter","slug":"flutter","permalink":"https://titangene.github.io/tags/flutter/"},{"name":"Native App","slug":"native-app","permalink":"https://titangene.github.io/tags/native-app/"}]},{"title":"Hexo 加入 Disqus 留言版 (包含留言數)","slug":"hexo-disqus","date":"2018-10-22T14:40:00.000Z","updated":"2019-02-07T11:20:56.153Z","comments":true,"path":"article/hexo-disqus.html","link":"","permalink":"https://titangene.github.io/article/hexo-disqus.html","excerpt":"Blog 最重要的是可以增進技術的交流，而交流就可以透過留言版來達成。大部分的 Blog 在每篇文章下面都會有留言板，而最常見的就是 Disqus 留言板，因此本篇會說明如何將 Disqus 留言板和各文章的留言數加入 Hexo 的主題中。","text":"Blog 最重要的是可以增進技術的交流，而交流就可以透過留言版來達成。大部分的 Blog 在每篇文章下面都會有留言板，而最常見的就是 Disqus 留言板，因此本篇會說明如何將 Disqus 留言板和各文章的留言數加入 Hexo 的主題中。申請網站留言版帳號至 Disqus 首頁註冊帳號後並登入，接著點擊首頁的「GET STARTED」：選擇「I want to install Disqus on my site」選項：需要輸入的欄位：Websit Name：自訂 short name，且是唯一，像我是設定 titangene-blog。short name 會在設定 Hexo 時需要Category：類別，自行選擇Language：語言，自行選擇填寫後點擊「Create Site」：設定 Hexo在 material-flow 主題內的 _config.yml 原有設定是使用 disqus_shortname 參數來設定 Disqus 的 short name：1disqus_shortname: your_disqus_short_name但我想在 blog 加上留言數，所以才將參數設定改成下面內容：enable：設定 true 或 false 來決定是否要啟用 Disqus 的留言版功能shortname：設定你的 Disqus 的 short namecount：設定 true 或 false 來決定是否要顯示文章的留言數12345# Commentsdisqus: enable: true shortname: your_disqus_short_name count: true那接著就是將 Disqus 的留言版功能加入主題中，主要分成幾個步驟：加入 Disqus script新增 Disqus 留言版新增 Disqus 留言數如果在剛剛上面的 count 參數設定為 false 則可以跳過第三個步驟 新增 Disqus 留言數。下面提供的程式碼可適用於 Hexo 的 material-flow 主題，HTML 結構可依各自使用的版型或需求來修改。若想直接看我設定的原始碼，可至此 Blog 的 GitHub Repo「titangene/hexo-blog」查看。加入 Disqus script在 themes\\material-flow\\layout\\_partial\\script\\disqus.ejs 檔案內加入以下程式碼，當頁面載入時，會以非同步的方式將 Disqus 的 script 加入 &lt;head&gt; 或 &lt;body&gt; 標籤中：12345678910111213141516171819202122&lt;% if (config.disqus.enable) &#123; %&gt; &lt;% if (page.comments) &#123; %&gt; &lt;script&gt; var disqus_shortname = '&lt;%= config.disqus.shortname %&gt;'; var disqus_config = function () &#123; this.page.url = '&lt;%= page.permalink %&gt;'; this.page.identifier = '&lt;%= page.path %&gt;'; this.page.title = '&lt;%= page.title %&gt;'; &#125;; (function() &#123; var dsq = document.createElement('script'); dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; dsq.setAttribute('data-timestamp', '' + new Date()); (document.head || document.body).appendChild(dsq); &#125;)(); &lt;/script&gt; &lt;% &#125; %&gt; &lt;% if (config.disqus.count) &#123; %&gt; &lt;script id=\"dsq-count-scr\" src=\"https://&lt;%= config.disqus.shortname %&gt;.disqus.com/count.js\" async&gt;&lt;/script&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt;接著在 themes\\material-flow\\layout\\layout.ejs 檔案內的 &lt;body&gt; 標籤中將剛剛新增的 disqus.ejs 載入：1&lt;%- partial('script/disqus') %&gt;新增 Disqus 留言版在 themes\\material-flow\\layout\\_partial\\article.ejs 檔案內找到適當的位置加入以下程式碼，就可以在文章內新增 Disqus 留言版：12345678&lt;% if (post.comments &amp;&amp; config.disqus.enable) &#123; %&gt; &lt;section class=\"comments\" id=\"comments\"&gt; &lt;h2&gt;留言版&lt;/h2&gt; &lt;div id=\"disqus_thread\"&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=\"https://disqus.com/?ref_noscript\"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt;&lt;% &#125; %&gt;上面程式碼中最重要的是 &lt;div id=&quot;disqus_thread&quot;&gt; 這句，因為當頁面載入並將 Disqus 的 script 載入後，就會將此標籤內的內容取代成 Disqus 留言版，而 Disqus 留言版是使用 &lt;iframe&gt; 標籤的方式嵌入在頁面中：新增 Disqus 留言數在 themes\\material-flow\\layout\\_partial\\article.ejs 檔案內找到適當的位置加入以下程式碼，就可以在文章內新增 Disqus 留言數：12345678910111213&lt;% if (post.comments &amp;&amp; config.disqus.enable &amp;&amp; config.disqus.count) &#123; %&gt; &lt;span class=\"comments-count\"&gt; &lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fas fa-comment\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;a href=\"&lt;%- post.permalink %&gt;#disqus_thread\" class=\"article-comment-count\" data-disqus-identifier=\"&lt;%= post.path %&gt;\" itemprop=\"discussionUrl\"&gt; &lt;/a&gt; &lt;/span&gt;&lt;% &#125; %&gt;也可以在 themes\\material-flow\\layout\\_partial\\post.ejs 檔案內新增 Disqus 留言數，這樣就可以在首頁看到各文章的留言數。上面程式碼中最重要的是 &lt;a href=&quot;&lt;%- post.permalink %&gt;#disqus_thread&quot;...&gt; 這句，因為在連結的最後加上 #disqus_thread，就代表要告訴 Disqus 要找哪個連結的留言數，並將留言數設為連結名稱 (例如：1 留言)。而 data-disqus-identifier 屬性需設為此頁面的識別名稱：可參考 Disqus 的 JavaScript configuration variables | Disqus 文件。若要設定顯示在頁面上的留言數文字，可至 Disqus 的「Setting &gt; Community &gt; Comment Count Link」內設定，可分別設定三種情況：0 則留言1 則留言多則留言：{num} 是作為留言數的變數Demo設定後就可以看到每篇文章下面都可以留言囉！可在每篇文章看到留言數：參考來源Install instructions for Universal Code | DisqusAdding comment count links to your home page | Disqus","categories":[{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/categories/blog/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://titangene.github.io/tags/hexo/"},{"name":"Blog","slug":"blog","permalink":"https://titangene.github.io/tags/blog/"},{"name":"Comment","slug":"comment","permalink":"https://titangene.github.io/tags/comment/"}]}]}