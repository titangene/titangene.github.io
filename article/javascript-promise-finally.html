<!DOCTYPE html><html><head><meta charset="utf-8"><title>JavaScript 之旅 (8)：Promise.prototype.finally() | Titangene Blog</title><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="author" content="Titangene"><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" href="/atom.xml" title="Titangene Blog"><meta name="description" content="本篇介紹 ES2018 (ES9) 提供的 Promise.prototype.finally()。"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript 之旅 (8)：Promise.prototype.finally()"><meta property="og:url" content="https://titangene.github.io/article/javascript-promise-finally.html"><meta property="og:site_name" content="Titangene Blog"><meta property="og:description" content="本篇介紹 ES2018 (ES9) 提供的 Promise.prototype.finally()。"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="https://titangene.github.io/images/cover/javascript.jpg"><meta property="article:published_time" content="2020-09-23T06:55:20.000Z"><meta property="article:modified_time" content="2020-09-27T13:37:24.820Z"><meta property="article:author" content="Titangene"><meta property="article:tag" content="IT 鐵人賽"><meta property="article:tag" content="ECMAScript"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://titangene.github.io/images/cover/javascript.jpg"><meta name="twitter:creator" content="@titangeneTW"><meta name="twitter:site" content="@titangene_blog"><meta property="fb:admins" content="100001106016019"><meta property="fb:app_id" content="2470546159839111"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="google-site-verification" content="AaJ39L7h-nWwJjXJMhAMtXSF6H6BUgGWXC80kYvLic8"><link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Source+Code+Pro&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="/style.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-KX04S5LSX1"></script><script>!function(a){function n(){dataLayer.push(arguments)}a.dataLayer=a.dataLayer||[],n("js",new Date),n("config","G-KX04S5LSX1")}(window)</script><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Titangene Blog" type="application/atom+xml"></head></html><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>setLoadingBarProgress(20)</script><header class="l_header"><div class="wrapper"><div class="nav-main container container--flex"><a class="logo flat-box" href="/">Titangene Blog</a><div class="menu"><ul class="h-list"><li><a class="flat-box nav-home" href="/">Home</a></li><li><a class="flat-box nav-archives" href="/archives">Archives</a></li></ul><div class="underline"></div></div><div class="m_search"><form name="searchform" class="form u-search-form"><input type="text" class="input u-search-input" placeholder="Search"> <i class="fas fa-search"></i></form></div><ul class="switcher h-list"><li class="s-search"><a class="fas fa-search" href="javascript:void(0)"></a></li><li class="s-menu"><a class="fas fa-bars" href="javascript:void(0)"></a></li></ul></div><div class="nav-sub container container--flex"><a class="logo flat-box" href="/">Titangene Blog</a><ul class="switcher h-list"><li class="s-comment"><a class="far fa-comment-alt" href="javascript:void(0)"></a></li><li class="s-top"><a class="fas fa-arrow-up" href="javascript:void(0)"></a></li><li class="s-toc"><a class="fas fa-list-ol" href="javascript:void(0)"></a></li></ul></div></div></header><aside class="menu-phone"><nav><a href="/" class="nav-home nav">Home </a><a href="/archives" class="nav-archives nav">Archives</a></nav></aside><script>setLoadingBarProgress(40)</script><div class="l_body"><div class="container clearfix"><div class="l_main"><article id="post-javascript-promise-finally" class="post white-box article-type-post" itemscope itemprop="blogPost"><section class="meta"><h2 class="title"><a href="/article/javascript-promise-finally.html">JavaScript 之旅 (8)：Promise.prototype.finally()</a></h2><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar"></i> </span><span class="post-meta-item-text">發表於</span> <time title="建立時間：2020-09-23 14:55:20" itemprop="dateCreated datePublished" datetime="2020-09-23T14:55:20+08:00">2020-09-23 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check"></i> </span><span class="post-meta-item-text">更新於</span> <time title="修改時間：2020-09-27 21:37:24" itemprop="dateModified" datetime="2020-09-27T21:37:24+08:00">2020-09-27</time></span> <span class="comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fas fa-comment"></i> </span><a href="https://titangene.github.io/article/javascript-promise-finally.html#comments" class="article-comment-count">留言</a></span><div class="post-category"><span class="post-meta-item-icon"><i class="fa fa-folder"></i> </span><span class="post-meta-item-text">分類於</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div></section><section class="toc-wrapper"><h3>目錄</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-Chain"><span class="toc-text">Promise Chain</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-prototype-finally-的回傳值永遠是-Promise"><span class="toc-text">Promise.prototype.finally() 的回傳值永遠是 Promise</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-prototype-finally-的-callback"><span class="toc-text">Promise.prototype.finally() 的 callback</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-prototype-finally-的-callback-沒有-argument"><span class="toc-text">Promise.prototype.finally() 的 callback 沒有 argument</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-prototype-finally-的-callback-會被忽略-return"><span class="toc-text">Promise.prototype.finally() 的 callback 會被忽略 return</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-prototype-finally-vs-finally-clause"><span class="toc-text">Promise.prototype.finally() vs. finally clause</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#return-值"><span class="toc-text">return 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw-值"><span class="toc-text">throw 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一定會執行的-finally"><span class="toc-text">一定會執行的 finally</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#finally-clause-一定會在最後執行"><span class="toc-text">finally clause 一定會在最後執行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不管是-fulfilled-或-rejected，Promise-prototype-finally-的-callback-都會執行"><span class="toc-text">不管是 fulfilled 或 rejected，Promise.prototype.finally() 的 callback 都會執行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-prototype-finally-vs-Promise-prototype-then-func-func"><span class="toc-text">Promise.prototype.finally() vs. Promise.prototype.then(func, func)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#情境範例"><span class="toc-text">情境範例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#資料來源"><span class="toc-text">資料來源</span></a></li></ol></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p><img src="../images/cover/javascript.jpg" alt=""></p><p>本篇介紹 ES2018 (ES9) 提供的 <code>Promise.prototype.finally()</code>。</p><a id="more"></a><blockquote><p>本文同步發表於 iT 邦幫忙：<a href="https://ithelp.ithome.com.tw/articles/10242649" target="_blank" rel="noopener">JavaScript 之旅 (8)：Promise.prototype.finally()</a></p><p>「JavaScript 之旅」系列文章發文於：</p><ul><li><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/3607" target="_blank" rel="noopener">iT 邦幫忙</a></li><li><a href="https://titangene.github.io/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/">Titangene Blog</a></li></ul></blockquote><p>下面是幾個非同步處理很常見的情境：</p><ul><li>進入某頁面時，會立即發 AJAX request，在拿到 response 之前都會顯示「正在載入…」的訊息，不管是拿到 response，還是發生錯誤，都會隱藏「正在載入…」</li><li>不管某個操作是否完成，都要紀錄 log</li><li>建立 DB 連線來搜尋資料時，不管是成功拿到，還是中途出現錯誤，都要關閉連線釋放資源</li></ul><p>以上情境都有一個共通點：不管做什麼事，最後都要做某件事。</p><p>也許你會想到 <code>try-finally</code>，會希望非同步處理的 <code>Promise</code> 上也有 finally 的功能 (我自己是沒想過啦 XD)，這就是今天要介紹的 <code>Promise.prototype.finally()</code>！</p><p>在過去原生的 <code>Promise</code> 沒有提供 finally 功能時，很多 library 都在非同步處理的 API 上實作了 <code>finally()</code> 方法，此方法是用來註冊一個在 promise settled 時 (即 fulfilled 或 rejected) invoke 用的 callback。</p><blockquote><p>更多 library 的實作可參閱：</p><ul><li><a href="http://bluebirdjs.com/docs/api/finally.html" target="_blank" rel="noopener">Bluebird#finally</a></li><li><a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback" target="_blank" rel="noopener">Q#finally</a></li><li><a href="https://github.com/cujojs/when/blob/master/docs/api.md#promisefinally" target="_blank" rel="noopener">when#finally</a></li><li><a href="https://api.jquery.com/jQuery.ajax/#jqXHR" target="_blank" rel="noopener">jQuery jqXHR#always</a></li></ul></blockquote><p>在 ES2018 (ES9) 提供了 <code>Promise.prototype.finally()</code> 新的 <code>Promise</code> method。當 promise settled 時 (即 fulfilled 或 rejected)，會執行指定的 callback。</p><h1 id="Promise-Chain"><a class="header-anchor" href="#Promise-Chain"></a>Promise Chain</h1><p>先說明什麼是 promise chain，因為之後會常常看到這個專有名詞。</p><p>將多個 <code>Promise</code> 串在一起，以表達一個序列的非同步執行步驟，而這個序列就是 promise chain。</p><p>那為何是 chain？因為每次在 <code>Promise</code> 上呼叫 <code>.then()</code>、<code>.catch()</code>、<code>.finally()</code> 等 <code>Promise</code> method 時，都會建立並回傳新的 <code>Promise</code>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Hi'</span>)<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Oops'</span>);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>  &#125;)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// OK</span><br><span class="hljs-comment">// Hi</span><br><span class="hljs-comment">// Oops</span><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><h1 id="Promise-prototype-finally-的回傳值永遠是-Promise"><a class="header-anchor" href="#Promise-prototype-finally-的回傳值永遠是-Promise"></a><code>Promise.prototype.finally()</code> 的回傳值永遠是 <code>Promise</code></h1><p><code>Promise.prototype.finally()</code> 的回傳值永遠是 <code>Promise</code> 物件，該 promise 可能會 fulfilled 或 rejected，那何時會 fulfilled？還是會 rejected？</p><p>先講結論：要看你的 promise chain 是怎麼寫的</p><ul><li>若 <code>.finally()</code> 的前一個 Promise 是 fulfilled，那 <code>.finally()</code> 回傳的 <code>Promise</code> 就會是 fulfilled</li><li>若 <code>.finally()</code> 的前一個 Promise 是 rejected，那 <code>.finally()</code> 回傳的 <code>Promise</code> 就會是 rejected</li></ul><p>先看幾個範例：</p><p>假設我先執行 <code>Promise.resolve('OK')</code>，該 promise 會立即 fulfilled，將 <code>OK</code> 傳給 <code>.then()</code> 的 callback，所以第一個輸出訊息會是 <code>OK</code>，接著執行 <code>.finally()</code>，並將 <code>.finally()</code> 的回傳值存在一個名為 <code>promiseA</code> 的變數：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseA = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(result);<br>  &#125;)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// OK</span><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><p>接著印出 <code>promiseA</code>，它是一個 <code>Promise</code> 物件，該 promise 已經 fulfilled 了，且 fulfilled 的值為 <code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(promiseA);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><br></code></pre></td></tr></table></figure><p>那為何 fulfilled 的值會是 <code>undefined</code>，因為在 promise chain 中，<code>.finally()</code> 的前一個 Promise 是 <code>.then()</code> 回傳的，而 <code>.then()</code> 的 callback 沒有回傳值，所以才會是 <code>undefined</code>。</p><blockquote><p>所以不要搞錯了，<code>promiseA</code> 存的不是 <code>Promise.resolve('OK')</code> 回傳的 <code>Promise</code> 物件，而是最後一個 promise chain 的。</p></blockquote><p>那再看下一個範例，這次拿到 <code>.then()</code> 這個步驟，一樣將的回傳值存起來，存在一個名為 <code>promiseB</code> 的變數：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseB = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><p>接著印出 <code>promiseB</code>，該 promise 一樣已經 fulfilled 了，但這次 fulfilled 的值是 <code>OK</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(promiseB);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "OK"&#125;</span><br></code></pre></td></tr></table></figure><p>為什麼會是 <code>OK</code>？因為在 promise chain 中，<code>.finally()</code> 的前一個 Promise 是 <code>Promise.resolve('OK')</code> 回傳的，該 <code>Promise</code> fulfilled 的值就是 <code>OK</code>，所以才會是 <code>OK</code>。</p><p>所以就如同前面結論說的，<code>.finally()</code> 回傳的 <code>Promise</code> 是 fulfilled 還是 rejected，是依據 promise chain 中前一個 Promise 來決定的。</p><h1 id="Promise-prototype-finally-的-callback"><a class="header-anchor" href="#Promise-prototype-finally-的-callback"></a><code>Promise.prototype.finally()</code> 的 callback</h1><h2 id="Promise-prototype-finally-的-callback-沒有-argument"><a class="header-anchor" href="#Promise-prototype-finally-的-callback-沒有-argument"></a><code>Promise.prototype.finally()</code> 的 callback 沒有 argument</h2><p><code>.then()</code> 和 <code>.catch()</code> 的 callback 會有 argument，而該 argument 是在 promise chain 中，前一個 Promise 的 fulfilled 值或 rejected 值。</p><p>但 <code>Promise.prototype.finally()</code> 的 callback 是沒有 argument 的，若你還是寫了 argument，其值也會是 <code>undefined</code>，不管 promise chain 中的前一個 Promise 的 fulfilled 或 rejected：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>  &#125;);<br><br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Oops'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>  &#125;);<br><br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h2 id="Promise-prototype-finally-的-callback-會被忽略-return"><a class="header-anchor" href="#Promise-prototype-finally-的-callback-會被忽略-return"></a><code>Promise.prototype.finally()</code> 的 callback 會被忽略 <code>return</code></h2><p><code>Promise.prototype.finally()</code> 的 callback 中的 <code>return</code> 會被忽略，但回傳的 <code>Promise</code> 的 fulfilled 值或 rejected 值會是 promise chain 中，前一個 Promise 的 fulfilled 值或 rejected 值。：</p><p>例如：<code>Promise.resolve('OK')</code> 會立即 fulfilled，接著在 <code>.finally()</code> 內 <code>return</code> 會被忽略，但 <code>.finally()</code> 回傳的 <code>Promise</code> 的 fulfilled 值會跟 <code>Promise.resolve('OK')</code> 回傳的 fulfilled 值相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally...'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'finally'</span>;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>若拆開 promise chain 就會更容易看出來：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseA = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>);<br><span class="hljs-built_in">console</span>.log(promiseA);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "OK"&#125;</span><br><br><br><span class="hljs-keyword">let</span> promiseB = promiseA.finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally...'</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">'finally'</span>;<br>&#125;);<br><span class="hljs-comment">// finally...</span><br><br><span class="hljs-built_in">console</span>.log(promiseB);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "OK"&#125;</span><br><br><br><span class="hljs-keyword">let</span> promiseC = promiseB.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;);<br><span class="hljs-comment">// OK</span><br><br><span class="hljs-built_in">console</span>.log(promiseC);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "undefined"&#125;</span><br></code></pre></td></tr></table></figure><p>promise rejected 的情況也一樣，你可以試著將上面的 <code>Promise.resolve('OK')</code> 改成 <code>Promise.reject('Oops')</code> 觀察看看。</p><h1 id="Promise-prototype-finally-vs-finally-clause"><a class="header-anchor" href="#Promise-prototype-finally-vs-finally-clause"></a><code>Promise.prototype.finally()</code> vs. <code>finally</code> clause</h1><p>先來看兩者的寫法。</p><p>下面是 <code>Promise.prototype.finally()</code> 的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(result);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>);<br>  &#125;)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// OK</span><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><p>而下面是 <code>try</code> 陳述句中 <code>finally</code> clause 的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK'</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>&#125;<br><br><span class="hljs-comment">// OK</span><br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><p>兩者有些地方很相識，但用法和行為都不同，下面會提出它們的不同之處。</p><h2 id="return-值"><a class="header-anchor" href="#return-值"></a><code>return</code> 值</h2><p><code>Promise.prototype.finally()</code> 會回傳 <code>Promise</code>，該 <code>Promise</code> 可能會 fulfilled 或 rejected (前面有說明)。</p><p>而 <code>finally</code> 只是 <code>try</code> 陳述句中的 clause，若在 <code>finally</code> clause 內 <code>return</code> 某個值會成為 function 的回傳值。</p><p>例如：在 <code>func()</code> 函數中，<code>finally</code> clause 內 <code>return</code> 的 <code>func</code> 就成為此函數的回傳值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'try'</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'catch'</span>);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'func'</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> result = func();<br><span class="hljs-comment">// try</span><br><span class="hljs-comment">// finally</span><br><br><span class="hljs-built_in">console</span>.log(result);<br><span class="hljs-comment">// "func"</span><br></code></pre></td></tr></table></figure><h2 id="throw-值"><a class="header-anchor" href="#throw-值"></a><code>throw</code> 值</h2><p>若在 <code>finally</code> clause 內使用 <code>throw</code>，需要讓另一個 <code>try-catch</code> 來捕捉錯誤：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'try'</span>);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops'</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>  func();<br>&#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>  <span class="hljs-built_in">console</span>.log(error);<br>&#125;<br><br><span class="hljs-comment">// try</span><br><span class="hljs-comment">// finally</span><br><span class="hljs-comment">// Error: Oops</span><br><span class="hljs-comment">//     at func (&lt;anonymous&gt;:6:11)</span><br><span class="hljs-comment">//     at &lt;anonymous&gt;:11:3</span><br></code></pre></td></tr></table></figure><p>而在 <code>Promise.prototype.finally()</code> 的 callback 中使用 <code>throw</code>，會讓回傳的 <code>Promise</code> rejected：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseA = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(result);<br>  &#125;);<br><br><span class="hljs-comment">// OK</span><br><br><span class="hljs-built_in">console</span>.log(promiseA);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><br><br><br><span class="hljs-keyword">let</span> promiseB = promiseA.finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// finally</span><br><span class="hljs-comment">// Uncaught (in promise) Error: Oops</span><br><span class="hljs-comment">//     at &lt;anonymous&gt;:3:11</span><br><span class="hljs-comment">//     at &lt;anonymous&gt;</span><br><br><span class="hljs-built_in">console</span>.log(promiseB);<br><span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: Error: Oops</span><br><span class="hljs-comment">//     at &lt;anonymous&gt;:3:11</span><br><span class="hljs-comment">//     at &lt;anonymous&gt;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="一定會執行的-finally"><a class="header-anchor" href="#一定會執行的-finally"></a>一定會執行的 finally</h2><p><code>Promise.prototype.finally()</code> 和 <code>finally</code> clause 的其中一個共通點就是一定會執行。</p><h3 id="finally-clause-一定會在最後執行"><a class="header-anchor" href="#finally-clause-一定會在最後執行"></a><code>finally</code> clause 一定會在最後執行</h3><p>先來說明 <code>finally</code> clause。</p><p>在函數內的 <code>try</code> clause 或 <code>catch</code> clause 裡面 <code>return</code> 某個值，函數會在回傳該值之前，先執行 <code>finally</code> clause 內的程式碼 (所以 <code>finally</code> 就如其名，真的是「最後」)。</p><p>例如：在 <code>try</code> clause 內 <code>return</code> 值，不會在回傳後直接結束此函數的執行，而是會在回傳之前先執行 <code>finally</code> clause 內的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'try'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'func'</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'catch'</span>);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(func());<br><span class="hljs-comment">// try</span><br><span class="hljs-comment">// finally</span><br><span class="hljs-comment">// "func"</span><br></code></pre></td></tr></table></figure><p>另一個範例：在 <code>catch</code> clause 內 <code>return</code> 值，不會在回傳後直接結束此函數的執行，而是會在回傳之前先執行 <code>finally</code> clause 內的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'catch'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'func'</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(func());<br><span class="hljs-comment">// catch</span><br><span class="hljs-comment">// finally</span><br><span class="hljs-comment">// "func"</span><br></code></pre></td></tr></table></figure><h3 id="不管是-fulfilled-或-rejected，Promise-prototype-finally-的-callback-都會執行"><a class="header-anchor" href="#不管是-fulfilled-或-rejected，Promise-prototype-finally-的-callback-都會執行"></a>不管是 fulfilled 或 rejected，<code>Promise.prototype.finally()</code> 的 callback 都會執行</h3><p>不管 <code>Promise</code> 是 fulfilled 或 rejected 都會執行 <code>Promise.prototype.finally()</code> 的 callback。</p><p>例如：<code>Promise.resolve('OK')</code> 會回傳的 promise 立即 fulfilled 後，會執行 <code>.finally()</code> 的 callback：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseA = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'OK'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-comment">// finally</span><br><br><span class="hljs-built_in">console</span>.log(promiseA);<br><span class="hljs-comment">// Promise &#123;&lt;fulfilled&gt;: "OK"&#125;</span><br></code></pre></td></tr></table></figure><p>另一個例子：<code>Promise.reject('Oops')</code> 會回傳的 promise 立即 rejected 後，會執行 <code>.finally()</code> 的 callback：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promiseB = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Oops'</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);<br>  &#125;);<br><br><span class="hljs-built_in">console</span>.log(promiseB);<br><span class="hljs-comment">// finally</span><br></code></pre></td></tr></table></figure><h1 id="Promise-prototype-finally-vs-Promise-prototype-then-func-func"><a class="header-anchor" href="#Promise-prototype-finally-vs-Promise-prototype-then-func-func"></a><code>Promise.prototype.finally()</code> vs. <code>Promise.prototype.then(func, func)</code></h1><p><code>.finally()</code> 和 <code>.then(onFinally, onFinally)</code> 很像，但有些差別。</p><p>因為沒有可靠的方法來確定 promise 是 fulfilled 或 rejected，所以 <code>.finally()</code> 的 callback 不會接收到任何 argument。代表這適用於不管是 fulfilled 還是 rejected 的情況。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;);<br><span class="hljs-comment">// Promise &#123;&lt;resolved&gt;: undefined&#125;</span><br><br><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;);<br><span class="hljs-comment">// Promise &#123;&lt;resolved&gt;: 2&#125;</span><br><br><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;);<br><span class="hljs-comment">// Promise &#123;&lt;resolved&gt;: undefined&#125;</span><br><br><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;);<br><span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: 3&#125;</span><br></code></pre></td></tr></table></figure><p><code>.finally()</code> 可避免在 <code>then()</code> 和 <code>catch()</code> handler 中有重複的程式碼，即在建立 inline 函數時，可以只傳一次，避免重複宣告或為它宣告變數。</p><h1 id="情境範例"><a class="header-anchor" href="#情境範例"></a>情境範例</h1><p>前面提到一些情境，就拿其中一個作為範例。</p><p>假設進入某頁面時，會立即發 AJAX request，在拿到 response 之前都會顯示「正在載入…」的訊息，不管是拿到 response，還是發生錯誤，都會隱藏「正在載入…」。</p><p>範例程式碼如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> isLoading = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> JSON_API = <span class="hljs-string">'https://jsonplaceholder.typicode.com/posts/1'</span>;<br><span class="hljs-keyword">let</span> HTML_API = <span class="hljs-string">'https://developer.mozilla.org/en-US/docs/Web'</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> fetch(url)<br>    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isLoading:'</span>, isLoading);<br><br>      <span class="hljs-keyword">const</span> contentType = response.headers.get(<span class="hljs-string">'Content-Type'</span>);<br>      <span class="hljs-keyword">if</span> (contentType?.includes(<span class="hljs-string">'application/json'</span>)) &#123;<br>        <span class="hljs-keyword">return</span> response.json();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`Oops, we haven't got JSON!`</span>);<br>      &#125;<br>    &#125;)<br>    .then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Success'</span>);<br>      <span class="hljs-keyword">return</span> json;<br>    &#125;)<br>    .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(error);<br>    &#125;)<br>    .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      isLoading = <span class="hljs-literal">false</span>;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isLoading:'</span>, isLoading);<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 試著換成 fetchData(HTML_API)</span><br>fetchData(JSON_API).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>之後會提到 <code>?.</code> Optional Chaining 運算子。</p></blockquote><p>若 API 的 <code>Content-Type</code> 是 <code>application/json</code> (即 <code>fetch(JSON_API)</code> 這個 AJAX response)，promise 就會 fulfilled 列印出 API 資料，並且在 finally 時將 <code>isLoading</code> 設為 <code>false</code>，所以輸出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetchData(JSON_API).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>&#125;);<br><br><span class="hljs-comment">// isLoading: true</span><br><span class="hljs-comment">// Success</span><br><span class="hljs-comment">// isLoading: false</span><br><span class="hljs-comment">// &#123;userId: 1, id: 1, title: "..."&#125;</span><br></code></pre></td></tr></table></figure><p>若 API 的 <code>Content-Type</code> 不是 <code>application/json</code> (即 <code>fetch(HTML_API)</code> 這個 AJAX response)，promise 就會 rejected 列印出錯誤訊息，並且在 finally 時將 <code>isLoading</code> 設為 <code>false</code>，所以輸出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetchData(HTML_API).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>&#125;);<br><br><span class="hljs-comment">// isLoading: true</span><br><span class="hljs-comment">// TypeError: Oops, we haven't got JSON!</span><br><span class="hljs-comment">// isLoading: false</span><br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>因為不管是 <code>.then()</code> 或 <code>.catch()</code> 都要執行 <code>isLoading = false</code>，那更好的作法就是統一在 <code>.finally()</code> 執行 <code>isLoading = false</code>，這樣就不用寫重複的邏輯了。</p><p>若上面的範例改用 <code>async</code> / <code>await</code> 的寫法也許會像這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> isLoading = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> JSON_API = <span class="hljs-string">'https://jsonplaceholder.typicode.com/posts/1'</span>;<br><span class="hljs-keyword">let</span> HTML_API = <span class="hljs-string">'https://developer.mozilla.org/en-US/docs/Web'</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isLoading:'</span>, isLoading);<br><br>    <span class="hljs-keyword">const</span> contentType = response.headers.get(<span class="hljs-string">'Content-Type'</span>);<br>    <span class="hljs-keyword">if</span> (contentType?.includes(<span class="hljs-string">'application/json'</span>)) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Success'</span>);<br>      <span class="hljs-keyword">return</span> response.json();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`Oops, we haven't got JSON!`</span>);<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    isLoading = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isLoading:'</span>, isLoading);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="資料來源"><a class="header-anchor" href="#資料來源"></a>資料來源</h1><ul><li><a href="https://github.com/tc39/proposal-promise-finally" target="_blank" rel="noopener">tc39/proposal-promise-finally</a></li></ul></div><div class="article-tags tags"><a href="/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD/" title="IT 鐵人賽">IT 鐵人賽</a> <a href="/tags/ecmascript/" title="ECMAScript">ECMAScript</a></div></section><div class="article-share-links"><span>分享：</span> <a class="fab fa-facebook-f" title="Facebook" target="_blank" href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Ftitangene.github.io%2Farticle%2Fjavascript-promise-finally.html"></a> <a class="fab fa-twitter" title="Twitter" target="_blank" href="https://twitter.com/share?url=https%3A%2F%2Ftitangene.github.io%2Farticle%2Fjavascript-promise-finally.html&amp;text=JavaScript 之旅 (8)：Promise.prototype.finally()&amp;hashtags=IT鐵人賽,ECMAScript&amp;via=titangene_blog"></a> <a class="fab fa-linkedin-in" title="Linkedin" target="_blank" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Ftitangene.github.io%2Farticle%2Fjavascript-promise-finally.html"></a> <a class="fab fa-facebook-messenger" title="Facebook Messenger" target="_blank" href="http://www.facebook.com/dialog/send?app_id=2470546159839111&amp;link=https%3A%2F%2Ftitangene.github.io%2Farticle%2Fjavascript-promise-finally.html&amp;display=popup&amp;redirect_uri=https%3A%2F%2Fwww.facebook.com%2Fdialog%2Freturn%2Fclose%23_%3D_"></a> <a class="fab fa-telegram-plane" href="https://telegram.me/share/url?url=https%3A%2F%2Ftitangene.github.io%2Farticle%2Fjavascript-promise-finally.html&text=JavaScript 之旅 (8)：Promise.prototype.finally()" target="_blank"></a></div><nav id="article-nav"><a href="/article/javascript-string-padstart-padend.html" id="article-nav-prev" class="article-nav-link-wrap" title="JavaScript 之旅 (5)：String method - padStart &amp; padEnd" rel="prev"><strong class="article-nav-caption">Prev</strong><p class="article-nav-title">JavaScript 之旅 (5)：String method - padStart &amp; padEnd</p><i class="fas fa-angle-left"></i> </a><a href="/article/javascript-object-rest-spread-properties.html" id="article-nav-next" class="article-nav-link-wrap" title="JavaScript 之旅 (13)：Object Rest/Spread Properties" rel="next"><strong class="article-nav-caption">Next</strong><p class="article-nav-title">JavaScript 之旅 (13)：Object Rest/Spread Properties</p><i class="fas fa-angle-right"></i></a></nav><section id="list_related_posts"><h2>相關文章</h2><ul class="related-posts"><li class="related-posts-item"><a class="related-posts-link" href="/article/javascript-ecmascript-tc39.html">JavaScript 之旅 (1)：介紹 ECMA、ECMAScript、JavaScript 和 TC39</a><div class="related-posts-item-abstract">你很常聽到 ES6、ES7、ES2017 等這些名稱嗎？有聽過 ECMA 和 TC39 嗎？ECMAScript 和 JavaScript 又是什麼？規範要去哪裡看？下面會各別介紹。本文同步發表於 iT 邦幫忙：Java</div></li><li class="related-posts-item"><a class="related-posts-link" href="/article/javascript-array-includes.html">JavaScript 之旅 (2)：Array.prototype.includes()</a><div class="related-posts-item-abstract">常會有找出陣列中是否包含某元素的需求，過去會使用 Array.prototype.indexOf() 來處理，但在 ES2016 (ES7) 提供了 Array.prototype.includes() 新的 Array</div></li><li class="related-posts-item"><a class="related-posts-link" href="/article/javascript-object-rest-spread-properties.html">JavaScript 之旅 (13)：Object Rest/Spread Properties</a><div class="related-posts-item-abstract">本篇介紹 ES2018 (ES9) 提供的 object rest/spread properties。本文同步發表於 iT 邦幫忙：JavaScript 之旅 (13)：Object Rest/Spread Prope</div></li><li class="related-posts-item"><a class="related-posts-link" href="/article/javascript-promise-any-aggregateerror.html">JavaScript 之旅 (27)：Promise.any() & AggregateError</a><div class="related-posts-item-abstract">本篇介紹 ES2021 (ES12) 提供的 Promise.any() 和 AggregateError。本文同步發表於 iT 邦幫忙：JavaScript 之旅 (27)：Promise.any() &amp; Ag</div></li><li class="related-posts-item"><a class="related-posts-link" href="/article/javascript-exponentiation-operator.html">JavaScript 之旅 (3)：Exponentiation Operator (指數運算子)</a><div class="related-posts-item-abstract">寫程式應該很常會用到指數運算，過去我們會用 Math.pow()，但在 ES2016 (ES7) 提供了 exponentiation operator (指數運算子) 的讓寫法更簡潔。那這兩個差在哪？讓我們從 ECMA</div></li><li class="related-posts-item"><a class="related-posts-link" href="/article/javascript-object-keys-values-entries.html">JavaScript 之旅 (4)：Object.keys() & Object.values() & Object.entries()</a><div class="related-posts-item-abstract">有時要將 JS 物件轉成其他資料結構，所以需要迭代物件中的所有 property，過去會用 for-in 陳述句，但只想列舉 own property，就必須用 hasOwnProperty() 才能解決。後來 ES5</div></li></ul></section><section class="comments" id="comments"><h2>討論區</h2><div id="gitalk-container"></div></section></article><script>window.subData={title:"JavaScript 之旅 (8)：Promise.prototype.finally()",tools:!0}</script></div><aside class="l_side"><section class="m_widget about"><div class="avatar-section"><style>.avatar-cover{background:url(/images/avatar_cover.jpg) 0 10%/cover no-repeat}</style><div class="avatar-cover"></div><img class="avatar" src="/images/avatar.jpg"></div><div class="header">Titangene</div><div class="content"><div class="desc">利用 blog 紀錄學習歷程</div></div><div class="content"><meta itemprop="url" content="https://titangene.github.io"><div class="social-wrapper"><a itemprop="sameAs" href="https://github.com/titangene" class="social github" target="_blank" rel="external"><span class="fab fa-github-alt"></span> </a><a itemprop="sameAs" href="https://www.facebook.com/titangene.tw" class="social facebook" target="_blank" rel="external"><span class="fab fa-facebook-square"></span> </a><a itemprop="sameAs" href="https://www.instagram.com/titangene/" class="social instagram" target="_blank" rel="external"><span class="fab fa-instagram"></span> </a><a itemprop="sameAs" href="https://www.flickr.com/photos/titangene" class="social flickr" target="_blank" rel="external"><span class="fab fa-flickr"></span> </a><a itemprop="sameAs" href="/atom.xml" class="social rss" target="_blank" rel="external"><span class="fas fa-rss"></span></a></div></div></section><section class="m_widget facebook_page"><div class="fb-page" data-href="https://www.facebook.com/titangene.blog/" data-width="250" data-small-header="false" data-adapt-container-width="false" data-hide-cover="false" data-show-facepile="true"><blockquote cite="https://www.facebook.com/titangene.blog/" class="fb-xfbml-parse-ignore"><p><a href="https://www.facebook.com/titangene.blog/" class="social facebook" target="_blank"><span class="fab fa-facebook-square"></span></a></p><p><a href="https://www.facebook.com/titangene.blog/" target="_blank" rel="noopener">Titangene Blog</a></p><p>Loading...</p></blockquote></div></section><section class="m_widget recent"><div class="header">Recents</div><div class="content"><ul class="entry"><li><a itemprop="url" class="flat-box" href="/article/vue-lottie.html"><time>2020-11-01</time><div class="name">在 Vue 中使用 Lottie 動畫</div></a></li><li><a itemprop="url" class="flat-box" href="/article/javascript-promise-any-aggregateerror.html"><time>2020-10-12</time><div class="name">JavaScript 之旅 (27)：Promise.any() &amp; AggregateError</div></a></li><li><a itemprop="url" class="flat-box" href="/article/javascript-bigint.html"><time>2020-10-07</time><div class="name">JavaScript 之旅 (22)：BigInt</div></a></li><li><a itemprop="url" class="flat-box" href="/article/javascript-object-rest-spread-properties.html"><time>2020-09-28</time><div class="name">JavaScript 之旅 (13)：Object Rest/Spread Properties</div></a></li><li><a itemprop="url" class="flat-box" href="/article/javascript-promise-finally.html"><time>2020-09-23</time><div class="name">JavaScript 之旅 (8)：Promise.prototype.finally()</div></a></li><li><a itemprop="url" class="flat-box" href="/article/javascript-string-padstart-padend.html"><time>2020-09-20</time><div class="name">JavaScript 之旅 (5)：String method - padStart &amp; padEnd</div></a></li><li><a itemprop="url" class="flat-box" href="/article/javascript-object-keys-values-entries.html"><time>2020-09-19</time><div class="name">JavaScript 之旅 (4)：Object.keys() &amp; Object.values() &amp; Object.entries()</div></a></li></ul></div></section></aside><script>setLoadingBarProgress(60)</script></div></div><footer id="footer" class="clearfix"><div class="social-wrapper"><a href="https://github.com/titangene" class="social github" target="_blank" rel="external"><span class="fab fa-github-alt"></span> </a><a href="https://www.facebook.com/titangene.tw" class="social facebook" target="_blank" rel="external"><span class="fab fa-facebook-square"></span> </a><a href="https://www.instagram.com/titangene/" class="social instagram" target="_blank" rel="external"><span class="fab fa-instagram"></span> </a><a href="https://www.flickr.com/photos/titangene" class="social flickr" target="_blank" rel="external"><span class="fab fa-flickr"></span> </a><a href="/atom.xml" class="social rss" target="_blank" rel="external"><span class="fas fa-rss"></span></a></div><div>© 2018 - 2022 <span itemprop="copyrightHolder">Titangene</span></div><div>Powered by <a href="https://hexo.io/" target="_blank" class="codename" rel="external noopener">Hexo</a> - Theme <a href="https://github.com/stkevintan/hexo-theme-material-flow" target="_blank" class="codename" rel="external noopener">MaterialFlow</a></div><div><a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external noopener"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png"></a></div></footer><script>setLoadingBarProgress(80)</script><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/jquery.fitvids.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script src="/js/clipboard-use.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"dd1684f31ee17e25c22b",clientSecret:"4b51bb4a5996b04d58821a6e3da8558f23da4cdf",id:window.location.pathname,repo:"hexo-blog",owner:"titangene",admin:"titangene",distractionFreeMode:"true"});gitalk.render("gitalk-container")</script><div id="fb-root"></div><script>window.fbAsyncInit=function(){FB.init({appId:"2470546159839111",autoLogAppEvents:!0,xfbml:!0,version:"v2.11"}),FB.AppEvents.logPageView()},function(e,n,t){var o,s=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="//connect.facebook.net/zh_TW/sdk.js",s.parentNode.insertBefore(o,s))}(document,"script","facebook-jssdk")</script><script>setLoadingBarProgress(100)</script></body>